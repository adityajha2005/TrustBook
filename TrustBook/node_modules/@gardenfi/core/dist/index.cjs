"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const f=require("ethers"),c=require("@gardenfi/orderbook"),h=require("@catalogfi/utils"),y=require("@catalogfi/wallets"),N=async(e,t,r,s)=>{const i=r[e],a=r[t];if(!a)throw new Error(`No ${e} wallet found`);if(!i)throw new Error(`No ${t} wallet found`);let d;if(w(e)){const o=f.sha256(h.with0x(Buffer.from("catalog.js"+s+await a.getAddress()).toString("hex"))).slice(2);d=await i.sign(o)}else{const o=f.sha256(h.with0x(Buffer.from("catalog.js"+s+await i.getAddress()).toString("hex"))).slice(2);d=await a.sign(o)}return h.trim0x(f.sha256(h.with0x(d)))},w=e=>e==="bitcoin"||e==="bitcoin_testnet"||e==="bitcoin_regtest",m={WALLET_NOT_FOUND:e=>`${e?"from":"to"} asset wallet not found; please pass the wallet associated with the chain of the asset swapping`,CHAIN_WALLET_NOT_FOUND:e=>`no ${e} wallet found`},S={NO_ACTION:"no actions can be performed in this state",NO_SECRET:"secret not found in order",INVALID_ACTION:(e,t)=>`can not ${e} on status: ${t}`};class L{constructor(t,r){this.order=t,this.wallets=r}get action(){return c.parseStatus(this.order)}get status(){return+`${this.order.status}${this.order.initiatorAtomicSwap.swapStatus}${this.order.followerAtomicSwap.swapStatus}`}async next(){switch(v[this.action]){case"Initiate":return await this.init();case"Redeem":return await this.redeem();case"Refund":return await this.refund();default:return U}}async init(){switch(this.action){case c.Actions.UserCanInitiate:{const t=this.wallets[this.order.initiatorAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.initiatorAtomicSwap.chain} wallet found`);return{user:"initiator",action:"Initiate",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).init()}}case c.Actions.CounterpartyCanInitiate:{const t=this.wallets[this.order.followerAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.followerAtomicSwap.chain} wallet`);return{user:"redeemer",action:"Initiate",output:await(await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset)).init()}}default:throw new Error(S.INVALID_ACTION("init",this.status))}}async redeem(){const t=this.getWallet(this.order.followerAtomicSwap.chain),r=this.getWallet(this.order.initiatorAtomicSwap.chain);switch(this.action){case c.Actions.UserCanRedeem:{const s=await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset),i=await N(this.order.initiatorAtomicSwap.chain,this.order.followerAtomicSwap.chain,this.wallets,this.order.secretNonce);return{user:"initiator",action:"Redeem",output:await s.redeem(i,this.order.userBtcWalletAddress)}}case c.Actions.CounterpartyCanRedeem:{if(!this.order.secret)throw new Error("Secret not found in order");return{user:"redeemer",action:"Redeem",output:await(await l(r,this.order,"native",this.order.initiatorAtomicSwap.asset)).redeem(this.order.secret)}}default:throw new Error(S.INVALID_ACTION("redeem",this.status))}}async refund(){const t=this.getWallet(this.order.initiatorAtomicSwap.chain),r=this.getWallet(this.order.followerAtomicSwap.chain);if(this.order.initiatorAtomicSwap.swapStatus===3)return{user:"initiator",action:"Refund",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};if(this.order.followerAtomicSwap.swapStatus===3)return{user:"redeemer",action:"Refund",output:await(await l(r,this.order,"foreign",this.order.followerAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};throw new Error(S.INVALID_ACTION("refund",this.status))}id(){throw new Error("Method not implemented.")}getWallet(t){const r=this.wallets[t];if(!r)throw new Error(`No ${t} wallet found`);return r}}const l=async(e,t,r,s)=>{const i=r==="native"?t.initiatorAtomicSwap:t.followerAtomicSwap;return e.newSwap({recipientAddress:i.redeemerAddress,refundAddress:i.initiatorAddress,initiatorAddress:i.initiatorAddress,chain:c.chainToId[i.chain],expiryBlocks:+i.timelock,secretHash:t.secretHash,amount:+i.amount,contractAddress:s})};var I=(e=>(e.INITIATOR="initiator",e.REDEEMER="redeemer",e))(I||{}),E=(e=>(e.Init="Initiate",e.Redeem="Redeem",e.Refund="Refund",e.None="None",e))(E||{});const v={[c.Actions.UserCanInitiate]:"Initiate",[c.Actions.CounterpartyCanInitiate]:"Initiate",[c.Actions.UserCanRedeem]:"Redeem",[c.Actions.CounterpartyCanRedeem]:"Redeem",[c.Actions.UserCanRefund]:"Refund",[c.Actions.CounterpartyCanRefund]:"Refund",[c.Actions.NoAction]:"None"},U={user:"initiator",action:"None",output:""};class ${constructor(t){if(t)this.extensionId=t.id;else if(x())this.extensionId=g("chrome");else if(O())this.extensionId=g("window");else throw new Error("Catalog wallet extension not found")}send(t,r){return new Promise((s,i)=>{const a={url:"",favicon:""},d=window.location.href.split("://")[1].replace(/\/$/,"");a.url=d;let o=document.querySelector("link[rel='icon']");if(o||(o=document.querySelector("link[rel='shortcut icon']")),o||(o=document.querySelector("link[rel='apple-touch-icon']")),o||(o=document.querySelector("meta[property='og:image']")),o)a.favicon=o instanceof HTMLMetaElement?o.content:o.href;else{const n=new URL(window.location.href);a.favicon=`${n.protocol}//${n.hostname}/favicon.ico`}chrome.runtime.sendMessage(this.extensionId,{method:t,params:r,metadata:a},n=>chrome.runtime.lastError?i(chrome.runtime.lastError):typeof n=="object"&&n&&"error"in n?i(n.error):s(n))})}}const O=()=>{try{const e=window;return e&&e.catalog&&e.catalog.id}catch{return!1}},g=e=>{if(e==="chrome")return chrome.runtime.id;if(e==="window")return window.catalog.id;throw new Error("Invalid medium to get wallet id")},x=()=>{try{return chrome&&!!chrome.runtime&&!!chrome.runtime.id}catch{return!1}},W={createOrderAndSwap:"createOrderAndSwap"};class B{constructor(t,r){this.orderbook=t,this.wallets=r}subscribeOrders(t,r){this.orderbook.subscribeOrders(t,r)}unsubscribeOrders(){return this.orderbook.unsubscribeOrders()}async swap(t,r,s,i,a){if(O()){const u=await new $().send(W.createOrderAndSwap,{from:t,to:r,amt:s,receiveAmount:i,opts:a});return Number(u)}const d=this.wallets[t.chain],o=this.wallets[r.chain];if(!d)throw new Error(m.WALLET_NOT_FOUND(!0));if(!o)throw new Error(m.WALLET_NOT_FOUND(!1));if(D(t.chain,r.chain),a&&!a.btcUserAddress||!a){a=a||{};const u=this.getBitcoinWallet();if(!u||!(u instanceof y.AbstractBitcoinWallet))throw new Error(m.CHAIN_WALLET_NOT_FOUND("Bitcoin"));a.btcUserAddress=await u.getAddress()}const n=w(t.chain),A=n?o:d,p=n?d:o,b=await A.getAddress(),R=await this.orderbook.getOrders(b),_=n?await p.getAddress():await A.getAddress(),C=n?await A.getAddress():await p.getAddress(),T=await N(t.chain,r.chain,this.wallets,R.length+1);return await this.orderbook.createOrder({fromAsset:t,toAsset:r,sendAmount:s.toString(),receiveAmount:i.toString(),receiveAddress:C,sendAddress:_,secretHash:f.sha256(h.with0x(T)),btcInputAddress:a.btcUserAddress??await p.getAddress()})}getSwap(t){return new L(t,this.wallets)}calculateReceiveAmt(t,r,s){return Promise.resolve(Math.floor(s-s*.003))}getBitcoinWallet(){for(const t in this.wallets)if(w(t))return this.wallets[t];return null}}const D=(e,t)=>{if(w(e)===w(t))throw new Error(w(e)?m.CHAIN_WALLET_NOT_FOUND("Bitcoin"):m.CHAIN_WALLET_NOT_FOUND("EVM"))};exports.GardenJS=B;exports.SwapperActions=E;exports.SwapperRole=I;exports.catalogWalletActions=W;
