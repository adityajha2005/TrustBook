import{sha256 as m}from"ethers";import{Actions as c,parseStatus as L,chainToId as W}from"@gardenfi/orderbook";import{with0x as f,trim0x as U}from"@catalogfi/utils";import{AbstractBitcoinWallet as v}from"@catalogfi/wallets";const g=async(e,t,r,a)=>{const i=r[e],s=r[t];if(!s)throw new Error(`No ${e} wallet found`);if(!i)throw new Error(`No ${t} wallet found`);let d;if(w(e)){const o=m(f(Buffer.from("catalog.js"+a+await s.getAddress()).toString("hex"))).slice(2);d=await i.sign(o)}else{const o=m(f(Buffer.from("catalog.js"+a+await i.getAddress()).toString("hex"))).slice(2);d=await s.sign(o)}return U(m(f(d)))},w=e=>e==="bitcoin"||e==="bitcoin_testnet"||e==="bitcoin_regtest",u={WALLET_NOT_FOUND:e=>`${e?"from":"to"} asset wallet not found; please pass the wallet associated with the chain of the asset swapping`,CHAIN_WALLET_NOT_FOUND:e=>`no ${e} wallet found`},S={NO_ACTION:"no actions can be performed in this state",NO_SECRET:"secret not found in order",INVALID_ACTION:(e,t)=>`can not ${e} on status: ${t}`};class ${constructor(t,r){this.order=t,this.wallets=r}get action(){return L(this.order)}get status(){return+`${this.order.status}${this.order.initiatorAtomicSwap.swapStatus}${this.order.followerAtomicSwap.swapStatus}`}async next(){switch(x[this.action]){case"Initiate":return await this.init();case"Redeem":return await this.redeem();case"Refund":return await this.refund();default:return D}}async init(){switch(this.action){case c.UserCanInitiate:{const t=this.wallets[this.order.initiatorAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.initiatorAtomicSwap.chain} wallet found`);return{user:"initiator",action:"Initiate",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).init()}}case c.CounterpartyCanInitiate:{const t=this.wallets[this.order.followerAtomicSwap.chain];if(!t)throw new Error(`No ${this.order.followerAtomicSwap.chain} wallet`);return{user:"redeemer",action:"Initiate",output:await(await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset)).init()}}default:throw new Error(S.INVALID_ACTION("init",this.status))}}async redeem(){const t=this.getWallet(this.order.followerAtomicSwap.chain),r=this.getWallet(this.order.initiatorAtomicSwap.chain);switch(this.action){case c.UserCanRedeem:{const a=await l(t,this.order,"foreign",this.order.followerAtomicSwap.asset),i=await g(this.order.initiatorAtomicSwap.chain,this.order.followerAtomicSwap.chain,this.wallets,this.order.secretNonce);return{user:"initiator",action:"Redeem",output:await a.redeem(i,this.order.userBtcWalletAddress)}}case c.CounterpartyCanRedeem:{if(!this.order.secret)throw new Error("Secret not found in order");return{user:"redeemer",action:"Redeem",output:await(await l(r,this.order,"native",this.order.initiatorAtomicSwap.asset)).redeem(this.order.secret)}}default:throw new Error(S.INVALID_ACTION("redeem",this.status))}}async refund(){const t=this.getWallet(this.order.initiatorAtomicSwap.chain),r=this.getWallet(this.order.followerAtomicSwap.chain);if(this.order.initiatorAtomicSwap.swapStatus===3)return{user:"initiator",action:"Refund",output:await(await l(t,this.order,"native",this.order.initiatorAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};if(this.order.followerAtomicSwap.swapStatus===3)return{user:"redeemer",action:"Refund",output:await(await l(r,this.order,"foreign",this.order.followerAtomicSwap.asset)).refund(this.order.userBtcWalletAddress)};throw new Error(S.INVALID_ACTION("refund",this.status))}id(){throw new Error("Method not implemented.")}getWallet(t){const r=this.wallets[t];if(!r)throw new Error(`No ${t} wallet found`);return r}}const l=async(e,t,r,a)=>{const i=r==="native"?t.initiatorAtomicSwap:t.followerAtomicSwap;return e.newSwap({recipientAddress:i.redeemerAddress,refundAddress:i.initiatorAddress,initiatorAddress:i.initiatorAddress,chain:W[i.chain],expiryBlocks:+i.timelock,secretHash:t.secretHash,amount:+i.amount,contractAddress:a})};var N=(e=>(e.INITIATOR="initiator",e.REDEEMER="redeemer",e))(N||{}),I=(e=>(e.Init="Initiate",e.Redeem="Redeem",e.Refund="Refund",e.None="None",e))(I||{});const x={[c.UserCanInitiate]:"Initiate",[c.CounterpartyCanInitiate]:"Initiate",[c.UserCanRedeem]:"Redeem",[c.CounterpartyCanRedeem]:"Redeem",[c.UserCanRefund]:"Refund",[c.CounterpartyCanRefund]:"Refund",[c.NoAction]:"None"},D={user:"initiator",action:"None",output:""};class B{constructor(t){if(t)this.extensionId=t.id;else if(k())this.extensionId=O("chrome");else if(E())this.extensionId=O("window");else throw new Error("Catalog wallet extension not found")}send(t,r){return new Promise((a,i)=>{const s={url:"",favicon:""},d=window.location.href.split("://")[1].replace(/\/$/,"");s.url=d;let o=document.querySelector("link[rel='icon']");if(o||(o=document.querySelector("link[rel='shortcut icon']")),o||(o=document.querySelector("link[rel='apple-touch-icon']")),o||(o=document.querySelector("meta[property='og:image']")),o)s.favicon=o instanceof HTMLMetaElement?o.content:o.href;else{const n=new URL(window.location.href);s.favicon=`${n.protocol}//${n.hostname}/favicon.ico`}chrome.runtime.sendMessage(this.extensionId,{method:t,params:r,metadata:s},n=>chrome.runtime.lastError?i(chrome.runtime.lastError):typeof n=="object"&&n&&"error"in n?i(n.error):a(n))})}}const E=()=>{try{const e=window;return e&&e.catalog&&e.catalog.id}catch{return!1}},O=e=>{if(e==="chrome")return chrome.runtime.id;if(e==="window")return window.catalog.id;throw new Error("Invalid medium to get wallet id")},k=()=>{try{return chrome&&!!chrome.runtime&&!!chrome.runtime.id}catch{return!1}},R={createOrderAndSwap:"createOrderAndSwap"};class F{constructor(t,r){this.orderbook=t,this.wallets=r}subscribeOrders(t,r){this.orderbook.subscribeOrders(t,r)}unsubscribeOrders(){return this.orderbook.unsubscribeOrders()}async swap(t,r,a,i,s){if(E()){const h=await new B().send(R.createOrderAndSwap,{from:t,to:r,amt:a,receiveAmount:i,opts:s});return Number(h)}const d=this.wallets[t.chain],o=this.wallets[r.chain];if(!d)throw new Error(u.WALLET_NOT_FOUND(!0));if(!o)throw new Error(u.WALLET_NOT_FOUND(!1));if(H(t.chain,r.chain),s&&!s.btcUserAddress||!s){s=s||{};const h=this.getBitcoinWallet();if(!h||!(h instanceof v))throw new Error(u.CHAIN_WALLET_NOT_FOUND("Bitcoin"));s.btcUserAddress=await h.getAddress()}const n=w(t.chain),A=n?o:d,p=n?d:o,C=await A.getAddress(),_=await this.orderbook.getOrders(C),b=n?await p.getAddress():await A.getAddress(),T=n?await A.getAddress():await p.getAddress(),y=await g(t.chain,r.chain,this.wallets,_.length+1);return await this.orderbook.createOrder({fromAsset:t,toAsset:r,sendAmount:a.toString(),receiveAmount:i.toString(),receiveAddress:T,sendAddress:b,secretHash:m(f(y)),btcInputAddress:s.btcUserAddress??await p.getAddress()})}getSwap(t){return new $(t,this.wallets)}calculateReceiveAmt(t,r,a){return Promise.resolve(Math.floor(a-a*.003))}getBitcoinWallet(){for(const t in this.wallets)if(w(t))return this.wallets[t];return null}}const H=(e,t)=>{if(w(e)===w(t))throw new Error(w(e)?u.CHAIN_WALLET_NOT_FOUND("Bitcoin"):u.CHAIN_WALLET_NOT_FOUND("EVM"))};export{F as GardenJS,I as SwapperActions,N as SwapperRole,R as catalogWalletActions};
