"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const h=require("@catalogfi/utils"),b=require("bip39"),m=require("ethers");function P(t){const s=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t){for(const e in t)if(e!=="default"){const a=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(s,e,a.get?a:{enumerable:!0,get:()=>t[e]})}}return s.default=t,Object.freeze(s)}const w=P(b);class v{constructor(s){this.endpoint=s}async getTransactions(s){for(let r=1;r<=10;r++){const n=await this._getTransactions(s);if(typeof n.result!="string")return n.result;await h.sleep(1e3*r)}throw new Error("Unable to fetch transactions.")}async _getTransactions(s){try{const e=new URL(this.endpoint);return e.searchParams.append("module","account"),e.searchParams.append("address",s),e.searchParams.append("startblock","0"),e.searchParams.append("endblock","latest"),e.searchParams.append("offset","1"),e.searchParams.append("action","txlist"),await h.Fetcher.get(e)}catch(e){return{status:"0",message:e.message,result:"Failed to fetch transactions"}}}}const T=(t,s)=>`m/44'/60'/${t}'/0/${s}`,f=(t,s,e)=>{const a=T(s,t),r=e.derivePath(a);return{address:r.address,path:a,publicKey:r.publicKey,privateKey:r.privateKey}},x=(t,s,e,a,r)=>{const n=[];for(let o=s;o<e;o++){const{address:c,path:i,privateKey:d}=f(o,t,a),u=new Promise((l,y)=>{r.getTransactions(c).then(p=>l({address:c,path:i,privateKey:d,transactions:p})).catch(p=>y(p))});n.push(u)}return n},g=t=>{if(!w.validateMnemonic(t))throw new Error("Invalid mnemonic");return m.HDNodeWallet.fromSeed(m.Mnemonic.fromPhrase(t,"").computeSeed())},K=async(t,s)=>{const e=g(t),a=20,r=5;let n=[];for(let o=0;;o++){const c=[];let i=0;for(let d=0;i<=a;d+=r){const u=await Promise.all(x(o,d,d+r,e,s));await h.sleep(1500);for(const l of u)l.transactions.length===0?i++:(c.push(l),i>0&&(i=0))}if(c.length===0)break;n.push(...c)}return n};exports.EtherscanTxProvider=v;exports.discover=K;exports.generateRootNode=g;exports.getKeysFromAddress=f;
