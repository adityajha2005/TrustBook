"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("./index7.cjs"),P=require("./index16.cjs"),v=require("./index2.cjs"),T=require("./index10.cjs"),h=require("./index27.cjs"),l=require("bitcoinjs-lib"),M=require("./index24.cjs"),g=require("./index15.cjs"),B=require("./index33.cjs"),x=require("./index32.cjs"),f=require("./index34.cjs"),k=require("./index35.cjs"),S=require("@catalogfi/utils"),b=require("./index36.cjs");class w{#e;#t;#n;#s;constructor(t,e,n){this.#e=t,this.#t=e,this.#n=n,this.#s=new f.WalletDetailsStore(n,e.getNetwork())}async getAccounts(){const t=[];let e=-1;const n=S.ensureVal(await this.#s.getMnemonic(),b.MultiKeyWalletErrors.MissingMnemonic),o=h.generateRootNode(n,this.#t.getNetwork());for(;++e>=0;){const s=await this.#s.getAccounts(e);if(s instanceof Error)break;for(const a of s){const r=o.derivePath(a.path).privateKey;if(!r)throw new Error("Unable to generate private key");const i=T.BitcoinWallet.fromPrivateKey(r.toString("hex"),this.#t,{pkType:a.addressType,pkPath:a.path});t.push({...a,accountNumber:k.Path.getAccountNumber(a.path),address:await i.getAddress()})}}return t}async getMnemonic(){return S.ensureVal(await this.#s.getMnemonic(),b.MultiKeyWalletErrors.MissingMnemonic)}get provider(){return this.#t}wallets(){return Array.from(this.#e.values())}walletByAddress(t){const e=this.#e.get(t);if(!e)throw new Error("Wallet not found");return e}walletByType(t){for(const e of this.#e.values())if(e.walletConfig().addressType===t)return e}getNetwork(){return K(this.#t.getNetwork())}async getAddresses(){const t=this.#e.keys(),e=[];for(const n of t){const o=this.#e.get(n);if(!o)throw new Error("Wallet not found");const s=o.walletConfig().addressType;e.push({address:n,type:s})}return e}async getBalance(){let t=0;for(const e of this.wallets())t+=await e.getBalance();return t}async nextAccount(t){if(t??=k.Path.getAccountNumber(this.wallets()[0].walletConfig().path)+1,!(await this.#s.getAccounts(t)instanceof Error))return this.nextAccount(t+1);const n=h.getInitialAccounts(await this.getMnemonic(),this.#t,t),o=n.map(a=>({...a,transactions:[]})),s=A(o,this.#t);return await this.#s.save(await this.getMnemonic(),n.map(a=>({path:a.path,addressType:a.type}))),new w(s,this.#t,this.#n)}static async createRandom(t,e){const n=v.generateMnemonic(),o=new P.EncryptedStore(e,n),s=h.getInitialAccounts(n,t),a=s.map(i=>({...i,transactions:[]})),r=A(a,t);return await f.WalletDetailsStore.save(n,s.map(i=>({path:i.path,addressType:i.type})),o,t.getNetwork()),new w(r,t,o)}static async fromDisk(t,e,n=0){const o=S.ensureVal(await f.WalletDetailsStore.getMnemonic(e),b.MultiKeyWalletErrors.MissingMnemonic),s=await f.WalletDetailsStore.getAccounts(e,n,t.getNetwork());if(s instanceof Error){const r=h.getInitialAccounts(o,t,n),i=A(r,t);return await f.WalletDetailsStore.save(o,r.map(c=>({path:c.path,addressType:c.type})),e,t.getNetwork()),new w(i,t,e)}const a=new Map;for(const r of s){const c=h.generateRootNode(o,t.getNetwork()).derivePath(r.path).privateKey;if(!c)throw new Error("Unable to generate private key");const u=T.BitcoinWallet.fromPrivateKey(c.toString("hex"),t,{pkType:r.addressType,pkPath:r.path});a.set(await u.getAddress(),u)}return new w(a,t,e)}static async fromMnemonic(t,e,n){if(await f.WalletDetailsStore.getMnemonic(n)&&e.getNetwork()===m.BitcoinNetwork.Mainnet)throw new Error("Wallet already exists in store");const s=await h.discover(t,e);if(s.length===0){const c=h.getInitialAccounts(t,e);s.push(...c.map(u=>({...u})))}const a=s.map(c=>c.type);for(const c of Object.values(g.AddressType))if(!a.includes(c)){const u=h.getAccount(t,e,c);s.push({...u})}const r=[];for(const c of s){const u=k.Path.getAccountNumber(c.path),y=s.filter(d=>k.Path.getAccountNumber(d.path)===u).map(d=>d.type);if(y.length!==Object.values(g.AddressType).length){for(const d of Object.values(g.AddressType))if(!y.includes(d)){const N=h.getAccount(t,e,d,u);r.push(N)}}}s.push(...r);const i=A(s,e);return await f.WalletDetailsStore.save(t,s.map(c=>({path:c.path,addressType:c.type})),n,e.getNetwork()),new w(i,e,n)}static async fromPrivateKeys(t,e){const n=new Map;for(const o of t)for(const s of Object.values(g.AddressType)){const a=T.BitcoinWallet.fromPrivateKey(o,e,{pkType:s});n.set(await a.getAddress(),a)}return new w(n,e,new P.WalletMemoryStore)}async sanityChecksBeforeSend(t){if(await this.getBalance()<t)throw new Error("Insufficient balance")}async getUTXOs(t,e){try{return await this.provider.getUTXOs(t,e)}catch{return await this.getUTXOs(t,0)}}async getPayouts(t,e){const n=await this.getAddresses();let o=t;const s=[];for(const r of n){const i=this.walletByAddress(r.address),c=await this.getUTXOs(r.address,o);if(c.length===0)continue;const u=c.reduce((y,d)=>y+d.value,0);if(o>u){s.push({address:r.address,amt:u,fee:0,change:0}),o-=u;continue}else if(e??=await i.suggestFee(o,m.Urgency.FAST),e+o>u){s.push({address:r.address,amt:o,fee:u-o,change:0}),o-=u;continue}else{s.push({address:r.address,amt:o>0?o:0,fee:o>0?e:e+o,change:u-o-e});break}}const a=s.reduce((r,i)=>r+i.amt+i.fee,0);if(a!==t+e)throw new Error("Amounts do not match: Expected "+(t+e)+" but got "+a);return s}async addPayoutsToTx(t,e,n){const o=[];for(const a of e){const r=await this.provider.getUTXOs(a.address,a.amt+a.fee+a.change);for(const i of r)t.addInput(M.reversify(i.txid),i.vout),o.push({address:a.address,val:i.value})}const s=e.reduce((a,r)=>a+r.amt,0);t.addOutput(l.address.toOutputScript(n,this.getNetwork()),s);for(const a of e)a.change>0&&t.addOutput(l.address.toOutputScript(a.address,this.getNetwork()),a.change);return o}async handleP2wpkh(t,e,n,o){const s=Buffer.from(await e.getPublicKey(),"hex"),a=l.Transaction.SIGHASH_ALL,r=l.payments.p2pkh({pubkey:s,network:await e.getNetwork()}),i=t.hashForWitnessV0(n,r.output,o,a),c=await e.sign(i.toString("hex")),u=[l.script.signature.encode(Buffer.from(c,"hex"),a),s];return t.setWitness(n,u),t}async handleP2pkh(t,e,n){const o=Buffer.from(await e.getPublicKey(),"hex"),s=l.payments.p2pkh({pubkey:o,network:this.getNetwork()}),a=l.Transaction.SIGHASH_ALL,r=t.hashForSignature(n,s.output,a),i=await e.sign(r.toString("hex")),c=l.payments.p2pkh({pubkey:o,redeem:{input:l.script.compile([l.script.signature.encode(Buffer.from(i,"hex"),a),o]),output:s.output},network:this.getNetwork()}).redeem?.input;if(!c)throw new Error("Redeem script not found");return t.setInputScript(n,c),t}async handleP2wpkhP2sh(t,e,n,o){const s=Buffer.from(await e.getPublicKey(),"hex"),a=l.payments.p2pkh({network:await e.getNetwork(),pubkey:s}),r=`160014${E(s).toString("hex")}`,i=l.Transaction.SIGHASH_ALL,c=t.hashForWitnessV0(n,a.output,o,i),u=await e.sign(c.toString("hex")),y=[l.script.signature.encode(Buffer.from(u,"hex"),i),s];t.setInputScript(n,Buffer.from(r,"hex")),t.setWitness(n,y)}async send(t,e,n){await this.sanityChecksBeforeSend(e);const o=await this.getPayouts(e,n);let s=W();const a=await this.addPayoutsToTx(s,o,t);for(let r=0;r<a.length;r++){const i=a[r],c=this.walletByAddress(i.address);switch(c.walletConfig().addressType){case g.AddressType.p2pkh:s=await this.handleP2pkh(s,c,r);break;case g.AddressType.p2wpkh:s=await this.handleP2wpkh(s,c,r,i.val);break;case g.AddressType["p2wpkh-p2sh"]:await this.handleP2wpkhP2sh(s,c,r,i.val);break}}return await this.provider.broadcast(s.toHex())}}function W(){const p=new l.Transaction;return p.version=2,p}function E(p){return Buffer.from(B.ripemd160(x.sha256(Uint8Array.from(p))))}function K(p){switch(p){case m.BitcoinNetwork.Mainnet:return l.networks.bitcoin;case m.BitcoinNetwork.Testnet:return l.networks.testnet;case m.BitcoinNetwork.Regtest:return l.networks.regtest;default:throw new Error("Invalid network")}}function A(p,t){const e=new Map;for(const n of p){const o=T.BitcoinWallet.fromPrivateKey(n.privateKey,t,{pkType:n.type,pkPath:n.path});e.set(n.address,o)}return e}exports.BitcoinMultiKeyWallet=w;
