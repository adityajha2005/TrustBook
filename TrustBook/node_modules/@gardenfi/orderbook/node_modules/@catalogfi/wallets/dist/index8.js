import{BitcoinNetwork as v,Urgency as k}from"./index7.js";import{reversify as N}from"./index24.js";import{sha256 as P}from"ethers";import{networks as l,payments as A,Psbt as O,Transaction as C,script as y}from"bitcoinjs-lib";import{ECPairFactory as I}from"ecpair";import{BWErrors as m}from"./index4.js";import{AbstractBitcoinWallet as _}from"./index3.js";import{trim0x as F}from"@catalogfi/utils";import{AddSignature as E}from"./index13.js";import{ScriptType as x}from"./index25.js";let T,b=(async()=>{T=class extends _{constructor(t,e,s){super(),this.minAmt=1e3,this.jsonRPCSigner=e,this.nonce=s||0,this.provider=t,this.network=t.getNetwork()===v.Mainnet?l.bitcoin:t.getNetwork()===v.Testnet?l.testnet:l.regtest}async getSigner(){return this.signer||(this.signer=await this.getBitcoinSigner()),this.signer}getProvider(){return Promise.resolve(this.provider)}async getAddress(){const t=await this.getSigner(),e=A.p2wpkh({pubkey:t.publicKey,network:this.network}).address;if(!e)throw new Error("failed to generate address");return e}async getBalance(){const t=await this.getAddress();return this.provider.getBalance(t)}async sign(t){return t=F(t),(await this.getSigner()).sign(Buffer.from(t,"hex")).toString("hex")}async signSchnorr(t){return(await this.getSigner()).signSchnorr(t)}async getPublicKey(){return(await this.getSigner()).publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}walletConfig(){return{network:this.provider.getNetwork(),path:""}}async getBitcoinSigner(){if(!this.jsonRPCSigner.provider)throw new Error("no provider in the signer");const t=await this.jsonRPCSigner.provider.getNetwork(),e={Data:[{name:"Message",type:"string"},{name:"Version",type:"string"},{name:"Nonce",type:"uint256"}]},s={Message:"Initialize your swap",Version:"1.1.0",Nonce:this.nonce},n={name:"CATALOG x WBTC GARDEN",version:"1",chainId:t.chainId},o={types:e,domain:n,primaryType:"Data",message:s},h=await this.jsonRPCSigner.signTypedData(o.domain,o.types,o.message),g=await import("tiny-secp256k1").then(async i=>(await i.__tla,i));return I(g).fromPrivateKey(Buffer.from(P(h).slice(2),"hex"),{network:this.network})}async send(t,e,s){const n=await this.getSigner();if(s||(s=await this.provider.suggestFee(await this.getAddress(),e,k.FAST)),s>e)throw new Error(m.FEE_EXCEEDS_AMOUNT(s,e));if(e<this.minAmt)throw new Error(m.MIN_AMOUNT(this.minAmt));const o=await this.getAddress(),h=await this.provider.getUTXOs(o,e+s),g=h.reduce((r,d)=>r+d.value,0),i=new O({network:this.network});for(const r of h){const d=await this.provider.getTransactionHex(r.txid);i.addInput({hash:N(r.txid),index:r.vout,nonWitnessUtxo:Buffer.from(d,"hex")})}const a=g-e-s;return i.addOutput({address:t,value:e}),a>0&&i.addOutput({address:o,value:a}),i.signAllInputs(n).finalizeAllInputs(),this.provider.broadcast(i.extractTransaction().toHex())}async spend(t,e,{toAddress:s,fee:n,nSequence:o,unlockScript:h,witness:g}){var S;const i=this.getScriptType(e,this.network),a=await this.provider.getBalance(e);if(a===0)throw new Error(m.SCRIPT_NOT_FUNDED);let r=new C;if(r.version=2,n??(n=await this.provider.suggestFee(e,a,k.FAST)),n>a)throw new Error(m.FEE_EXCEEDS_AMOUNT(n,a));const d=await this.provider.getUTXOs(e);r=await this.addAllInputs(r,e,this.provider,{nSequence:o,utxos:d}),r.addOutput(await this.toOutputScript(s??await this.getAddress()),a-n);for(let c=0;c<r.ins.length;c++)if(i===x.P2SH){if(!h)throw new Error("Unlock script is required for p2sh");const p=[];for(const w of h)if(w instanceof E){const f=w.sigHashType,B=r.hashForSignature(c,t,f);p.push(y.signature.encode(Buffer.from(await this.sign(B.toString("hex")),"hex"),f))}else p.push(w);const u=(S=A.p2sh({redeem:{input:y.compile(p),output:t},network:this.network}).redeem)==null?void 0:S.input;r.setInputScript(c,u)}else if(i===x.P2WSH){if(!g)throw new Error("Witness is required for p2wsh");const p=[];for(const u of g)if(u instanceof E){const w=u.sigHashType,f=r.hashForWitnessV0(c,t,d[c].value,w);p.push(y.signature.encode(Buffer.from(await this.sign(f.toString("hex")),"hex"),w))}else p.push(u);r.setWitness(c,p)}else throw new Error("Invalid script type "+i);return this.provider.broadcast(r.toHex())}}})();export{T as BitcoinOTA,b as __tla};
