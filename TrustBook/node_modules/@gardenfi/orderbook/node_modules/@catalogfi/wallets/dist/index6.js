import{AbstractBitcoinWallet as W}from"./index3.js";import{Urgency as m}from"./index7.js";import{ECPairFactory as I}from"ecpair";import{payments as v,Transaction as l,script as p,address as O,crypto as A}from"bitcoinjs-lib";import*as U from"tiny-secp256k1";import{getBitcoinNetwork as k,parseGuardianAPI as H,reversify as F}from"./index24.js";import{mnemonicToPrivateKey as E}from"./index2.js";import{BitcoinPaths as P}from"./index23.js";import{GuardianWalletStatus as _}from"./index12.js";import{GuardianErrors as S}from"./index11.js";import{BWErrors as x}from"./index4.js";import{guardianScript as T}from"./index29.js";import{ensureVal as b}from"@catalogfi/utils";import{Guardian as G}from"./index30.js";class f extends W{constructor({provider:e,privateKey:t,guardianApiUrl:a,pkIndex:i,pkPath:n}){const s=e.getNetwork(),r=I(U),d=k(s),o=Buffer.from(t,"hex");if(o.length===0)throw new Error("invalid private key");super(),this.minAmt=1e5,this.index=i??0,this.path=n??"",this.signer=r.fromPrivateKey(o,{network:d}),this.provider=e,this.network=d,this.guardian=new G(H(s,a))}static fromMnemonic(e,t,a){const i=P.bip44(t.getNetwork(),a==null?void 0:a.index),n=E(e,t.getNetwork(),{path:i});return new f({provider:t,privateKey:n,guardianApiUrl:a==null?void 0:a.guardianApiUrl,pkIndex:a==null?void 0:a.index,pkPath:i})}static fromPrivateKey(e,t,a){return new f({provider:t,privateKey:e,guardianApiUrl:a==null?void 0:a.guardianApiUrl})}walletConfig(){return{network:this.provider.getNetwork(),path:this.path}}signSchnorr(e){throw new Error("Method not implemented.")}async getGuardianWallet(){try{return await this.guardian.getWallet(await this.getPublicKey())}catch(e){if(e.message===S.WalletNotFound)return await this.guardian.createWallet(await this.getPublicKey()),await this.guardian.getWallet(await this.getPublicKey());throw e}}async getAddress(){const{address:e}=v.p2pkh({pubkey:this.signer.publicKey,network:this.network});if(!e)throw new Error("failed to get the p2pkh address");return e}async getGuardianWalletAddress(){return(await this.getGuardianWallet()).wallet_address}async suggestFee(e,t){const a=await this.getGuardianWalletAddress();return this.provider.suggestFee(a,e,t)}async getBalance(){return this.provider.getBalance(await this.getGuardianWalletAddress())}async sign(e){return this.signer.sign(Buffer.from(e,"hex")).toString("hex")}async getPublicKey(){return this.signer.publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}getProvider(){return Promise.resolve(this.provider)}async deposit(e){var y;if(e<this.minAmt)throw new Error(x.MIN_AMOUNT(this.minAmt));const t=await this.getGuardianWallet();if((y=t.funding_utxo)!=null&&y.tx_hash&&t.status!==_.WalletStatusReady&&t.status!==_.WalletStatusFundingNonEmpty)throw new Error(S.DepositNotFinal);const a=await this.getAddress(),i=await this.provider.getUTXOs(a,e),n=await this.provider.suggestFee(a,e,m.FAST),s=this.totalValueFromUTXOs(i);if(e>s)throw new Error(x.INSUFFICIENT_FUNDS(s,e));let r=new l;r.version=2,r=await this.addGuardianUTXO(r,t),r=await this.addAllInputs(r,a,this.provider,{utxos:i});const d=s-e-n,o=e+await this.getFundingUTXOAmt(t)-(d<0?n:0);r.addOutput(await this.toOutputScript(t.wallet_address),o),d>0&&r.addOutput(await this.toOutputScript(a),d);for(let g=0;g<r.ins.length;g++)t.funding_utxo&&g===0||r.setInputScript(g,this.getScriptSigP2PKH(r,g,a));if(t.status===_.WalletStatusFundingNonEmpty&&t.funding_utxo&&t.funding_utxo.tx_hash!==r.getId())throw new Error(S.DepositNotFinal);const{secretHash:c}=await this.generateSecret(r.getId()),u=await this.guardian.getRefundTx({wallet_address:t.wallet_address,secret_hash:c.toString("hex"),utxo_hash:r.getId(),utxo_index:0,utxo_amount:o,deposit_tx:t.funding_utxo?r.toHex():void 0});t.funding_utxo&&(r=await this.setMultiSigWitness(r,u.deposit_guardian_signature,t));let h;try{h=await this.provider.broadcast(r.toHex())}catch(g){return{txHex:r.toHex(),txId:r.getId(),refundDetails:u,broadcastError:(g==null?void 0:g.message)||"failed to broadcast tx"}}const w={txHex:r.toHex(),txId:h,refundDetails:u};return t.funding_utxo||await this.guardian.submitDepositTx({wallet_address:t.wallet_address,raw_funding_tx:r.toHex(),secret_hash:c.toString("hex")}),w}async getUTXO(e){const t=e.funding_utxo;if(!t)return null;try{await this.provider.getTransaction(t.tx_hash)}catch(a){if(a.message==="Transaction not found"){const i=await this.provider.getUTXOs(e.wallet_address);return i.length===0?null:{tx_hash:i[0].txid,tx_index:await this.provider.getTxIndex(i[0].txid,e.wallet_address),tx_amount:i[0].value}}return null}return t}async send(e,t,a){const i=await this.getGuardianWallet();a??(a=await this.suggestFee(t,m.FAST));const n=new l;n.version=2;const s=await this.getUTXO(i);if(!s)throw new Error(x.INSUFFICIENT_FUNDS(0,t+a));if(t+a>s.tx_amount)throw new Error(x.AmtPlusFeeExceedsBalance(t,a,s.tx_amount));n.addInput(F(s.tx_hash),s.tx_index);const r=s.tx_amount-t-a;r>0&&n.addOutput(await this.toOutputScript(i.wallet_address),r),n.addOutput(await this.toOutputScript(e),t);const d=T(await this.getPublicKey(),i.guardian_public_key),o=l.SIGHASH_ALL,c=n.hashForWitnessV0(0,d,s.tx_amount,o);n.setWitness(0,[Buffer.from(""),p.signature.encode(this.signer.sign(c),o),Buffer.from(""),d]);const{guardian_signature:u}=await this.guardian.send({wallet_address:i.wallet_address,send_tx:n.toHex(),secret_hash:r>0?(await this.generateSecret(n.getId())).secretHash.toString("hex"):void 0}),h=Buffer.from(u,"hex");n.setWitness(0,[Buffer.from(""),p.signature.encode(this.signer.sign(c),o),h,d]);const w=await this.provider.broadcast(n.toHex());return await this.guardian.commit({wallet_address:i.wallet_address,tx_hash:w,secret:(await this.generateSecret(s.tx_hash)).secret.toString("hex")}),w}async spend(e,t,a,i){const n=await this.scriptToAddress(e),s=await this.provider.getBalance(n);let r=new l;r.version=2;const d=await this.provider.suggestFee(n,s,m.FAST),o=await this.getGuardianWallet();if(a===await this.getAddress()&&this.isFunded(o)&&(a=void 0),a||(r=await this.addGuardianUTXO(r,o)),r=await this.addAllInputs(r,n,this.provider,{nSequence:i}),s-d<0)throw new Error(x.AmtPlusFeeExceedsBalance(s,d,s));const c=s+await this.getFundingUTXOAmt(o)-d;r.addOutput(await this.toOutputScript(a??o.wallet_address),a?s-d:c);for(let u=0;u<r.ins.length;u++){if(o.funding_utxo&&u===0)continue;const h=l.SIGHASH_ALL,w=r.hashForWitnessV0(u,e,s,h);r.setWitness(u,[p.signature.encode(Buffer.from(await this.sign(w.toString("hex")),"hex"),h),...t])}if(a)return this.provider.broadcast(r.toHex());if(this.isFunded(o)){const{secretHash:u}=await this.generateSecret(r.getId()),h=await this.guardian.getRefundTx({wallet_address:o.wallet_address,secret_hash:u.toString("hex"),utxo_hash:r.getId(),utxo_index:0,utxo_amount:c,deposit_tx:r.toHex()});return o.funding_utxo&&(r=await this.setMultiSigWitness(r,h.deposit_guardian_signature,o)),this.provider.broadcast(r.toHex())}throw new Error("Unknown error")}async setMultiSigWitness(e,t,a){const i=await this.getUTXO(a);if(!i)throw new Error("setMultiSigWitness: no utxo found");const n=Buffer.from(t,"hex"),s=T(await this.getPublicKey(),a.guardian_public_key),r=l.SIGHASH_ALL,d=e.hashForWitnessV0(0,s,i.tx_amount,r);return e.setWitness(0,[Buffer.from(""),p.signature.encode(this.signer.sign(d),r),n,s]),e}isFunded(e){return e.funding_utxo!==null&&e.funding_utxo.tx_amount>0}getScriptSigP2PKH(e,t,a){const i=O.toOutputScript(a,this.network),n=l.SIGHASH_ALL,s=e.hashForSignature(t,i,n),r=v.p2pkh({pubkey:this.signer.publicKey,signature:p.signature.encode(this.signer.sign(s),n)}).input;return b(r,"failed to get scriptSig")}async addGuardianUTXO(e,t){if(t.funding_utxo&&t.funding_utxo.tx_amount>0){const a=await this.getUTXO(t);if(!a)throw new Error("addGuardianUTXO: no utxo found");e.addInput(F(a.tx_hash),a.tx_index)}return e}async getFundingUTXOAmt(e){const t=await this.getUTXO(e);return t?t.tx_amount:0}async generateSecret(e){const t=await this.sign(e),a=A.sha256(Buffer.from(t,"hex")),i=A.sha256(a);return{secret:a,secretHash:i}}}export{f as BitcoinGuardianWallet};
