import{JsonRpc as n}from"@catalogfi/utils";import{GuardianErrors as t}from"./index11.js";const o={CreateWallet:"btc_createWallet",GetWallet:"btc_getWallet",GetRefundTx:"btc_getRefundTx",SubmitDeposit:"btc_submitDeposit",Send:"btc_send",Commit:"btc_commit",GetCommitment:"btc_getCommitment"};class a{constructor(e){this.url=e,this.client=new n(this.url)}async createWallet(e){if(!e)throw new Error(t.UserPubKeyRequired);if(e.length!==66)throw new Error(t.InvalidPublicKey);const r=await this.rpcRequest(o.CreateWallet,{user_public_key:e});if(r.error&&r.error.message==="Invalid params")throw new Error(t.InvalidPublicKey);if(!r.result)throw new Error(JSON.stringify(r));return r.result}async getWalletByAddress(e){if(!e)throw new Error(t.WalletAddressRequired);const r=await this.rpcRequest(o.GetWallet,{wallet_address:e});if(r.error&&r.error.data.includes("not found"))throw new Error(t.WalletNotFound);if(r.error&&r.error.data.includes("invalid byte"))throw new Error(t.InvalidPublicKey);if(!r.result)throw new Error(JSON.stringify(r));return r.result}async getWallet(e){if(!e)throw new Error(t.UserPubKeyRequired);const r=await this.rpcRequest(o.GetWallet,{public_key:e});if(r.error&&r.error.data.includes("not found"))throw new Error(t.WalletNotFound);if(r.error&&r.error.data.includes("invalid byte"))throw new Error(t.InvalidPublicKey);if(!r.result)throw new Error(JSON.stringify(r));return r.result}async getRefundTx(e){var s;const r=await this.rpcRequest(o.GetRefundTx,e);if(r.error)throw console.log(r.error),new Error(((s=r.error)==null?void 0:s.data)??r.error.message);if(!r.result)throw new Error(JSON.stringify(r));return r.result}async submitDepositTx(e){const r=await this.rpcRequest(o.SubmitDeposit,e);if(r.error)throw console.log(r.error),new Error(r.error.message)}async send(e){var s;const r=await this.rpcRequest(o.Send,e);if(r.error){if(r.error.code===-32602&&r.error.data.includes("wallet not ready for spending")){const i=await this.getWalletByAddress(e.wallet_address);if(i.redeem_tx)return{guardian_signature:i.redeem_tx.guardian_signature}}throw console.log(r.error),new Error(((s=r.error)==null?void 0:s.data)??r.error.message)}if(!r.result)throw new Error(JSON.stringify(r));return r.result}async commit(e){const r=await this.rpcRequest(o.Commit,e);if(r.error)throw new Error(r.error.message);if(!r.result)throw new Error(JSON.stringify(r));return r.result}async getCommitment(e){const r=await this.rpcRequest(o.GetCommitment,{tx_hash:e});if(r.error)throw new Error(r.error.message);if(!r.result)throw new Error(JSON.stringify(r));return r.result}rpcRequest(e,r){const s={method:e,params:r,id:1,version:"2.0"};return this.client.sendRequest(s)}}export{a as Guardian};
