"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("ethers"),w=require("@catalogfi/utils"),i=require("./index20.cjs"),E=require("./index17.cjs"),u=require("./index18.cjs");class p{newSwap(t){return Promise.resolve(new h(t,this))}}class h{constructor(t,s){if(this.swap={...t,contractAddress:t.contractAddress},this.swap.secretHash=w.with0x(this.swap.secretHash),this.swap.secretHash.length!==66)throw new Error(i.EVMHTLCErrors.INVALID_SECRET_HASH);this.wallet=s,this.AtomicSwapContract=E.AtomicSwap__factory.connect(this.swap.contractAddress,s.getSigner())}id(){return this.swap.contractAddress}async init(){const t=await this.wallet.getAddress(),s=await this.AtomicSwapContract.token(),r=u.ERC20__factory.connect(s,this.wallet.getSigner());return await r.allowance(t,this.swap.contractAddress)<BigInt(this.swap.amount)&&await this.contractExecutor(r.approve,[this.swap.contractAddress,a.MaxUint256],s,t,!0),this.contractExecutor(this.AtomicSwapContract.initiate,[this.swap.recipientAddress,this.swap.expiryBlocks,this.swap.amount,this.swap.secretHash],this.swap.contractAddress,t)}async redeem(t){t=w.with0x(t);const s=this.swap.initiatorAddress,r=new a.AbiCoder,c=a.sha256(r.encode(["bytes32","address"],[this.swap.secretHash,s]));return this.contractExecutor(this.AtomicSwapContract.redeem,[c,t],this.swap.contractAddress,await this.wallet.getAddress())}async refund(){const t=this.swap.initiatorAddress,s=new a.AbiCoder,r=a.sha256(s.encode(["bytes32","address"],[this.swap.secretHash,t]));return this.contractExecutor(this.AtomicSwapContract.refund,[r],this.swap.contractAddress,t)}async contractExecutor(t,s,r,c,l){let n;try{const e=await t.populateTransaction(...s);n=a.formatEther(await t.estimateGas(...s));const d=await this.wallet.contractCall({to:r,from:c,data:e.data});return l&&await d.wait(),d.hash}catch(e){throw e.message.includes("insufficient funds")?new Error(i.EVMHTLCErrors.INSUFFICIENT_FUNDS(await A(this.wallet),n)):e.message.includes("exceeds balance")?new Error(i.EVMHTLCErrors.INSUFFICIENT_TOKENS):e.message.includes("duplicate")?new Error(i.EVMHTLCErrors.ORDER_INITIATED):e.message.includes("invalid secret")?new Error(i.EVMHTLCErrors.INVALID_SECRET):e.message.includes("order not expired")?new Error(i.EVMHTLCErrors.ORDER_NOT_EXPIRED):new Error(e.message)}}}const A=async o=>a.parseEther((await o.getProvider().getBalance(await o.getAddress())).toString()).toString();exports.AbstractEVMWallet=p;exports.EVMHTLC=h;
