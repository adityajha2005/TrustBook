import{Connector as h}from"@catalogfi/extension";import{networks as g}from"bitcoinjs-lib";import{number as b,string as s,mixed as v}from"yup";import{AbstractBitcoinWallet as y}from"./index3.js";import{BitcoinNetwork as r}from"./index7.js";import{BitcoinProvider as k}from"./index9.js";import{AddSignature as w}from"./index13.js";const n={getAddress:"btc_getAddress",getBalance:"btc_getBalance",getPublicKey:"btc_getPublicKey",getNetwork:"btc_getNetwork",getWalletConfig:"btc_getWalletConfig",sign:"btc_sign",send:"btc_send",spend:"btc_spend"};class u extends y{constructor(t){super(),this.connector=t}static async detect(){const t=new h;return new u(t)}async getBalance(){const t=await this.connector.send(n.getBalance);return await b().required().validate(t)}async getPublicKey(){const t=await this.connector.send(n.getPublicKey);return await s().required().validate(t)}async getProviderNetwork(){const t=await this.connector.send(n.getNetwork);return v().oneOf([r.Mainnet,r.Testnet,r.Regtest]).required().validate(t)}async getNetwork(){const t=await this.getProviderNetwork();if(t===r.Mainnet)return g.bitcoin;if(t===r.Testnet)return g.testnet;if(t===r.Regtest)return g.regtest;throw new Error("Invalid network from catalog wallet")}async getProvider(){const t=await this.getProviderNetwork();return new k(t)}async send(t,i,o){const a=await this.connector.send(n.send,{toAddress:t,amt:i,fee:o});return await s().required().validate(a)}async spend(t,i,{toAddress:o,fee:a,nSequence:l,unlockScript:c,witness:d}){const f=d==null?void 0:d.map(e=>e instanceof w?e.toString():e.toString("hex")),p=c==null?void 0:c.map(e=>{if(e instanceof w)return e.toString();if(e instanceof Buffer)return e.toString("hex");if(typeof e=="number")return"num_"+e.toString();throw new Error("Invalid unlock script")}),m=await this.connector.send(n.spend,{script:t.toString("hex"),scriptAddress:i,witness:f,toAddress:o,fee:a,unlockScript:p,nSequence:l});return await s().required().validate(m)}walletConfig(){throw new Error("Method not supported")}async getAddress(){const t=await this.connector.send(n.getAddress);return await s().required().validate(t)}async sign(t){const i=await this.connector.send(n.sign,{hexMsg:t});return await s().required().validate(i)}}export{n as BitcoinActions,u as BitcoinRpcProvider};
