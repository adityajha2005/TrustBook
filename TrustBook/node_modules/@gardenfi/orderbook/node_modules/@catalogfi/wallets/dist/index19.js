import{MaxUint256 as E,AbiCoder as w,sha256 as d,formatEther as m,parseEther as A}from"ethers";import{with0x as h}from"@catalogfi/utils";import{EVMHTLCErrors as r}from"./index20.js";import{AtomicSwap__factory as u}from"./index17.js";import{ERC20__factory as g}from"./index18.js";class S{newSwap(t){return Promise.resolve(new p(t,this))}}class p{constructor(t,s){if(this.swap={...t,contractAddress:t.contractAddress},this.swap.secretHash=h(this.swap.secretHash),this.swap.secretHash.length!==66)throw new Error(r.INVALID_SECRET_HASH);this.wallet=s,this.AtomicSwapContract=u.connect(this.swap.contractAddress,s.getSigner())}id(){return this.swap.contractAddress}async init(){const t=await this.wallet.getAddress(),s=await this.AtomicSwapContract.token(),a=g.connect(s,this.wallet.getSigner());return await a.allowance(t,this.swap.contractAddress)<BigInt(this.swap.amount)&&await this.contractExecutor(a.approve,[this.swap.contractAddress,E],s,t,!0),this.contractExecutor(this.AtomicSwapContract.initiate,[this.swap.recipientAddress,this.swap.expiryBlocks,this.swap.amount,this.swap.secretHash],this.swap.contractAddress,t)}async redeem(t){t=h(t);const s=this.swap.initiatorAddress,a=new w,c=d(a.encode(["bytes32","address"],[this.swap.secretHash,s]));return this.contractExecutor(this.AtomicSwapContract.redeem,[c,t],this.swap.contractAddress,await this.wallet.getAddress())}async refund(){const t=this.swap.initiatorAddress,s=new w,a=d(s.encode(["bytes32","address"],[this.swap.secretHash,t]));return this.contractExecutor(this.AtomicSwapContract.refund,[a],this.swap.contractAddress,t)}async contractExecutor(t,s,a,c,l){let n;try{const e=await t.populateTransaction(...s);n=m(await t.estimateGas(...s));const o=await this.wallet.contractCall({to:a,from:c,data:e.data});return l&&await o.wait(),o.hash}catch(e){throw e.message.includes("insufficient funds")?new Error(r.INSUFFICIENT_FUNDS(await f(this.wallet),n)):e.message.includes("exceeds balance")?new Error(r.INSUFFICIENT_TOKENS):e.message.includes("duplicate")?new Error(r.ORDER_INITIATED):e.message.includes("invalid secret")?new Error(r.INVALID_SECRET):e.message.includes("order not expired")?new Error(r.ORDER_NOT_EXPIRED):new Error(e.message)}}}const f=async i=>A((await i.getProvider().getBalance(await i.getAddress())).toString()).toString();export{S as AbstractEVMWallet,p as EVMHTLC};
