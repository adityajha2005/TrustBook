"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const W=require("./index3.cjs"),S=require("./index7.cjs"),b=require("ecpair"),d=require("bitcoinjs-lib"),O=require("tiny-secp256k1"),x=require("./index24.cjs"),F=require("./index2.cjs"),A=require("./index23.cjs"),y=require("./index12.cjs"),m=require("./index11.cjs"),f=require("./index4.cjs"),v=require("./index29.cjs"),H=require("@catalogfi/utils"),U=require("./index30.cjs");function E(p){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(p){for(const t in p)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(p,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:()=>p[t]})}}return e.default=p,Object.freeze(e)}const I=E(O);class _ extends W.AbstractBitcoinWallet{constructor({provider:e,privateKey:t,guardianApiUrl:r,pkIndex:a,pkPath:o}){const n=e.getNetwork(),s=b.ECPairFactory(I),i=x.getBitcoinNetwork(n),u=Buffer.from(t,"hex");if(u.length===0)throw new Error("invalid private key");super(),this.minAmt=1e5,this.index=a??0,this.path=o??"",this.signer=s.fromPrivateKey(u,{network:i}),this.provider=e,this.network=i,this.guardian=new U.Guardian(x.parseGuardianAPI(n,r))}static fromMnemonic(e,t,r){const a=A.BitcoinPaths.bip44(t.getNetwork(),r?.index),o=F.mnemonicToPrivateKey(e,t.getNetwork(),{path:a});return new _({provider:t,privateKey:o,guardianApiUrl:r?.guardianApiUrl,pkIndex:r?.index,pkPath:a})}static fromPrivateKey(e,t,r){return new _({provider:t,privateKey:e,guardianApiUrl:r?.guardianApiUrl})}walletConfig(){return{network:this.provider.getNetwork(),path:this.path}}signSchnorr(e){throw new Error("Method not implemented.")}async getGuardianWallet(){try{return await this.guardian.getWallet(await this.getPublicKey())}catch(e){if(e.message===m.GuardianErrors.WalletNotFound)return await this.guardian.createWallet(await this.getPublicKey()),await this.guardian.getWallet(await this.getPublicKey());throw e}}async getAddress(){const{address:e}=d.payments.p2pkh({pubkey:this.signer.publicKey,network:this.network});if(!e)throw new Error("failed to get the p2pkh address");return e}async getGuardianWalletAddress(){return(await this.getGuardianWallet()).wallet_address}async suggestFee(e,t){const r=await this.getGuardianWalletAddress();return this.provider.suggestFee(r,e,t)}async getBalance(){return this.provider.getBalance(await this.getGuardianWalletAddress())}async sign(e){return this.signer.sign(Buffer.from(e,"hex")).toString("hex")}async getPublicKey(){return this.signer.publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}getProvider(){return Promise.resolve(this.provider)}async deposit(e){if(e<this.minAmt)throw new Error(f.BWErrors.MIN_AMOUNT(this.minAmt));const t=await this.getGuardianWallet();if(t.funding_utxo?.tx_hash&&t.status!==y.GuardianWalletStatus.WalletStatusReady&&t.status!==y.GuardianWalletStatus.WalletStatusFundingNonEmpty)throw new Error(m.GuardianErrors.DepositNotFinal);const a=await this.getAddress(),o=await this.provider.getUTXOs(a,e),n=await this.provider.suggestFee(a,e,S.Urgency.FAST),s=this.totalValueFromUTXOs(o);if(e>s)throw new Error(f.BWErrors.INSUFFICIENT_FUNDS(s,e));let i=new d.Transaction;i.version=2,i=await this.addGuardianUTXO(i,t),i=await this.addAllInputs(i,a,this.provider,{utxos:o});const u=s-e-n,g=e+await this.getFundingUTXOAmt(t)-(u<0?n:0);i.addOutput(await this.toOutputScript(t.wallet_address),g),u>0&&i.addOutput(await this.toOutputScript(a),u);for(let w=0;w<i.ins.length;w++)t.funding_utxo&&w===0||i.setInputScript(w,this.getScriptSigP2PKH(i,w,a));if(t.status===y.GuardianWalletStatus.WalletStatusFundingNonEmpty&&t.funding_utxo&&t.funding_utxo.tx_hash!==i.getId())throw new Error(m.GuardianErrors.DepositNotFinal);const{secretHash:c}=await this.generateSecret(i.getId()),h=await this.guardian.getRefundTx({wallet_address:t.wallet_address,secret_hash:c.toString("hex"),utxo_hash:i.getId(),utxo_index:0,utxo_amount:g,deposit_tx:t.funding_utxo?i.toHex():void 0});t.funding_utxo&&(i=await this.setMultiSigWitness(i,h.deposit_guardian_signature,t));let l;try{l=await this.provider.broadcast(i.toHex())}catch(w){return{txHex:i.toHex(),txId:i.getId(),refundDetails:h,broadcastError:w?.message||"failed to broadcast tx"}}const T={txHex:i.toHex(),txId:l,refundDetails:h};return t.funding_utxo||await this.guardian.submitDepositTx({wallet_address:t.wallet_address,raw_funding_tx:i.toHex(),secret_hash:c.toString("hex")}),T}async getUTXO(e){const t=e.funding_utxo;if(!t)return null;try{await this.provider.getTransaction(t.tx_hash)}catch(r){if(r.message==="Transaction not found"){const a=await this.provider.getUTXOs(e.wallet_address);return a.length===0?null:{tx_hash:a[0].txid,tx_index:await this.provider.getTxIndex(a[0].txid,e.wallet_address),tx_amount:a[0].value}}return null}return t}async send(e,t,r){const a=await this.getGuardianWallet();r??=await this.suggestFee(t,S.Urgency.FAST);const o=new d.Transaction;o.version=2;const n=await this.getUTXO(a);if(!n)throw new Error(f.BWErrors.INSUFFICIENT_FUNDS(0,t+r));if(t+r>n.tx_amount)throw new Error(f.BWErrors.AmtPlusFeeExceedsBalance(t,r,n.tx_amount));o.addInput(x.reversify(n.tx_hash),n.tx_index);const s=n.tx_amount-t-r;s>0&&o.addOutput(await this.toOutputScript(a.wallet_address),s),o.addOutput(await this.toOutputScript(e),t);const i=v.guardianScript(await this.getPublicKey(),a.guardian_public_key),u=d.Transaction.SIGHASH_ALL,g=o.hashForWitnessV0(0,i,n.tx_amount,u);o.setWitness(0,[Buffer.from(""),d.script.signature.encode(this.signer.sign(g),u),Buffer.from(""),i]);const{guardian_signature:c}=await this.guardian.send({wallet_address:a.wallet_address,send_tx:o.toHex(),secret_hash:s>0?(await this.generateSecret(o.getId())).secretHash.toString("hex"):void 0}),h=Buffer.from(c,"hex");o.setWitness(0,[Buffer.from(""),d.script.signature.encode(this.signer.sign(g),u),h,i]);const l=await this.provider.broadcast(o.toHex());return await this.guardian.commit({wallet_address:a.wallet_address,tx_hash:l,secret:(await this.generateSecret(n.tx_hash)).secret.toString("hex")}),l}async spend(e,t,r,a){const o=await this.scriptToAddress(e),n=await this.provider.getBalance(o);let s=new d.Transaction;s.version=2;const i=await this.provider.suggestFee(o,n,S.Urgency.FAST),u=await this.getGuardianWallet();if(r===await this.getAddress()&&this.isFunded(u)&&(r=void 0),r||(s=await this.addGuardianUTXO(s,u)),s=await this.addAllInputs(s,o,this.provider,{nSequence:a}),n-i<0)throw new Error(f.BWErrors.AmtPlusFeeExceedsBalance(n,i,n));const g=n+await this.getFundingUTXOAmt(u)-i;s.addOutput(await this.toOutputScript(r??u.wallet_address),r?n-i:g);for(let c=0;c<s.ins.length;c++){if(u.funding_utxo&&c===0)continue;const h=d.Transaction.SIGHASH_ALL,l=s.hashForWitnessV0(c,e,n,h);s.setWitness(c,[d.script.signature.encode(Buffer.from(await this.sign(l.toString("hex")),"hex"),h),...t])}if(r)return this.provider.broadcast(s.toHex());if(this.isFunded(u)){const{secretHash:c}=await this.generateSecret(s.getId()),h=await this.guardian.getRefundTx({wallet_address:u.wallet_address,secret_hash:c.toString("hex"),utxo_hash:s.getId(),utxo_index:0,utxo_amount:g,deposit_tx:s.toHex()});return u.funding_utxo&&(s=await this.setMultiSigWitness(s,h.deposit_guardian_signature,u)),this.provider.broadcast(s.toHex())}throw new Error("Unknown error")}async setMultiSigWitness(e,t,r){const a=await this.getUTXO(r);if(!a)throw new Error("setMultiSigWitness: no utxo found");const o=Buffer.from(t,"hex"),n=v.guardianScript(await this.getPublicKey(),r.guardian_public_key),s=d.Transaction.SIGHASH_ALL,i=e.hashForWitnessV0(0,n,a.tx_amount,s);return e.setWitness(0,[Buffer.from(""),d.script.signature.encode(this.signer.sign(i),s),o,n]),e}isFunded(e){return e.funding_utxo!==null&&e.funding_utxo.tx_amount>0}getScriptSigP2PKH(e,t,r){const a=d.address.toOutputScript(r,this.network),o=d.Transaction.SIGHASH_ALL,n=e.hashForSignature(t,a,o),s=d.payments.p2pkh({pubkey:this.signer.publicKey,signature:d.script.signature.encode(this.signer.sign(n),o)}).input;return H.ensureVal(s,"failed to get scriptSig")}async addGuardianUTXO(e,t){if(t.funding_utxo&&t.funding_utxo.tx_amount>0){const r=await this.getUTXO(t);if(!r)throw new Error("addGuardianUTXO: no utxo found");e.addInput(x.reversify(r.tx_hash),r.tx_index)}return e}async getFundingUTXOAmt(e){const t=await this.getUTXO(e);return t?t.tx_amount:0}async generateSecret(e){const t=await this.sign(e),r=d.crypto.sha256(Buffer.from(t,"hex")),a=d.crypto.sha256(r);return{secret:r,secretHash:a}}}exports.BitcoinGuardianWallet=_;
