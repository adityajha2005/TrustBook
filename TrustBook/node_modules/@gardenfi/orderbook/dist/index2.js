import { Fetcher as n, trim0x as S } from "@catalogfi/utils";
import { OrdersSocket as d } from "./index7.js";
import { Siwe as u } from "./index8.js";
import { orderPairGenerator as y } from "./index3.js";
import { OrderbookErrors as i } from "./index9.js";
import { StoreKeys as E } from "./index10.js";
import { MemoryStorage as o } from "./index11.js";
import { MAINNET_ORDERBOOK_API as p } from "./index6.js";
import { Url as h } from "./index12.js";
class m {
  /**
   * Creates an instance of Orderbook. Does not login to the orderbook backend
   * @constructor
   * @param {OrderbookConfig} orderbookConfig - The configuration object for the orderbook.
   *
   */
  constructor(s) {
    var t;
    this.supportedContracts = {}, this.url = new h("/", s.url ?? p), this.orderSocket = new d(this.url.socket()), this.auth = new u(this.url, s.signer, {
      ...s.opts,
      store: ((t = s.opts) == null ? void 0 : t.store) || new o()
    });
  }
  /**
   * Initializes the orderbook as well as logs in the orderbook and stores the auth token in the store.
   *
   * @param {OrderbookConfig} orderbookConfig - The configuration object for the orderbook.
   */
  static async init(s) {
    var a;
    const e = await new u(
      new h("/", s.url ?? p),
      s.signer,
      s.opts
    ).getToken(), r = ((a = s.opts) == null ? void 0 : a.store) ?? new o();
    return s.opts = {
      ...s.opts,
      store: r
    }, r.setItem(E.AUTH_TOKEN, e), new m(s);
  }
  /**
   * Returns the supported contracts from the orderbook.
   */
  async getSupportedContracts() {
    if (Object.keys(this.supportedContracts).length > 0)
      return this.supportedContracts;
    const s = this.url.endpoint("assets"), t = await n.get(s), e = {};
    for (const r in t)
      e[r] = t[r][0];
    return this.supportedContracts = e, e;
  }
  async getOrder(s) {
    const t = this.url.endpoint(`orders/${s}`);
    return n.get(t);
  }
  async createOrder(s) {
    const {
      sendAmount: t,
      secretHash: e,
      receiveAmount: r,
      fromAsset: a,
      toAsset: l,
      ...c
    } = s;
    this.validateConfig(s);
    const w = await this.getSupportedContracts(), A = y(a, l, w), O = this.url.endpoint("orders"), { orderId: N } = await n.post(O, {
      body: JSON.stringify({
        ...c,
        sendAmount: t,
        receiveAmount: r,
        secretHash: S(e),
        orderPair: A,
        userWalletBTCAddress: c.btcInputAddress
      }),
      headers: {
        Authorization: await this.auth.getToken()
      }
    });
    return N;
  }
  async getOrders(s, t) {
    const e = await n.get(
      this.url + "orders?" + new URLSearchParams({
        ...t != null && t.taker ? { taker: s } : { maker: s },
        verbose: t != null && t.verbose ? "true" : "false",
        ...t != null && t.pending ? { status: "2" } : {}
      })
    );
    return t != null && t.verbose, e;
  }
  subscribeOrders(s, t) {
    this.orderSocket.subscribe(s, t);
  }
  unsubscribeOrders() {
    this.orderSocket.unsubscribe();
  }
  validateConfig(s) {
    const { sendAmount: t, receiveAmount: e } = s, r = +t, a = +e;
    if (isNaN(r) || r <= 0 || t.includes("."))
      throw new Error(i.INVALID_SEND_AMOUNT);
    if (isNaN(a) || a <= 0 || e.includes("."))
      throw new Error(i.INVALID_RECEIVE_AMOUNT);
  }
}
export {
  m as Orderbook
};
