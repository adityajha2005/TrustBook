import { SiweMessage as h } from "siwe";
import { Fetcher as o } from "@catalogfi/utils";
import { StoreKeys as a } from "./index10.js";
import { MemoryStorage as m } from "./index11.js";
import { MAINNET_ORDERBOOK_API as c } from "./index6.js";
import { Url as d } from "./index12.js";
class v {
  constructor(e, r, t) {
    this.signingStatement = "I'm signing in to Catalog", this.url = new d("/", e ?? c), this.signer = r, this.domain = (t == null ? void 0 : t.domain) || "catalog.fi", this.domain.startsWith("https://") && (this.domain = this.domain.split("https://")[1]), this.store = (t == null ? void 0 : t.store) ?? new m();
  }
  verifyToken(e, r) {
    const t = f(e);
    if (!t) return !1;
    try {
      const i = Math.floor(Date.now() / 1e3) + 120;
      return t.exp > i && t.userWallet.toLowerCase() === r.toLowerCase();
    } catch {
      return !1;
    }
  }
  async getToken() {
    const e = this.store.getItem(a.AUTH_TOKEN);
    if (e && this.verifyToken(e, this.signer.address))
      return e;
    const { message: r, signature: t } = await this.signStatement(), { token: i } = await o.post(
      this.url.endpoint("verify"),
      {
        body: JSON.stringify({
          message: r,
          signature: t
        })
      }
    );
    if (!this.verifyToken(i, await this.signer.getAddress()))
      throw new Error("Token verification failed");
    return this.store.setItem(a.AUTH_TOKEN, i), i;
  }
  async signStatement() {
    if (!this.signer.provider)
      throw new Error("signer does not have a provider");
    const e = /* @__PURE__ */ new Date(), r = new Date(e.getTime() + 300 * 1e3), { nonce: t } = await o.get(this.url.endpoint("nonce")), i = await this.signer.provider.getNetwork(), n = new h({
      domain: this.domain,
      address: await this.signer.getAddress(),
      statement: this.signingStatement,
      nonce: t,
      uri: "https://" + this.domain,
      version: "1",
      chainId: +i.chainId.toString(),
      expirationTime: r.toISOString()
    }).prepareMessage(), g = await this.signer.signMessage(n);
    return {
      message: n,
      signature: g
    };
  }
}
const f = (s) => {
  try {
    if (s.split(".").length < 3) return;
    const e = s.split(".")[1];
    return e ? JSON.parse(Buffer.from(e, "base64").toString("latin1")) : void 0;
  } catch {
    return;
  }
};
export {
  v as Siwe
};
