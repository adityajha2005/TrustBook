import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_crypto_browserify
} from "./chunk-I3J45ZP3.js";
import {
  dist_exports,
  init_dist
} from "./chunk-IL4DCKII.js";
import {
  require_jsx_runtime
} from "./chunk-JHATJSUY.js";
import {
  require_react
} from "./chunk-6BX3RX47.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-HKR3LW4X.js";

// node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues) {
        getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues(rnds8);
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i2 = 0; i2 < 256; ++i2) {
      byteToHex.push((i2 + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    function stringify2(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i2 = buf && offset || 0;
      const b2 = buf || new Array(16);
      options = options || {};
      let node2 = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node2 == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node2 == null) {
          node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt2 < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b2[i2++] = tl >>> 24 & 255;
      b2[i2++] = tl >>> 16 & 255;
      b2[i2++] = tl >>> 8 & 255;
      b2[i2++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b2[i2++] = tmh >>> 8 & 255;
      b2[i2++] = tmh & 255;
      b2[i2++] = tmh >>> 24 & 15 | 16;
      b2[i2++] = tmh >>> 16 & 255;
      b2[i2++] = clockseq >>> 8 | 128;
      b2[i2++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b2[i2 + n] = node2[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b2);
    }
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v2;
      const arr = new Uint8Array(16);
      arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v2 >>> 16 & 255;
      arr[2] = v2 >>> 8 & 255;
      arr[3] = v2 & 255;
      arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v2 & 255;
      arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v2 & 255;
      arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v2 & 255;
      arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v2 / 4294967296 & 255;
      arr[12] = v2 >>> 24 & 255;
      arr[13] = v2 >>> 16 & 255;
      arr[14] = v2 >>> 8 & 255;
      arr[15] = v2 & 255;
      return arr;
    }
    var _default = parse2;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        bytes.push(str.charCodeAt(i2));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function v35(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i2 = 0; i2 < 16; ++i2) {
            buf[offset + i2] = bytes[i2];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i2 = 0; i2 < msg.length; ++i2) {
          bytes[i2] = msg.charCodeAt(i2);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i2 = 0; i2 < length32; i2 += 8) {
        const x2 = input[i2 >> 5] >>> i2 % 32 & 255;
        const hex2 = parseInt(hexTab.charAt(x2 >>> 4 & 15) + hexTab.charAt(x2 & 15), 16);
        output.push(hex2);
      }
      return output;
    }
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    function wordsToMd5(x2, len) {
      x2[len >> 5] |= 128 << len % 32;
      x2[getOutputLength(len) - 1] = len;
      let a2 = 1732584193;
      let b2 = -271733879;
      let c2 = -1732584194;
      let d = 271733878;
      for (let i2 = 0; i2 < x2.length; i2 += 16) {
        const olda = a2;
        const oldb = b2;
        const oldc = c2;
        const oldd = d;
        a2 = md5ff(a2, b2, c2, d, x2[i2], 7, -680876936);
        d = md5ff(d, a2, b2, c2, x2[i2 + 1], 12, -389564586);
        c2 = md5ff(c2, d, a2, b2, x2[i2 + 2], 17, 606105819);
        b2 = md5ff(b2, c2, d, a2, x2[i2 + 3], 22, -1044525330);
        a2 = md5ff(a2, b2, c2, d, x2[i2 + 4], 7, -176418897);
        d = md5ff(d, a2, b2, c2, x2[i2 + 5], 12, 1200080426);
        c2 = md5ff(c2, d, a2, b2, x2[i2 + 6], 17, -1473231341);
        b2 = md5ff(b2, c2, d, a2, x2[i2 + 7], 22, -45705983);
        a2 = md5ff(a2, b2, c2, d, x2[i2 + 8], 7, 1770035416);
        d = md5ff(d, a2, b2, c2, x2[i2 + 9], 12, -1958414417);
        c2 = md5ff(c2, d, a2, b2, x2[i2 + 10], 17, -42063);
        b2 = md5ff(b2, c2, d, a2, x2[i2 + 11], 22, -1990404162);
        a2 = md5ff(a2, b2, c2, d, x2[i2 + 12], 7, 1804603682);
        d = md5ff(d, a2, b2, c2, x2[i2 + 13], 12, -40341101);
        c2 = md5ff(c2, d, a2, b2, x2[i2 + 14], 17, -1502002290);
        b2 = md5ff(b2, c2, d, a2, x2[i2 + 15], 22, 1236535329);
        a2 = md5gg(a2, b2, c2, d, x2[i2 + 1], 5, -165796510);
        d = md5gg(d, a2, b2, c2, x2[i2 + 6], 9, -1069501632);
        c2 = md5gg(c2, d, a2, b2, x2[i2 + 11], 14, 643717713);
        b2 = md5gg(b2, c2, d, a2, x2[i2], 20, -373897302);
        a2 = md5gg(a2, b2, c2, d, x2[i2 + 5], 5, -701558691);
        d = md5gg(d, a2, b2, c2, x2[i2 + 10], 9, 38016083);
        c2 = md5gg(c2, d, a2, b2, x2[i2 + 15], 14, -660478335);
        b2 = md5gg(b2, c2, d, a2, x2[i2 + 4], 20, -405537848);
        a2 = md5gg(a2, b2, c2, d, x2[i2 + 9], 5, 568446438);
        d = md5gg(d, a2, b2, c2, x2[i2 + 14], 9, -1019803690);
        c2 = md5gg(c2, d, a2, b2, x2[i2 + 3], 14, -187363961);
        b2 = md5gg(b2, c2, d, a2, x2[i2 + 8], 20, 1163531501);
        a2 = md5gg(a2, b2, c2, d, x2[i2 + 13], 5, -1444681467);
        d = md5gg(d, a2, b2, c2, x2[i2 + 2], 9, -51403784);
        c2 = md5gg(c2, d, a2, b2, x2[i2 + 7], 14, 1735328473);
        b2 = md5gg(b2, c2, d, a2, x2[i2 + 12], 20, -1926607734);
        a2 = md5hh(a2, b2, c2, d, x2[i2 + 5], 4, -378558);
        d = md5hh(d, a2, b2, c2, x2[i2 + 8], 11, -2022574463);
        c2 = md5hh(c2, d, a2, b2, x2[i2 + 11], 16, 1839030562);
        b2 = md5hh(b2, c2, d, a2, x2[i2 + 14], 23, -35309556);
        a2 = md5hh(a2, b2, c2, d, x2[i2 + 1], 4, -1530992060);
        d = md5hh(d, a2, b2, c2, x2[i2 + 4], 11, 1272893353);
        c2 = md5hh(c2, d, a2, b2, x2[i2 + 7], 16, -155497632);
        b2 = md5hh(b2, c2, d, a2, x2[i2 + 10], 23, -1094730640);
        a2 = md5hh(a2, b2, c2, d, x2[i2 + 13], 4, 681279174);
        d = md5hh(d, a2, b2, c2, x2[i2], 11, -358537222);
        c2 = md5hh(c2, d, a2, b2, x2[i2 + 3], 16, -722521979);
        b2 = md5hh(b2, c2, d, a2, x2[i2 + 6], 23, 76029189);
        a2 = md5hh(a2, b2, c2, d, x2[i2 + 9], 4, -640364487);
        d = md5hh(d, a2, b2, c2, x2[i2 + 12], 11, -421815835);
        c2 = md5hh(c2, d, a2, b2, x2[i2 + 15], 16, 530742520);
        b2 = md5hh(b2, c2, d, a2, x2[i2 + 2], 23, -995338651);
        a2 = md5ii(a2, b2, c2, d, x2[i2], 6, -198630844);
        d = md5ii(d, a2, b2, c2, x2[i2 + 7], 10, 1126891415);
        c2 = md5ii(c2, d, a2, b2, x2[i2 + 14], 15, -1416354905);
        b2 = md5ii(b2, c2, d, a2, x2[i2 + 5], 21, -57434055);
        a2 = md5ii(a2, b2, c2, d, x2[i2 + 12], 6, 1700485571);
        d = md5ii(d, a2, b2, c2, x2[i2 + 3], 10, -1894986606);
        c2 = md5ii(c2, d, a2, b2, x2[i2 + 10], 15, -1051523);
        b2 = md5ii(b2, c2, d, a2, x2[i2 + 1], 21, -2054922799);
        a2 = md5ii(a2, b2, c2, d, x2[i2 + 8], 6, 1873313359);
        d = md5ii(d, a2, b2, c2, x2[i2 + 15], 10, -30611744);
        c2 = md5ii(c2, d, a2, b2, x2[i2 + 6], 15, -1560198380);
        b2 = md5ii(b2, c2, d, a2, x2[i2 + 13], 21, 1309151649);
        a2 = md5ii(a2, b2, c2, d, x2[i2 + 4], 6, -145523070);
        d = md5ii(d, a2, b2, c2, x2[i2 + 11], 10, -1120210379);
        c2 = md5ii(c2, d, a2, b2, x2[i2 + 2], 15, 718787259);
        b2 = md5ii(b2, c2, d, a2, x2[i2 + 9], 21, -343485551);
        a2 = safeAdd(a2, olda);
        b2 = safeAdd(b2, oldb);
        c2 = safeAdd(c2, oldc);
        d = safeAdd(d, oldd);
      }
      return [a2, b2, c2, d];
    }
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i2 = 0; i2 < length8; i2 += 8) {
        output[i2 >> 5] |= (input[i2 / 8] & 255) << i2 % 32;
      }
      return output;
    }
    function safeAdd(x2, y2) {
      const lsw = (x2 & 65535) + (y2 & 65535);
      const msw = (x2 >> 16) + (y2 >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q2, a2, b2, x2, s2, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q2), safeAdd(x2, t)), s2), b2);
    }
    function md5ff(a2, b2, c2, d, x2, s2, t) {
      return md5cmn(b2 & c2 | ~b2 & d, a2, b2, x2, s2, t);
    }
    function md5gg(a2, b2, c2, d, x2, s2, t) {
      return md5cmn(b2 & d | c2 & ~d, a2, b2, x2, s2, t);
    }
    function md5hh(a2, b2, c2, d, x2, s2, t) {
      return md5cmn(b2 ^ c2 ^ d, a2, b2, x2, s2, t);
    }
    function md5ii(a2, b2, c2, d, x2, s2, t) {
      return md5cmn(c2 ^ (b2 | ~d), a2, b2, x2, s2, t);
    }
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID
    };
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i2 = 0; i2 < 16; ++i2) {
          buf[offset + i2] = rnds[i2];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f2(s2, x2, y2, z2) {
      switch (s2) {
        case 0:
          return x2 & y2 ^ ~x2 & z2;
        case 1:
          return x2 ^ y2 ^ z2;
        case 2:
          return x2 & y2 ^ x2 & z2 ^ y2 & z2;
        case 3:
          return x2 ^ y2 ^ z2;
      }
    }
    function ROTL(x2, n) {
      return x2 << n | x2 >>> 32 - n;
    }
    function sha1(bytes) {
      const K2 = [1518500249, 1859775393, 2400959708, 3395469782];
      const H2 = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i2 = 0; i2 < msg.length; ++i2) {
          bytes.push(msg.charCodeAt(i2));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l2 = bytes.length / 4 + 2;
      const N2 = Math.ceil(l2 / 16);
      const M2 = new Array(N2);
      for (let i2 = 0; i2 < N2; ++i2) {
        const arr = new Uint32Array(16);
        for (let j2 = 0; j2 < 16; ++j2) {
          arr[j2] = bytes[i2 * 64 + j2 * 4] << 24 | bytes[i2 * 64 + j2 * 4 + 1] << 16 | bytes[i2 * 64 + j2 * 4 + 2] << 8 | bytes[i2 * 64 + j2 * 4 + 3];
        }
        M2[i2] = arr;
      }
      M2[N2 - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M2[N2 - 1][14] = Math.floor(M2[N2 - 1][14]);
      M2[N2 - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i2 = 0; i2 < N2; ++i2) {
        const W2 = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W2[t] = M2[i2][t];
        }
        for (let t = 16; t < 80; ++t) {
          W2[t] = ROTL(W2[t - 3] ^ W2[t - 8] ^ W2[t - 14] ^ W2[t - 16], 1);
        }
        let a2 = H2[0];
        let b2 = H2[1];
        let c2 = H2[2];
        let d = H2[3];
        let e2 = H2[4];
        for (let t = 0; t < 80; ++t) {
          const s2 = Math.floor(t / 20);
          const T2 = ROTL(a2, 5) + f2(s2, b2, c2, d) + e2 + K2[s2] + W2[t] >>> 0;
          e2 = d;
          d = c2;
          c2 = ROTL(b2, 30) >>> 0;
          b2 = a2;
          a2 = T2;
        }
        H2[0] = H2[0] + a2 >>> 0;
        H2[1] = H2[1] + b2 >>> 0;
        H2[2] = H2[2] + c2 >>> 0;
        H2[3] = H2[3] + d >>> 0;
        H2[4] = H2[4] + e2 >>> 0;
      }
      return [H2[0] >> 24 & 255, H2[0] >> 16 & 255, H2[0] >> 8 & 255, H2[0] & 255, H2[1] >> 24 & 255, H2[1] >> 16 & 255, H2[1] >> 8 & 255, H2[1] & 255, H2[2] >> 24 & 255, H2[2] >> 16 & 255, H2[2] >> 8 & 255, H2[2] & 255, H2[3] >> 24 & 255, H2[3] >> 16 & 255, H2[3] >> 8 & 255, H2[3] & 255, H2[4] >> 24 & 255, H2[4] >> 16 & 255, H2[4] >> 8 & 255, H2[4] & 255];
    }
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    var _default = version;
    exports.default = _default;
  }
});

// node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function get() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function get() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function get() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function get() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function get() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function get() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function get() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function get() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function get() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js
function fromString(s2, radix) {
  if (!radix || radix == 10) {
    return BigInt(s2);
  } else if (radix == 16) {
    if (s2.slice(0, 2) == "0x") {
      return BigInt(s2);
    } else {
      return BigInt("0x" + s2);
    }
  }
}
function fromArray(a2, radix) {
  let acc = BigInt(0);
  radix = BigInt(radix);
  for (let i2 = 0; i2 < a2.length; i2++) {
    acc = acc * radix + BigInt(a2[i2]);
  }
  return acc;
}
function bitLength$6(a2) {
  const aS = a2.toString(16);
  return (aS.length - 1) * 4 + hexLen[parseInt(aS[0], 16)];
}
function isNegative$4(a2) {
  return BigInt(a2) < BigInt(0);
}
function isZero$1(a2) {
  return !a2;
}
function shiftLeft(a2, n) {
  return BigInt(a2) << BigInt(n);
}
function shiftRight(a2, n) {
  return BigInt(a2) >> BigInt(n);
}
function isOdd$5(a2) {
  return (BigInt(a2) & BigInt(1)) == BigInt(1);
}
function naf(n) {
  let E2 = BigInt(n);
  const res = [];
  while (E2) {
    if (E2 & BigInt(1)) {
      const z2 = 2 - Number(E2 % BigInt(4));
      res.push(z2);
      E2 = E2 - BigInt(z2);
    } else {
      res.push(0);
    }
    E2 = E2 >> BigInt(1);
  }
  return res;
}
function bits(n) {
  let E2 = BigInt(n);
  const res = [];
  while (E2) {
    if (E2 & BigInt(1)) {
      res.push(1);
    } else {
      res.push(0);
    }
    E2 = E2 >> BigInt(1);
  }
  return res;
}
function toNumber$1(s2) {
  if (s2 > BigInt(Number.MAX_SAFE_INTEGER)) {
    throw new Error("Number too big");
  }
  return Number(s2);
}
function toArray(s2, radix) {
  const res = [];
  let rem = BigInt(s2);
  radix = BigInt(radix);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  return res;
}
function add(a2, b2) {
  return BigInt(a2) + BigInt(b2);
}
function sub(a2, b2) {
  return BigInt(a2) - BigInt(b2);
}
function neg(a2) {
  return -BigInt(a2);
}
function mul(a2, b2) {
  return BigInt(a2) * BigInt(b2);
}
function square$2(a2) {
  return BigInt(a2) * BigInt(a2);
}
function pow(a2, b2) {
  return BigInt(a2) ** BigInt(b2);
}
function exp$1(a2, b2) {
  return BigInt(a2) ** BigInt(b2);
}
function abs$1(a2) {
  return BigInt(a2) >= 0 ? BigInt(a2) : -BigInt(a2);
}
function div(a2, b2) {
  return BigInt(a2) / BigInt(b2);
}
function mod(a2, b2) {
  return BigInt(a2) % BigInt(b2);
}
function eq(a2, b2) {
  return BigInt(a2) == BigInt(b2);
}
function neq(a2, b2) {
  return BigInt(a2) != BigInt(b2);
}
function lt(a2, b2) {
  return BigInt(a2) < BigInt(b2);
}
function gt(a2, b2) {
  return BigInt(a2) > BigInt(b2);
}
function leq(a2, b2) {
  return BigInt(a2) <= BigInt(b2);
}
function geq(a2, b2) {
  return BigInt(a2) >= BigInt(b2);
}
function band(a2, b2) {
  return BigInt(a2) & BigInt(b2);
}
function bor(a2, b2) {
  return BigInt(a2) | BigInt(b2);
}
function bxor(a2, b2) {
  return BigInt(a2) ^ BigInt(b2);
}
function land(a2, b2) {
  return BigInt(a2) && BigInt(b2);
}
function lor(a2, b2) {
  return BigInt(a2) || BigInt(b2);
}
function lnot(a2) {
  return !BigInt(a2);
}
function toRprLE(buff, o2, e2, n8) {
  const s2 = "0000000" + e2.toString(16);
  const v2 = new Uint32Array(buff.buffer, buff.byteOffset + o2, n8 / 4);
  const l2 = ((s2.length - 7) * 4 - 1 >> 5) + 1;
  for (let i2 = 0; i2 < l2; i2++) v2[i2] = parseInt(s2.substring(s2.length - 8 * i2 - 8, s2.length - 8 * i2), 16);
  for (let i2 = l2; i2 < v2.length; i2++) v2[i2] = 0;
  for (let i2 = v2.length * 4; i2 < n8; i2++) buff[i2] = toNumber$1(band(shiftRight(e2, i2 * 8), 255));
}
function toRprBE(buff, o2, e2, n8) {
  const s2 = "0000000" + e2.toString(16);
  const v2 = new DataView(buff.buffer, buff.byteOffset + o2, n8);
  const l2 = ((s2.length - 7) * 4 - 1 >> 5) + 1;
  for (let i2 = 0; i2 < l2; i2++) v2.setUint32(n8 - i2 * 4 - 4, parseInt(s2.substring(s2.length - 8 * i2 - 8, s2.length - 8 * i2), 16), false);
  for (let i2 = 0; i2 < n8 / 4 - l2; i2++) v2[i2] = 0;
}
function fromRprLE(buff, o2, n8) {
  n8 = n8 || buff.byteLength;
  o2 = o2 || 0;
  const v2 = new Uint32Array(buff.buffer, buff.byteOffset + o2, n8 / 4);
  const a2 = new Array(n8 / 4);
  v2.forEach((ch, i2) => a2[a2.length - i2 - 1] = ch.toString(16).padStart(8, "0"));
  return fromString(a2.join(""), 16);
}
function fromRprBE(buff, o2, n8) {
  n8 = n8 || buff.byteLength;
  o2 = o2 || 0;
  const v2 = new DataView(buff.buffer, buff.byteOffset + o2, n8);
  const a2 = new Array(n8 / 4);
  for (let i2 = 0; i2 < n8 / 4; i2++) {
    a2[i2] = v2.getUint32(i2 * 4, false).toString(16).padStart(8, "0");
  }
  return fromString(a2.join(""), 16);
}
function toString(a2, radix) {
  return a2.toString(radix);
}
function toLEBuff(a2) {
  const buff = new Uint8Array(Math.floor((bitLength$6(a2) - 1) / 8) + 1);
  toRprLE(buff, 0, a2, buff.byteLength);
  return buff;
}
function _revSlow$1(idx, bits2) {
  let res = 0;
  let a2 = idx;
  for (let i2 = 0; i2 < bits2; i2++) {
    res <<= 1;
    res = res | a2 & 1;
    a2 >>= 1;
  }
  return res;
}
function exp(F2, base, e2) {
  if (isZero$1(e2)) return F2.one;
  const n = bits(e2);
  if (n.length == 0) return F2.one;
  let res = base;
  for (let i2 = n.length - 2; i2 >= 0; i2--) {
    res = F2.square(res);
    if (n[i2]) {
      res = F2.mul(res, base);
    }
  }
  return res;
}
function buildSqrt(F2) {
  if (F2.m % 2 == 1) {
    if (eq(mod(F2.p, 4), 1)) {
      if (eq(mod(F2.p, 8), 1)) {
        if (eq(mod(F2.p, 16), 1)) {
          alg5_tonelliShanks(F2);
        } else if (eq(mod(F2.p, 16), 9)) {
          alg4_kong(F2);
        } else {
          throw new Error("Field withot sqrt");
        }
      } else if (eq(mod(F2.p, 8), 5)) {
        alg3_atkin(F2);
      } else {
        throw new Error("Field withot sqrt");
      }
    } else if (eq(mod(F2.p, 4), 3)) {
      alg2_shanks(F2);
    }
  } else {
    const pm2mod4 = mod(pow(F2.p, F2.m / 2), 4);
    if (pm2mod4 == 1) {
      alg10_adj(F2);
    } else if (pm2mod4 == 3) {
      alg9_adj(F2);
    } else {
      alg8_complex(F2);
    }
  }
}
function alg5_tonelliShanks(F2) {
  F2.sqrt_q = pow(F2.p, F2.m);
  F2.sqrt_s = 0;
  F2.sqrt_t = sub(F2.sqrt_q, 1);
  while (!isOdd$5(F2.sqrt_t)) {
    F2.sqrt_s = F2.sqrt_s + 1;
    F2.sqrt_t = div(F2.sqrt_t, 2);
  }
  let c0 = F2.one;
  while (F2.eq(c0, F2.one)) {
    const c2 = F2.random();
    F2.sqrt_z = F2.pow(c2, F2.sqrt_t);
    c0 = F2.pow(F2.sqrt_z, 2 ** (F2.sqrt_s - 1));
  }
  F2.sqrt_tm1d2 = div(sub(F2.sqrt_t, 1), 2);
  F2.sqrt = function(a2) {
    const F3 = this;
    if (F3.isZero(a2)) return F3.zero;
    let w2 = F3.pow(a2, F3.sqrt_tm1d2);
    const a0 = F3.pow(F3.mul(F3.square(w2), a2), 2 ** (F3.sqrt_s - 1));
    if (F3.eq(a0, F3.negone)) return null;
    let v2 = F3.sqrt_s;
    let x2 = F3.mul(a2, w2);
    let b2 = F3.mul(x2, w2);
    let z2 = F3.sqrt_z;
    while (!F3.eq(b2, F3.one)) {
      let b2k = F3.square(b2);
      let k2 = 1;
      while (!F3.eq(b2k, F3.one)) {
        b2k = F3.square(b2k);
        k2++;
      }
      w2 = z2;
      for (let i2 = 0; i2 < v2 - k2 - 1; i2++) {
        w2 = F3.square(w2);
      }
      z2 = F3.square(w2);
      b2 = F3.mul(b2, z2);
      x2 = F3.mul(x2, w2);
      v2 = k2;
    }
    return F3.geq(x2, F3.zero) ? x2 : F3.neg(x2);
  };
}
function alg4_kong(F2) {
  F2.sqrt = function() {
    throw new Error("Sqrt alg 4 not implemented");
  };
}
function alg3_atkin(F2) {
  F2.sqrt = function() {
    throw new Error("Sqrt alg 3 not implemented");
  };
}
function alg2_shanks(F2) {
  F2.sqrt_q = pow(F2.p, F2.m);
  F2.sqrt_e1 = div(sub(F2.sqrt_q, 3), 4);
  F2.sqrt = function(a2) {
    if (this.isZero(a2)) return this.zero;
    const a1 = this.pow(a2, this.sqrt_e1);
    const a0 = this.mul(this.square(a1), a2);
    if (this.eq(a0, this.negone)) return null;
    const x2 = this.mul(a1, a2);
    return F2.geq(x2, F2.zero) ? x2 : F2.neg(x2);
  };
}
function alg10_adj(F2) {
  F2.sqrt = function() {
    throw new Error("Sqrt alg 10 not implemented");
  };
}
function alg9_adj(F2) {
  F2.sqrt_q = pow(F2.p, F2.m / 2);
  F2.sqrt_e34 = div(sub(F2.sqrt_q, 3), 4);
  F2.sqrt_e12 = div(sub(F2.sqrt_q, 1), 2);
  F2.frobenius = function(n, x2) {
    if (n % 2 == 1) {
      return F2.conjugate(x2);
    } else {
      return x2;
    }
  };
  F2.sqrt = function(a2) {
    const F3 = this;
    const a1 = F3.pow(a2, F3.sqrt_e34);
    const alfa = F3.mul(F3.square(a1), a2);
    const a0 = F3.mul(F3.frobenius(1, alfa), alfa);
    if (F3.eq(a0, F3.negone)) return null;
    const x0 = F3.mul(a1, a2);
    let x2;
    if (F3.eq(alfa, F3.negone)) {
      x2 = F3.mul(x0, [F3.F.zero, F3.F.one]);
    } else {
      const b2 = F3.pow(F3.add(F3.one, alfa), F3.sqrt_e12);
      x2 = F3.mul(b2, x0);
    }
    return F3.geq(x2, F3.zero) ? x2 : F3.neg(x2);
  };
}
function alg8_complex(F2) {
  F2.sqrt = function() {
    throw new Error("Sqrt alg 8 not implemented");
  };
}
function quarterRound(st2, a2, b2, c2, d) {
  st2[a2] = st2[a2] + st2[b2] >>> 0;
  st2[d] = (st2[d] ^ st2[a2]) >>> 0;
  st2[d] = (st2[d] << 16 | st2[d] >>> 16 & 65535) >>> 0;
  st2[c2] = st2[c2] + st2[d] >>> 0;
  st2[b2] = (st2[b2] ^ st2[c2]) >>> 0;
  st2[b2] = (st2[b2] << 12 | st2[b2] >>> 20 & 4095) >>> 0;
  st2[a2] = st2[a2] + st2[b2] >>> 0;
  st2[d] = (st2[d] ^ st2[a2]) >>> 0;
  st2[d] = (st2[d] << 8 | st2[d] >>> 24 & 255) >>> 0;
  st2[c2] = st2[c2] + st2[d] >>> 0;
  st2[b2] = (st2[b2] ^ st2[c2]) >>> 0;
  st2[b2] = (st2[b2] << 7 | st2[b2] >>> 25 & 127) >>> 0;
}
function doubleRound(st2) {
  quarterRound(st2, 0, 4, 8, 12);
  quarterRound(st2, 1, 5, 9, 13);
  quarterRound(st2, 2, 6, 10, 14);
  quarterRound(st2, 3, 7, 11, 15);
  quarterRound(st2, 0, 5, 10, 15);
  quarterRound(st2, 1, 6, 11, 12);
  quarterRound(st2, 2, 7, 8, 13);
  quarterRound(st2, 3, 4, 9, 14);
}
function getRandomBytes(n) {
  let array = new Uint8Array(n);
  {
    if (typeof globalThis.crypto !== "undefined") {
      globalThis.crypto.getRandomValues(array);
    } else {
      for (let i2 = 0; i2 < n; i2++) {
        array[i2] = Math.random() * 4294967296 >>> 0;
      }
    }
  }
  return array;
}
function getRandomSeed() {
  const arr = getRandomBytes(32);
  const arrV = new Uint32Array(arr.buffer);
  const seed = [];
  for (let i2 = 0; i2 < 8; i2++) {
    seed.push(arrV[i2]);
  }
  return seed;
}
function getThreadRng() {
  if (threadRng) return threadRng;
  threadRng = new ChaCha(getRandomSeed());
  return threadRng;
}
function log2$1(V2) {
  return ((V2 & 4294901760) !== 0 ? (V2 &= 4294901760, 16) : 0) | ((V2 & 4278255360) !== 0 ? (V2 &= 4278255360, 8) : 0) | ((V2 & 4042322160) !== 0 ? (V2 &= 4042322160, 4) : 0) | ((V2 & 3435973836) !== 0 ? (V2 &= 3435973836, 2) : 0) | (V2 & 2863311530) !== 0;
}
function __fft(PF, pall, bits2, offset, step) {
  const n = 1 << bits2;
  if (n == 1) {
    return [pall[offset]];
  } else if (n == 2) {
    return [
      PF.G.add(pall[offset], pall[offset + step]),
      PF.G.sub(pall[offset], pall[offset + step])
    ];
  }
  const ndiv2 = n >> 1;
  const p1 = __fft(PF, pall, bits2 - 1, offset, step * 2);
  const p2 = __fft(PF, pall, bits2 - 1, offset + step, step * 2);
  const out = new Array(n);
  for (let i2 = 0; i2 < ndiv2; i2++) {
    out[i2] = PF.G.add(p1[i2], PF.opMulGF(p2[i2], PF.roots[bits2][i2]));
    out[i2 + ndiv2] = PF.G.sub(p1[i2], PF.opMulGF(p2[i2], PF.roots[bits2][i2]));
  }
  return out;
}
function buildBatchInverse$3(module, prefix2) {
  const n8 = module.modules[prefix2].n64 * 8;
  const f2 = module.addFunction(prefix2 + "_batchInverse");
  f2.addParam("pIn", "i32");
  f2.addParam("inStep", "i32");
  f2.addParam("n", "i32");
  f2.addParam("pOut", "i32");
  f2.addParam("outStep", "i32");
  f2.addLocal("itAux", "i32");
  f2.addLocal("itIn", "i32");
  f2.addLocal("itOut", "i32");
  f2.addLocal("i", "i32");
  const c2 = f2.getCodeBuilder();
  const AUX = c2.i32_const(module.alloc(n8));
  f2.addCode(
    c2.setLocal("itAux", c2.i32_load(c2.i32_const(0))),
    c2.i32_store(
      c2.i32_const(0),
      c2.i32_add(
        c2.getLocal("itAux"),
        c2.i32_mul(
          c2.i32_add(
            c2.getLocal("n"),
            c2.i32_const(1)
          ),
          c2.i32_const(n8)
        )
      )
    )
  );
  f2.addCode(
    // aux[0] = a;
    c2.call(prefix2 + "_one", c2.getLocal("itAux")),
    // for (i=0;i<n;i++) aux[i] = aux[i-1]*in[i]
    c2.setLocal("itIn", c2.getLocal("pIn")),
    c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
    c2.setLocal("i", c2.i32_const(0)),
    c2.block(c2.loop(
      c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
      c2.if(
        c2.call(prefix2 + "_isZero", c2.getLocal("itIn")),
        c2.call(
          prefix2 + "_copy",
          c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)),
          c2.getLocal("itAux")
        ),
        c2.call(
          prefix2 + "_mul",
          c2.getLocal("itIn"),
          c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)),
          c2.getLocal("itAux")
        )
      ),
      c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.getLocal("inStep"))),
      c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
      c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
      c2.br(0)
    )),
    // point to the last
    c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.getLocal("inStep"))),
    c2.setLocal("itAux", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))),
    // itOut = pOut + (n-1)*stepOut   // Point to the last
    c2.setLocal(
      "itOut",
      c2.i32_add(
        c2.getLocal("pOut"),
        c2.i32_mul(
          c2.i32_sub(c2.getLocal("n"), c2.i32_const(1)),
          c2.getLocal("outStep")
        )
      )
    ),
    // aux[n-1] = 1/aux[n-1]
    c2.call(prefix2 + "_inverse", c2.getLocal("itAux"), c2.getLocal("itAux")),
    c2.block(c2.loop(
      c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
      c2.if(
        c2.call(prefix2 + "_isZero", c2.getLocal("itIn")),
        [
          ...c2.call(
            prefix2 + "_copy",
            c2.getLocal("itAux"),
            c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))
          ),
          ...c2.call(
            prefix2 + "_zero",
            c2.getLocal("itOut")
          )
        ],
        [
          ...c2.call(prefix2 + "_copy", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8)), AUX),
          ...c2.call(
            prefix2 + "_mul",
            c2.getLocal("itAux"),
            c2.getLocal("itIn"),
            c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))
          ),
          ...c2.call(
            prefix2 + "_mul",
            c2.getLocal("itAux"),
            AUX,
            c2.getLocal("itOut")
          )
        ]
      ),
      c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.getLocal("inStep"))),
      c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.getLocal("outStep"))),
      c2.setLocal("itAux", c2.i32_sub(c2.getLocal("itAux"), c2.i32_const(n8))),
      c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
      c2.br(0)
    ))
  );
  f2.addCode(
    c2.i32_store(
      c2.i32_const(0),
      c2.getLocal("itAux")
    )
  );
}
function buildBatchConvertion$3(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
  if (typeof reverse === "undefined") {
    if (sizeIn < sizeOut) {
      reverse = true;
    } else {
      reverse = false;
    }
  }
  const f2 = module.addFunction(fnName);
  f2.addParam("pIn", "i32");
  f2.addParam("n", "i32");
  f2.addParam("pOut", "i32");
  f2.addLocal("i", "i32");
  f2.addLocal("itIn", "i32");
  f2.addLocal("itOut", "i32");
  const c2 = f2.getCodeBuilder();
  if (reverse) {
    f2.addCode(
      c2.setLocal(
        "itIn",
        c2.i32_add(
          c2.getLocal("pIn"),
          c2.i32_mul(
            c2.i32_sub(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.i32_const(sizeIn)
          )
        )
      ),
      c2.setLocal(
        "itOut",
        c2.i32_add(
          c2.getLocal("pOut"),
          c2.i32_mul(
            c2.i32_sub(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.i32_const(sizeOut)
          )
        )
      ),
      c2.setLocal("i", c2.i32_const(0)),
      c2.block(c2.loop(
        c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
        c2.call(internalFnName, c2.getLocal("itIn"), c2.getLocal("itOut")),
        c2.setLocal("itIn", c2.i32_sub(c2.getLocal("itIn"), c2.i32_const(sizeIn))),
        c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
        c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
        c2.br(0)
      ))
    );
  } else {
    f2.addCode(
      c2.setLocal("itIn", c2.getLocal("pIn")),
      c2.setLocal("itOut", c2.getLocal("pOut")),
      c2.setLocal("i", c2.i32_const(0)),
      c2.block(c2.loop(
        c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
        c2.call(internalFnName, c2.getLocal("itIn"), c2.getLocal("itOut")),
        c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(sizeIn))),
        c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
        c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
        c2.br(0)
      ))
    );
  }
}
function buildBatchConvertion$2(module, fnName, internalFnName, sizeIn, sizeOut, reverse) {
  if (typeof reverse === "undefined") {
    if (sizeIn < sizeOut) {
      reverse = true;
    } else {
      reverse = false;
    }
  }
  const f2 = module.addFunction(fnName);
  f2.addParam("pIn1", "i32");
  f2.addParam("pIn2", "i32");
  f2.addParam("n", "i32");
  f2.addParam("pOut", "i32");
  f2.addLocal("i", "i32");
  f2.addLocal("itIn1", "i32");
  f2.addLocal("itIn2", "i32");
  f2.addLocal("itOut", "i32");
  const c2 = f2.getCodeBuilder();
  if (reverse) {
    f2.addCode(
      c2.setLocal(
        "itIn1",
        c2.i32_add(
          c2.getLocal("pIn1"),
          c2.i32_mul(
            c2.i32_sub(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.i32_const(sizeIn)
          )
        )
      ),
      c2.setLocal(
        "itIn2",
        c2.i32_add(
          c2.getLocal("pIn2"),
          c2.i32_mul(
            c2.i32_sub(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.i32_const(sizeIn)
          )
        )
      ),
      c2.setLocal(
        "itOut",
        c2.i32_add(
          c2.getLocal("pOut"),
          c2.i32_mul(
            c2.i32_sub(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.i32_const(sizeOut)
          )
        )
      ),
      c2.setLocal("i", c2.i32_const(0)),
      c2.block(c2.loop(
        c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
        c2.call(internalFnName, c2.getLocal("itIn1"), c2.getLocal("itIn2"), c2.getLocal("itOut")),
        c2.setLocal("itIn1", c2.i32_sub(c2.getLocal("itIn1"), c2.i32_const(sizeIn))),
        c2.setLocal("itIn2", c2.i32_sub(c2.getLocal("itIn2"), c2.i32_const(sizeIn))),
        c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
        c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
        c2.br(0)
      ))
    );
  } else {
    f2.addCode(
      c2.setLocal("itIn1", c2.getLocal("pIn1")),
      c2.setLocal("itIn2", c2.getLocal("pIn2")),
      c2.setLocal("itOut", c2.getLocal("pOut")),
      c2.setLocal("i", c2.i32_const(0)),
      c2.block(c2.loop(
        c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
        c2.call(internalFnName, c2.getLocal("itIn1"), c2.getLocal("itIn2"), c2.getLocal("itOut")),
        c2.setLocal("itIn1", c2.i32_add(c2.getLocal("itIn1"), c2.i32_const(sizeIn))),
        c2.setLocal("itIn2", c2.i32_add(c2.getLocal("itIn2"), c2.i32_const(sizeIn))),
        c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(sizeOut))),
        c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
        c2.br(0)
      ))
    );
  }
}
function compare(a2, b2) {
  return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;
}
function square$1(n) {
  return n * n;
}
function isOdd$4(n) {
  return n % 2n !== 0n;
}
function isEven(n) {
  return n % 2n === 0n;
}
function isNegative$3(n) {
  return n < 0n;
}
function isPositive(n) {
  return n > 0n;
}
function bitLength$5(n) {
  if (isNegative$3(n)) {
    return n.toString(2).length - 1;
  } else {
    return n.toString(2).length;
  }
}
function abs(n) {
  return n < 0n ? -n : n;
}
function isUnit(n) {
  return abs(n) === 1n;
}
function modInv$3(a2, n) {
  var t = 0n, newT = 1n, r2 = n, newR = abs(a2), q2, lastT, lastR;
  while (newR !== 0n) {
    q2 = r2 / newR;
    lastT = t;
    lastR = r2;
    t = newT;
    r2 = newR;
    newT = lastT - q2 * newT;
    newR = lastR - q2 * newR;
  }
  if (!isUnit(r2)) throw new Error(a2.toString() + " and " + n.toString() + " are not co-prime");
  if (compare(t, 0n) === -1) {
    t = t + n;
  }
  if (isNegative$3(a2)) {
    return -t;
  }
  return t;
}
function modPow$2(n, exp2, mod2) {
  if (mod2 === 0n) throw new Error("Cannot take modPow with modulus 0");
  var r2 = 1n, base = n % mod2;
  if (isNegative$3(exp2)) {
    exp2 = exp2 * -1n;
    base = modInv$3(base, mod2);
  }
  while (isPositive(exp2)) {
    if (base === 0n) return 0n;
    if (isOdd$4(exp2)) r2 = r2 * base % mod2;
    exp2 = exp2 / 2n;
    base = square$1(base) % mod2;
  }
  return r2;
}
function compareAbs(a2, b2) {
  a2 = a2 >= 0n ? a2 : -a2;
  b2 = b2 >= 0n ? b2 : -b2;
  return a2 === b2 ? 0 : a2 > b2 ? 1 : -1;
}
function isDivisibleBy(a2, n) {
  if (n === 0n) return false;
  if (isUnit(n)) return true;
  if (compareAbs(n, 2n) === 0) return isEven(a2);
  return a2 % n === 0n;
}
function isBasicPrime(v2) {
  var n = abs(v2);
  if (isUnit(n)) return false;
  if (n === 2n || n === 3n || n === 5n) return true;
  if (isEven(n) || isDivisibleBy(n, 3n) || isDivisibleBy(n, 5n)) return false;
  if (n < 49n) return true;
}
function prev(n) {
  return n - 1n;
}
function millerRabinTest(n, a2) {
  var nPrev = prev(n), b2 = nPrev, r2 = 0, d, i2, x2;
  while (isEven(b2)) b2 = b2 / 2n, r2++;
  next: for (i2 = 0; i2 < a2.length; i2++) {
    if (n < a2[i2]) continue;
    x2 = modPow$2(BigInt(a2[i2]), b2, n);
    if (isUnit(x2) || x2 === nPrev) continue;
    for (d = r2 - 1; d != 0; d--) {
      x2 = square$1(x2) % n;
      if (isUnit(x2)) return false;
      if (x2 === nPrev) continue next;
    }
    return false;
  }
  return true;
}
function isPrime$1(p2) {
  var isPrime2 = isBasicPrime(p2);
  if (isPrime2 !== void 0) return isPrime2;
  var n = abs(p2);
  var bits2 = bitLength$5(n);
  if (bits2 <= 64)
    return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
  var logN = Math.log(2) * Number(bits2);
  var t = Math.ceil(logN);
  for (var a2 = [], i2 = 0; i2 < t; i2++) {
    a2.push(BigInt(i2 + 2));
  }
  return millerRabinTest(n, a2);
}
function stringifyBigInts(o2) {
  if (typeof o2 == "bigint" || o2.eq !== void 0) {
    return o2.toString(10);
  } else if (o2 instanceof Uint8Array) {
    return fromRprLE(o2, 0);
  } else if (Array.isArray(o2)) {
    return o2.map(stringifyBigInts);
  } else if (typeof o2 == "object") {
    const res = {};
    const keys = Object.keys(o2);
    keys.forEach((k2) => {
      res[k2] = stringifyBigInts(o2[k2]);
    });
    return res;
  } else {
    return o2;
  }
}
function unstringifyBigInts(o2) {
  if (typeof o2 == "string" && /^[0-9]+$/.test(o2)) {
    return BigInt(o2);
  } else if (typeof o2 == "string" && /^0x[0-9a-fA-F]+$/.test(o2)) {
    return BigInt(o2);
  } else if (Array.isArray(o2)) {
    return o2.map(unstringifyBigInts);
  } else if (typeof o2 == "object") {
    if (o2 === null) return null;
    const res = {};
    const keys = Object.keys(o2);
    keys.forEach((k2) => {
      res[k2] = unstringifyBigInts(o2[k2]);
    });
    return res;
  } else {
    return o2;
  }
}
function beBuff2int(buff) {
  let res = BigInt(0);
  let i2 = buff.length;
  let offset = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i2 > 0) {
    if (i2 >= 4) {
      i2 -= 4;
      res += BigInt(buffV.getUint32(i2)) << BigInt(offset * 8);
      offset += 4;
    } else if (i2 >= 2) {
      i2 -= 2;
      res += BigInt(buffV.getUint16(i2)) << BigInt(offset * 8);
      offset += 2;
    } else {
      i2 -= 1;
      res += BigInt(buffV.getUint8(i2)) << BigInt(offset * 8);
      offset += 1;
    }
  }
  return res;
}
function beInt2Buff(n, len) {
  let r2 = n;
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o2 = len;
  while (o2 > 0) {
    if (o2 - 4 >= 0) {
      o2 -= 4;
      buffV.setUint32(o2, Number(r2 & BigInt(4294967295)));
      r2 = r2 >> BigInt(32);
    } else if (o2 - 2 >= 0) {
      o2 -= 2;
      buffV.setUint16(o2, Number(r2 & BigInt(65535)));
      r2 = r2 >> BigInt(16);
    } else {
      o2 -= 1;
      buffV.setUint8(o2, Number(r2 & BigInt(255)));
      r2 = r2 >> BigInt(8);
    }
  }
  if (r2) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function leBuff2int(buff) {
  let res = BigInt(0);
  let i2 = 0;
  const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
  while (i2 < buff.length) {
    if (i2 + 4 <= buff.length) {
      res += BigInt(buffV.getUint32(i2, true)) << BigInt(i2 * 8);
      i2 += 4;
    } else if (i2 + 2 <= buff.length) {
      res += BigInt(buffV.getUint16(i2, true)) << BigInt(i2 * 8);
      i2 += 2;
    } else {
      res += BigInt(buffV.getUint8(i2, true)) << BigInt(i2 * 8);
      i2 += 1;
    }
  }
  return res;
}
function leInt2Buff(n, len) {
  let r2 = n;
  if (typeof len === "undefined") {
    len = Math.floor((bitLength$6(n) - 1) / 8) + 1;
    if (len == 0) len = 1;
  }
  const buff = new Uint8Array(len);
  const buffV = new DataView(buff.buffer);
  let o2 = 0;
  while (o2 < len) {
    if (o2 + 4 <= len) {
      buffV.setUint32(o2, Number(r2 & BigInt(4294967295)), true);
      o2 += 4;
      r2 = r2 >> BigInt(32);
    } else if (o2 + 2 <= len) {
      buffV.setUint16(o2, Number(r2 & BigInt(65535)), true);
      o2 += 2;
      r2 = r2 >> BigInt(16);
    } else {
      buffV.setUint8(o2, Number(r2 & BigInt(255)), true);
      o2 += 1;
      r2 = r2 >> BigInt(8);
    }
  }
  if (r2) {
    throw new Error("Number does not fit in this length");
  }
  return buff;
}
function stringifyFElements(F2, o2) {
  if (typeof o2 == "bigint" || o2.eq !== void 0) {
    return o2.toString(10);
  } else if (o2 instanceof Uint8Array) {
    return F2.toString(F2.e(o2));
  } else if (Array.isArray(o2)) {
    return o2.map(stringifyFElements.bind(this, F2));
  } else if (typeof o2 == "object") {
    const res = {};
    const keys = Object.keys(o2);
    keys.forEach((k2) => {
      res[k2] = stringifyFElements(F2, o2[k2]);
    });
    return res;
  } else {
    return o2;
  }
}
function unstringifyFElements(F2, o2) {
  if (typeof o2 == "string" && /^[0-9]+$/.test(o2)) {
    return F2.e(o2);
  } else if (typeof o2 == "string" && /^0x[0-9a-fA-F]+$/.test(o2)) {
    return F2.e(o2);
  } else if (Array.isArray(o2)) {
    return o2.map(unstringifyFElements.bind(this, F2));
  } else if (typeof o2 == "object") {
    if (o2 === null) return null;
    const res = {};
    const keys = Object.keys(o2);
    keys.forEach((k2) => {
      res[k2] = unstringifyFElements(F2, o2[k2]);
    });
    return res;
  } else {
    return o2;
  }
}
function _revSlow(idx, bits2) {
  let res = 0;
  let a2 = idx;
  for (let i2 = 0; i2 < bits2; i2++) {
    res <<= 1;
    res = res | a2 & 1;
    a2 >>= 1;
  }
  return res;
}
function bitReverse(idx, bits2) {
  return (_revTable[idx >>> 24] | _revTable[idx >>> 16 & 255] << 8 | _revTable[idx >>> 8 & 255] << 16 | _revTable[idx & 255] << 24) >>> 32 - bits2;
}
function log2(V2) {
  return ((V2 & 4294901760) !== 0 ? (V2 &= 4294901760, 16) : 0) | ((V2 & 4278255360) !== 0 ? (V2 &= 4278255360, 8) : 0) | ((V2 & 4042322160) !== 0 ? (V2 &= 4042322160, 4) : 0) | ((V2 & 3435973836) !== 0 ? (V2 &= 3435973836, 2) : 0) | (V2 & 2863311530) !== 0;
}
function buffReverseBits(buff, eSize) {
  const n = buff.byteLength / eSize;
  const bits2 = log2(n);
  if (n != 1 << bits2) {
    throw new Error("Invalid number of pointers");
  }
  for (let i2 = 0; i2 < n; i2++) {
    const r2 = bitReverse(i2, bits2);
    if (i2 > r2) {
      const tmp = buff.slice(i2 * eSize, (i2 + 1) * eSize);
      buff.set(buff.slice(r2 * eSize, (r2 + 1) * eSize), i2 * eSize);
      buff.set(tmp, r2 * eSize);
    }
  }
}
function array2buffer(arr, sG) {
  const buff = new Uint8Array(sG * arr.length);
  for (let i2 = 0; i2 < arr.length; i2++) {
    buff.set(arr[i2], i2 * sG);
  }
  return buff;
}
function buffer2array(buff, sG) {
  const n = buff.byteLength / sG;
  const arr = new Array(n);
  for (let i2 = 0; i2 < n; i2++) {
    arr[i2] = buff.slice(i2 * sG, i2 * sG + sG);
  }
  return arr;
}
function buildBatchConvert(tm, fnName, sIn, sOut) {
  return async function batchConvert(buffIn) {
    const nPoints = Math.floor(buffIn.byteLength / sIn);
    if (nPoints * sIn !== buffIn.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i2 = 0; i2 < tm.concurrency; i2++) {
      let n;
      if (i2 < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i2 * pointsPerChunk;
      }
      if (n == 0) continue;
      const buffChunk = buffIn.slice(i2 * pointsPerChunk * sIn, i2 * pointsPerChunk * sIn + n * sIn);
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffChunk },
        { cmd: "ALLOC", var: 1, len: sOut * n },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: n },
          { var: 1 }
        ] },
        { cmd: "GET", out: 0, var: 1, len: sOut * n }
      ];
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buffIn instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sOut);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sOut);
    }
    let p2 = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      fullBuffOut.set(result[i2][0], p2);
      p2 += result[i2][0].byteLength;
    }
    return fullBuffOut;
  };
}
function thread(self2) {
  const MAXMEM = 32767;
  let instance;
  let memory;
  if (self2) {
    self2.onmessage = function(e2) {
      let data;
      if (e2.data) {
        data = e2.data;
      } else {
        data = e2;
      }
      if (data[0].cmd == "INIT") {
        init(data[0]).then(function() {
          self2.postMessage(data.result);
        });
      } else if (data[0].cmd == "TERMINATE") {
        self2.close();
      } else {
        const res = runTask(data);
        self2.postMessage(res);
      }
    };
  }
  async function init(data) {
    const code = new Uint8Array(data.code);
    const wasmModule = await WebAssembly.compile(code);
    memory = new WebAssembly.Memory({ initial: data.init, maximum: MAXMEM });
    instance = await WebAssembly.instantiate(wasmModule, {
      env: {
        "memory": memory
      }
    });
  }
  function alloc2(length2) {
    const u322 = new Uint32Array(memory.buffer, 0, 1);
    while (u322[0] & 3) u322[0]++;
    const res = u322[0];
    u322[0] += length2;
    if (u322[0] + length2 > memory.buffer.byteLength) {
      const currentPages = memory.buffer.byteLength / 65536;
      let requiredPages = Math.floor((u322[0] + length2) / 65536) + 1;
      if (requiredPages > MAXMEM) requiredPages = MAXMEM;
      memory.grow(requiredPages - currentPages);
    }
    return res;
  }
  function allocBuffer(buffer) {
    const p2 = alloc2(buffer.byteLength);
    setBuffer(p2, buffer);
    return p2;
  }
  function getBuffer(pointer, length2) {
    const u8 = new Uint8Array(memory.buffer);
    return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length2);
  }
  function setBuffer(pointer, buffer) {
    const u8 = new Uint8Array(memory.buffer);
    u8.set(new Uint8Array(buffer), pointer);
  }
  function runTask(task) {
    if (task[0].cmd == "INIT") {
      return init(task[0]);
    }
    const ctx = {
      vars: [],
      out: []
    };
    const u32a = new Uint32Array(memory.buffer, 0, 1);
    const oldAlloc = u32a[0];
    for (let i2 = 0; i2 < task.length; i2++) {
      switch (task[i2].cmd) {
        case "ALLOCSET":
          ctx.vars[task[i2].var] = allocBuffer(task[i2].buff);
          break;
        case "ALLOC":
          ctx.vars[task[i2].var] = alloc2(task[i2].len);
          break;
        case "SET":
          setBuffer(ctx.vars[task[i2].var], task[i2].buff);
          break;
        case "CALL": {
          const params = [];
          for (let j2 = 0; j2 < task[i2].params.length; j2++) {
            const p2 = task[i2].params[j2];
            if (typeof p2.var !== "undefined") {
              params.push(ctx.vars[p2.var] + (p2.offset || 0));
            } else if (typeof p2.val != "undefined") {
              params.push(p2.val);
            }
          }
          instance.exports[task[i2].fnName](...params);
          break;
        }
        case "GET":
          ctx.out[task[i2].out] = getBuffer(ctx.vars[task[i2].var], task[i2].len).slice();
          break;
        default:
          throw new Error("Invalid cmd");
      }
    }
    const u32b = new Uint32Array(memory.buffer, 0, 1);
    u32b[0] = oldAlloc;
    return ctx.out;
  }
  return runTask;
}
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
async function buildThreadManager(wasm2, singleThread) {
  const tm = new ThreadManager();
  tm.memory = new WebAssembly.Memory({ initial: MEM_SIZE });
  tm.u8 = new Uint8Array(tm.memory.buffer);
  tm.u32 = new Uint32Array(tm.memory.buffer);
  const wasmModule = await WebAssembly.compile(wasm2.code);
  tm.instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": tm.memory
    }
  });
  if (!globalThis?.Worker) {
    singleThread = true;
  }
  tm.singleThread = singleThread;
  tm.initalPFree = tm.u32[0];
  tm.pq = wasm2.pq;
  tm.pr = wasm2.pr;
  tm.pG1gen = wasm2.pG1gen;
  tm.pG1zero = wasm2.pG1zero;
  tm.pG2gen = wasm2.pG2gen;
  tm.pG2zero = wasm2.pG2zero;
  tm.pOneT = wasm2.pOneT;
  if (singleThread) {
    tm.code = wasm2.code;
    tm.taskManager = thread();
    await tm.taskManager([{
      cmd: "INIT",
      init: MEM_SIZE,
      code: tm.code.slice()
    }]);
    tm.concurrency = 1;
  } else {
    tm.workers = [];
    tm.pendingDeferreds = [];
    tm.working = [];
    let concurrency = 2;
    {
      if (typeof navigator === "object" && navigator.hardwareConcurrency) {
        concurrency = navigator.hardwareConcurrency;
      }
    }
    if (concurrency == 0) {
      concurrency = 2;
    }
    if (concurrency > 64) concurrency = 64;
    tm.concurrency = concurrency;
    for (let i2 = 0; i2 < concurrency; i2++) {
      tm.workers[i2] = new Worker(workerSource);
      tm.workers[i2].addEventListener("message", getOnMsg(i2));
      tm.working[i2] = false;
    }
    const initPromises = [];
    for (let i2 = 0; i2 < tm.workers.length; i2++) {
      const copyCode = wasm2.code.slice();
      initPromises.push(tm.postAction(i2, [{
        cmd: "INIT",
        init: MEM_SIZE,
        code: copyCode
      }], [copyCode.buffer]));
    }
    await Promise.all(initPromises);
  }
  return tm;
  function getOnMsg(i2) {
    return function(e2) {
      let data;
      if (e2 && e2.data) {
        data = e2.data;
      } else {
        data = e2;
      }
      tm.working[i2] = false;
      tm.pendingDeferreds[i2].resolve(data);
      tm.processWorks();
    };
  }
}
function buildBatchApplyKey(curve2, groupName) {
  const G2 = curve2[groupName];
  const Fr = curve2.Fr;
  const tm = curve2.tm;
  curve2[groupName].batchApplyKey = async function(buff, first, inc, inType, outType) {
    inType = inType || "affine";
    outType = outType || "affine";
    let fnName, fnAffine;
    let sGin, sGmid, sGout;
    if (groupName == "G1") {
      if (inType == "jacobian") {
        sGin = G2.F.n8 * 3;
        fnName = "g1m_batchApplyKey";
      } else {
        sGin = G2.F.n8 * 2;
        fnName = "g1m_batchApplyKeyMixed";
      }
      sGmid = G2.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G2.F.n8 * 3;
      } else {
        fnAffine = "g1m_batchToAffine";
        sGout = G2.F.n8 * 2;
      }
    } else if (groupName == "G2") {
      if (inType == "jacobian") {
        sGin = G2.F.n8 * 3;
        fnName = "g2m_batchApplyKey";
      } else {
        sGin = G2.F.n8 * 2;
        fnName = "g2m_batchApplyKeyMixed";
      }
      sGmid = G2.F.n8 * 3;
      if (outType == "jacobian") {
        sGout = G2.F.n8 * 3;
      } else {
        fnAffine = "g2m_batchToAffine";
        sGout = G2.F.n8 * 2;
      }
    } else if (groupName == "Fr") {
      fnName = "frm_batchApplyKey";
      sGin = G2.n8;
      sGmid = G2.n8;
      sGout = G2.n8;
    } else {
      throw new Error("Invalid group: " + groupName);
    }
    const nPoints = Math.floor(buff.byteLength / sGin);
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    inc = Fr.e(inc);
    let t = Fr.e(first);
    for (let i2 = 0; i2 < tm.concurrency; i2++) {
      let n;
      if (i2 < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i2 * pointsPerChunk;
      }
      if (n == 0) continue;
      const task = [];
      task.push({
        cmd: "ALLOCSET",
        var: 0,
        buff: buff.slice(i2 * pointsPerChunk * sGin, i2 * pointsPerChunk * sGin + n * sGin)
      });
      task.push({ cmd: "ALLOCSET", var: 1, buff: t });
      task.push({ cmd: "ALLOCSET", var: 2, buff: inc });
      task.push({ cmd: "ALLOC", var: 3, len: n * Math.max(sGmid, sGout) });
      task.push({
        cmd: "CALL",
        fnName,
        params: [
          { var: 0 },
          { val: n },
          { var: 1 },
          { var: 2 },
          { var: 3 }
        ]
      });
      if (fnAffine) {
        task.push({
          cmd: "CALL",
          fnName: fnAffine,
          params: [
            { var: 3 },
            { val: n },
            { var: 3 }
          ]
        });
      }
      task.push({ cmd: "GET", out: 0, var: 3, len: n * sGout });
      opPromises.push(tm.queueAction(task));
      t = Fr.mul(t, Fr.exp(inc, n));
    }
    const result = await Promise.all(opPromises);
    let outBuff;
    if (buff instanceof BigBuffer) {
      outBuff = new BigBuffer(nPoints * sGout);
    } else {
      outBuff = new Uint8Array(nPoints * sGout);
    }
    let p2 = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      outBuff.set(result[i2][0], p2);
      p2 += result[i2][0].byteLength;
    }
    return outBuff;
  };
}
function buildPairing(curve2) {
  const tm = curve2.tm;
  curve2.pairing = function pairing(a2, b2) {
    tm.startSyncOp();
    const pA = tm.allocBuff(curve2.G1.toJacobian(a2));
    const pB = tm.allocBuff(curve2.G2.toJacobian(b2));
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports[curve2.name + "_pairing"](pA, pB, pRes);
    const res = tm.getBuff(pRes, curve2.Gt.n8);
    tm.endSyncOp();
    return res;
  };
  curve2.pairingEq = async function pairingEq() {
    let buffCt;
    let nEqs;
    if (arguments.length % 2 == 1) {
      buffCt = arguments[arguments.length - 1];
      nEqs = (arguments.length - 1) / 2;
    } else {
      buffCt = curve2.Gt.one;
      nEqs = arguments.length / 2;
    }
    const opPromises = [];
    for (let i2 = 0; i2 < nEqs; i2++) {
      const task = [];
      const g1Buff = curve2.G1.toJacobian(arguments[i2 * 2]);
      task.push({ cmd: "ALLOCSET", var: 0, buff: g1Buff });
      task.push({ cmd: "ALLOC", var: 1, len: curve2.prePSize });
      const g2Buff = curve2.G2.toJacobian(arguments[i2 * 2 + 1]);
      task.push({ cmd: "ALLOCSET", var: 2, buff: g2Buff });
      task.push({ cmd: "ALLOC", var: 3, len: curve2.preQSize });
      task.push({ cmd: "ALLOC", var: 4, len: curve2.Gt.n8 });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG1", params: [
        { var: 0 },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_prepareG2", params: [
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "CALL", fnName: curve2.name + "_millerLoop", params: [
        { var: 1 },
        { var: 3 },
        { var: 4 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 4, len: curve2.Gt.n8 });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    tm.startSyncOp();
    const pRes = tm.alloc(curve2.Gt.n8);
    tm.instance.exports.ftm_one(pRes);
    for (let i2 = 0; i2 < result.length; i2++) {
      const pMR = tm.allocBuff(result[i2][0]);
      tm.instance.exports.ftm_mul(pRes, pMR, pRes);
    }
    tm.instance.exports[curve2.name + "_finalExponentiation"](pRes, pRes);
    const pCt = tm.allocBuff(buffCt);
    const r2 = !!tm.instance.exports.ftm_eq(pRes, pCt);
    tm.endSyncOp();
    return r2;
  };
  curve2.prepareG1 = function(p2) {
    this.tm.startSyncOp();
    const pP = this.tm.allocBuff(p2);
    const pPrepP = this.tm.alloc(this.prePSize);
    this.tm.instance.exports[this.name + "_prepareG1"](pP, pPrepP);
    const res = this.tm.getBuff(pPrepP, this.prePSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.prepareG2 = function(q2) {
    this.tm.startSyncOp();
    const pQ = this.tm.allocBuff(q2);
    const pPrepQ = this.tm.alloc(this.preQSize);
    this.tm.instance.exports[this.name + "_prepareG2"](pQ, pPrepQ);
    const res = this.tm.getBuff(pPrepQ, this.preQSize);
    this.tm.endSyncOp();
    return res;
  };
  curve2.millerLoop = function(preP, preQ) {
    this.tm.startSyncOp();
    const pPreP = this.tm.allocBuff(preP);
    const pPreQ = this.tm.allocBuff(preQ);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_millerLoop"](pPreP, pPreQ, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
  curve2.finalExponentiation = function(a2) {
    this.tm.startSyncOp();
    const pA = this.tm.allocBuff(a2);
    const pRes = this.tm.alloc(this.Gt.n8);
    this.tm.instance.exports[this.name + "_finalExponentiation"](pA, pRes);
    const res = this.tm.getBuff(pRes, this.Gt.n8);
    this.tm.endSyncOp();
    return res;
  };
}
function buildMultiexp2(curve2, groupName) {
  const G2 = curve2[groupName];
  const tm = G2.tm;
  async function _multiExpChunk(buffBases, buffScalars, inType, logger, logText) {
    if (!(buffBases instanceof Uint8Array)) {
      if (logger) logger.error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffBases is not Uint8Array`);
    }
    if (!(buffScalars instanceof Uint8Array)) {
      if (logger) logger.error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
      throw new Error(`${logText} _multiExpChunk buffScalars is not Uint8Array`);
    }
    inType = inType || "affine";
    let sGIn;
    let fnName;
    if (groupName == "G1") {
      if (inType == "affine") {
        fnName = "g1m_multiexpAffine_chunk";
        sGIn = G2.F.n8 * 2;
      } else {
        fnName = "g1m_multiexp_chunk";
        sGIn = G2.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        fnName = "g2m_multiexpAffine_chunk";
        sGIn = G2.F.n8 * 2;
      } else {
        fnName = "g2m_multiexp_chunk";
        sGIn = G2.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    if (nPoints == 0) return G2.zero;
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log2(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    const opPromises = [];
    for (let i2 = 0; i2 < nChunks; i2++) {
      const task = [
        { cmd: "ALLOCSET", var: 0, buff: buffBases },
        { cmd: "ALLOCSET", var: 1, buff: buffScalars },
        { cmd: "ALLOC", var: 2, len: G2.F.n8 * 3 },
        { cmd: "CALL", fnName, params: [
          { var: 0 },
          { var: 1 },
          { val: sScalar },
          { val: nPoints },
          { val: i2 * bitChunkSize },
          { val: Math.min(sScalar * 8 - i2 * bitChunkSize, bitChunkSize) },
          { var: 2 }
        ] },
        { cmd: "GET", out: 0, var: 2, len: G2.F.n8 * 3 }
      ];
      opPromises.push(
        G2.tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let res = G2.zero;
    for (let i2 = result.length - 1; i2 >= 0; i2--) {
      if (!G2.isZero(res)) {
        for (let j2 = 0; j2 < bitChunkSize; j2++) res = G2.double(res);
      }
      res = G2.add(res, result[i2][0]);
    }
    return res;
  }
  async function _multiExp(buffBases, buffScalars, inType, logger, logText) {
    const MAX_CHUNK_SIZE = 1 << 22;
    const MIN_CHUNK_SIZE = 1 << 10;
    let sGIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sGIn = G2.F.n8 * 2;
      } else {
        sGIn = G2.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sGIn = G2.F.n8 * 2;
      } else {
        sGIn = G2.F.n8 * 3;
      }
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buffBases.byteLength / sGIn);
    const sScalar = Math.floor(buffScalars.byteLength / nPoints);
    if (sScalar * nPoints != buffScalars.byteLength) {
      throw new Error("Scalar size does not match");
    }
    const bitChunkSize = pTSizes[log2(nPoints)];
    const nChunks = Math.floor((sScalar * 8 - 1) / bitChunkSize) + 1;
    let chunkSize;
    chunkSize = Math.floor(nPoints / (tm.concurrency / nChunks));
    if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;
    if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;
    const opPromises = [];
    for (let i2 = 0; i2 < nPoints; i2 += chunkSize) {
      if (logger) logger.debug(`Multiexp start: ${logText}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, chunkSize);
      const buffBasesChunk = buffBases.slice(i2 * sGIn, (i2 + n) * sGIn);
      const buffScalarsChunk = buffScalars.slice(i2 * sScalar, (i2 + n) * sScalar);
      opPromises.push(_multiExpChunk(buffBasesChunk, buffScalarsChunk, inType, logger, logText).then((r2) => {
        if (logger) logger.debug(`Multiexp end: ${logText}: ${i2}/${nPoints}`);
        return r2;
      }));
    }
    const result = await Promise.all(opPromises);
    let res = G2.zero;
    for (let i2 = result.length - 1; i2 >= 0; i2--) {
      res = G2.add(res, result[i2]);
    }
    return res;
  }
  G2.multiExp = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "jacobian", logger, logText);
  };
  G2.multiExpAffine = async function multiExpAffine(buffBases, buffScalars, logger, logText) {
    return await _multiExp(buffBases, buffScalars, "affine", logger, logText);
  };
}
function buildFFT2(curve2, groupName) {
  const G2 = curve2[groupName];
  const Fr = curve2.Fr;
  const tm = G2.tm;
  async function _fft(buff, inverse, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    const MAX_BITS_THREAD = 14;
    let sIn, sMid, sOut, fnIn2Mid, fnMid2Out, fnFFTMix, fnFFTJoin, fnFFTFinal;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G2.F.n8 * 3;
      }
      sMid = G2.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g1m_fftFinal";
      }
      fnFFTJoin = "g1m_fftJoin";
      fnFFTMix = "g1m_fftMix";
      if (outType == "affine") {
        sOut = G2.F.n8 * 2;
        fnMid2Out = "g1m_batchToAffine";
      } else {
        sOut = G2.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G2.F.n8 * 3;
      }
      sMid = G2.F.n8 * 3;
      if (inverse) {
        fnFFTFinal = "g2m_fftFinal";
      }
      fnFFTJoin = "g2m_fftJoin";
      fnFFTMix = "g2m_fftMix";
      if (outType == "affine") {
        sOut = G2.F.n8 * 2;
        fnMid2Out = "g2m_batchToAffine";
      } else {
        sOut = G2.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = G2.n8;
      sMid = G2.n8;
      sOut = G2.n8;
      if (inverse) {
        fnFFTFinal = "frm_fftFinal";
      }
      fnFFTMix = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    }
    let returnArray = false;
    if (Array.isArray(buff)) {
      buff = array2buffer(buff, sIn);
      returnArray = true;
    } else {
      buff = buff.slice(0, buff.byteLength);
    }
    const nPoints = buff.byteLength / sIn;
    const bits2 = log2(nPoints);
    if (1 << bits2 != nPoints) {
      throw new Error("fft must be multiple of 2");
    }
    if (bits2 == Fr.s + 1) {
      let buffOut2;
      if (inverse) {
        buffOut2 = await _fftExtInv(buff, inType, outType, logger, loggerTxt);
      } else {
        buffOut2 = await _fftExt(buff, inType, outType, logger, loggerTxt);
      }
      if (returnArray) {
        return buffer2array(buffOut2, sOut);
      } else {
        return buffOut2;
      }
    }
    let inv;
    if (inverse) {
      inv = Fr.inv(Fr.e(nPoints));
    }
    let buffOut;
    buffReverseBits(buff, sIn);
    let chunks;
    let pointsInChunk = Math.min(1 << MAX_BITS_THREAD, nPoints);
    let nChunks = nPoints / pointsInChunk;
    while (nChunks < tm.concurrency && pointsInChunk >= 16) {
      nChunks *= 2;
      pointsInChunk /= 2;
    }
    const l2Chunk = log2(pointsInChunk);
    const promises = [];
    for (let i2 = 0; i2 < nChunks; i2++) {
      if (logger) logger.debug(`${loggerTxt}: fft ${bits2} mix start: ${i2}/${nChunks}`);
      const task = [];
      task.push({ cmd: "ALLOC", var: 0, len: sMid * pointsInChunk });
      const buffChunk = buff.slice(pointsInChunk * i2 * sIn, pointsInChunk * (i2 + 1) * sIn);
      task.push({ cmd: "SET", var: 0, buff: buffChunk });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
      }
      for (let j2 = 1; j2 <= l2Chunk; j2++) {
        task.push({ cmd: "CALL", fnName: fnFFTMix, params: [{ var: 0 }, { val: pointsInChunk }, { val: j2 }] });
      }
      if (l2Chunk == bits2) {
        if (fnFFTFinal) {
          task.push({ cmd: "ALLOCSET", var: 1, buff: inv });
          task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
            { var: 0 },
            { val: pointsInChunk },
            { var: 1 }
          ] });
        }
        if (fnMid2Out) {
          task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
        }
        task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
      } else {
        task.push({ cmd: "GET", out: 0, var: 0, len: sMid * pointsInChunk });
      }
      promises.push(tm.queueAction(task).then((r2) => {
        if (logger) logger.debug(`${loggerTxt}: fft ${bits2} mix end: ${i2}/${nChunks}`);
        return r2;
      }));
    }
    chunks = await Promise.all(promises);
    for (let i2 = 0; i2 < nChunks; i2++) chunks[i2] = chunks[i2][0];
    for (let i2 = l2Chunk + 1; i2 <= bits2; i2++) {
      if (logger) logger.debug(`${loggerTxt}: fft  ${bits2}  join: ${i2}/${bits2}`);
      const nGroups = 1 << bits2 - i2;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises = [];
      for (let j2 = 0; j2 < nGroups; j2++) {
        for (let k2 = 0; k2 < nChunksPerGroup / 2; k2++) {
          const first = Fr.exp(Fr.w[i2], k2 * pointsInChunk);
          const inc = Fr.w[i2];
          const o1 = j2 * nChunksPerGroup + k2;
          const o2 = j2 * nChunksPerGroup + k2 + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsInChunk },
            { var: 2 },
            { var: 3 }
          ] });
          if (i2 == bits2) {
            if (fnFFTFinal) {
              task.push({ cmd: "ALLOCSET", var: 4, buff: inv });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 0 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
              task.push({ cmd: "CALL", fnName: fnFFTFinal, params: [
                { var: 1 },
                { val: pointsInChunk },
                { var: 4 }
              ] });
            }
            if (fnMid2Out) {
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: pointsInChunk }, { var: 0 }] });
              task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: pointsInChunk }, { var: 1 }] });
            }
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sOut });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sOut });
          } else {
            task.push({ cmd: "GET", out: 0, var: 0, len: pointsInChunk * sMid });
            task.push({ cmd: "GET", out: 1, var: 1, len: pointsInChunk * sMid });
          }
          opPromises.push(tm.queueAction(task).then((r2) => {
            if (logger) logger.debug(`${loggerTxt}: fft ${bits2} join  ${i2}/${bits2}  ${j2 + 1}/${nGroups} ${k2}/${nChunksPerGroup / 2}`);
            return r2;
          }));
        }
      }
      const res = await Promise.all(opPromises);
      for (let j2 = 0; j2 < nGroups; j2++) {
        for (let k2 = 0; k2 < nChunksPerGroup / 2; k2++) {
          const o1 = j2 * nChunksPerGroup + k2;
          const o2 = j2 * nChunksPerGroup + k2 + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    if (buff instanceof BigBuffer) {
      buffOut = new BigBuffer(nPoints * sOut);
    } else {
      buffOut = new Uint8Array(nPoints * sOut);
    }
    if (inverse) {
      buffOut.set(chunks[0].slice((pointsInChunk - 1) * sOut));
      let p2 = sOut;
      for (let i2 = nChunks - 1; i2 > 0; i2--) {
        buffOut.set(chunks[i2], p2);
        p2 += pointsInChunk * sOut;
        delete chunks[i2];
      }
      buffOut.set(chunks[0].slice(0, (pointsInChunk - 1) * sOut), p2);
      delete chunks[0];
    } else {
      for (let i2 = 0; i2 < nChunks; i2++) {
        buffOut.set(chunks[i2], pointsInChunk * sOut * i2);
        delete chunks[i2];
      }
    }
    if (returnArray) {
      return buffer2array(buffOut, sOut);
    } else {
      return buffOut;
    }
  }
  async function _fftExt(buff, inType, outType, logger, loggerTxt) {
    let b1, b2;
    b1 = buff.slice(0, buff.byteLength / 2);
    b2 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    [b1, b2] = await _fftJoinExt(b1, b2, "fftJoinExt", Fr.one, Fr.shift, inType, "jacobian", logger, loggerTxt);
    promises.push(_fft(b1, false, "jacobian", outType, logger, loggerTxt));
    promises.push(_fft(b2, false, "jacobian", outType, logger, loggerTxt));
    const res1 = await Promise.all(promises);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftExtInv(buff, inType, outType, logger, loggerTxt) {
    let b1, b2;
    b1 = buff.slice(0, buff.byteLength / 2);
    b2 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const promises = [];
    promises.push(_fft(b1, true, inType, "jacobian", logger, loggerTxt));
    promises.push(_fft(b2, true, inType, "jacobian", logger, loggerTxt));
    [b1, b2] = await Promise.all(promises);
    const res1 = await _fftJoinExt(b1, b2, "fftJoinExtInv", Fr.one, Fr.shiftInv, "jacobian", outType, logger, loggerTxt);
    let buffOut;
    if (res1[0].byteLength > 1 << 28) {
      buffOut = new BigBuffer(res1[0].byteLength * 2);
    } else {
      buffOut = new Uint8Array(res1[0].byteLength * 2);
    }
    buffOut.set(res1[0]);
    buffOut.set(res1[1], res1[0].byteLength);
    return buffOut;
  }
  async function _fftJoinExt(buff1, buff2, fn, first, inc, inType, outType, logger, loggerTxt) {
    const MAX_CHUNK_SIZE = 1 << 16;
    const MIN_CHUNK_SIZE = 1 << 4;
    let fnName;
    let fnIn2Mid, fnMid2Out;
    let sOut, sIn, sMid;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
        fnIn2Mid = "g1m_batchToJacobian";
      } else {
        sIn = G2.F.n8 * 3;
      }
      sMid = G2.F.n8 * 3;
      fnName = "g1m_" + fn;
      if (outType == "affine") {
        fnMid2Out = "g1m_batchToAffine";
        sOut = G2.F.n8 * 2;
      } else {
        sOut = G2.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
        fnIn2Mid = "g2m_batchToJacobian";
      } else {
        sIn = G2.F.n8 * 3;
      }
      fnName = "g2m_" + fn;
      sMid = G2.F.n8 * 3;
      if (outType == "affine") {
        fnMid2Out = "g2m_batchToAffine";
        sOut = G2.F.n8 * 2;
      } else {
        sOut = G2.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr.n8;
      sOut = Fr.n8;
      sMid = Fr.n8;
      fnName = "frm_" + fn;
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sIn);
    if (nPoints != 1 << log2(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let chunkSize = Math.floor(nPoints / tm.concurrency);
    if (chunkSize < MIN_CHUNK_SIZE) chunkSize = MIN_CHUNK_SIZE;
    if (chunkSize > MAX_CHUNK_SIZE) chunkSize = MAX_CHUNK_SIZE;
    const opPromises = [];
    for (let i2 = 0; i2 < nPoints; i2 += chunkSize) {
      if (logger) logger.debug(`${loggerTxt}: fftJoinExt Start: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, chunkSize);
      const firstChunk = Fr.mul(first, Fr.exp(inc, i2));
      const task = [];
      const b1 = buff1.slice(i2 * sIn, (i2 + n) * sIn);
      const b2 = buff2.slice(i2 * sIn, (i2 + n) * sIn);
      task.push({ cmd: "ALLOC", var: 0, len: sMid * n });
      task.push({ cmd: "SET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOC", var: 1, len: sMid * n });
      task.push({ cmd: "SET", var: 1, buff: b2 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      if (fnIn2Mid) {
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 0 }, { val: n }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnIn2Mid, params: [{ var: 1 }, { val: n }, { var: 1 }] });
      }
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: n },
        { var: 2 },
        { var: 3 },
        { val: Fr.s }
      ] });
      if (fnMid2Out) {
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 0 }, { val: n }, { var: 0 }] });
        task.push({ cmd: "CALL", fnName: fnMid2Out, params: [{ var: 1 }, { val: n }, { var: 1 }] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: n * sOut });
      task.push({ cmd: "GET", out: 1, var: 1, len: n * sOut });
      opPromises.push(
        tm.queueAction(task).then((r2) => {
          if (logger) logger.debug(`${loggerTxt}: fftJoinExt End: ${i2}/${nPoints}`);
          return r2;
        })
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (nPoints * sOut > 1 << 28) {
      fullBuffOut1 = new BigBuffer(nPoints * sOut);
      fullBuffOut2 = new BigBuffer(nPoints * sOut);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sOut);
      fullBuffOut2 = new Uint8Array(nPoints * sOut);
    }
    let p2 = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      fullBuffOut1.set(result[i2][0], p2);
      fullBuffOut2.set(result[i2][1], p2);
      p2 += result[i2][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  }
  G2.fft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, false, inType, outType, logger, loggerTxt);
  };
  G2.ifft = async function(buff, inType, outType, logger, loggerTxt) {
    return await _fft(buff, true, inType, outType, logger, loggerTxt);
  };
  G2.lagrangeEvaluations = async function(buff, inType, outType, logger, loggerTxt) {
    inType = inType || "affine";
    outType = outType || "affine";
    let sIn;
    if (groupName == "G1") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
      } else {
        sIn = G2.F.n8 * 3;
      }
    } else if (groupName == "G2") {
      if (inType == "affine") {
        sIn = G2.F.n8 * 2;
      } else {
        sIn = G2.F.n8 * 3;
      }
    } else if (groupName == "Fr") {
      sIn = Fr.n8;
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = buff.byteLength / sIn;
    const bits2 = log2(nPoints);
    if (2 ** bits2 * sIn != buff.byteLength) {
      if (logger) logger.error("lagrangeEvaluations iinvalid input size");
      throw new Error("lagrangeEvaluations invalid Input size");
    }
    if (bits2 <= Fr.s) {
      return await G2.ifft(buff, inType, outType, logger, loggerTxt);
    }
    if (bits2 > Fr.s + 1) {
      if (logger) logger.error("lagrangeEvaluations input too big");
      throw new Error("lagrangeEvaluations input too big");
    }
    let t0 = buff.slice(0, buff.byteLength / 2);
    let t1 = buff.slice(buff.byteLength / 2, buff.byteLength);
    const shiftToSmallM = Fr.exp(Fr.shift, nPoints / 2);
    const sConst = Fr.inv(Fr.sub(Fr.one, shiftToSmallM));
    [t0, t1] = await _fftJoinExt(t0, t1, "prepareLagrangeEvaluation", sConst, Fr.shiftInv, inType, "jacobian", logger, loggerTxt + " prep");
    const promises = [];
    promises.push(_fft(t0, true, "jacobian", outType, logger, loggerTxt + " t0"));
    promises.push(_fft(t1, true, "jacobian", outType, logger, loggerTxt + " t1"));
    [t0, t1] = await Promise.all(promises);
    let buffOut;
    if (t0.byteLength > 1 << 28) {
      buffOut = new BigBuffer(t0.byteLength * 2);
    } else {
      buffOut = new Uint8Array(t0.byteLength * 2);
    }
    buffOut.set(t0);
    buffOut.set(t1, t0.byteLength);
    return buffOut;
  };
  G2.fftMix = async function fftMix(buff) {
    const sG = G2.F.n8 * 3;
    let fnName, fnFFTJoin;
    if (groupName == "G1") {
      fnName = "g1m_fftMix";
      fnFFTJoin = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftMix";
      fnFFTJoin = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftMix";
      fnFFTJoin = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    const power = log2(nPoints);
    let nChunks = 1 << log2(tm.concurrency);
    if (nPoints <= nChunks * 2) nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const powerChunk = log2(pointsPerChunk);
    const opPromises = [];
    for (let i2 = 0; i2 < nChunks; i2++) {
      const task = [];
      const b2 = buff.slice(i2 * pointsPerChunk * sG, (i2 + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b2 });
      for (let j2 = 1; j2 <= powerChunk; j2++) {
        task.push({ cmd: "CALL", fnName, params: [
          { var: 0 },
          { val: pointsPerChunk },
          { val: j2 }
        ] });
      }
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    const chunks = [];
    for (let i2 = 0; i2 < result.length; i2++) chunks[i2] = result[i2][0];
    for (let i2 = powerChunk + 1; i2 <= power; i2++) {
      const nGroups = 1 << power - i2;
      const nChunksPerGroup = nChunks / nGroups;
      const opPromises2 = [];
      for (let j2 = 0; j2 < nGroups; j2++) {
        for (let k2 = 0; k2 < nChunksPerGroup / 2; k2++) {
          const first = Fr.exp(Fr.w[i2], k2 * pointsPerChunk);
          const inc = Fr.w[i2];
          const o1 = j2 * nChunksPerGroup + k2;
          const o2 = j2 * nChunksPerGroup + k2 + nChunksPerGroup / 2;
          const task = [];
          task.push({ cmd: "ALLOCSET", var: 0, buff: chunks[o1] });
          task.push({ cmd: "ALLOCSET", var: 1, buff: chunks[o2] });
          task.push({ cmd: "ALLOCSET", var: 2, buff: first });
          task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
          task.push({ cmd: "CALL", fnName: fnFFTJoin, params: [
            { var: 0 },
            { var: 1 },
            { val: pointsPerChunk },
            { var: 2 },
            { var: 3 }
          ] });
          task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
          task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
          opPromises2.push(tm.queueAction(task));
        }
      }
      const res = await Promise.all(opPromises2);
      for (let j2 = 0; j2 < nGroups; j2++) {
        for (let k2 = 0; k2 < nChunksPerGroup / 2; k2++) {
          const o1 = j2 * nChunksPerGroup + k2;
          const o2 = j2 * nChunksPerGroup + k2 + nChunksPerGroup / 2;
          const resChunk = res.shift();
          chunks[o1] = resChunk[0];
          chunks[o2] = resChunk[1];
        }
      }
    }
    let fullBuffOut;
    if (buff instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sG);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sG);
    }
    let p2 = 0;
    for (let i2 = 0; i2 < nChunks; i2++) {
      fullBuffOut.set(chunks[i2], p2);
      p2 += chunks[i2].byteLength;
    }
    return fullBuffOut;
  };
  G2.fftJoin = async function fftJoin(buff1, buff2, first, inc) {
    const sG = G2.F.n8 * 3;
    let fnName;
    if (groupName == "G1") {
      fnName = "g1m_fftJoin";
    } else if (groupName == "G2") {
      fnName = "g2m_fftJoin";
    } else if (groupName == "Fr") {
      fnName = "frm_fftJoin";
    } else {
      throw new Error("Invalid group");
    }
    if (buff1.byteLength != buff2.byteLength) {
      throw new Error("Invalid buffer size");
    }
    const nPoints = Math.floor(buff1.byteLength / sG);
    if (nPoints != 1 << log2(nPoints)) {
      throw new Error("Invalid number of points");
    }
    let nChunks = 1 << log2(tm.concurrency);
    if (nPoints <= nChunks * 2) nChunks = 1;
    const pointsPerChunk = nPoints / nChunks;
    const opPromises = [];
    for (let i2 = 0; i2 < nChunks; i2++) {
      const task = [];
      const firstChunk = Fr.mul(first, Fr.exp(inc, i2 * pointsPerChunk));
      const b1 = buff1.slice(i2 * pointsPerChunk * sG, (i2 + 1) * pointsPerChunk * sG);
      const b2 = buff2.slice(i2 * pointsPerChunk * sG, (i2 + 1) * pointsPerChunk * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b1 });
      task.push({ cmd: "ALLOCSET", var: 1, buff: b2 });
      task.push({ cmd: "ALLOCSET", var: 2, buff: firstChunk });
      task.push({ cmd: "ALLOCSET", var: 3, buff: inc });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { var: 1 },
        { val: pointsPerChunk },
        { var: 2 },
        { var: 3 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: pointsPerChunk * sG });
      task.push({ cmd: "GET", out: 1, var: 1, len: pointsPerChunk * sG });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut1;
    let fullBuffOut2;
    if (buff1 instanceof BigBuffer) {
      fullBuffOut1 = new BigBuffer(nPoints * sG);
      fullBuffOut2 = new BigBuffer(nPoints * sG);
    } else {
      fullBuffOut1 = new Uint8Array(nPoints * sG);
      fullBuffOut2 = new Uint8Array(nPoints * sG);
    }
    let p2 = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      fullBuffOut1.set(result[i2][0], p2);
      fullBuffOut2.set(result[i2][1], p2);
      p2 += result[i2][0].byteLength;
    }
    return [fullBuffOut1, fullBuffOut2];
  };
  G2.fftFinal = async function fftFinal(buff, factor) {
    const sG = G2.F.n8 * 3;
    const sGout = G2.F.n8 * 2;
    let fnName, fnToAffine;
    if (groupName == "G1") {
      fnName = "g1m_fftFinal";
      fnToAffine = "g1m_batchToAffine";
    } else if (groupName == "G2") {
      fnName = "g2m_fftFinal";
      fnToAffine = "g2m_batchToAffine";
    } else {
      throw new Error("Invalid group");
    }
    const nPoints = Math.floor(buff.byteLength / sG);
    if (nPoints != 1 << log2(nPoints)) {
      throw new Error("Invalid number of points");
    }
    const pointsPerChunk = Math.floor(nPoints / tm.concurrency);
    const opPromises = [];
    for (let i2 = 0; i2 < tm.concurrency; i2++) {
      let n;
      if (i2 < tm.concurrency - 1) {
        n = pointsPerChunk;
      } else {
        n = nPoints - i2 * pointsPerChunk;
      }
      if (n == 0) continue;
      const task = [];
      const b2 = buff.slice(i2 * pointsPerChunk * sG, (i2 * pointsPerChunk + n) * sG);
      task.push({ cmd: "ALLOCSET", var: 0, buff: b2 });
      task.push({ cmd: "ALLOCSET", var: 1, buff: factor });
      task.push({ cmd: "CALL", fnName, params: [
        { var: 0 },
        { val: n },
        { var: 1 }
      ] });
      task.push({ cmd: "CALL", fnName: fnToAffine, params: [
        { var: 0 },
        { val: n },
        { var: 0 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 0, len: n * sGout });
      opPromises.push(
        tm.queueAction(task)
      );
    }
    const result = await Promise.all(opPromises);
    let fullBuffOut;
    if (buff instanceof BigBuffer) {
      fullBuffOut = new BigBuffer(nPoints * sGout);
    } else {
      fullBuffOut = new Uint8Array(nPoints * sGout);
    }
    let p2 = 0;
    for (let i2 = result.length - 1; i2 >= 0; i2--) {
      fullBuffOut.set(result[i2][0], p2);
      p2 += result[i2][0].byteLength;
    }
    return fullBuffOut;
  };
}
async function buildEngine(params) {
  const tm = await buildThreadManager(params.wasm, params.singleThread);
  const curve2 = {};
  curve2.q = e(params.wasm.q.toString());
  curve2.r = e(params.wasm.r.toString());
  curve2.name = params.name;
  curve2.tm = tm;
  curve2.prePSize = params.wasm.prePSize;
  curve2.preQSize = params.wasm.preQSize;
  curve2.Fr = new WasmField1(tm, "frm", params.n8r, params.r);
  curve2.F1 = new WasmField1(tm, "f1m", params.n8q, params.q);
  curve2.F2 = new WasmField2(tm, "f2m", curve2.F1);
  curve2.G1 = new WasmCurve(tm, "g1m", curve2.F1, params.wasm.pG1gen, params.wasm.pG1b, params.cofactorG1);
  curve2.G2 = new WasmCurve(tm, "g2m", curve2.F2, params.wasm.pG2gen, params.wasm.pG2b, params.cofactorG2);
  curve2.F6 = new WasmField3(tm, "f6m", curve2.F2);
  curve2.F12 = new WasmField2(tm, "ftm", curve2.F6);
  curve2.Gt = curve2.F12;
  buildBatchApplyKey(curve2, "G1");
  buildBatchApplyKey(curve2, "G2");
  buildBatchApplyKey(curve2, "Fr");
  buildMultiexp2(curve2, "G1");
  buildMultiexp2(curve2, "G2");
  buildFFT2(curve2, "G1");
  buildFFT2(curve2, "G2");
  buildFFT2(curve2, "Fr");
  buildPairing(curve2);
  curve2.array2buffer = function(arr, sG) {
    const buff = new Uint8Array(sG * arr.length);
    for (let i2 = 0; i2 < arr.length; i2++) {
      buff.set(arr[i2], i2 * sG);
    }
    return buff;
  };
  curve2.buffer2array = function(buff, sG) {
    const n = buff.byteLength / sG;
    const arr = new Array(n);
    for (let i2 = 0; i2 < n; i2++) {
      arr[i2] = buff.slice(i2 * sG, i2 * sG + sG);
    }
    return arr;
  };
  return curve2;
}
function toNumber(n) {
  return BigInt(n);
}
function isNegative(n) {
  return n < 0n;
}
function isZero(n) {
  return n === 0n;
}
function bitLength(n) {
  if (isNegative(n)) {
    return n.toString(2).length - 1;
  } else {
    return n.toString(2).length;
  }
}
function u32(n) {
  const b2 = [];
  const v2 = toNumber(n);
  b2.push(Number(v2 & 0xFFn));
  b2.push(Number(v2 >> 8n & 0xFFn));
  b2.push(Number(v2 >> 16n & 0xFFn));
  b2.push(Number(v2 >> 24n & 0xFFn));
  return b2;
}
function toUTF8Array(str) {
  var utf82 = [];
  for (var i2 = 0; i2 < str.length; i2++) {
    var charcode = str.charCodeAt(i2);
    if (charcode < 128) utf82.push(charcode);
    else if (charcode < 2048) {
      utf82.push(
        192 | charcode >> 6,
        128 | charcode & 63
      );
    } else if (charcode < 55296 || charcode >= 57344) {
      utf82.push(
        224 | charcode >> 12,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    } else {
      i2++;
      charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);
      utf82.push(
        240 | charcode >> 18,
        128 | charcode >> 12 & 63,
        128 | charcode >> 6 & 63,
        128 | charcode & 63
      );
    }
  }
  return utf82;
}
function string(str) {
  const bytes = toUTF8Array(str);
  return [...varuint32(bytes.length), ...bytes];
}
function varuint(n) {
  const code = [];
  let v2 = toNumber(n);
  if (isNegative(v2)) throw new Error("Number cannot be negative");
  while (!isZero(v2)) {
    code.push(Number(v2 & 0x7Fn));
    v2 = v2 >> 7n;
  }
  if (code.length == 0) code.push(0);
  for (let i2 = 0; i2 < code.length - 1; i2++) {
    code[i2] = code[i2] | 128;
  }
  return code;
}
function varint(_n) {
  let n, sign;
  const bits2 = bitLength(_n);
  if (_n < 0) {
    sign = true;
    n = (1n << BigInt(bits2)) + _n;
  } else {
    sign = false;
    n = toNumber(_n);
  }
  const paddingBits = 7 - bits2 % 7;
  const padding = (1n << BigInt(paddingBits)) - 1n << BigInt(bits2);
  const paddingMask = (1 << 7 - paddingBits) - 1 | 128;
  const code = varuint(n + padding);
  if (!sign) {
    code[code.length - 1] = code[code.length - 1] & paddingMask;
  }
  return code;
}
function varint32(n) {
  let v2 = toNumber(n);
  if (v2 > 0xFFFFFFFFn) throw new Error("Number too big");
  if (v2 > 0x7FFFFFFFn) v2 = v2 - 0x100000000n;
  if (v2 < -2147483648n) throw new Error("Number too small");
  return varint(v2);
}
function varint64(n) {
  let v2 = toNumber(n);
  if (v2 > 0xFFFFFFFFFFFFFFFFn) throw new Error("Number too big");
  if (v2 > 0x7FFFFFFFFFFFFFFFn) v2 = v2 - 0x10000000000000000n;
  if (v2 < -9223372036854775808n) throw new Error("Number too small");
  return varint(v2);
}
function varuint32(n) {
  let v2 = toNumber(n);
  if (v2 > 0xFFFFFFFFn) throw new Error("Number too big");
  return varuint(v2);
}
function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}
async function buildBn128(singleThread, plugins) {
  if (!singleThread && globalThis.curve_bn128) return globalThis.curve_bn128;
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  buildBn128$1(moduleBuilder);
  if (plugins) plugins(moduleBuilder);
  const bn128wasm = {};
  bn128wasm.code = moduleBuilder.build();
  bn128wasm.pq = moduleBuilder.modules.f1m.pq;
  bn128wasm.pr = moduleBuilder.modules.frm.pq;
  bn128wasm.pG1gen = moduleBuilder.modules.bn128.pG1gen;
  bn128wasm.pG1zero = moduleBuilder.modules.bn128.pG1zero;
  bn128wasm.pG1b = moduleBuilder.modules.bn128.pG1b;
  bn128wasm.pG2gen = moduleBuilder.modules.bn128.pG2gen;
  bn128wasm.pG2zero = moduleBuilder.modules.bn128.pG2zero;
  bn128wasm.pG2b = moduleBuilder.modules.bn128.pG2b;
  bn128wasm.pOneT = moduleBuilder.modules.bn128.pOneT;
  bn128wasm.prePSize = moduleBuilder.modules.bn128.prePSize;
  bn128wasm.preQSize = moduleBuilder.modules.bn128.preQSize;
  bn128wasm.n8q = 32;
  bn128wasm.n8r = 32;
  bn128wasm.q = moduleBuilder.modules.bn128.q;
  bn128wasm.r = moduleBuilder.modules.bn128.r;
  const params = {
    name: "bn128",
    wasm: bn128wasm,
    q: e("21888242871839275222246405745257275088696311157297823662689037894645226208583"),
    r: e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),
    n8q: 32,
    n8r: 32,
    cofactorG2: e("30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bn128 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bn128 = curve2;
  }
  return curve2;
}
async function buildBls12381(singleThread, plugins) {
  if (!singleThread && globalThis.curve_bls12381) return globalThis.curve_bls12381;
  const moduleBuilder = new ModuleBuilder();
  moduleBuilder.setMemory(25);
  buildBls12381$1(moduleBuilder);
  if (plugins) plugins(moduleBuilder);
  const bls12381wasm = {};
  bls12381wasm.code = moduleBuilder.build();
  bls12381wasm.pq = moduleBuilder.modules.f1m.pq;
  bls12381wasm.pr = moduleBuilder.modules.frm.pq;
  bls12381wasm.pG1gen = moduleBuilder.modules.bls12381.pG1gen;
  bls12381wasm.pG1zero = moduleBuilder.modules.bls12381.pG1zero;
  bls12381wasm.pG1b = moduleBuilder.modules.bls12381.pG1b;
  bls12381wasm.pG2gen = moduleBuilder.modules.bls12381.pG2gen;
  bls12381wasm.pG2zero = moduleBuilder.modules.bls12381.pG2zero;
  bls12381wasm.pG2b = moduleBuilder.modules.bls12381.pG2b;
  bls12381wasm.pOneT = moduleBuilder.modules.bls12381.pOneT;
  bls12381wasm.prePSize = moduleBuilder.modules.bls12381.prePSize;
  bls12381wasm.preQSize = moduleBuilder.modules.bls12381.preQSize;
  bls12381wasm.n8q = 48;
  bls12381wasm.n8r = 32;
  bls12381wasm.q = moduleBuilder.modules.bls12381.q;
  bls12381wasm.r = moduleBuilder.modules.bls12381.r;
  const params = {
    name: "bls12381",
    wasm: bls12381wasm,
    q: e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16),
    r: e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16),
    n8q: 48,
    n8r: 32,
    cofactorG1: e("0x396c8c005555e1568c00aaab0000aaab", 16),
    cofactorG2: e("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5", 16),
    singleThread: singleThread ? true : false
  };
  const curve2 = await buildEngine(params);
  curve2.terminate = async function() {
    if (!params.singleThread) {
      globalThis.curve_bls12381 = null;
      await this.tm.terminate();
    }
  };
  if (!singleThread) {
    globalThis.curve_bls12381 = curve2;
  }
  return curve2;
}
async function getCurveFromR(r2, singleThread, plugins) {
  let curve2;
  if (eq(r2, bn128r)) {
    curve2 = await buildBn128(singleThread, plugins);
  } else if (eq(r2, bls12381r)) {
    curve2 = await buildBls12381(singleThread, plugins);
  } else {
    throw new Error(`Curve not supported: ${toString(r2)}`);
  }
  return curve2;
}
var import_dist, import_dist2, import_dist3, hexLen, e, shl, shr, zero, one, _Scalar, _revTable$1, ChaCha, threadRng, FFT, ZqField, utils$6, build_int, build_timesscalar, build_batchinverse, build_batchconvertion, build_batchop, bigint, buildInt2, utils$5, buildExp$2, buildBatchInverse$2, buildBatchConvertion$1, buildBatchOp, bitLength$4, modInv$2, modPow$1, isPrime, isOdd$3, square, build_f1m, buildF1m$2, bitLength$3, build_f1, buildExp$1, buildBatchInverse$1, utils$4, build_f2m, buildExp, buildBatchInverse, build_f3m, build_timesscalarnaf, build_multiexp, buildTimesScalarNAF2, buildBatchConvertion, buildMultiexp$1, build_curve_jacobian_a0, isOdd$2, modInv$1, modPow, utils$3, build_fft, build_pol, build_qap, build_applykey, utils$2, buildF1m$1, buildF1$1, buildF2m$1, buildF3m$1, buildCurve$1, buildFFT$2, buildPol$1, buildQAP$1, buildApplyKey$1, bitLength$2, modInv, isOdd$1, isNegative$2, build_bn128, utils$1, buildF1m2, buildF12, buildF2m2, buildF3m2, buildCurve2, buildFFT$1, buildPol2, buildQAP2, buildApplyKey2, bitLength$1, isOdd, isNegative$1, build_bls12381, buildBn128$1, buildBls12381$1, _revTable, _utils, PAGE_SIZE, BigBuffer, WasmField1, WasmField2, WasmField3, WasmCurve, MEM_SIZE, Deferred, workerSource, threadStr, ThreadManager, pTSizes, CodeBuilder, typeCodes, FunctionBuilder, ModuleBuilder, bls12381r, bn128r, bls12381q, bn128q, Scalar, utils;
var init_browser_esm = __esm({
  "node_modules/snarkjs/node_modules/ffjavascript/build/browser.esm.js"() {
    import_dist = __toESM(require_dist());
    import_dist2 = __toESM(require_dist2());
    import_dist3 = __toESM(require_dist3());
    hexLen = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];
    e = fromString;
    shl = shiftLeft;
    shr = shiftRight;
    zero = e(0);
    one = e(1);
    _Scalar = Object.freeze({
      __proto__: null,
      abs: abs$1,
      add,
      band,
      bitLength: bitLength$6,
      bits,
      bor,
      bxor,
      div,
      e,
      eq,
      exp: exp$1,
      fromArray,
      fromRprBE,
      fromRprLE,
      fromString,
      geq,
      gt,
      isNegative: isNegative$4,
      isOdd: isOdd$5,
      isZero: isZero$1,
      land,
      leq,
      lnot,
      lor,
      lt,
      mod,
      mul,
      naf,
      neg,
      neq,
      one,
      pow,
      shiftLeft,
      shiftRight,
      shl,
      shr,
      square: square$2,
      sub,
      toArray,
      toLEBuff,
      toNumber: toNumber$1,
      toRprBE,
      toRprLE,
      toString,
      zero
    });
    _revTable$1 = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _revTable$1[i2] = _revSlow$1(i2, 8);
    }
    ChaCha = class {
      constructor(seed) {
        seed = seed || [0, 0, 0, 0, 0, 0, 0, 0];
        this.state = [
          1634760805,
          857760878,
          2036477234,
          1797285236,
          seed[0],
          seed[1],
          seed[2],
          seed[3],
          seed[4],
          seed[5],
          seed[6],
          seed[7],
          0,
          0,
          0,
          0
        ];
        this.idx = 16;
        this.buff = new Array(16);
      }
      nextU32() {
        if (this.idx == 16) this.update();
        return this.buff[this.idx++];
      }
      nextU64() {
        return add(mul(this.nextU32(), 4294967296), this.nextU32());
      }
      nextBool() {
        return (this.nextU32() & 1) == 1;
      }
      update() {
        for (let i2 = 0; i2 < 16; i2++) this.buff[i2] = this.state[i2];
        for (let i2 = 0; i2 < 10; i2++) doubleRound(this.buff);
        for (let i2 = 0; i2 < 16; i2++) this.buff[i2] = this.buff[i2] + this.state[i2] >>> 0;
        this.idx = 0;
        this.state[12] = this.state[12] + 1 >>> 0;
        if (this.state[12] != 0) return;
        this.state[13] = this.state[13] + 1 >>> 0;
        if (this.state[13] != 0) return;
        this.state[14] = this.state[14] + 1 >>> 0;
        if (this.state[14] != 0) return;
        this.state[15] = this.state[15] + 1 >>> 0;
      }
    };
    threadRng = null;
    FFT = class {
      constructor(G2, F2, opMulGF) {
        this.F = F2;
        this.G = G2;
        this.opMulGF = opMulGF;
        let rem = F2.sqrt_t || F2.t;
        let s2 = F2.sqrt_s || F2.s;
        let nqr = F2.one;
        while (F2.eq(F2.pow(nqr, F2.half), F2.one)) nqr = F2.add(nqr, F2.one);
        this.w = new Array(s2 + 1);
        this.wi = new Array(s2 + 1);
        this.w[s2] = this.F.pow(nqr, rem);
        this.wi[s2] = this.F.inv(this.w[s2]);
        let n = s2 - 1;
        while (n >= 0) {
          this.w[n] = this.F.square(this.w[n + 1]);
          this.wi[n] = this.F.square(this.wi[n + 1]);
          n--;
        }
        this.roots = [];
        this._setRoots(Math.min(s2, 15));
      }
      _setRoots(n) {
        for (let i2 = n; i2 >= 0 && !this.roots[i2]; i2--) {
          let r2 = this.F.one;
          const nroots = 1 << i2;
          const rootsi = new Array(nroots);
          for (let j2 = 0; j2 < nroots; j2++) {
            rootsi[j2] = r2;
            r2 = this.F.mul(r2, this.w[i2]);
          }
          this.roots[i2] = rootsi;
        }
      }
      fft(p2) {
        if (p2.length <= 1) return p2;
        const bits2 = log2$1(p2.length - 1) + 1;
        this._setRoots(bits2);
        const m2 = 1 << bits2;
        if (p2.length != m2) {
          throw new Error("Size must be multiple of 2");
        }
        const res = __fft(this, p2, bits2, 0, 1);
        return res;
      }
      ifft(p2) {
        if (p2.length <= 1) return p2;
        const bits2 = log2$1(p2.length - 1) + 1;
        this._setRoots(bits2);
        const m2 = 1 << bits2;
        if (p2.length != m2) {
          throw new Error("Size must be multiple of 2");
        }
        const res = __fft(this, p2, bits2, 0, 1);
        const twoinvm = this.F.inv(this.F.mulScalar(this.F.one, m2));
        const resn = new Array(m2);
        for (let i2 = 0; i2 < m2; i2++) {
          resn[i2] = this.opMulGF(res[(m2 - i2) % m2], twoinvm);
        }
        return resn;
      }
    };
    ZqField = class {
      constructor(p2) {
        this.type = "F1";
        this.one = BigInt(1);
        this.zero = BigInt(0);
        this.p = BigInt(p2);
        this.m = 1;
        this.negone = this.p - this.one;
        this.two = BigInt(2);
        this.half = this.p >> this.one;
        this.bitLength = bitLength$6(this.p);
        this.mask = (this.one << BigInt(this.bitLength)) - this.one;
        this.n64 = Math.floor((this.bitLength - 1) / 64) + 1;
        this.n32 = this.n64 * 2;
        this.n8 = this.n64 * 8;
        this.R = this.e(this.one << BigInt(this.n64 * 64));
        this.Ri = this.inv(this.R);
        const e2 = this.negone >> this.one;
        this.nqr = this.two;
        let r2 = this.pow(this.nqr, e2);
        while (!this.eq(r2, this.negone)) {
          this.nqr = this.nqr + this.one;
          r2 = this.pow(this.nqr, e2);
        }
        this.s = 0;
        this.t = this.negone;
        while ((this.t & this.one) == this.zero) {
          this.s = this.s + 1;
          this.t = this.t >> this.one;
        }
        this.nqr_to_t = this.pow(this.nqr, this.t);
        buildSqrt(this);
        this.FFT = new FFT(this, this, this.mul.bind(this));
        this.fft = this.FFT.fft.bind(this.FFT);
        this.ifft = this.FFT.ifft.bind(this.FFT);
        this.w = this.FFT.w;
        this.wi = this.FFT.wi;
        this.shift = this.square(this.nqr);
        this.k = this.exp(this.nqr, 2 ** this.s);
      }
      e(a2, b2) {
        let res;
        if (!b2) {
          res = BigInt(a2);
        } else if (b2 == 16) {
          res = BigInt("0x" + a2);
        }
        if (res < 0) {
          let nres = -res;
          if (nres >= this.p) nres = nres % this.p;
          return this.p - nres;
        } else {
          return res >= this.p ? res % this.p : res;
        }
      }
      add(a2, b2) {
        const res = a2 + b2;
        return res >= this.p ? res - this.p : res;
      }
      sub(a2, b2) {
        return a2 >= b2 ? a2 - b2 : this.p - b2 + a2;
      }
      neg(a2) {
        return a2 ? this.p - a2 : a2;
      }
      mul(a2, b2) {
        return a2 * b2 % this.p;
      }
      mulScalar(base, s2) {
        return base * this.e(s2) % this.p;
      }
      square(a2) {
        return a2 * a2 % this.p;
      }
      eq(a2, b2) {
        return a2 == b2;
      }
      neq(a2, b2) {
        return a2 != b2;
      }
      lt(a2, b2) {
        const aa = a2 > this.half ? a2 - this.p : a2;
        const bb = b2 > this.half ? b2 - this.p : b2;
        return aa < bb;
      }
      gt(a2, b2) {
        const aa = a2 > this.half ? a2 - this.p : a2;
        const bb = b2 > this.half ? b2 - this.p : b2;
        return aa > bb;
      }
      leq(a2, b2) {
        const aa = a2 > this.half ? a2 - this.p : a2;
        const bb = b2 > this.half ? b2 - this.p : b2;
        return aa <= bb;
      }
      geq(a2, b2) {
        const aa = a2 > this.half ? a2 - this.p : a2;
        const bb = b2 > this.half ? b2 - this.p : b2;
        return aa >= bb;
      }
      div(a2, b2) {
        return this.mul(a2, this.inv(b2));
      }
      idiv(a2, b2) {
        if (!b2) throw new Error("Division by zero");
        return a2 / b2;
      }
      inv(a2) {
        if (!a2) throw new Error("Division by zero");
        let t = this.zero;
        let r2 = this.p;
        let newt = this.one;
        let newr = a2 % this.p;
        while (newr) {
          let q2 = r2 / newr;
          [t, newt] = [newt, t - q2 * newt];
          [r2, newr] = [newr, r2 - q2 * newr];
        }
        if (t < this.zero) t += this.p;
        return t;
      }
      mod(a2, b2) {
        return a2 % b2;
      }
      pow(b2, e2) {
        return exp(this, b2, e2);
      }
      exp(b2, e2) {
        return exp(this, b2, e2);
      }
      band(a2, b2) {
        const res = a2 & b2 & this.mask;
        return res >= this.p ? res - this.p : res;
      }
      bor(a2, b2) {
        const res = (a2 | b2) & this.mask;
        return res >= this.p ? res - this.p : res;
      }
      bxor(a2, b2) {
        const res = (a2 ^ b2) & this.mask;
        return res >= this.p ? res - this.p : res;
      }
      bnot(a2) {
        const res = a2 ^ this.mask;
        return res >= this.p ? res - this.p : res;
      }
      shl(a2, b2) {
        if (Number(b2) < this.bitLength) {
          const res = a2 << b2 & this.mask;
          return res >= this.p ? res - this.p : res;
        } else {
          const nb = this.p - b2;
          if (Number(nb) < this.bitLength) {
            return a2 >> nb;
          } else {
            return this.zero;
          }
        }
      }
      shr(a2, b2) {
        if (Number(b2) < this.bitLength) {
          return a2 >> b2;
        } else {
          const nb = this.p - b2;
          if (Number(nb) < this.bitLength) {
            const res = a2 << nb & this.mask;
            return res >= this.p ? res - this.p : res;
          } else {
            return 0;
          }
        }
      }
      land(a2, b2) {
        return a2 && b2 ? this.one : this.zero;
      }
      lor(a2, b2) {
        return a2 || b2 ? this.one : this.zero;
      }
      lnot(a2) {
        return a2 ? this.zero : this.one;
      }
      sqrt_old(n) {
        if (n == this.zero) return this.zero;
        const res = this.pow(n, this.negone >> this.one);
        if (res != this.one) return null;
        let m2 = this.s;
        let c2 = this.nqr_to_t;
        let t = this.pow(n, this.t);
        let r2 = this.pow(n, this.add(this.t, this.one) >> this.one);
        while (t != this.one) {
          let sq = this.square(t);
          let i2 = 1;
          while (sq != this.one) {
            i2++;
            sq = this.square(sq);
          }
          let b2 = c2;
          for (let j2 = 0; j2 < m2 - i2 - 1; j2++) b2 = this.square(b2);
          m2 = i2;
          c2 = this.square(b2);
          t = this.mul(t, c2);
          r2 = this.mul(r2, b2);
        }
        if (r2 > this.p >> this.one) {
          r2 = this.neg(r2);
        }
        return r2;
      }
      normalize(a2, b2) {
        a2 = BigInt(a2, b2);
        if (a2 < 0) {
          let na = -a2;
          if (na >= this.p) na = na % this.p;
          return this.p - na;
        } else {
          return a2 >= this.p ? a2 % this.p : a2;
        }
      }
      random() {
        const nBytes = this.bitLength * 2 / 8;
        let res = this.zero;
        for (let i2 = 0; i2 < nBytes; i2++) {
          res = (res << BigInt(8)) + BigInt(getRandomBytes(1)[0]);
        }
        return res % this.p;
      }
      toString(a2, base) {
        base = base || 10;
        let vs;
        if (a2 > this.half && base == 10) {
          const v2 = this.p - a2;
          vs = "-" + v2.toString(base);
        } else {
          vs = a2.toString(base);
        }
        return vs;
      }
      isZero(a2) {
        return a2 == this.zero;
      }
      fromRng(rng) {
        let v2;
        do {
          v2 = this.zero;
          for (let i2 = 0; i2 < this.n64; i2++) {
            v2 += rng.nextU64() << BigInt(64 * i2);
          }
          v2 &= this.mask;
        } while (v2 >= this.p);
        v2 = v2 * this.Ri % this.p;
        return v2;
      }
      fft(a2) {
        return this.FFT.fft(a2);
      }
      ifft(a2) {
        return this.FFT.ifft(a2);
      }
      // Returns a buffer with Little Endian Representation
      toRprLE(buff, o2, e2) {
        toRprLE(buff, o2, e2, this.n64 * 8);
      }
      // Returns a buffer with Big Endian Representation
      toRprBE(buff, o2, e2) {
        toRprBE(buff, o2, e2, this.n64 * 8);
      }
      // Returns a buffer with Big Endian Montgomery Representation
      toRprBEM(buff, o2, e2) {
        return this.toRprBE(buff, o2, this.mul(this.R, e2));
      }
      toRprLEM(buff, o2, e2) {
        return this.toRprLE(buff, o2, this.mul(this.R, e2));
      }
      // Pases a buffer with Little Endian Representation
      fromRprLE(buff, o2) {
        return fromRprLE(buff, o2, this.n8);
      }
      // Pases a buffer with Big Endian Representation
      fromRprBE(buff, o2) {
        return fromRprBE(buff, o2, this.n8);
      }
      fromRprLEM(buff, o2) {
        return this.mul(this.fromRprLE(buff, o2), this.Ri);
      }
      fromRprBEM(buff, o2) {
        return this.mul(this.fromRprBE(buff, o2), this.Ri);
      }
      toObject(a2) {
        return a2;
      }
    };
    utils$6 = {};
    utils$6.bigInt2BytesLE = function bigInt2BytesLE(_a, len) {
      const b2 = Array(len);
      let v2 = BigInt(_a);
      for (let i2 = 0; i2 < len; i2++) {
        b2[i2] = Number(v2 & 0xFFn);
        v2 = v2 >> 8n;
      }
      return b2;
    };
    utils$6.bigInt2U32LE = function bigInt2BytesLE2(_a, len) {
      const b2 = Array(len);
      let v2 = BigInt(_a);
      for (let i2 = 0; i2 < len; i2++) {
        b2[i2] = Number(v2 & 0xFFFFFFFFn);
        v2 = v2 >> 32n;
      }
      return b2;
    };
    utils$6.isOcamNum = function(a2) {
      if (!Array.isArray(a2)) return false;
      if (a2.length != 3) return false;
      if (typeof a2[0] !== "number") return false;
      if (typeof a2[1] !== "number") return false;
      if (!Array.isArray(a2[2])) return false;
      return true;
    };
    build_int = function buildInt(module, n64, _prefix) {
      const prefix2 = _prefix || "int";
      if (module.modules[prefix2]) return prefix2;
      module.modules[prefix2] = {};
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      function buildCopy() {
        const f2 = module.addFunction(prefix2 + "_copy");
        f2.addParam("px", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < n64; i2++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i2 * 8,
              c2.i64_load(
                c2.getLocal("px"),
                i2 * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f2 = module.addFunction(prefix2 + "_zero");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < n64; i2++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i2 * 8,
              c2.i64_const(0)
            )
          );
        }
      }
      function buildOne() {
        const f2 = module.addFunction(prefix2 + "_one");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i64_store(
            c2.getLocal("pr"),
            0,
            c2.i64_const(1)
          )
        );
        for (let i2 = 1; i2 < n64; i2++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pr"),
              i2 * 8,
              c2.i64_const(0)
            )
          );
        }
      }
      function buildIsZero() {
        const f2 = module.addFunction(prefix2 + "_isZero");
        f2.addParam("px", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c2.ret(c2.i64_eqz(
              c2.i64_load(c2.getLocal("px"))
            ));
          }
          return c2.if(
            c2.i64_eqz(
              c2.i64_load(c2.getLocal("px"), n * 8)
            ),
            getCompCode(n - 1),
            c2.ret(c2.i32_const(0))
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildEq() {
        const f2 = module.addFunction(prefix2 + "_eq");
        f2.addParam("px", "i32");
        f2.addParam("py", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c2.ret(c2.i64_eq(
              c2.i64_load(c2.getLocal("px")),
              c2.i64_load(c2.getLocal("py"))
            ));
          }
          return c2.if(
            c2.i64_eq(
              c2.i64_load(c2.getLocal("px"), n * 8),
              c2.i64_load(c2.getLocal("py"), n * 8)
            ),
            getCompCode(n - 1),
            c2.ret(c2.i32_const(0))
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildGte() {
        const f2 = module.addFunction(prefix2 + "_gte");
        f2.addParam("px", "i32");
        f2.addParam("py", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        function getCompCode(n) {
          if (n == 0) {
            return c2.ret(c2.i64_ge_u(
              c2.i64_load(c2.getLocal("px")),
              c2.i64_load(c2.getLocal("py"))
            ));
          }
          return c2.if(
            c2.i64_lt_u(
              c2.i64_load(c2.getLocal("px"), n * 8),
              c2.i64_load(c2.getLocal("py"), n * 8)
            ),
            c2.ret(c2.i32_const(0)),
            c2.if(
              c2.i64_gt_u(
                c2.i64_load(c2.getLocal("px"), n * 8),
                c2.i64_load(c2.getLocal("py"), n * 8)
              ),
              c2.ret(c2.i32_const(1)),
              getCompCode(n - 1)
            )
          );
        }
        f2.addCode(getCompCode(n64 - 1));
        f2.addCode(c2.ret(c2.i32_const(0)));
      }
      function buildAdd() {
        const f2 = module.addFunction(prefix2 + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.setReturnType("i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_add(
            c2.i64_load32_u(c2.getLocal("x")),
            c2.i64_load32_u(c2.getLocal("y"))
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("r"),
          c2.getLocal("c")
        ));
        for (let i2 = 1; i2 < n32; i2++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_add(
                c2.i64_load32_u(c2.getLocal("x"), 4 * i2),
                c2.i64_load32_u(c2.getLocal("y"), 4 * i2)
              ),
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("r"),
            i2 * 4,
            c2.getLocal("c")
          ));
        }
        f2.addCode(c2.i32_wrap_i64(c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))));
      }
      function buildSub() {
        const f2 = module.addFunction(prefix2 + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.setReturnType("i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_sub(
            c2.i64_load32_u(c2.getLocal("x")),
            c2.i64_load32_u(c2.getLocal("y"))
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("r"),
          c2.i64_and(
            c2.getLocal("c"),
            c2.i64_const("0xFFFFFFFF")
          )
        ));
        for (let i2 = 1; i2 < n32; i2++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_sub(
                c2.i64_load32_u(c2.getLocal("x"), 4 * i2),
                c2.i64_load32_u(c2.getLocal("y"), 4 * i2)
              ),
              c2.i64_shr_s(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("r"),
            i2 * 4,
            c2.i64_and(c2.getLocal("c"), c2.i64_const("0xFFFFFFFF"))
          ));
        }
        f2.addCode(c2.i32_wrap_i64(c2.i64_shr_s(c2.getLocal("c"), c2.i64_const(32))));
      }
      function buildMul() {
        const f2 = module.addFunction(prefix2 + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        for (let i2 = 0; i2 < n32; i2++) {
          f2.addLocal("x" + i2, "i64");
          f2.addLocal("y" + i2, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const loadX = [];
        const loadY = [];
        function mulij(i2, j2) {
          let X2, Y2;
          if (!loadX[i2]) {
            X2 = c2.teeLocal("x" + i2, c2.i64_load32_u(c2.getLocal("x"), i2 * 4));
            loadX[i2] = true;
          } else {
            X2 = c2.getLocal("x" + i2);
          }
          if (!loadY[j2]) {
            Y2 = c2.teeLocal("y" + j2, c2.i64_load32_u(c2.getLocal("y"), j2 * 4));
            loadY[j2] = true;
          } else {
            Y2 = c2.getLocal("y" + j2);
          }
          return c2.i64_mul(X2, Y2);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k2 = 0; k2 < n32 * 2 - 1; k2++) {
          for (let i2 = Math.max(0, k2 - n32 + 1); i2 <= k2 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.getLocal("r"),
              k2 * 4,
              c2.getLocal(c0)
            )
          );
          [c0, c1] = [c1, c0];
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_shr_u(
                c2.getLocal(c0),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 * 2 - 4,
            c2.getLocal(c0)
          )
        );
      }
      function buildSquare() {
        const f2 = module.addFunction(prefix2 + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("c0_old", "i64");
        f2.addLocal("c1_old", "i64");
        for (let i2 = 0; i2 < n32; i2++) {
          f2.addLocal("x" + i2, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const loadX = [];
        function mulij(i2, j2) {
          let X2, Y2;
          if (!loadX[i2]) {
            X2 = c2.teeLocal("x" + i2, c2.i64_load32_u(c2.getLocal("x"), i2 * 4));
            loadX[i2] = true;
          } else {
            X2 = c2.getLocal("x" + i2);
          }
          if (!loadX[j2]) {
            Y2 = c2.teeLocal("x" + j2, c2.i64_load32_u(c2.getLocal("x"), j2 * 4));
            loadX[j2] = true;
          } else {
            Y2 = c2.getLocal("x" + j2);
          }
          return c2.i64_mul(X2, Y2);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k2 = 0; k2 < n32 * 2 - 1; k2++) {
          f2.addCode(
            c2.setLocal(c0, c2.i64_const(0)),
            c2.setLocal(c1, c2.i64_const(0))
          );
          for (let i2 = Math.max(0, k2 - n32 + 1); i2 < k2 + 1 >> 1 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0,
              c2.i64_shl(
                c2.i64_and(
                  c2.getLocal(c0),
                  c2.i64_const(4294967295)
                ),
                c2.i64_const(1)
              )
            )
          );
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_add(
                c2.i64_shl(
                  c2.getLocal(c1),
                  c2.i64_const(1)
                ),
                c2.i64_shr_u(
                  c2.getLocal(c0),
                  c2.i64_const(32)
                )
              )
            )
          );
          if (k2 % 2 == 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(k2 >> 1, k2 >> 1)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 > 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  c2.i64_and(
                    c2.getLocal(c0_old),
                    c2.i64_const(4294967295)
                  )
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.i64_add(
                    c2.getLocal(c1),
                    c2.i64_shr_u(
                      c2.getLocal(c0),
                      c2.i64_const(32)
                    )
                  ),
                  c2.getLocal(c1_old)
                )
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.getLocal("r"),
              k2 * 4,
              c2.getLocal(c0)
            )
          );
          f2.addCode(
            c2.setLocal(
              c0_old,
              c2.getLocal(c1)
            ),
            c2.setLocal(
              c1_old,
              c2.i64_shr_u(
                c2.getLocal(c0_old),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 * 2 - 4,
            c2.getLocal(c0_old)
          )
        );
      }
      function buildSquareOld() {
        const f2 = module.addFunction(prefix2 + "_squareOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix2 + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function _buildMul1() {
        const f2 = module.addFunction(prefix2 + "__mul1");
        f2.addParam("px", "i32");
        f2.addParam("y", "i64");
        f2.addParam("pr", "i32");
        f2.addLocal("c", "i64");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_mul(
            c2.i64_load32_u(c2.getLocal("px"), 0, 0),
            c2.getLocal("y")
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("pr"),
          0,
          0,
          c2.getLocal("c")
        ));
        for (let i2 = 1; i2 < n32; i2++) {
          f2.addCode(c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_mul(
                c2.i64_load32_u(c2.getLocal("px"), 4 * i2, 0),
                c2.getLocal("y")
              ),
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          ));
          f2.addCode(c2.i64_store32(
            c2.getLocal("pr"),
            i2 * 4,
            0,
            c2.getLocal("c")
          ));
        }
      }
      function _buildAdd1() {
        const f2 = module.addFunction(prefix2 + "__add1");
        f2.addParam("x", "i32");
        f2.addParam("y", "i64");
        f2.addLocal("c", "i64");
        f2.addLocal("px", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.setLocal("px", c2.getLocal("x")));
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_add(
            c2.i64_load32_u(c2.getLocal("px"), 0, 0),
            c2.getLocal("y")
          )
        ));
        f2.addCode(c2.i64_store32(
          c2.getLocal("px"),
          0,
          0,
          c2.getLocal("c")
        ));
        f2.addCode(c2.setLocal(
          "c",
          c2.i64_shr_u(
            c2.getLocal("c"),
            c2.i64_const(32)
          )
        ));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i64_eqz(c2.getLocal("c"))
          ),
          c2.setLocal(
            "px",
            c2.i32_add(
              c2.getLocal("px"),
              c2.i32_const(4)
            )
          ),
          c2.setLocal(
            "c",
            c2.i64_add(
              c2.i64_load32_u(c2.getLocal("px"), 0, 0),
              c2.getLocal("c")
            )
          ),
          c2.i64_store32(
            c2.getLocal("px"),
            0,
            0,
            c2.getLocal("c")
          ),
          c2.setLocal(
            "c",
            c2.i64_shr_u(
              c2.getLocal("c"),
              c2.i64_const(32)
            )
          ),
          c2.br(0)
        )));
      }
      function buildDiv() {
        _buildMul1();
        _buildAdd1();
        const f2 = module.addFunction(prefix2 + "_div");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("c", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("rr", "i32");
        f2.addLocal("cc", "i32");
        f2.addLocal("eX", "i32");
        f2.addLocal("eY", "i32");
        f2.addLocal("sy", "i64");
        f2.addLocal("sx", "i64");
        f2.addLocal("ec", "i32");
        const c2 = f2.getCodeBuilder();
        const Y2 = c2.i32_const(module.alloc(n8));
        const Caux = c2.i32_const(module.alloc(n8));
        const Raux = c2.i32_const(module.alloc(n8));
        const C2 = c2.getLocal("cc");
        const R2 = c2.getLocal("rr");
        const pr1 = module.alloc(n8 * 2);
        const R1 = c2.i32_const(pr1);
        const R22 = c2.i32_const(pr1 + n8);
        f2.addCode(c2.if(
          c2.getLocal("c"),
          c2.setLocal("cc", c2.getLocal("c")),
          c2.setLocal("cc", Caux)
        ));
        f2.addCode(c2.if(
          c2.getLocal("r"),
          c2.setLocal("rr", c2.getLocal("r")),
          c2.setLocal("rr", Raux)
        ));
        f2.addCode(c2.call(prefix2 + "_copy", c2.getLocal("x"), R2));
        f2.addCode(c2.call(prefix2 + "_copy", c2.getLocal("y"), Y2));
        f2.addCode(c2.call(prefix2 + "_zero", C2));
        f2.addCode(c2.call(prefix2 + "_zero", R1));
        f2.addCode(c2.setLocal("eX", c2.i32_const(n8 - 1)));
        f2.addCode(c2.setLocal("eY", c2.i32_const(n8 - 1)));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i32_or(
              c2.i32_load8_u(
                c2.i32_add(Y2, c2.getLocal("eY")),
                0,
                0
              ),
              c2.i32_eq(
                c2.getLocal("eY"),
                c2.i32_const(3)
              )
            )
          ),
          c2.setLocal("eY", c2.i32_sub(c2.getLocal("eY"), c2.i32_const(1))),
          c2.br(0)
        )));
        f2.addCode(
          c2.setLocal(
            "sy",
            c2.i64_add(
              c2.i64_load32_u(
                c2.i32_sub(
                  c2.i32_add(Y2, c2.getLocal("eY")),
                  c2.i32_const(3)
                ),
                0,
                0
              ),
              c2.i64_const(1)
            )
          )
        );
        f2.addCode(
          c2.if(
            c2.i64_eq(
              c2.getLocal("sy"),
              c2.i64_const(1)
            ),
            c2.drop(c2.i64_div_u(c2.i64_const(0), c2.i64_const(0)))
          )
        );
        f2.addCode(c2.block(c2.loop(
          // while (eX>7)&&(Y[eX]==0) ex--;
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_or(
                c2.i32_load8_u(
                  c2.i32_add(R2, c2.getLocal("eX")),
                  0,
                  0
                ),
                c2.i32_eq(
                  c2.getLocal("eX"),
                  c2.i32_const(7)
                )
              )
            ),
            c2.setLocal("eX", c2.i32_sub(c2.getLocal("eX"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.setLocal(
            "sx",
            c2.i64_load(
              c2.i32_sub(
                c2.i32_add(R2, c2.getLocal("eX")),
                c2.i32_const(7)
              ),
              0,
              0
            )
          ),
          c2.setLocal(
            "sx",
            c2.i64_div_u(
              c2.getLocal("sx"),
              c2.getLocal("sy")
            )
          ),
          c2.setLocal(
            "ec",
            c2.i32_sub(
              c2.i32_sub(
                c2.getLocal("eX"),
                c2.getLocal("eY")
              ),
              c2.i32_const(4)
            )
          ),
          // While greater than 32 bits or ec is neg, shr and inc exp
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_and(
                c2.i64_eqz(
                  c2.i64_and(
                    c2.getLocal("sx"),
                    c2.i64_const("0xFFFFFFFF00000000")
                  )
                ),
                c2.i32_ge_s(
                  c2.getLocal("ec"),
                  c2.i32_const(0)
                )
              )
            ),
            c2.setLocal(
              "sx",
              c2.i64_shr_u(
                c2.getLocal("sx"),
                c2.i64_const(8)
              )
            ),
            c2.setLocal(
              "ec",
              c2.i32_add(
                c2.getLocal("ec"),
                c2.i32_const(1)
              )
            ),
            c2.br(0)
          )),
          c2.if(
            c2.i64_eqz(c2.getLocal("sx")),
            [
              ...c2.br_if(
                2,
                c2.i32_eqz(c2.call(prefix2 + "_gte", R2, Y2))
              ),
              ...c2.setLocal("sx", c2.i64_const(1)),
              ...c2.setLocal("ec", c2.i32_const(0))
            ]
          ),
          c2.call(prefix2 + "__mul1", Y2, c2.getLocal("sx"), R22),
          c2.drop(c2.call(
            prefix2 + "_sub",
            R2,
            c2.i32_sub(R22, c2.getLocal("ec")),
            R2
          )),
          c2.call(
            prefix2 + "__add1",
            c2.i32_add(C2, c2.getLocal("ec")),
            c2.getLocal("sx")
          ),
          c2.br(0)
        )));
      }
      function buildInverseMod() {
        const f2 = module.addFunction(prefix2 + "_inverseMod");
        f2.addParam("px", "i32");
        f2.addParam("pm", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("t", "i32");
        f2.addLocal("newt", "i32");
        f2.addLocal("r", "i32");
        f2.addLocal("qq", "i32");
        f2.addLocal("qr", "i32");
        f2.addLocal("newr", "i32");
        f2.addLocal("swp", "i32");
        f2.addLocal("x", "i32");
        f2.addLocal("signt", "i32");
        f2.addLocal("signnewt", "i32");
        f2.addLocal("signx", "i32");
        const c2 = f2.getCodeBuilder();
        const aux1 = c2.i32_const(module.alloc(n8));
        const aux2 = c2.i32_const(module.alloc(n8));
        const aux3 = c2.i32_const(module.alloc(n8));
        const aux4 = c2.i32_const(module.alloc(n8));
        const aux5 = c2.i32_const(module.alloc(n8));
        const aux6 = c2.i32_const(module.alloc(n8));
        const mulBuff = c2.i32_const(module.alloc(n8 * 2));
        const aux7 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.setLocal("t", aux1),
          c2.call(prefix2 + "_zero", aux1),
          c2.setLocal("signt", c2.i32_const(0))
        );
        f2.addCode(
          c2.setLocal("r", aux2),
          c2.call(prefix2 + "_copy", c2.getLocal("pm"), aux2)
        );
        f2.addCode(
          c2.setLocal("newt", aux3),
          c2.call(prefix2 + "_one", aux3),
          c2.setLocal("signnewt", c2.i32_const(0))
        );
        f2.addCode(
          c2.setLocal("newr", aux4),
          c2.call(prefix2 + "_copy", c2.getLocal("px"), aux4)
        );
        f2.addCode(c2.setLocal("qq", aux5));
        f2.addCode(c2.setLocal("qr", aux6));
        f2.addCode(c2.setLocal("x", aux7));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.call(prefix2 + "_isZero", c2.getLocal("newr"))
          ),
          c2.call(prefix2 + "_div", c2.getLocal("r"), c2.getLocal("newr"), c2.getLocal("qq"), c2.getLocal("qr")),
          c2.call(prefix2 + "_mul", c2.getLocal("qq"), c2.getLocal("newt"), mulBuff),
          c2.if(
            c2.getLocal("signt"),
            c2.if(
              c2.getLocal("signnewt"),
              c2.if(
                c2.call(prefix2 + "_gte", mulBuff, c2.getLocal("t")),
                [
                  ...c2.drop(c2.call(prefix2 + "_sub", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(0))
                ],
                [
                  ...c2.drop(c2.call(prefix2 + "_sub", c2.getLocal("t"), mulBuff, c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(1))
                ]
              ),
              [
                ...c2.drop(c2.call(prefix2 + "_add", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                ...c2.setLocal("signx", c2.i32_const(1))
              ]
            ),
            c2.if(
              c2.getLocal("signnewt"),
              [
                ...c2.drop(c2.call(prefix2 + "_add", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                ...c2.setLocal("signx", c2.i32_const(0))
              ],
              c2.if(
                c2.call(prefix2 + "_gte", c2.getLocal("t"), mulBuff),
                [
                  ...c2.drop(c2.call(prefix2 + "_sub", c2.getLocal("t"), mulBuff, c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(0))
                ],
                [
                  ...c2.drop(c2.call(prefix2 + "_sub", mulBuff, c2.getLocal("t"), c2.getLocal("x"))),
                  ...c2.setLocal("signx", c2.i32_const(1))
                ]
              )
            )
          ),
          c2.setLocal("swp", c2.getLocal("t")),
          c2.setLocal("t", c2.getLocal("newt")),
          c2.setLocal("newt", c2.getLocal("x")),
          c2.setLocal("x", c2.getLocal("swp")),
          c2.setLocal("signt", c2.getLocal("signnewt")),
          c2.setLocal("signnewt", c2.getLocal("signx")),
          c2.setLocal("swp", c2.getLocal("r")),
          c2.setLocal("r", c2.getLocal("newr")),
          c2.setLocal("newr", c2.getLocal("qr")),
          c2.setLocal("qr", c2.getLocal("swp")),
          c2.br(0)
        )));
        f2.addCode(c2.if(
          c2.getLocal("signt"),
          c2.drop(c2.call(prefix2 + "_sub", c2.getLocal("pm"), c2.getLocal("t"), c2.getLocal("pr"))),
          c2.call(prefix2 + "_copy", c2.getLocal("t"), c2.getLocal("pr"))
        ));
      }
      buildCopy();
      buildZero();
      buildIsZero();
      buildOne();
      buildEq();
      buildGte();
      buildAdd();
      buildSub();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildDiv();
      buildInverseMod();
      module.exportFunction(prefix2 + "_copy");
      module.exportFunction(prefix2 + "_zero");
      module.exportFunction(prefix2 + "_one");
      module.exportFunction(prefix2 + "_isZero");
      module.exportFunction(prefix2 + "_eq");
      module.exportFunction(prefix2 + "_gte");
      module.exportFunction(prefix2 + "_add");
      module.exportFunction(prefix2 + "_sub");
      module.exportFunction(prefix2 + "_mul");
      module.exportFunction(prefix2 + "_square");
      module.exportFunction(prefix2 + "_squareOld");
      module.exportFunction(prefix2 + "_div");
      module.exportFunction(prefix2 + "_inverseMod");
      return prefix2;
    };
    build_timesscalar = function buildTimesScalar(module, fnName, elementLen, opAB, opAA, opCopy, opInit) {
      const f2 = module.addFunction(fnName);
      f2.addParam("base", "i32");
      f2.addParam("scalar", "i32");
      f2.addParam("scalarLength", "i32");
      f2.addParam("r", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("b", "i32");
      const c2 = f2.getCodeBuilder();
      const aux = c2.i32_const(module.alloc(elementLen));
      f2.addCode(
        c2.if(
          c2.i32_eqz(c2.getLocal("scalarLength")),
          [
            ...c2.call(opInit, c2.getLocal("r")),
            ...c2.ret([])
          ]
        )
      );
      f2.addCode(c2.call(opCopy, c2.getLocal("base"), aux));
      f2.addCode(c2.call(opInit, c2.getLocal("r")));
      f2.addCode(c2.setLocal("i", c2.getLocal("scalarLength")));
      f2.addCode(c2.block(c2.loop(
        c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
        c2.setLocal(
          "b",
          c2.i32_load8_u(
            c2.i32_add(
              c2.getLocal("scalar"),
              c2.getLocal("i")
            )
          )
        ),
        ...innerLoop(),
        c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
        c2.br(0)
      )));
      function innerLoop() {
        const code = [];
        for (let i2 = 0; i2 < 8; i2++) {
          code.push(
            ...c2.call(opAA, c2.getLocal("r"), c2.getLocal("r")),
            ...c2.if(
              c2.i32_ge_u(c2.getLocal("b"), c2.i32_const(128 >> i2)),
              [
                ...c2.setLocal(
                  "b",
                  c2.i32_sub(
                    c2.getLocal("b"),
                    c2.i32_const(128 >> i2)
                  )
                ),
                ...c2.call(opAB, c2.getLocal("r"), aux, c2.getLocal("r"))
              ]
            )
          );
        }
        return code;
      }
    };
    build_batchinverse = buildBatchInverse$3;
    build_batchconvertion = buildBatchConvertion$3;
    build_batchop = buildBatchConvertion$2;
    bigint = {};
    bigint.bitLength = bitLength$5;
    bigint.isOdd = isOdd$4;
    bigint.isNegative = isNegative$3;
    bigint.abs = abs;
    bigint.isUnit = isUnit;
    bigint.compare = compare;
    bigint.modInv = modInv$3;
    bigint.modPow = modPow$2;
    bigint.isPrime = isPrime$1;
    bigint.square = square$1;
    buildInt2 = build_int;
    utils$5 = utils$6;
    buildExp$2 = build_timesscalar;
    buildBatchInverse$2 = build_batchinverse;
    buildBatchConvertion$1 = build_batchconvertion;
    buildBatchOp = build_batchop;
    ({ bitLength: bitLength$4, modInv: modInv$2, modPow: modPow$1, isPrime, isOdd: isOdd$3, square } = bigint);
    build_f1m = function buildF1m(module, _q, _prefix, _intPrefix) {
      const q2 = BigInt(_q);
      const n64 = Math.floor((bitLength$4(q2 - 1n) - 1) / 64) + 1;
      const n32 = n64 * 2;
      const n8 = n64 * 8;
      const prefix2 = _prefix || "f1m";
      if (module.modules[prefix2]) return prefix2;
      const intPrefix = buildInt2(module, n64, _intPrefix);
      const pq = module.alloc(n8, utils$5.bigInt2BytesLE(q2, n8));
      const pR2 = module.alloc(utils$5.bigInt2BytesLE(square(1n << BigInt(n64 * 64)) % q2, n8));
      const pOne = module.alloc(utils$5.bigInt2BytesLE((1n << BigInt(n64 * 64)) % q2, n8));
      const pZero = module.alloc(utils$5.bigInt2BytesLE(0n, n8));
      const _minusOne = q2 - 1n;
      const _e2 = _minusOne >> 1n;
      const pe2 = module.alloc(n8, utils$5.bigInt2BytesLE(_e2, n8));
      const _ePlusOne = _e2 + 1n;
      const pePlusOne = module.alloc(n8, utils$5.bigInt2BytesLE(_ePlusOne, n8));
      module.modules[prefix2] = {
        pq,
        pR2,
        n64,
        q: q2,
        pOne,
        pZero,
        pePlusOne
      };
      function buildOne() {
        const f2 = module.addFunction(prefix2 + "_one");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_copy", c2.i32_const(pOne), c2.getLocal("pr")));
      }
      function buildAdd() {
        const f2 = module.addFunction(prefix2 + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_add", c2.getLocal("x"), c2.getLocal("y"), c2.getLocal("r")),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSub() {
        const f2 = module.addFunction(prefix2 + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_sub", c2.getLocal("x"), c2.getLocal("y"), c2.getLocal("r")),
            c2.drop(c2.call(intPrefix + "_add", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
          )
        );
      }
      function buildNeg() {
        const f2 = module.addFunction(prefix2 + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(prefix2 + "_sub", c2.i32_const(pZero), c2.getLocal("x"), c2.getLocal("r"))
        );
      }
      function buildIsNegative() {
        const f2 = module.addFunction(prefix2 + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.call(prefix2 + "_fromMontgomery", c2.getLocal("x"), AUX),
          c2.call(intPrefix + "_gte", AUX, c2.i32_const(pePlusOne))
        );
      }
      function buildSign() {
        const f2 = module.addFunction(prefix2 + "_sign");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(intPrefix + "_isZero", c2.getLocal("x")),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(prefix2 + "_fromMontgomery", c2.getLocal("x"), AUX),
          c2.if(
            c2.call(intPrefix + "_gte", AUX, c2.i32_const(pePlusOne)),
            c2.ret(c2.i32_const(-1))
          ),
          c2.ret(c2.i32_const(1))
        );
      }
      function buildMReduct() {
        const carries = module.alloc(n32 * n32 * 8);
        const f2 = module.addFunction(prefix2 + "_mReduct");
        f2.addParam("t", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("np32", "i64");
        f2.addLocal("c", "i64");
        f2.addLocal("m", "i64");
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv$2(q2, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        for (let i2 = 0; i2 < n32; i2++) {
          f2.addCode(c2.setLocal("c", c2.i64_const(0)));
          f2.addCode(
            c2.setLocal(
              "m",
              c2.i64_and(
                c2.i64_mul(
                  c2.i64_load32_u(c2.getLocal("t"), i2 * 4),
                  c2.getLocal("np32")
                ),
                c2.i64_const("0xFFFFFFFF")
              )
            )
          );
          for (let j2 = 0; j2 < n32; j2++) {
            f2.addCode(
              c2.setLocal(
                "c",
                c2.i64_add(
                  c2.i64_add(
                    c2.i64_load32_u(c2.getLocal("t"), (i2 + j2) * 4),
                    c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
                  ),
                  c2.i64_mul(
                    c2.i64_load32_u(c2.i32_const(pq), j2 * 4),
                    c2.getLocal("m")
                  )
                )
              )
            );
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("t"),
                (i2 + j2) * 4,
                c2.getLocal("c")
              )
            );
          }
          f2.addCode(
            c2.i64_store32(
              c2.i32_const(carries),
              i2 * 4,
              c2.i64_shr_u(c2.getLocal("c"), c2.i64_const(32))
            )
          );
        }
        f2.addCode(
          c2.call(
            prefix2 + "_add",
            c2.i32_const(carries),
            c2.i32_add(
              c2.getLocal("t"),
              c2.i32_const(n32 * 4)
            ),
            c2.getLocal("r")
          )
        );
      }
      function buildMul() {
        const f2 = module.addFunction(prefix2 + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("np32", "i64");
        for (let i2 = 0; i2 < n32; i2++) {
          f2.addLocal("x" + i2, "i64");
          f2.addLocal("y" + i2, "i64");
          f2.addLocal("m" + i2, "i64");
          f2.addLocal("q" + i2, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv$2(q2, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        const loadX = [];
        const loadY = [];
        const loadQ = [];
        function mulij(i2, j2) {
          let X2, Y2;
          if (!loadX[i2]) {
            X2 = c2.teeLocal("x" + i2, c2.i64_load32_u(c2.getLocal("x"), i2 * 4));
            loadX[i2] = true;
          } else {
            X2 = c2.getLocal("x" + i2);
          }
          if (!loadY[j2]) {
            Y2 = c2.teeLocal("y" + j2, c2.i64_load32_u(c2.getLocal("y"), j2 * 4));
            loadY[j2] = true;
          } else {
            Y2 = c2.getLocal("y" + j2);
          }
          return c2.i64_mul(X2, Y2);
        }
        function mulqm(i2, j2) {
          let Q2, M2;
          if (!loadQ[i2]) {
            Q2 = c2.teeLocal("q" + i2, c2.i64_load32_u(c2.i32_const(0), pq + i2 * 4));
            loadQ[i2] = true;
          } else {
            Q2 = c2.getLocal("q" + i2);
          }
          M2 = c2.getLocal("m" + j2);
          return c2.i64_mul(Q2, M2);
        }
        let c0 = "c0";
        let c1 = "c1";
        for (let k2 = 0; k2 < n32 * 2 - 1; k2++) {
          for (let i2 = Math.max(0, k2 - n32 + 1); i2 <= k2 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          for (let i2 = Math.max(1, k2 - n32 + 1); i2 <= k2 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 < n32) {
            f2.addCode(
              c2.setLocal(
                "m" + k2,
                c2.i64_and(
                  c2.i64_mul(
                    c2.i64_and(
                      c2.getLocal(c0),
                      c2.i64_const(4294967295)
                    ),
                    c2.getLocal("np32")
                  ),
                  c2.i64_const("0xFFFFFFFF")
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(0, k2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 >= n32) {
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("r"),
                (k2 - n32) * 4,
                c2.getLocal(c0)
              )
            );
          }
          [c0, c1] = [c1, c0];
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_shr_u(
                c2.getLocal(c0),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 - 4,
            c2.getLocal(c0)
          )
        );
        f2.addCode(
          c2.if(
            c2.i32_wrap_i64(c2.getLocal(c1)),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSquare() {
        const f2 = module.addFunction(prefix2 + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("c0", "i64");
        f2.addLocal("c1", "i64");
        f2.addLocal("c0_old", "i64");
        f2.addLocal("c1_old", "i64");
        f2.addLocal("np32", "i64");
        for (let i2 = 0; i2 < n32; i2++) {
          f2.addLocal("x" + i2, "i64");
          f2.addLocal("m" + i2, "i64");
          f2.addLocal("q" + i2, "i64");
        }
        const c2 = f2.getCodeBuilder();
        const np32 = Number(0x100000000n - modInv$2(q2, 0x100000000n));
        f2.addCode(c2.setLocal("np32", c2.i64_const(np32)));
        const loadX = [];
        const loadQ = [];
        function mulij(i2, j2) {
          let X2, Y2;
          if (!loadX[i2]) {
            X2 = c2.teeLocal("x" + i2, c2.i64_load32_u(c2.getLocal("x"), i2 * 4));
            loadX[i2] = true;
          } else {
            X2 = c2.getLocal("x" + i2);
          }
          if (!loadX[j2]) {
            Y2 = c2.teeLocal("x" + j2, c2.i64_load32_u(c2.getLocal("x"), j2 * 4));
            loadX[j2] = true;
          } else {
            Y2 = c2.getLocal("x" + j2);
          }
          return c2.i64_mul(X2, Y2);
        }
        function mulqm(i2, j2) {
          let Q2, M2;
          if (!loadQ[i2]) {
            Q2 = c2.teeLocal("q" + i2, c2.i64_load32_u(c2.i32_const(0), pq + i2 * 4));
            loadQ[i2] = true;
          } else {
            Q2 = c2.getLocal("q" + i2);
          }
          M2 = c2.getLocal("m" + j2);
          return c2.i64_mul(Q2, M2);
        }
        let c0 = "c0";
        let c1 = "c1";
        let c0_old = "c0_old";
        let c1_old = "c1_old";
        for (let k2 = 0; k2 < n32 * 2 - 1; k2++) {
          f2.addCode(
            c2.setLocal(c0, c2.i64_const(0)),
            c2.setLocal(c1, c2.i64_const(0))
          );
          for (let i2 = Math.max(0, k2 - n32 + 1); i2 < k2 + 1 >> 1 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0,
              c2.i64_shl(
                c2.i64_and(
                  c2.getLocal(c0),
                  c2.i64_const(4294967295)
                ),
                c2.i64_const(1)
              )
            )
          );
          f2.addCode(
            c2.setLocal(
              c1,
              c2.i64_add(
                c2.i64_shl(
                  c2.getLocal(c1),
                  c2.i64_const(1)
                ),
                c2.i64_shr_u(
                  c2.getLocal(c0),
                  c2.i64_const(32)
                )
              )
            )
          );
          if (k2 % 2 == 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulij(k2 >> 1, k2 >> 1)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 > 0) {
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  c2.i64_and(
                    c2.getLocal(c0_old),
                    c2.i64_const(4294967295)
                  )
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.i64_add(
                    c2.getLocal(c1),
                    c2.i64_shr_u(
                      c2.getLocal(c0),
                      c2.i64_const(32)
                    )
                  ),
                  c2.getLocal(c1_old)
                )
              )
            );
          }
          for (let i2 = Math.max(1, k2 - n32 + 1); i2 <= k2 && i2 < n32; i2++) {
            const j2 = k2 - i2;
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(i2, j2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 < n32) {
            f2.addCode(
              c2.setLocal(
                "m" + k2,
                c2.i64_and(
                  c2.i64_mul(
                    c2.i64_and(
                      c2.getLocal(c0),
                      c2.i64_const(4294967295)
                    ),
                    c2.getLocal("np32")
                  ),
                  c2.i64_const("0xFFFFFFFF")
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c0,
                c2.i64_add(
                  c2.i64_and(
                    c2.getLocal(c0),
                    c2.i64_const(4294967295)
                  ),
                  mulqm(0, k2)
                )
              )
            );
            f2.addCode(
              c2.setLocal(
                c1,
                c2.i64_add(
                  c2.getLocal(c1),
                  c2.i64_shr_u(
                    c2.getLocal(c0),
                    c2.i64_const(32)
                  )
                )
              )
            );
          }
          if (k2 >= n32) {
            f2.addCode(
              c2.i64_store32(
                c2.getLocal("r"),
                (k2 - n32) * 4,
                c2.getLocal(c0)
              )
            );
          }
          f2.addCode(
            c2.setLocal(
              c0_old,
              c2.getLocal(c1)
            ),
            c2.setLocal(
              c1_old,
              c2.i64_shr_u(
                c2.getLocal(c0_old),
                c2.i64_const(32)
              )
            )
          );
        }
        f2.addCode(
          c2.i64_store32(
            c2.getLocal("r"),
            n32 * 4 - 4,
            c2.getLocal(c0_old)
          )
        );
        f2.addCode(
          c2.if(
            c2.i32_wrap_i64(c2.getLocal(c1_old)),
            c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r"))),
            c2.if(
              c2.call(intPrefix + "_gte", c2.getLocal("r"), c2.i32_const(pq)),
              c2.drop(c2.call(intPrefix + "_sub", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")))
            )
          )
        );
      }
      function buildSquareOld() {
        const f2 = module.addFunction(prefix2 + "_squareOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix2 + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function buildToMontgomery() {
        const f2 = module.addFunction(prefix2 + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix2 + "_mul", c2.getLocal("x"), c2.i32_const(pR2), c2.getLocal("r")));
      }
      function buildFromMontgomery() {
        const pAux2 = module.alloc(n8 * 2);
        const f2 = module.addFunction(prefix2 + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_copy", c2.getLocal("x"), c2.i32_const(pAux2)));
        f2.addCode(c2.call(intPrefix + "_zero", c2.i32_const(pAux2 + n8)));
        f2.addCode(c2.call(prefix2 + "_mReduct", c2.i32_const(pAux2), c2.getLocal("r")));
      }
      function buildInverse() {
        const f2 = module.addFunction(prefix2 + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix2 + "_fromMontgomery", c2.getLocal("x"), c2.getLocal("r")));
        f2.addCode(c2.call(intPrefix + "_inverseMod", c2.getLocal("r"), c2.i32_const(pq), c2.getLocal("r")));
        f2.addCode(c2.call(prefix2 + "_toMontgomery", c2.getLocal("r"), c2.getLocal("r")));
      }
      let _nqr = 2n;
      if (isPrime(q2)) {
        while (modPow$1(_nqr, _e2, q2) !== _minusOne) _nqr = _nqr + 1n;
      }
      let s2 = 0;
      let _t = _minusOne;
      while (!isOdd$3(_t) && _t !== 0n) {
        s2++;
        _t = _t >> 1n;
      }
      const pt2 = module.alloc(n8, utils$5.bigInt2BytesLE(_t, n8));
      const _nqrToT = modPow$1(_nqr, _t, q2);
      const pNqrToT = module.alloc(utils$5.bigInt2BytesLE((_nqrToT << BigInt(n64 * 64)) % q2, n8));
      const _tPlusOneOver2 = _t + 1n >> 1n;
      const ptPlusOneOver2 = module.alloc(n8, utils$5.bigInt2BytesLE(_tPlusOneOver2, n8));
      function buildSqrt2() {
        const f2 = module.addFunction(prefix2 + "_sqrt");
        f2.addParam("n", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        const c2 = f2.getCodeBuilder();
        const ONE = c2.i32_const(pOne);
        const C2 = c2.i32_const(module.alloc(n8));
        const T2 = c2.i32_const(module.alloc(n8));
        const R2 = c2.i32_const(module.alloc(n8));
        const SQ = c2.i32_const(module.alloc(n8));
        const B2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          // If (n==0) return 0
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("n")),
            c2.ret(
              c2.call(prefix2 + "_zero", c2.getLocal("r"))
            )
          ),
          c2.setLocal("m", c2.i32_const(s2)),
          c2.call(prefix2 + "_copy", c2.i32_const(pNqrToT), C2),
          c2.call(prefix2 + "_exp", c2.getLocal("n"), c2.i32_const(pt2), c2.i32_const(n8), T2),
          c2.call(prefix2 + "_exp", c2.getLocal("n"), c2.i32_const(ptPlusOneOver2), c2.i32_const(n8), R2),
          c2.block(c2.loop(
            c2.br_if(1, c2.call(prefix2 + "_eq", T2, ONE)),
            c2.call(prefix2 + "_square", T2, SQ),
            c2.setLocal("i", c2.i32_const(1)),
            c2.block(c2.loop(
              c2.br_if(1, c2.call(prefix2 + "_eq", SQ, ONE)),
              c2.call(prefix2 + "_square", SQ, SQ),
              c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.call(prefix2 + "_copy", C2, B2),
            c2.setLocal("j", c2.i32_sub(c2.i32_sub(c2.getLocal("m"), c2.getLocal("i")), c2.i32_const(1))),
            c2.block(c2.loop(
              c2.br_if(1, c2.i32_eqz(c2.getLocal("j"))),
              c2.call(prefix2 + "_square", B2, B2),
              c2.setLocal("j", c2.i32_sub(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("m", c2.getLocal("i")),
            c2.call(prefix2 + "_square", B2, C2),
            c2.call(prefix2 + "_mul", T2, C2, T2),
            c2.call(prefix2 + "_mul", R2, B2, R2),
            c2.br(0)
          )),
          c2.if(
            c2.call(prefix2 + "_isNegative", R2),
            c2.call(prefix2 + "_neg", R2, c2.getLocal("r")),
            c2.call(prefix2 + "_copy", R2, c2.getLocal("r"))
          )
        );
      }
      function buildIsSquare() {
        const f2 = module.addFunction(prefix2 + "_isSquare");
        f2.addParam("n", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const ONE = c2.i32_const(pOne);
        const AUX = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("n")),
            c2.ret(c2.i32_const(1))
          ),
          c2.call(prefix2 + "_exp", c2.getLocal("n"), c2.i32_const(pe2), c2.i32_const(n8), AUX),
          c2.call(prefix2 + "_eq", AUX, ONE)
        );
      }
      function buildLoad() {
        const f2 = module.addFunction(prefix2 + "_load");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("p", "i32");
        f2.addLocal("l", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        const c2 = f2.getCodeBuilder();
        const R2 = c2.i32_const(module.alloc(n8));
        const pAux = module.alloc(n8);
        const AUX = c2.i32_const(pAux);
        f2.addCode(
          c2.call(intPrefix + "_zero", c2.getLocal("r")),
          c2.setLocal("i", c2.i32_const(n8)),
          c2.setLocal("p", c2.getLocal("scalar")),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_gt_u(c2.getLocal("i"), c2.getLocal("scalarLen"))),
            c2.if(
              c2.i32_eq(c2.getLocal("i"), c2.i32_const(n8)),
              c2.call(prefix2 + "_one", R2),
              c2.call(prefix2 + "_mul", R2, c2.i32_const(pR2), R2)
            ),
            c2.call(prefix2 + "_mul", c2.getLocal("p"), R2, AUX),
            c2.call(prefix2 + "_add", c2.getLocal("r"), AUX, c2.getLocal("r")),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(n8))),
            c2.br(0)
          )),
          c2.setLocal("l", c2.i32_rem_u(c2.getLocal("scalarLen"), c2.i32_const(n8))),
          c2.if(c2.i32_eqz(c2.getLocal("l")), c2.ret([])),
          c2.call(intPrefix + "_zero", AUX),
          c2.setLocal("j", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("j"), c2.getLocal("l"))),
            c2.i32_store8(
              c2.getLocal("j"),
              pAux,
              c2.i32_load8_u(c2.getLocal("p"))
            ),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(1))),
            c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.if(
            c2.i32_eq(c2.getLocal("i"), c2.i32_const(n8)),
            c2.call(prefix2 + "_one", R2),
            c2.call(prefix2 + "_mul", R2, c2.i32_const(pR2), R2)
          ),
          c2.call(prefix2 + "_mul", AUX, R2, AUX),
          c2.call(prefix2 + "_add", c2.getLocal("r"), AUX, c2.getLocal("r"))
        );
      }
      function buildTimesScalar2() {
        const f2 = module.addFunction(prefix2 + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.call(prefix2 + "_load", c2.getLocal("scalar"), c2.getLocal("scalarLen"), AUX),
          c2.call(prefix2 + "_toMontgomery", AUX, AUX),
          c2.call(prefix2 + "_mul", c2.getLocal("x"), AUX, c2.getLocal("r"))
        );
      }
      function buildIsOne() {
        const f2 = module.addFunction(prefix2 + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.ret(c2.call(intPrefix + "_eq", c2.getLocal("x"), c2.i32_const(pOne)))
        );
      }
      module.exportFunction(intPrefix + "_copy", prefix2 + "_copy");
      module.exportFunction(intPrefix + "_zero", prefix2 + "_zero");
      module.exportFunction(intPrefix + "_isZero", prefix2 + "_isZero");
      module.exportFunction(intPrefix + "_eq", prefix2 + "_eq");
      buildIsOne();
      buildAdd();
      buildSub();
      buildNeg();
      buildMReduct();
      buildMul();
      buildSquare();
      buildSquareOld();
      buildToMontgomery();
      buildFromMontgomery();
      buildIsNegative();
      buildSign();
      buildInverse();
      buildOne();
      buildLoad();
      buildTimesScalar2();
      buildBatchInverse$2(module, prefix2);
      buildBatchConvertion$1(module, prefix2 + "_batchToMontgomery", prefix2 + "_toMontgomery", n8, n8);
      buildBatchConvertion$1(module, prefix2 + "_batchFromMontgomery", prefix2 + "_fromMontgomery", n8, n8);
      buildBatchConvertion$1(module, prefix2 + "_batchNeg", prefix2 + "_neg", n8, n8);
      buildBatchOp(module, prefix2 + "_batchAdd", prefix2 + "_add", n8, n8);
      buildBatchOp(module, prefix2 + "_batchSub", prefix2 + "_sub", n8, n8);
      buildBatchOp(module, prefix2 + "_batchMul", prefix2 + "_mul", n8, n8);
      module.exportFunction(prefix2 + "_add");
      module.exportFunction(prefix2 + "_sub");
      module.exportFunction(prefix2 + "_neg");
      module.exportFunction(prefix2 + "_isNegative");
      module.exportFunction(prefix2 + "_isOne");
      module.exportFunction(prefix2 + "_sign");
      module.exportFunction(prefix2 + "_mReduct");
      module.exportFunction(prefix2 + "_mul");
      module.exportFunction(prefix2 + "_square");
      module.exportFunction(prefix2 + "_squareOld");
      module.exportFunction(prefix2 + "_fromMontgomery");
      module.exportFunction(prefix2 + "_toMontgomery");
      module.exportFunction(prefix2 + "_inverse");
      module.exportFunction(prefix2 + "_one");
      module.exportFunction(prefix2 + "_load");
      module.exportFunction(prefix2 + "_timesScalar");
      buildExp$2(
        module,
        prefix2 + "_exp",
        n8,
        prefix2 + "_mul",
        prefix2 + "_square",
        intPrefix + "_copy",
        prefix2 + "_one"
      );
      module.exportFunction(prefix2 + "_exp");
      module.exportFunction(prefix2 + "_batchInverse");
      if (isPrime(q2)) {
        buildSqrt2();
        buildIsSquare();
        module.exportFunction(prefix2 + "_sqrt");
        module.exportFunction(prefix2 + "_isSquare");
      }
      module.exportFunction(prefix2 + "_batchToMontgomery");
      module.exportFunction(prefix2 + "_batchFromMontgomery");
      return prefix2;
    };
    buildF1m$2 = build_f1m;
    ({ bitLength: bitLength$3 } = bigint);
    build_f1 = function buildF1(module, _q, _prefix, _f1mPrefix, _intPrefix) {
      const q2 = BigInt(_q);
      const n64 = Math.floor((bitLength$3(q2 - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const prefix2 = _prefix || "f1";
      if (module.modules[prefix2]) return prefix2;
      module.modules[prefix2] = {
        n64
      };
      const intPrefix = _intPrefix || "int";
      const f1mPrefix = buildF1m$2(module, q2, _f1mPrefix, intPrefix);
      const pR2 = module.modules[f1mPrefix].pR2;
      const pq = module.modules[f1mPrefix].pq;
      const pePlusOne = module.modules[f1mPrefix].pePlusOne;
      function buildMul() {
        const pAux1 = module.alloc(n8);
        const f2 = module.addFunction(prefix2 + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(f1mPrefix + "_mul", c2.getLocal("x"), c2.getLocal("y"), c2.i32_const(pAux1)));
        f2.addCode(c2.call(f1mPrefix + "_mul", c2.i32_const(pAux1), c2.i32_const(pR2), c2.getLocal("r")));
      }
      function buildSquare() {
        const f2 = module.addFunction(prefix2 + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(prefix2 + "_mul", c2.getLocal("x"), c2.getLocal("x"), c2.getLocal("r")));
      }
      function buildInverse() {
        const f2 = module.addFunction(prefix2 + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(intPrefix + "_inverseMod", c2.getLocal("x"), c2.i32_const(pq), c2.getLocal("r")));
      }
      function buildIsNegative() {
        const f2 = module.addFunction(prefix2 + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(intPrefix + "_gte", c2.getLocal("x"), c2.i32_const(pePlusOne))
        );
      }
      buildMul();
      buildSquare();
      buildInverse();
      buildIsNegative();
      module.exportFunction(f1mPrefix + "_add", prefix2 + "_add");
      module.exportFunction(f1mPrefix + "_sub", prefix2 + "_sub");
      module.exportFunction(f1mPrefix + "_neg", prefix2 + "_neg");
      module.exportFunction(prefix2 + "_mul");
      module.exportFunction(prefix2 + "_square");
      module.exportFunction(prefix2 + "_inverse");
      module.exportFunction(prefix2 + "_isNegative");
      module.exportFunction(f1mPrefix + "_copy", prefix2 + "_copy");
      module.exportFunction(f1mPrefix + "_zero", prefix2 + "_zero");
      module.exportFunction(f1mPrefix + "_one", prefix2 + "_one");
      module.exportFunction(f1mPrefix + "_isZero", prefix2 + "_isZero");
      module.exportFunction(f1mPrefix + "_eq", prefix2 + "_eq");
      return prefix2;
    };
    buildExp$1 = build_timesscalar;
    buildBatchInverse$1 = build_batchinverse;
    utils$4 = utils$6;
    build_f2m = function buildF2m(module, mulNonResidueFn, prefix2, f1mPrefix) {
      if (module.modules[prefix2]) return prefix2;
      const f1n8 = module.modules[f1mPrefix].n64 * 8;
      const q2 = module.modules[f1mPrefix].q;
      module.modules[prefix2] = {
        n64: module.modules[f1mPrefix].n64 * 2
      };
      function buildAdd() {
        const f2 = module.addFunction(prefix2 + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_add", x0, y0, r0),
          c2.call(f1mPrefix + "_add", x1, y1, r1)
        );
      }
      function buildTimesScalar2() {
        const f2 = module.addFunction(prefix2 + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_timesScalar", x0, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r0),
          c2.call(f1mPrefix + "_timesScalar", x1, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r1)
        );
      }
      function buildSub() {
        const f2 = module.addFunction(prefix2 + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_sub", x0, y0, r0),
          c2.call(f1mPrefix + "_sub", x1, y1, r1)
        );
      }
      function buildNeg() {
        const f2 = module.addFunction(prefix2 + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_neg", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildConjugate() {
        const f2 = module.addFunction(prefix2 + "_conjugate");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1)
        );
      }
      function buildIsNegative() {
        const f2 = module.addFunction(prefix2 + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.if(
            c2.call(f1mPrefix + "_isZero", x1),
            c2.ret(c2.call(f1mPrefix + "_isNegative", x0))
          ),
          c2.ret(c2.call(f1mPrefix + "_isNegative", x1))
        );
      }
      function buildMul() {
        const f2 = module.addFunction(prefix2 + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const A2 = c2.i32_const(module.alloc(f1n8));
        const B2 = c2.i32_const(module.alloc(f1n8));
        const C2 = c2.i32_const(module.alloc(f1n8));
        const D2 = c2.i32_const(module.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_mul", x0, y0, A2),
          // A = x0*y0
          c2.call(f1mPrefix + "_mul", x1, y1, B2),
          // B = x1*y1
          c2.call(f1mPrefix + "_add", x0, x1, C2),
          // C = x0 + x1
          c2.call(f1mPrefix + "_add", y0, y1, D2),
          // D = y0 + y1
          c2.call(f1mPrefix + "_mul", C2, D2, C2),
          // C = (x0 + x1)*(y0 + y1) = x0*y0+x0*y1+x1*y0+x1*y1
          //  c.call(f1mPrefix + "_mul", B, c.i32_const(pNonResidue), r0),  // r0 = nr*(x1*y1)
          c2.call(mulNonResidueFn, B2, r0),
          // r0 = nr*(x1*y1)
          c2.call(f1mPrefix + "_add", A2, r0, r0),
          // r0 = x0*y0 + nr*(x1*y1)
          c2.call(f1mPrefix + "_add", A2, B2, r1),
          // r1 = x0*y0+x1*y1
          c2.call(f1mPrefix + "_sub", C2, r1, r1)
          // r1 = x0*y0+x0*y1+x1*y0+x1*y1 - x0*y0+x1*y1 = x0*y1+x1*y0
        );
      }
      function buildMul1() {
        const f2 = module.addFunction(prefix2 + "_mul1");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y2 = c2.getLocal("y");
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_mul", x0, y2, r0),
          // A = x0*y
          c2.call(f1mPrefix + "_mul", x1, y2, r1)
          // B = x1*y
        );
      }
      function buildSquare() {
        const f2 = module.addFunction(prefix2 + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const AB = c2.i32_const(module.alloc(f1n8));
        const APB = c2.i32_const(module.alloc(f1n8));
        const APNB = c2.i32_const(module.alloc(f1n8));
        const ABPNAB = c2.i32_const(module.alloc(f1n8));
        f2.addCode(
          // AB = x0*y1
          c2.call(f1mPrefix + "_mul", x0, x1, AB),
          // APB = x0+y1
          c2.call(f1mPrefix + "_add", x0, x1, APB),
          // APBN0 = x0 + nr*x1
          c2.call(mulNonResidueFn, x1, APNB),
          c2.call(f1mPrefix + "_add", x0, APNB, APNB),
          // ABPNAB = ab + nr*ab
          c2.call(mulNonResidueFn, AB, ABPNAB),
          c2.call(f1mPrefix + "_add", ABPNAB, AB, ABPNAB),
          // r0 = APB * APNB - ABPNAB
          c2.call(f1mPrefix + "_mul", APB, APNB, r0),
          c2.call(f1mPrefix + "_sub", r0, ABPNAB, r0),
          // r1 = AB + AB
          c2.call(f1mPrefix + "_add", AB, AB, r1)
        );
      }
      function buildToMontgomery() {
        const f2 = module.addFunction(prefix2 + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_toMontgomery", x0, r0),
          c2.call(f1mPrefix + "_toMontgomery", x1, r1)
        );
      }
      function buildFromMontgomery() {
        const f2 = module.addFunction(prefix2 + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c2.call(f1mPrefix + "_fromMontgomery", x1, r1)
        );
      }
      function buildCopy() {
        const f2 = module.addFunction(prefix2 + "_copy");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_copy", x1, r1)
        );
      }
      function buildZero() {
        const f2 = module.addFunction(prefix2 + "_zero");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_zero", x0),
          c2.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildOne() {
        const f2 = module.addFunction(prefix2 + "_one");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_one", x0),
          c2.call(f1mPrefix + "_zero", x1)
        );
      }
      function buildEq() {
        const f2 = module.addFunction(prefix2 + "_eq");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        f2.addCode(
          c2.i32_and(
            c2.call(f1mPrefix + "_eq", x0, y0),
            c2.call(f1mPrefix + "_eq", x1, y1)
          )
        );
      }
      function buildIsZero() {
        const f2 = module.addFunction(prefix2 + "_isZero");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.i32_and(
            c2.call(f1mPrefix + "_isZero", x0),
            c2.call(f1mPrefix + "_isZero", x1)
          )
        );
      }
      function buildInverse() {
        const f2 = module.addFunction(prefix2 + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const t0 = c2.i32_const(module.alloc(f1n8));
        const t1 = c2.i32_const(module.alloc(f1n8));
        const t2 = c2.i32_const(module.alloc(f1n8));
        const t3 = c2.i32_const(module.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", x0, t0),
          c2.call(f1mPrefix + "_square", x1, t1),
          // c.call(f1mPrefix+"_mul", t1, c.i32_const(pNonResidue), t2),
          c2.call(mulNonResidueFn, t1, t2),
          c2.call(f1mPrefix + "_sub", t0, t2, t2),
          c2.call(f1mPrefix + "_inverse", t2, t3),
          c2.call(f1mPrefix + "_mul", x0, t3, r0),
          c2.call(f1mPrefix + "_mul", x1, t3, r1),
          c2.call(f1mPrefix + "_neg", r1, r1)
        );
      }
      function buildSign() {
        const f2 = module.addFunction(prefix2 + "_sign");
        f2.addParam("x", "i32");
        f2.addLocal("s", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x1)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.ret(c2.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f2 = module.addFunction(prefix2 + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        f2.addCode(
          c2.ret(c2.i32_and(
            c2.call(f1mPrefix + "_isOne", x0),
            c2.call(f1mPrefix + "_isZero", x1)
          ))
        );
      }
      function buildSqrt2() {
        const f2 = module.addFunction(prefix2 + "_sqrt");
        f2.addParam("a", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const e34 = c2.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q2 || 0) - 3n) / 4n, f1n8)));
        const e12 = c2.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q2 || 0) - 1n) / 2n, f1n8)));
        const a2 = c2.getLocal("a");
        const a1 = c2.i32_const(module.alloc(f1n8 * 2));
        const alpha = c2.i32_const(module.alloc(f1n8 * 2));
        const a0 = c2.i32_const(module.alloc(f1n8 * 2));
        const pn1 = module.alloc(f1n8 * 2);
        const n1 = c2.i32_const(pn1);
        const n1a = c2.i32_const(pn1);
        const n1b = c2.i32_const(pn1 + f1n8);
        const x0 = c2.i32_const(module.alloc(f1n8 * 2));
        const b2 = c2.i32_const(module.alloc(f1n8 * 2));
        f2.addCode(
          c2.call(prefix2 + "_one", n1),
          c2.call(prefix2 + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix2 + "_exp", a2, e34, c2.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix2 + "_square", a1, alpha),
          c2.call(prefix2 + "_mul", a2, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c2.call(prefix2 + "_conjugate", alpha, a0),
          c2.call(prefix2 + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c2.if(c2.call(prefix2 + "_eq", a0, n1), c2.unreachable()),
          // const x0 = F.mul(a1, a);
          c2.call(prefix2 + "_mul", a1, a2, x0),
          // if (F.eq(alfa, F.negone)) {
          c2.if(
            c2.call(prefix2 + "_eq", alpha, n1),
            [
              // x = F.mul(x0, [F.F.zero, F.F.one]);
              ...c2.call(f1mPrefix + "_zero", n1a),
              ...c2.call(f1mPrefix + "_one", n1b),
              ...c2.call(prefix2 + "_mul", n1, x0, c2.getLocal("pr"))
            ],
            [
              // const b = F.pow(F.add(F.one, alfa), F.sqrt_e12);
              ...c2.call(prefix2 + "_one", b2),
              ...c2.call(prefix2 + "_add", b2, alpha, b2),
              ...c2.call(prefix2 + "_exp", b2, e12, c2.i32_const(f1n8), b2),
              // x = F.mul(b, x0);
              ...c2.call(prefix2 + "_mul", b2, x0, c2.getLocal("pr"))
            ]
          )
        );
      }
      function buildIsSquare() {
        const f2 = module.addFunction(prefix2 + "_isSquare");
        f2.addParam("a", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const e34 = c2.i32_const(module.alloc(utils$4.bigInt2BytesLE((BigInt(q2 || 0) - 3n) / 4n, f1n8)));
        const a2 = c2.getLocal("a");
        const a1 = c2.i32_const(module.alloc(f1n8 * 2));
        const alpha = c2.i32_const(module.alloc(f1n8 * 2));
        const a0 = c2.i32_const(module.alloc(f1n8 * 2));
        const pn1 = module.alloc(f1n8 * 2);
        const n1 = c2.i32_const(pn1);
        f2.addCode(
          c2.call(prefix2 + "_one", n1),
          c2.call(prefix2 + "_neg", n1, n1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix2 + "_exp", a2, e34, c2.i32_const(f1n8), a1),
          // const a1 = F.pow(a, F.sqrt_e34);
          c2.call(prefix2 + "_square", a1, alpha),
          c2.call(prefix2 + "_mul", a2, alpha, alpha),
          // const a0 = F.mul(F.frobenius(1, alfa), alfa);
          c2.call(prefix2 + "_conjugate", alpha, a0),
          c2.call(prefix2 + "_mul", a0, alpha, a0),
          // if (F.eq(a0, F.negone)) return null;
          c2.if(
            c2.call(
              prefix2 + "_eq",
              a0,
              n1
            ),
            c2.ret(c2.i32_const(0))
          ),
          c2.ret(c2.i32_const(1))
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildMul1();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildConjugate();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar2();
      buildSign();
      buildIsNegative();
      module.exportFunction(prefix2 + "_isZero");
      module.exportFunction(prefix2 + "_isOne");
      module.exportFunction(prefix2 + "_zero");
      module.exportFunction(prefix2 + "_one");
      module.exportFunction(prefix2 + "_copy");
      module.exportFunction(prefix2 + "_mul");
      module.exportFunction(prefix2 + "_mul1");
      module.exportFunction(prefix2 + "_square");
      module.exportFunction(prefix2 + "_add");
      module.exportFunction(prefix2 + "_sub");
      module.exportFunction(prefix2 + "_neg");
      module.exportFunction(prefix2 + "_sign");
      module.exportFunction(prefix2 + "_conjugate");
      module.exportFunction(prefix2 + "_fromMontgomery");
      module.exportFunction(prefix2 + "_toMontgomery");
      module.exportFunction(prefix2 + "_eq");
      module.exportFunction(prefix2 + "_inverse");
      buildBatchInverse$1(module, prefix2);
      buildExp$1(
        module,
        prefix2 + "_exp",
        f1n8 * 2,
        prefix2 + "_mul",
        prefix2 + "_square",
        prefix2 + "_copy",
        prefix2 + "_one"
      );
      buildSqrt2();
      buildIsSquare();
      module.exportFunction(prefix2 + "_exp");
      module.exportFunction(prefix2 + "_timesScalar");
      module.exportFunction(prefix2 + "_batchInverse");
      module.exportFunction(prefix2 + "_sqrt");
      module.exportFunction(prefix2 + "_isSquare");
      module.exportFunction(prefix2 + "_isNegative");
      return prefix2;
    };
    buildExp = build_timesscalar;
    buildBatchInverse = build_batchinverse;
    build_f3m = function buildF3m(module, mulNonResidueFn, prefix2, f1mPrefix) {
      if (module.modules[prefix2]) return prefix2;
      const f1n8 = module.modules[f1mPrefix].n64 * 8;
      module.modules[prefix2] = {
        n64: module.modules[f1mPrefix].n64 * 3
      };
      function buildAdd() {
        const f2 = module.addFunction(prefix2 + "_add");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_add", x0, y0, r0),
          c2.call(f1mPrefix + "_add", x1, y1, r1),
          c2.call(f1mPrefix + "_add", x2, y2, r2)
        );
      }
      function buildTimesScalar2() {
        const f2 = module.addFunction(prefix2 + "_timesScalar");
        f2.addParam("x", "i32");
        f2.addParam("scalar", "i32");
        f2.addParam("scalarLen", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_timesScalar", x0, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r0),
          c2.call(f1mPrefix + "_timesScalar", x1, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r1),
          c2.call(f1mPrefix + "_timesScalar", x2, c2.getLocal("scalar"), c2.getLocal("scalarLen"), r2)
        );
      }
      function buildSub() {
        const f2 = module.addFunction(prefix2 + "_sub");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_sub", x0, y0, r0),
          c2.call(f1mPrefix + "_sub", x1, y1, r1),
          c2.call(f1mPrefix + "_sub", x2, y2, r2)
        );
      }
      function buildNeg() {
        const f2 = module.addFunction(prefix2 + "_neg");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_neg", x0, r0),
          c2.call(f1mPrefix + "_neg", x1, r1),
          c2.call(f1mPrefix + "_neg", x2, r2)
        );
      }
      function buildIsNegative() {
        const f2 = module.addFunction(prefix2 + "_isNegative");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.if(
            c2.call(f1mPrefix + "_isZero", x2),
            c2.if(
              c2.call(f1mPrefix + "_isZero", x1),
              c2.ret(c2.call(f1mPrefix + "_isNegative", x0)),
              c2.ret(c2.call(f1mPrefix + "_isNegative", x1))
            )
          ),
          c2.ret(c2.call(f1mPrefix + "_isNegative", x2))
        );
      }
      function buildMul() {
        const f2 = module.addFunction(prefix2 + "_mul");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.addParam("r", "i32");
        const cd = f2.getCodeBuilder();
        const a2 = cd.getLocal("x");
        const b2 = cd.i32_add(cd.getLocal("x"), cd.i32_const(f1n8));
        const c2 = cd.i32_add(cd.getLocal("x"), cd.i32_const(2 * f1n8));
        const A2 = cd.getLocal("y");
        const B2 = cd.i32_add(cd.getLocal("y"), cd.i32_const(f1n8));
        const C2 = cd.i32_add(cd.getLocal("y"), cd.i32_const(2 * f1n8));
        const r0 = cd.getLocal("r");
        const r1 = cd.i32_add(cd.getLocal("r"), cd.i32_const(f1n8));
        const r2 = cd.i32_add(cd.getLocal("r"), cd.i32_const(2 * f1n8));
        const aA = cd.i32_const(module.alloc(f1n8));
        const bB = cd.i32_const(module.alloc(f1n8));
        const cC = cd.i32_const(module.alloc(f1n8));
        const a_b = cd.i32_const(module.alloc(f1n8));
        const A_B = cd.i32_const(module.alloc(f1n8));
        const a_c = cd.i32_const(module.alloc(f1n8));
        const A_C = cd.i32_const(module.alloc(f1n8));
        const b_c = cd.i32_const(module.alloc(f1n8));
        const B_C = cd.i32_const(module.alloc(f1n8));
        const aA_bB = cd.i32_const(module.alloc(f1n8));
        const aA_cC = cd.i32_const(module.alloc(f1n8));
        const bB_cC = cd.i32_const(module.alloc(f1n8));
        const AUX = cd.i32_const(module.alloc(f1n8));
        f2.addCode(
          cd.call(f1mPrefix + "_mul", a2, A2, aA),
          cd.call(f1mPrefix + "_mul", b2, B2, bB),
          cd.call(f1mPrefix + "_mul", c2, C2, cC),
          cd.call(f1mPrefix + "_add", a2, b2, a_b),
          cd.call(f1mPrefix + "_add", A2, B2, A_B),
          cd.call(f1mPrefix + "_add", a2, c2, a_c),
          cd.call(f1mPrefix + "_add", A2, C2, A_C),
          cd.call(f1mPrefix + "_add", b2, c2, b_c),
          cd.call(f1mPrefix + "_add", B2, C2, B_C),
          cd.call(f1mPrefix + "_add", aA, bB, aA_bB),
          cd.call(f1mPrefix + "_add", aA, cC, aA_cC),
          cd.call(f1mPrefix + "_add", bB, cC, bB_cC),
          cd.call(f1mPrefix + "_mul", b_c, B_C, r0),
          cd.call(f1mPrefix + "_sub", r0, bB_cC, r0),
          cd.call(mulNonResidueFn, r0, r0),
          cd.call(f1mPrefix + "_add", aA, r0, r0),
          cd.call(f1mPrefix + "_mul", a_b, A_B, r1),
          cd.call(f1mPrefix + "_sub", r1, aA_bB, r1),
          cd.call(mulNonResidueFn, cC, AUX),
          cd.call(f1mPrefix + "_add", r1, AUX, r1),
          cd.call(f1mPrefix + "_mul", a_c, A_C, r2),
          cd.call(f1mPrefix + "_sub", r2, aA_cC, r2),
          cd.call(f1mPrefix + "_add", r2, bB, r2)
        );
      }
      function buildSquare() {
        const f2 = module.addFunction(prefix2 + "_square");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const A2 = c2.getLocal("x");
        const B2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const C2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        const s0 = c2.i32_const(module.alloc(f1n8));
        const ab = c2.i32_const(module.alloc(f1n8));
        const s1 = c2.i32_const(module.alloc(f1n8));
        const s2 = c2.i32_const(module.alloc(f1n8));
        const bc = c2.i32_const(module.alloc(f1n8));
        const s3 = c2.i32_const(module.alloc(f1n8));
        const s4 = c2.i32_const(module.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", A2, s0),
          c2.call(f1mPrefix + "_mul", A2, B2, ab),
          c2.call(f1mPrefix + "_add", ab, ab, s1),
          c2.call(f1mPrefix + "_sub", A2, B2, s2),
          c2.call(f1mPrefix + "_add", s2, C2, s2),
          c2.call(f1mPrefix + "_square", s2, s2),
          c2.call(f1mPrefix + "_mul", B2, C2, bc),
          c2.call(f1mPrefix + "_add", bc, bc, s3),
          c2.call(f1mPrefix + "_square", C2, s4),
          c2.call(mulNonResidueFn, s3, r0),
          c2.call(f1mPrefix + "_add", s0, r0, r0),
          c2.call(mulNonResidueFn, s4, r1),
          c2.call(f1mPrefix + "_add", s1, r1, r1),
          c2.call(f1mPrefix + "_add", s0, s4, r2),
          c2.call(f1mPrefix + "_sub", s3, r2, r2),
          c2.call(f1mPrefix + "_add", s2, r2, r2),
          c2.call(f1mPrefix + "_add", s1, r2, r2)
        );
      }
      function buildToMontgomery() {
        const f2 = module.addFunction(prefix2 + "_toMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_toMontgomery", x0, r0),
          c2.call(f1mPrefix + "_toMontgomery", x1, r1),
          c2.call(f1mPrefix + "_toMontgomery", x2, r2)
        );
      }
      function buildFromMontgomery() {
        const f2 = module.addFunction(prefix2 + "_fromMontgomery");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_fromMontgomery", x0, r0),
          c2.call(f1mPrefix + "_fromMontgomery", x1, r1),
          c2.call(f1mPrefix + "_fromMontgomery", x2, r2)
        );
      }
      function buildCopy() {
        const f2 = module.addFunction(prefix2 + "_copy");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, r0),
          c2.call(f1mPrefix + "_copy", x1, r1),
          c2.call(f1mPrefix + "_copy", x2, r2)
        );
      }
      function buildZero() {
        const f2 = module.addFunction(prefix2 + "_zero");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_zero", x0),
          c2.call(f1mPrefix + "_zero", x1),
          c2.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildOne() {
        const f2 = module.addFunction(prefix2 + "_one");
        f2.addParam("x", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_one", x0),
          c2.call(f1mPrefix + "_zero", x1),
          c2.call(f1mPrefix + "_zero", x2)
        );
      }
      function buildEq() {
        const f2 = module.addFunction(prefix2 + "_eq");
        f2.addParam("x", "i32");
        f2.addParam("y", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const y0 = c2.getLocal("y");
        const y1 = c2.i32_add(c2.getLocal("y"), c2.i32_const(f1n8));
        const y2 = c2.i32_add(c2.getLocal("y"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.i32_and(
            c2.i32_and(
              c2.call(f1mPrefix + "_eq", x0, y0),
              c2.call(f1mPrefix + "_eq", x1, y1)
            ),
            c2.call(f1mPrefix + "_eq", x2, y2)
          )
        );
      }
      function buildIsZero() {
        const f2 = module.addFunction(prefix2 + "_isZero");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.i32_and(
            c2.i32_and(
              c2.call(f1mPrefix + "_isZero", x0),
              c2.call(f1mPrefix + "_isZero", x1)
            ),
            c2.call(f1mPrefix + "_isZero", x2)
          )
        );
      }
      function buildInverse() {
        const f2 = module.addFunction(prefix2 + "_inverse");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        const r0 = c2.getLocal("r");
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f1n8));
        const r2 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f1n8));
        const t0 = c2.i32_const(module.alloc(f1n8));
        const t1 = c2.i32_const(module.alloc(f1n8));
        const t2 = c2.i32_const(module.alloc(f1n8));
        const t3 = c2.i32_const(module.alloc(f1n8));
        const t4 = c2.i32_const(module.alloc(f1n8));
        const t5 = c2.i32_const(module.alloc(f1n8));
        const c0 = c2.i32_const(module.alloc(f1n8));
        const c1 = c2.i32_const(module.alloc(f1n8));
        const c22 = c2.i32_const(module.alloc(f1n8));
        const t6 = c2.i32_const(module.alloc(f1n8));
        const AUX = c2.i32_const(module.alloc(f1n8));
        f2.addCode(
          c2.call(f1mPrefix + "_square", x0, t0),
          c2.call(f1mPrefix + "_square", x1, t1),
          c2.call(f1mPrefix + "_square", x2, t2),
          c2.call(f1mPrefix + "_mul", x0, x1, t3),
          c2.call(f1mPrefix + "_mul", x0, x2, t4),
          c2.call(f1mPrefix + "_mul", x1, x2, t5),
          c2.call(mulNonResidueFn, t5, c0),
          c2.call(f1mPrefix + "_sub", t0, c0, c0),
          c2.call(mulNonResidueFn, t2, c1),
          c2.call(f1mPrefix + "_sub", c1, t3, c1),
          c2.call(f1mPrefix + "_sub", t1, t4, c22),
          c2.call(f1mPrefix + "_mul", x2, c1, t6),
          c2.call(f1mPrefix + "_mul", x1, c22, AUX),
          c2.call(f1mPrefix + "_add", t6, AUX, t6),
          c2.call(mulNonResidueFn, t6, t6),
          c2.call(f1mPrefix + "_mul", x0, c0, AUX),
          c2.call(f1mPrefix + "_add", AUX, t6, t6),
          c2.call(f1mPrefix + "_inverse", t6, t6),
          c2.call(f1mPrefix + "_mul", t6, c0, r0),
          c2.call(f1mPrefix + "_mul", t6, c1, r1),
          c2.call(f1mPrefix + "_mul", t6, c22, r2)
        );
      }
      function buildSign() {
        const f2 = module.addFunction(prefix2 + "_sign");
        f2.addParam("x", "i32");
        f2.addLocal("s", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f1n8));
        f2.addCode(
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x2)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.setLocal("s", c2.call(f1mPrefix + "_sign", x1)),
          c2.if(
            c2.getLocal("s"),
            c2.ret(c2.getLocal("s"))
          ),
          c2.ret(c2.call(f1mPrefix + "_sign", x0))
        );
      }
      function buildIsOne() {
        const f2 = module.addFunction(prefix2 + "_isOne");
        f2.addParam("x", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1n8 * 2));
        f2.addCode(
          c2.ret(
            c2.i32_and(
              c2.i32_and(
                c2.call(f1mPrefix + "_isOne", x0),
                c2.call(f1mPrefix + "_isZero", x1)
              ),
              c2.call(f1mPrefix + "_isZero", x2)
            )
          )
        );
      }
      buildIsZero();
      buildIsOne();
      buildZero();
      buildOne();
      buildCopy();
      buildMul();
      buildSquare();
      buildAdd();
      buildSub();
      buildNeg();
      buildSign();
      buildToMontgomery();
      buildFromMontgomery();
      buildEq();
      buildInverse();
      buildTimesScalar2();
      buildIsNegative();
      module.exportFunction(prefix2 + "_isZero");
      module.exportFunction(prefix2 + "_isOne");
      module.exportFunction(prefix2 + "_zero");
      module.exportFunction(prefix2 + "_one");
      module.exportFunction(prefix2 + "_copy");
      module.exportFunction(prefix2 + "_mul");
      module.exportFunction(prefix2 + "_square");
      module.exportFunction(prefix2 + "_add");
      module.exportFunction(prefix2 + "_sub");
      module.exportFunction(prefix2 + "_neg");
      module.exportFunction(prefix2 + "_sign");
      module.exportFunction(prefix2 + "_fromMontgomery");
      module.exportFunction(prefix2 + "_toMontgomery");
      module.exportFunction(prefix2 + "_eq");
      module.exportFunction(prefix2 + "_inverse");
      buildBatchInverse(module, prefix2);
      buildExp(
        module,
        prefix2 + "_exp",
        f1n8 * 3,
        prefix2 + "_mul",
        prefix2 + "_square",
        prefix2 + "_copy",
        prefix2 + "_one"
      );
      module.exportFunction(prefix2 + "_exp");
      module.exportFunction(prefix2 + "_timesScalar");
      module.exportFunction(prefix2 + "_batchInverse");
      module.exportFunction(prefix2 + "_isNegative");
      return prefix2;
    };
    build_timesscalarnaf = function buildTimesScalarNAF(module, fnName, elementLen, opAB, opAA, opAmB, opCopy, opInit) {
      const f2 = module.addFunction(fnName);
      f2.addParam("base", "i32");
      f2.addParam("scalar", "i32");
      f2.addParam("scalarLength", "i32");
      f2.addParam("r", "i32");
      f2.addLocal("old0", "i32");
      f2.addLocal("nbits", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("last", "i32");
      f2.addLocal("cur", "i32");
      f2.addLocal("carry", "i32");
      f2.addLocal("p", "i32");
      const c2 = f2.getCodeBuilder();
      const aux = c2.i32_const(module.alloc(elementLen));
      function getBit(IDX) {
        return c2.i32_and(
          c2.i32_shr_u(
            c2.i32_load(
              c2.i32_add(
                c2.getLocal("scalar"),
                c2.i32_and(
                  c2.i32_shr_u(
                    IDX,
                    c2.i32_const(3)
                  ),
                  c2.i32_const(4294967292)
                )
              )
            ),
            c2.i32_and(
              IDX,
              c2.i32_const(31)
            )
          ),
          c2.i32_const(1)
        );
      }
      function pushBit(b2) {
        return [
          ...c2.i32_store8(
            c2.getLocal("p"),
            c2.i32_const(b2)
          ),
          ...c2.setLocal(
            "p",
            c2.i32_add(
              c2.getLocal("p"),
              c2.i32_const(1)
            )
          )
        ];
      }
      f2.addCode(
        c2.if(
          c2.i32_eqz(c2.getLocal("scalarLength")),
          [
            ...c2.call(opInit, c2.getLocal("r")),
            ...c2.ret([])
          ]
        ),
        c2.setLocal("nbits", c2.i32_shl(c2.getLocal("scalarLength"), c2.i32_const(3))),
        c2.setLocal("old0", c2.i32_load(c2.i32_const(0))),
        c2.setLocal("p", c2.getLocal("old0")),
        c2.i32_store(
          c2.i32_const(0),
          c2.i32_and(
            c2.i32_add(
              c2.i32_add(
                c2.getLocal("old0"),
                c2.i32_const(32)
              ),
              c2.getLocal("nbits")
            ),
            c2.i32_const(4294967288)
          )
        ),
        c2.setLocal("i", c2.i32_const(1)),
        c2.setLocal("last", getBit(c2.i32_const(0))),
        c2.setLocal("carry", c2.i32_const(0)),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("nbits"))),
          c2.setLocal("cur", getBit(c2.getLocal("i"))),
          c2.if(
            c2.getLocal("last"),
            c2.if(
              c2.getLocal("cur"),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(1)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(255)
                ]
              ),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(255)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(1)
                ]
              )
            ),
            c2.if(
              c2.getLocal("cur"),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(1)),
                  ...pushBit(0)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(1)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ]
              ),
              c2.if(
                c2.getLocal("carry"),
                [
                  ...c2.setLocal("last", c2.i32_const(1)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ],
                [
                  ...c2.setLocal("last", c2.i32_const(0)),
                  ...c2.setLocal("carry", c2.i32_const(0)),
                  ...pushBit(0)
                ]
              )
            )
          ),
          c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        )),
        c2.if(
          c2.getLocal("last"),
          c2.if(
            c2.getLocal("carry"),
            [
              ...pushBit(255),
              ...pushBit(0),
              ...pushBit(1)
            ],
            [
              ...pushBit(1)
            ]
          ),
          c2.if(
            c2.getLocal("carry"),
            [
              ...pushBit(0),
              ...pushBit(1)
            ]
          )
        ),
        c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
        // p already points to the last bit
        c2.call(opCopy, c2.getLocal("base"), aux),
        c2.call(opInit, c2.getLocal("r")),
        c2.block(c2.loop(
          c2.call(opAA, c2.getLocal("r"), c2.getLocal("r")),
          c2.setLocal(
            "cur",
            c2.i32_load8_u(
              c2.getLocal("p")
            )
          ),
          c2.if(
            c2.getLocal("cur"),
            c2.if(
              c2.i32_eq(c2.getLocal("cur"), c2.i32_const(1)),
              c2.call(opAB, c2.getLocal("r"), aux, c2.getLocal("r")),
              c2.call(opAmB, c2.getLocal("r"), aux, c2.getLocal("r"))
            )
          ),
          c2.br_if(1, c2.i32_eq(c2.getLocal("old0"), c2.getLocal("p"))),
          c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
          c2.br(0)
        )),
        c2.i32_store(c2.i32_const(0), c2.getLocal("old0"))
      );
    };
    build_multiexp = function buildMultiexp(module, prefix2, fnName, opAdd, n8b) {
      const n64g = module.modules[prefix2].n64;
      const n8g = n64g * 8;
      function buildGetChunk() {
        const f2 = module.addFunction(fnName + "_getChunk");
        f2.addParam("pScalar", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("startBit", "i32");
        f2.addParam("chunkSize", "i32");
        f2.addLocal("bitsToEnd", "i32");
        f2.addLocal("mask", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "bitsToEnd",
            c2.i32_sub(
              c2.i32_mul(
                c2.getLocal("scalarSize"),
                c2.i32_const(8)
              ),
              c2.getLocal("startBit")
            )
          ),
          c2.if(
            c2.i32_gt_s(
              c2.getLocal("chunkSize"),
              c2.getLocal("bitsToEnd")
            ),
            c2.setLocal(
              "mask",
              c2.i32_sub(
                c2.i32_shl(
                  c2.i32_const(1),
                  c2.getLocal("bitsToEnd")
                ),
                c2.i32_const(1)
              )
            ),
            c2.setLocal(
              "mask",
              c2.i32_sub(
                c2.i32_shl(
                  c2.i32_const(1),
                  c2.getLocal("chunkSize")
                ),
                c2.i32_const(1)
              )
            )
          ),
          c2.i32_and(
            c2.i32_shr_u(
              c2.i32_load(
                c2.i32_add(
                  c2.getLocal("pScalar"),
                  c2.i32_shr_u(
                    c2.getLocal("startBit"),
                    c2.i32_const(3)
                  )
                ),
                0,
                // offset
                0
                // align to byte.
              ),
              c2.i32_and(
                c2.getLocal("startBit"),
                c2.i32_const(7)
              )
            ),
            c2.getLocal("mask")
          )
        );
      }
      function buildMutiexpChunk() {
        const f2 = module.addFunction(fnName + "_chunk");
        f2.addParam("pBases", "i32");
        f2.addParam("pScalars", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("n", "i32");
        f2.addParam("startBit", "i32");
        f2.addParam("chunkSize", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("nChunks", "i32");
        f2.addLocal("itScalar", "i32");
        f2.addLocal("endScalar", "i32");
        f2.addLocal("itBase", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("nTable", "i32");
        f2.addLocal("pTable", "i32");
        f2.addLocal("idx", "i32");
        f2.addLocal("pIdxTable", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.i32_eqz(c2.getLocal("n")),
            [
              ...c2.call(prefix2 + "_zero", c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          // Allocate memory
          c2.setLocal(
            "nTable",
            c2.i32_shl(
              c2.i32_const(1),
              c2.getLocal("chunkSize")
            )
          ),
          c2.setLocal("pTable", c2.i32_load(c2.i32_const(0))),
          c2.i32_store(
            c2.i32_const(0),
            c2.i32_add(
              c2.getLocal("pTable"),
              c2.i32_mul(
                c2.getLocal("nTable"),
                c2.i32_const(n8g)
              )
            )
          ),
          // Reset Table
          c2.setLocal("j", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("j"),
                c2.getLocal("nTable")
              )
            ),
            c2.call(
              prefix2 + "_zero",
              c2.i32_add(
                c2.getLocal("pTable"),
                c2.i32_mul(
                  c2.getLocal("j"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
            c2.br(0)
          )),
          // Distribute elements
          c2.setLocal("itBase", c2.getLocal("pBases")),
          c2.setLocal("itScalar", c2.getLocal("pScalars")),
          c2.setLocal(
            "endScalar",
            c2.i32_add(
              c2.getLocal("pScalars"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.getLocal("scalarSize")
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("itScalar"),
                c2.getLocal("endScalar")
              )
            ),
            c2.setLocal(
              "idx",
              c2.call(
                fnName + "_getChunk",
                c2.getLocal("itScalar"),
                c2.getLocal("scalarSize"),
                c2.getLocal("startBit"),
                c2.getLocal("chunkSize")
              )
            ),
            c2.if(
              c2.getLocal("idx"),
              [
                ...c2.setLocal(
                  "pIdxTable",
                  c2.i32_add(
                    c2.getLocal("pTable"),
                    c2.i32_mul(
                      c2.i32_sub(
                        c2.getLocal("idx"),
                        c2.i32_const(1)
                      ),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                ...c2.call(
                  opAdd,
                  c2.getLocal("pIdxTable"),
                  c2.getLocal("itBase"),
                  c2.getLocal("pIdxTable")
                )
              ]
            ),
            c2.setLocal("itScalar", c2.i32_add(c2.getLocal("itScalar"), c2.getLocal("scalarSize"))),
            c2.setLocal("itBase", c2.i32_add(c2.getLocal("itBase"), c2.i32_const(n8b))),
            c2.br(0)
          )),
          c2.call(fnName + "_reduceTable", c2.getLocal("pTable"), c2.getLocal("chunkSize")),
          c2.call(
            prefix2 + "_copy",
            c2.getLocal("pTable"),
            c2.getLocal("pr")
          ),
          c2.i32_store(
            c2.i32_const(0),
            c2.getLocal("pTable")
          )
        );
      }
      function buildMultiexp3() {
        const f2 = module.addFunction(fnName);
        f2.addParam("pBases", "i32");
        f2.addParam("pScalars", "i32");
        f2.addParam("scalarSize", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("chunkSize", "i32");
        f2.addLocal("nChunks", "i32");
        f2.addLocal("itScalar", "i32");
        f2.addLocal("endScalar", "i32");
        f2.addLocal("itBase", "i32");
        f2.addLocal("itBit", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("nTable", "i32");
        f2.addLocal("pTable", "i32");
        f2.addLocal("idx", "i32");
        f2.addLocal("pIdxTable", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module.alloc(n8g));
        const pTSizes2 = module.alloc([
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          17,
          16,
          16,
          15,
          14,
          13,
          13,
          12,
          11,
          10,
          9,
          8,
          7,
          7,
          6,
          5,
          4,
          3,
          2,
          1,
          1,
          1,
          1
        ]);
        f2.addCode(
          c2.call(prefix2 + "_zero", c2.getLocal("pr")),
          c2.if(
            c2.i32_eqz(c2.getLocal("n")),
            c2.ret([])
          ),
          c2.setLocal("chunkSize", c2.i32_load8_u(c2.i32_clz(c2.getLocal("n")), pTSizes2)),
          c2.setLocal(
            "nChunks",
            c2.i32_add(
              c2.i32_div_u(
                c2.i32_sub(
                  c2.i32_shl(
                    c2.getLocal("scalarSize"),
                    c2.i32_const(3)
                  ),
                  c2.i32_const(1)
                ),
                c2.getLocal("chunkSize")
              ),
              c2.i32_const(1)
            )
          ),
          // Allocate memory
          c2.setLocal(
            "itBit",
            c2.i32_mul(
              c2.i32_sub(
                c2.getLocal("nChunks"),
                c2.i32_const(1)
              ),
              c2.getLocal("chunkSize")
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_lt_s(
                c2.getLocal("itBit"),
                c2.i32_const(0)
              )
            ),
            // Double nChunk times
            c2.if(
              c2.i32_eqz(c2.call(prefix2 + "_isZero", c2.getLocal("pr"))),
              [
                ...c2.setLocal("j", c2.i32_const(0)),
                ...c2.block(c2.loop(
                  c2.br_if(
                    1,
                    c2.i32_eq(
                      c2.getLocal("j"),
                      c2.getLocal("chunkSize")
                    )
                  ),
                  c2.call(prefix2 + "_double", c2.getLocal("pr"), c2.getLocal("pr")),
                  c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
                  c2.br(0)
                ))
              ]
            ),
            c2.call(
              fnName + "_chunk",
              c2.getLocal("pBases"),
              c2.getLocal("pScalars"),
              c2.getLocal("scalarSize"),
              c2.getLocal("n"),
              c2.getLocal("itBit"),
              c2.getLocal("chunkSize"),
              aux
            ),
            c2.call(
              prefix2 + "_add",
              c2.getLocal("pr"),
              aux,
              c2.getLocal("pr")
            ),
            c2.setLocal("itBit", c2.i32_sub(c2.getLocal("itBit"), c2.getLocal("chunkSize"))),
            c2.br(0)
          ))
        );
      }
      function buildReduceTable() {
        const f2 = module.addFunction(fnName + "_reduceTable");
        f2.addParam("pTable", "i32");
        f2.addParam("p", "i32");
        f2.addLocal("half", "i32");
        f2.addLocal("it1", "i32");
        f2.addLocal("it2", "i32");
        f2.addLocal("pAcc", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.if(
            c2.i32_eq(c2.getLocal("p"), c2.i32_const(1)),
            c2.ret([])
          ),
          c2.setLocal(
            "half",
            c2.i32_shl(
              c2.i32_const(1),
              c2.i32_sub(
                c2.getLocal("p"),
                c2.i32_const(1)
              )
            )
          ),
          c2.setLocal("it1", c2.getLocal("pTable")),
          c2.setLocal(
            "it2",
            c2.i32_add(
              c2.getLocal("pTable"),
              c2.i32_mul(
                c2.getLocal("half"),
                c2.i32_const(n8g)
              )
            )
          ),
          c2.setLocal(
            "pAcc",
            c2.i32_sub(
              c2.getLocal("it2"),
              c2.i32_const(n8g)
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("it1"),
                c2.getLocal("pAcc")
              )
            ),
            c2.call(
              prefix2 + "_add",
              c2.getLocal("it1"),
              c2.getLocal("it2"),
              c2.getLocal("it1")
            ),
            c2.call(
              prefix2 + "_add",
              c2.getLocal("pAcc"),
              c2.getLocal("it2"),
              c2.getLocal("pAcc")
            ),
            c2.setLocal("it1", c2.i32_add(c2.getLocal("it1"), c2.i32_const(n8g))),
            c2.setLocal("it2", c2.i32_add(c2.getLocal("it2"), c2.i32_const(n8g))),
            c2.br(0)
          )),
          c2.call(
            fnName + "_reduceTable",
            c2.getLocal("pTable"),
            c2.i32_sub(
              c2.getLocal("p"),
              c2.i32_const(1)
            )
          ),
          c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eqz(c2.getLocal("p"))),
            c2.call(prefix2 + "_double", c2.getLocal("pAcc"), c2.getLocal("pAcc")),
            c2.setLocal("p", c2.i32_sub(c2.getLocal("p"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(prefix2 + "_add", c2.getLocal("pTable"), c2.getLocal("pAcc"), c2.getLocal("pTable"))
        );
      }
      buildGetChunk();
      buildReduceTable();
      buildMutiexpChunk();
      buildMultiexp3();
      module.exportFunction(fnName);
      module.exportFunction(fnName + "_chunk");
    };
    buildTimesScalarNAF2 = build_timesscalarnaf;
    buildBatchConvertion = build_batchconvertion;
    buildMultiexp$1 = build_multiexp;
    build_curve_jacobian_a0 = function buildCurve(module, prefix2, prefixField, pB) {
      const n64 = module.modules[prefixField].n64;
      const n8 = n64 * 8;
      if (module.modules[prefix2]) return prefix2;
      module.modules[prefix2] = {
        n64: n64 * 3
      };
      function buildIsZero() {
        const f2 = module.addFunction(prefix2 + "_isZero");
        f2.addParam("p1", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_isZero",
          c2.i32_add(
            c2.getLocal("p1"),
            c2.i32_const(n8 * 2)
          )
        ));
      }
      function buildIsZeroAffine() {
        const f2 = module.addFunction(prefix2 + "_isZeroAffine");
        f2.addParam("p1", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i32_and(
            c2.call(
              prefixField + "_isZero",
              c2.getLocal("p1")
            ),
            c2.call(
              prefixField + "_isZero",
              c2.i32_add(
                c2.getLocal("p1"),
                c2.i32_const(n8)
              )
            )
          )
        );
      }
      function buildCopy() {
        const f2 = module.addFunction(prefix2 + "_copy");
        f2.addParam("ps", "i32");
        f2.addParam("pd", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < n64 * 3; i2++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pd"),
              i2 * 8,
              c2.i64_load(
                c2.getLocal("ps"),
                i2 * 8
              )
            )
          );
        }
      }
      function buildCopyAffine() {
        const f2 = module.addFunction(prefix2 + "_copyAffine");
        f2.addParam("ps", "i32");
        f2.addParam("pd", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < n64 * 2; i2++) {
          f2.addCode(
            c2.i64_store(
              c2.getLocal("pd"),
              i2 * 8,
              c2.i64_load(
                c2.getLocal("ps"),
                i2 * 8
              )
            )
          );
        }
      }
      function buildZero() {
        const f2 = module.addFunction(prefix2 + "_zero");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.getLocal("pr")
        ));
        f2.addCode(c2.call(
          prefixField + "_one",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8)
          )
        ));
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8 * 2)
          )
        ));
      }
      function buildZeroAffine() {
        const f2 = module.addFunction(prefix2 + "_zeroAffine");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.getLocal("pr")
        ));
        f2.addCode(c2.call(
          prefixField + "_zero",
          c2.i32_add(
            c2.getLocal("pr"),
            c2.i32_const(n8)
          )
        ));
      }
      function buildEq() {
        const f2 = module.addFunction(prefix2 + "_eq");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        f2.addLocal("z2", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z2", c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8 * 2))));
        const z2 = c2.getLocal("z2");
        const Z1Z1 = c2.i32_const(module.alloc(n8));
        const Z2Z2 = c2.i32_const(module.alloc(n8));
        const U1 = c2.i32_const(module.alloc(n8));
        const U2 = c2.i32_const(module.alloc(n8));
        const Z1_cubed = c2.i32_const(module.alloc(n8));
        const Z2_cubed = c2.i32_const(module.alloc(n8));
        const S1 = c2.i32_const(module.alloc(n8));
        const S2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            c2.ret(c2.call(prefix2 + "_isZero", c2.getLocal("p2")))
          ),
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p2")),
            c2.ret(c2.i32_const(0))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            c2.ret(c2.call(prefix2 + "_eqMixed", c2.getLocal("p2"), c2.getLocal("p1")))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            c2.ret(c2.call(prefix2 + "_eqMixed", c2.getLocal("p1"), c2.getLocal("p2")))
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_square", z2, Z2Z2),
          c2.call(prefixField + "_mul", x1, Z2Z2, U1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U2),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c2.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", U1, U2),
            c2.if(
              c2.call(prefixField + "_eq", S1, S2),
              c2.ret(c2.i32_const(1))
            )
          ),
          c2.ret(c2.i32_const(0))
        );
      }
      function buildEqMixed() {
        const f2 = module.addFunction(prefix2 + "_eqMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const Z1Z1 = c2.i32_const(module.alloc(n8));
        const U2 = c2.i32_const(module.alloc(n8));
        const Z1_cubed = c2.i32_const(module.alloc(n8));
        const S2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            c2.ret(c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p2")))
          ),
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p2")),
            c2.ret(c2.i32_const(0))
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            c2.ret(c2.call(prefix2 + "_eqAffine", c2.getLocal("p1"), c2.getLocal("p2")))
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U2),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", x1, U2),
            c2.if(
              c2.call(prefixField + "_eq", y1, S2),
              c2.ret(c2.i32_const(1))
            )
          ),
          c2.ret(c2.i32_const(0))
        );
      }
      function buildDouble() {
        const f2 = module.addFunction(prefix2 + "_double");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const A2 = c2.i32_const(module.alloc(n8));
        const B2 = c2.i32_const(module.alloc(n8));
        const C2 = c2.i32_const(module.alloc(n8));
        const D2 = c2.i32_const(module.alloc(n8));
        const E2 = c2.i32_const(module.alloc(n8));
        const F2 = c2.i32_const(module.alloc(n8));
        const G2 = c2.i32_const(module.alloc(n8));
        const eightC = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix2 + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            [
              ...c2.ret(c2.call(prefix2 + "_doubleAffine", c2.getLocal("p1"), c2.getLocal("pr"))),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", x2, A2),
          c2.call(prefixField + "_square", y2, B2),
          c2.call(prefixField + "_square", B2, C2),
          c2.call(prefixField + "_add", x2, B2, D2),
          c2.call(prefixField + "_square", D2, D2),
          c2.call(prefixField + "_sub", D2, A2, D2),
          c2.call(prefixField + "_sub", D2, C2, D2),
          c2.call(prefixField + "_add", D2, D2, D2),
          c2.call(prefixField + "_add", A2, A2, E2),
          c2.call(prefixField + "_add", E2, A2, E2),
          c2.call(prefixField + "_square", E2, F2),
          c2.call(prefixField + "_mul", y2, z2, G2),
          c2.call(prefixField + "_add", D2, D2, x3),
          c2.call(prefixField + "_sub", F2, x3, x3),
          c2.call(prefixField + "_add", C2, C2, eightC),
          c2.call(prefixField + "_add", eightC, eightC, eightC),
          c2.call(prefixField + "_add", eightC, eightC, eightC),
          c2.call(prefixField + "_sub", D2, x3, y3),
          c2.call(prefixField + "_mul", y3, E2, y3),
          c2.call(prefixField + "_sub", y3, eightC, y3),
          c2.call(prefixField + "_add", G2, G2, z3)
        );
      }
      function buildDoubleAffine() {
        const f2 = module.addFunction(prefix2 + "_doubleAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const XX = c2.i32_const(module.alloc(n8));
        const YY = c2.i32_const(module.alloc(n8));
        const YYYY = c2.i32_const(module.alloc(n8));
        const S2 = c2.i32_const(module.alloc(n8));
        const M2 = c2.i32_const(module.alloc(n8));
        const eightYYYY = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p1")),
            [
              ...c2.call(prefix2 + "_toJacobian", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          // XX = X1^2
          c2.call(prefixField + "_square", x2, XX),
          // YY = Y1^2
          c2.call(prefixField + "_square", y2, YY),
          // YYYY = YY^2
          c2.call(prefixField + "_square", YY, YYYY),
          // S = 2*((X1+YY)^2-XX-YYYY)
          c2.call(prefixField + "_add", x2, YY, S2),
          c2.call(prefixField + "_square", S2, S2),
          c2.call(prefixField + "_sub", S2, XX, S2),
          c2.call(prefixField + "_sub", S2, YYYY, S2),
          c2.call(prefixField + "_add", S2, S2, S2),
          // M = 3*XX+a  (Hera a=0)
          c2.call(prefixField + "_add", XX, XX, M2),
          c2.call(prefixField + "_add", M2, XX, M2),
          // Z3 = 2*Y1
          c2.call(prefixField + "_add", y2, y2, z3),
          // T = M^2-2*S
          // X3 = T
          c2.call(prefixField + "_square", M2, x3),
          c2.call(prefixField + "_sub", x3, S2, x3),
          c2.call(prefixField + "_sub", x3, S2, x3),
          // Y3 = M*(S-T)-8*YYYY
          c2.call(prefixField + "_add", YYYY, YYYY, eightYYYY),
          c2.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c2.call(prefixField + "_add", eightYYYY, eightYYYY, eightYYYY),
          c2.call(prefixField + "_sub", S2, x3, y3),
          c2.call(prefixField + "_mul", y3, M2, y3),
          c2.call(prefixField + "_sub", y3, eightYYYY, y3)
        );
      }
      function buildEqAffine() {
        const f2 = module.addFunction(prefix2 + "_eqAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.setReturnType("i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.ret(c2.i32_and(
            c2.call(
              prefixField + "_eq",
              c2.getLocal("p1"),
              c2.getLocal("p2")
            ),
            c2.call(
              prefixField + "_eq",
              c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8)),
              c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8))
            )
          ))
        );
      }
      function buildToMontgomery() {
        const f2 = module.addFunction(prefix2 + "_toMontgomery");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_toMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i2 = 1; i2 < 3; i2++) {
          f2.addCode(c2.call(
            prefixField + "_toMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i2 * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i2 * n8))
          ));
        }
      }
      function buildToMontgomeryAffine() {
        const f2 = module.addFunction(prefix2 + "_toMontgomeryAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_toMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i2 = 1; i2 < 2; i2++) {
          f2.addCode(c2.call(
            prefixField + "_toMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i2 * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i2 * n8))
          ));
        }
      }
      function buildFromMontgomery() {
        const f2 = module.addFunction(prefix2 + "_fromMontgomery");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_fromMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i2 = 1; i2 < 3; i2++) {
          f2.addCode(c2.call(
            prefixField + "_fromMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i2 * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i2 * n8))
          ));
        }
      }
      function buildFromMontgomeryAffine() {
        const f2 = module.addFunction(prefix2 + "_fromMontgomeryAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(c2.call(
          prefixField + "_fromMontgomery",
          c2.getLocal("p1"),
          c2.getLocal("pr")
        ));
        for (let i2 = 1; i2 < 2; i2++) {
          f2.addCode(c2.call(
            prefixField + "_fromMontgomery",
            c2.i32_add(c2.getLocal("p1"), c2.i32_const(i2 * n8)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(i2 * n8))
          ));
        }
      }
      function buildAdd() {
        const f2 = module.addFunction(prefix2 + "_add");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        f2.addLocal("z2", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z2", c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8 * 2))));
        const z2 = c2.getLocal("z2");
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z1Z1 = c2.i32_const(module.alloc(n8));
        const Z2Z2 = c2.i32_const(module.alloc(n8));
        const U1 = c2.i32_const(module.alloc(n8));
        const U2 = c2.i32_const(module.alloc(n8));
        const Z1_cubed = c2.i32_const(module.alloc(n8));
        const Z2_cubed = c2.i32_const(module.alloc(n8));
        const S1 = c2.i32_const(module.alloc(n8));
        const S2 = c2.i32_const(module.alloc(n8));
        const H2 = c2.i32_const(module.alloc(n8));
        const S2_minus_S1 = c2.i32_const(module.alloc(n8));
        const I2 = c2.i32_const(module.alloc(n8));
        const J2 = c2.i32_const(module.alloc(n8));
        const r2 = c2.i32_const(module.alloc(n8));
        const r22 = c2.i32_const(module.alloc(n8));
        const V2 = c2.i32_const(module.alloc(n8));
        const V22 = c2.i32_const(module.alloc(n8));
        const S1_J2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix2 + "_copy", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p2")),
            [
              ...c2.call(prefix2 + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            [
              ...c2.call(prefix2 + "_addMixed", x2, x1, x3),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z2),
            [
              ...c2.call(prefix2 + "_addMixed", x1, x2, x3),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_square", z2, Z2Z2),
          c2.call(prefixField + "_mul", x1, Z2Z2, U1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U2),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", z2, Z2Z2, Z2_cubed),
          c2.call(prefixField + "_mul", y1, Z2_cubed, S1),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", U1, U2),
            c2.if(
              c2.call(prefixField + "_eq", S1, S2),
              [
                ...c2.call(prefix2 + "_double", c2.getLocal("p1"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", U2, U1, H2),
          c2.call(prefixField + "_sub", S2, S1, S2_minus_S1),
          c2.call(prefixField + "_add", H2, H2, I2),
          c2.call(prefixField + "_square", I2, I2),
          c2.call(prefixField + "_mul", H2, I2, J2),
          c2.call(prefixField + "_add", S2_minus_S1, S2_minus_S1, r2),
          c2.call(prefixField + "_mul", U1, I2, V2),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V2, V2, V22),
          c2.call(prefixField + "_sub", r22, J2, x3),
          c2.call(prefixField + "_sub", x3, V22, x3),
          c2.call(prefixField + "_mul", S1, J2, S1_J2),
          c2.call(prefixField + "_add", S1_J2, S1_J2, S1_J2),
          c2.call(prefixField + "_sub", V2, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, S1_J2, y3),
          c2.call(prefixField + "_add", z1, z2, z3),
          c2.call(prefixField + "_square", z3, z3),
          c2.call(prefixField + "_sub", z3, Z1Z1, z3),
          c2.call(prefixField + "_sub", z3, Z2Z2, z3),
          c2.call(prefixField + "_mul", z3, H2, z3)
        );
      }
      function buildAddMixed() {
        const f2 = module.addFunction(prefix2 + "_addMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const z1 = c2.getLocal("z1");
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z1Z1 = c2.i32_const(module.alloc(n8));
        const U2 = c2.i32_const(module.alloc(n8));
        const Z1_cubed = c2.i32_const(module.alloc(n8));
        const S2 = c2.i32_const(module.alloc(n8));
        const H2 = c2.i32_const(module.alloc(n8));
        const HH = c2.i32_const(module.alloc(n8));
        const S2_minus_y1 = c2.i32_const(module.alloc(n8));
        const I2 = c2.i32_const(module.alloc(n8));
        const J2 = c2.i32_const(module.alloc(n8));
        const r2 = c2.i32_const(module.alloc(n8));
        const r22 = c2.i32_const(module.alloc(n8));
        const V2 = c2.i32_const(module.alloc(n8));
        const V22 = c2.i32_const(module.alloc(n8));
        const y1_J2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefix2 + "_copyAffine", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p2")),
            [
              ...c2.call(prefix2 + "_copy", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_isOne", z1),
            [
              ...c2.call(prefix2 + "_addAffine", x1, x2, x3),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_square", z1, Z1Z1),
          c2.call(prefixField + "_mul", x2, Z1Z1, U2),
          c2.call(prefixField + "_mul", z1, Z1Z1, Z1_cubed),
          c2.call(prefixField + "_mul", y2, Z1_cubed, S2),
          c2.if(
            c2.call(prefixField + "_eq", x1, U2),
            c2.if(
              c2.call(prefixField + "_eq", y1, S2),
              [
                ...c2.call(prefix2 + "_doubleAffine", c2.getLocal("p2"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", U2, x1, H2),
          c2.call(prefixField + "_sub", S2, y1, S2_minus_y1),
          c2.call(prefixField + "_square", H2, HH),
          c2.call(prefixField + "_add", HH, HH, I2),
          c2.call(prefixField + "_add", I2, I2, I2),
          c2.call(prefixField + "_mul", H2, I2, J2),
          c2.call(prefixField + "_add", S2_minus_y1, S2_minus_y1, r2),
          c2.call(prefixField + "_mul", x1, I2, V2),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V2, V2, V22),
          c2.call(prefixField + "_sub", r22, J2, x3),
          c2.call(prefixField + "_sub", x3, V22, x3),
          c2.call(prefixField + "_mul", y1, J2, y1_J2),
          c2.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c2.call(prefixField + "_sub", V2, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, y1_J2, y3),
          c2.call(prefixField + "_add", z1, H2, z3),
          c2.call(prefixField + "_square", z3, z3),
          c2.call(prefixField + "_sub", z3, Z1Z1, z3),
          c2.call(prefixField + "_sub", z3, HH, z3)
        );
      }
      function buildAddAffine() {
        const f2 = module.addFunction(prefix2 + "_addAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("z1", "i32");
        const c2 = f2.getCodeBuilder();
        const x1 = c2.getLocal("p1");
        const y1 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        f2.addCode(c2.setLocal("z1", c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2))));
        const x2 = c2.getLocal("p2");
        const y2 = c2.i32_add(c2.getLocal("p2"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const H2 = c2.i32_const(module.alloc(n8));
        const HH = c2.i32_const(module.alloc(n8));
        const y2_minus_y1 = c2.i32_const(module.alloc(n8));
        const I2 = c2.i32_const(module.alloc(n8));
        const J2 = c2.i32_const(module.alloc(n8));
        const r2 = c2.i32_const(module.alloc(n8));
        const r22 = c2.i32_const(module.alloc(n8));
        const V2 = c2.i32_const(module.alloc(n8));
        const V22 = c2.i32_const(module.alloc(n8));
        const y1_J2 = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p1")),
            [
              ...c2.call(prefix2 + "_copyAffine", c2.getLocal("p2"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p2")),
            [
              ...c2.call(prefix2 + "_copyAffine", c2.getLocal("p1"), c2.getLocal("pr")),
              ...c2.call(prefixField + "_one", c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))),
              ...c2.ret([])
            ]
          ),
          c2.if(
            c2.call(prefixField + "_eq", x1, x2),
            c2.if(
              c2.call(prefixField + "_eq", y1, y2),
              [
                ...c2.call(prefix2 + "_doubleAffine", c2.getLocal("p2"), c2.getLocal("pr")),
                ...c2.ret([])
              ]
            )
          ),
          c2.call(prefixField + "_sub", x2, x1, H2),
          c2.call(prefixField + "_sub", y2, y1, y2_minus_y1),
          c2.call(prefixField + "_square", H2, HH),
          c2.call(prefixField + "_add", HH, HH, I2),
          c2.call(prefixField + "_add", I2, I2, I2),
          c2.call(prefixField + "_mul", H2, I2, J2),
          c2.call(prefixField + "_add", y2_minus_y1, y2_minus_y1, r2),
          c2.call(prefixField + "_mul", x1, I2, V2),
          c2.call(prefixField + "_square", r2, r22),
          c2.call(prefixField + "_add", V2, V2, V22),
          c2.call(prefixField + "_sub", r22, J2, x3),
          c2.call(prefixField + "_sub", x3, V22, x3),
          c2.call(prefixField + "_mul", y1, J2, y1_J2),
          c2.call(prefixField + "_add", y1_J2, y1_J2, y1_J2),
          c2.call(prefixField + "_sub", V2, x3, y3),
          c2.call(prefixField + "_mul", y3, r2, y3),
          c2.call(prefixField + "_sub", y3, y1_J2, y3),
          c2.call(prefixField + "_add", H2, H2, z3)
        );
      }
      function buildNeg() {
        const f2 = module.addFunction(prefix2 + "_neg");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        f2.addCode(
          c2.call(prefixField + "_copy", x2, x3),
          c2.call(prefixField + "_neg", y2, y3),
          c2.call(prefixField + "_copy", z2, z3)
        );
      }
      function buildNegAffine() {
        const f2 = module.addFunction(prefix2 + "_negAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        f2.addCode(
          c2.call(prefixField + "_copy", x2, x3),
          c2.call(prefixField + "_neg", y2, y3)
        );
      }
      function buildSub() {
        const f2 = module.addFunction(prefix2 + "_sub");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix2 + "_neg", c2.getLocal("p2"), AUX),
          c2.call(prefix2 + "_add", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildSubMixed() {
        const f2 = module.addFunction(prefix2 + "_subMixed");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix2 + "_negAffine", c2.getLocal("p2"), AUX),
          c2.call(prefix2 + "_addMixed", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildSubAffine() {
        const f2 = module.addFunction(prefix2 + "_subAffine");
        f2.addParam("p1", "i32");
        f2.addParam("p2", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8 * 3));
        f2.addCode(
          c2.call(prefix2 + "_negAffine", c2.getLocal("p2"), AUX),
          c2.call(prefix2 + "_addAffine", c2.getLocal("p1"), AUX, c2.getLocal("pr"))
        );
      }
      function buildNormalize() {
        const f2 = module.addFunction(prefix2 + "_normalize");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        const Z_inv = c2.i32_const(module.alloc(n8));
        const Z2_inv = c2.i32_const(module.alloc(n8));
        const Z3_inv = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            c2.call(prefix2 + "_zero", c2.getLocal("pr")),
            [
              ...c2.call(prefixField + "_inverse", z2, Z_inv),
              ...c2.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c2.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c2.call(prefixField + "_mul", x2, Z2_inv, x3),
              ...c2.call(prefixField + "_mul", y2, Z3_inv, y3),
              ...c2.call(prefixField + "_one", z3)
            ]
          )
        );
      }
      function buildToAffine() {
        const f2 = module.addFunction(prefix2 + "_toAffine");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8 * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const Z_inv = c2.i32_const(module.alloc(n8));
        const Z2_inv = c2.i32_const(module.alloc(n8));
        const Z3_inv = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZero", c2.getLocal("p1")),
            [
              ...c2.call(prefixField + "_zero", x3),
              ...c2.call(prefixField + "_zero", y3)
            ],
            [
              ...c2.call(prefixField + "_inverse", z2, Z_inv),
              ...c2.call(prefixField + "_square", Z_inv, Z2_inv),
              ...c2.call(prefixField + "_mul", Z_inv, Z2_inv, Z3_inv),
              ...c2.call(prefixField + "_mul", x2, Z2_inv, x3),
              ...c2.call(prefixField + "_mul", y2, Z3_inv, y3)
            ]
          )
        );
      }
      function buildToJacobian() {
        const f2 = module.addFunction(prefix2 + "_toJacobian");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(n8));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("p1")),
            c2.call(prefix2 + "_zero", c2.getLocal("pr")),
            [
              ...c2.call(prefixField + "_one", z3),
              ...c2.call(prefixField + "_copy", y2, y3),
              ...c2.call(prefixField + "_copy", x2, x3)
            ]
          )
        );
      }
      function buildBatchToAffine() {
        const f2 = module.addFunction(prefix2 + "_batchToAffine");
        f2.addParam("pIn", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("pAux", "i32");
        f2.addLocal("itIn", "i32");
        f2.addLocal("itAux", "i32");
        f2.addLocal("itOut", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const tmp = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.setLocal("pAux", c2.i32_load(c2.i32_const(0))),
          c2.i32_store(
            c2.i32_const(0),
            c2.i32_add(
              c2.getLocal("pAux"),
              c2.i32_mul(c2.getLocal("n"), c2.i32_const(n8))
            )
          ),
          c2.call(
            prefixField + "_batchInverse",
            c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8 * 2)),
            c2.i32_const(n8 * 3),
            c2.getLocal("n"),
            c2.getLocal("pAux"),
            c2.i32_const(n8)
          ),
          c2.setLocal("itIn", c2.getLocal("pIn")),
          c2.setLocal("itAux", c2.getLocal("pAux")),
          c2.setLocal("itOut", c2.getLocal("pOut")),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
            c2.if(
              c2.call(prefixField + "_isZero", c2.getLocal("itAux")),
              [
                ...c2.call(prefixField + "_zero", c2.getLocal("itOut")),
                ...c2.call(prefixField + "_zero", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8)))
              ],
              [
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  c2.i32_add(c2.getLocal("itIn"), c2.i32_const(n8)),
                  tmp
                ),
                ...c2.call(
                  prefixField + "_square",
                  c2.getLocal("itAux"),
                  c2.getLocal("itAux")
                ),
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  c2.getLocal("itIn"),
                  c2.getLocal("itOut")
                ),
                ...c2.call(
                  prefixField + "_mul",
                  c2.getLocal("itAux"),
                  tmp,
                  c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8))
                )
              ]
            ),
            c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(n8 * 3))),
            c2.setLocal("itOut", c2.i32_add(c2.getLocal("itOut"), c2.i32_const(n8 * 2))),
            c2.setLocal("itAux", c2.i32_add(c2.getLocal("itAux"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.i32_store(
            c2.i32_const(0),
            c2.getLocal("pAux")
          )
        );
      }
      function buildReverseBytes() {
        const f2 = module.addFunction(prefix2 + "__reverseBytes");
        f2.addParam("pIn", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("itOut", "i32");
        f2.addLocal("itIn", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "itOut",
            c2.i32_sub(
              c2.i32_add(
                c2.getLocal("pOut"),
                c2.getLocal("n")
              ),
              c2.i32_const(1)
            )
          ),
          c2.setLocal(
            "itIn",
            c2.getLocal("pIn")
          ),
          c2.block(c2.loop(
            c2.br_if(1, c2.i32_lt_s(c2.getLocal("itOut"), c2.getLocal("pOut"))),
            c2.i32_store8(
              c2.getLocal("itOut"),
              c2.i32_load8_u(c2.getLocal("itIn"))
            ),
            c2.setLocal("itOut", c2.i32_sub(c2.getLocal("itOut"), c2.i32_const(1))),
            c2.setLocal("itIn", c2.i32_add(c2.getLocal("itIn"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildLEMtoC() {
        const f2 = module.addFunction(prefix2 + "_LEMtoC");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const tmp = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("pIn")),
            [
              ...c2.call(prefixField + "_zero", c2.getLocal("pOut")),
              ...c2.i32_store8(
                c2.getLocal("pOut"),
                c2.i32_const(64)
              ),
              ...c2.ret([])
            ]
          ),
          c2.call(prefixField + "_fromMontgomery", c2.getLocal("pIn"), tmp),
          c2.call(prefix2 + "__reverseBytes", tmp, c2.i32_const(n8), c2.getLocal("pOut")),
          c2.if(
            c2.i32_eq(
              c2.call(prefixField + "_sign", c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8))),
              c2.i32_const(-1)
            ),
            c2.i32_store8(
              c2.getLocal("pOut"),
              c2.i32_or(
                c2.i32_load8_u(c2.getLocal("pOut")),
                c2.i32_const(128)
              )
            )
          )
        );
      }
      function buildLEMtoU() {
        const f2 = module.addFunction(prefix2 + "_LEMtoU");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module.alloc(n8 * 2);
        const tmp = c2.i32_const(pTmp);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.if(
            c2.call(prefix2 + "_isZeroAffine", c2.getLocal("pIn")),
            [
              ...c2.call(prefix2 + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.call(prefix2 + "_fromMontgomeryAffine", c2.getLocal("pIn"), tmp),
          c2.call(prefix2 + "__reverseBytes", tmpX, c2.i32_const(n8), c2.getLocal("pOut")),
          c2.call(prefix2 + "__reverseBytes", tmpY, c2.i32_const(n8), c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
        );
      }
      function buildUtoLEM() {
        const f2 = module.addFunction(prefix2 + "_UtoLEM");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module.alloc(n8 * 2);
        const tmp = c2.i32_const(pTmp);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.if(
            c2.i32_and(c2.i32_load8_u(c2.getLocal("pIn")), c2.i32_const(64)),
            [
              ...c2.call(prefix2 + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.call(prefix2 + "__reverseBytes", c2.getLocal("pIn"), c2.i32_const(n8), tmpX),
          c2.call(prefix2 + "__reverseBytes", c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8)), c2.i32_const(n8), tmpY),
          c2.call(prefix2 + "_toMontgomeryAffine", tmp, c2.getLocal("pOut"))
        );
      }
      function buildCtoLEM() {
        const f2 = module.addFunction(prefix2 + "_CtoLEM");
        f2.addParam("pIn", "i32");
        f2.addParam("pOut", "i32");
        f2.addLocal("firstByte", "i32");
        f2.addLocal("greatest", "i32");
        const c2 = f2.getCodeBuilder();
        const pTmp = module.alloc(n8 * 2);
        const tmpX = c2.i32_const(pTmp);
        const tmpY = c2.i32_const(pTmp + n8);
        f2.addCode(
          c2.setLocal("firstByte", c2.i32_load8_u(c2.getLocal("pIn"))),
          c2.if(
            c2.i32_and(
              c2.getLocal("firstByte"),
              c2.i32_const(64)
            ),
            [
              ...c2.call(prefix2 + "_zeroAffine", c2.getLocal("pOut")),
              ...c2.ret([])
            ]
          ),
          c2.setLocal(
            "greatest",
            c2.i32_and(
              c2.getLocal("firstByte"),
              c2.i32_const(128)
            )
          ),
          c2.call(prefixField + "_copy", c2.getLocal("pIn"), tmpY),
          c2.i32_store8(tmpY, c2.i32_and(c2.getLocal("firstByte"), c2.i32_const(63))),
          c2.call(prefix2 + "__reverseBytes", tmpY, c2.i32_const(n8), tmpX),
          c2.call(prefixField + "_toMontgomery", tmpX, c2.getLocal("pOut")),
          c2.call(prefixField + "_square", c2.getLocal("pOut"), tmpY),
          c2.call(prefixField + "_mul", c2.getLocal("pOut"), tmpY, tmpY),
          c2.call(prefixField + "_add", tmpY, c2.i32_const(pB), tmpY),
          c2.call(prefixField + "_sqrt", tmpY, tmpY),
          c2.call(prefixField + "_neg", tmpY, tmpX),
          c2.if(
            c2.i32_eq(
              c2.call(prefixField + "_sign", tmpY),
              c2.i32_const(-1)
            ),
            c2.if(
              c2.getLocal("greatest"),
              c2.call(prefixField + "_copy", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8))),
              c2.call(prefixField + "_neg", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
            ),
            c2.if(
              c2.getLocal("greatest"),
              c2.call(prefixField + "_neg", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8))),
              c2.call(prefixField + "_copy", tmpY, c2.i32_add(c2.getLocal("pOut"), c2.i32_const(n8)))
            )
          )
        );
      }
      function buildInCurveAffine() {
        const f2 = module.addFunction(prefix2 + "_inCurveAffine");
        f2.addParam("pIn", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("pIn");
        const y2 = c2.i32_add(c2.getLocal("pIn"), c2.i32_const(n8));
        const y22 = c2.i32_const(module.alloc(n8));
        const x3b = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.call(prefixField + "_square", y2, y22),
          c2.call(prefixField + "_square", x2, x3b),
          c2.call(prefixField + "_mul", x2, x3b, x3b),
          c2.call(prefixField + "_add", x3b, c2.i32_const(pB), x3b),
          c2.ret(
            c2.call(prefixField + "_eq", y22, x3b)
          )
        );
      }
      function buildInCurve() {
        const f2 = module.addFunction(prefix2 + "_inCurve");
        f2.addParam("pIn", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module.alloc(n8 * 2));
        f2.addCode(
          c2.call(prefix2 + "_toAffine", c2.getLocal("pIn"), aux),
          c2.ret(
            c2.call(prefix2 + "_inCurveAffine", aux)
          )
        );
      }
      buildIsZeroAffine();
      buildIsZero();
      buildZeroAffine();
      buildZero();
      buildCopyAffine();
      buildCopy();
      buildToJacobian();
      buildEqAffine();
      buildEqMixed();
      buildEq();
      buildDoubleAffine();
      buildDouble();
      buildAddAffine();
      buildAddMixed();
      buildAdd();
      buildNegAffine();
      buildNeg();
      buildSubAffine();
      buildSubMixed();
      buildSub();
      buildFromMontgomeryAffine();
      buildFromMontgomery();
      buildToMontgomeryAffine();
      buildToMontgomery();
      buildToAffine();
      buildInCurveAffine();
      buildInCurve();
      buildBatchToAffine();
      buildNormalize();
      buildReverseBytes();
      buildLEMtoU();
      buildLEMtoC();
      buildUtoLEM();
      buildCtoLEM();
      buildBatchConvertion(module, prefix2 + "_batchLEMtoU", prefix2 + "_LEMtoU", n8 * 2, n8 * 2);
      buildBatchConvertion(module, prefix2 + "_batchLEMtoC", prefix2 + "_LEMtoC", n8 * 2, n8);
      buildBatchConvertion(module, prefix2 + "_batchUtoLEM", prefix2 + "_UtoLEM", n8 * 2, n8 * 2);
      buildBatchConvertion(module, prefix2 + "_batchCtoLEM", prefix2 + "_CtoLEM", n8, n8 * 2, true);
      buildBatchConvertion(module, prefix2 + "_batchToJacobian", prefix2 + "_toJacobian", n8 * 2, n8 * 3, true);
      buildMultiexp$1(module, prefix2, prefix2 + "_multiexp", prefix2 + "_add", n8 * 3);
      buildMultiexp$1(module, prefix2, prefix2 + "_multiexpAffine", prefix2 + "_addMixed", n8 * 2);
      buildTimesScalarNAF2(
        module,
        prefix2 + "_timesScalar",
        n8 * 3,
        prefix2 + "_add",
        prefix2 + "_double",
        prefix2 + "_sub",
        prefix2 + "_copy",
        prefix2 + "_zero"
      );
      buildTimesScalarNAF2(
        module,
        prefix2 + "_timesScalarAffine",
        n8 * 2,
        prefix2 + "_addMixed",
        prefix2 + "_double",
        prefix2 + "_subMixed",
        prefix2 + "_copyAffine",
        prefix2 + "_zero"
      );
      module.exportFunction(prefix2 + "_isZero");
      module.exportFunction(prefix2 + "_isZeroAffine");
      module.exportFunction(prefix2 + "_eq");
      module.exportFunction(prefix2 + "_eqMixed");
      module.exportFunction(prefix2 + "_eqAffine");
      module.exportFunction(prefix2 + "_copy");
      module.exportFunction(prefix2 + "_copyAffine");
      module.exportFunction(prefix2 + "_zero");
      module.exportFunction(prefix2 + "_zeroAffine");
      module.exportFunction(prefix2 + "_double");
      module.exportFunction(prefix2 + "_doubleAffine");
      module.exportFunction(prefix2 + "_add");
      module.exportFunction(prefix2 + "_addMixed");
      module.exportFunction(prefix2 + "_addAffine");
      module.exportFunction(prefix2 + "_neg");
      module.exportFunction(prefix2 + "_negAffine");
      module.exportFunction(prefix2 + "_sub");
      module.exportFunction(prefix2 + "_subMixed");
      module.exportFunction(prefix2 + "_subAffine");
      module.exportFunction(prefix2 + "_fromMontgomery");
      module.exportFunction(prefix2 + "_fromMontgomeryAffine");
      module.exportFunction(prefix2 + "_toMontgomery");
      module.exportFunction(prefix2 + "_toMontgomeryAffine");
      module.exportFunction(prefix2 + "_timesScalar");
      module.exportFunction(prefix2 + "_timesScalarAffine");
      module.exportFunction(prefix2 + "_normalize");
      module.exportFunction(prefix2 + "_LEMtoU");
      module.exportFunction(prefix2 + "_LEMtoC");
      module.exportFunction(prefix2 + "_UtoLEM");
      module.exportFunction(prefix2 + "_CtoLEM");
      module.exportFunction(prefix2 + "_batchLEMtoU");
      module.exportFunction(prefix2 + "_batchLEMtoC");
      module.exportFunction(prefix2 + "_batchUtoLEM");
      module.exportFunction(prefix2 + "_batchCtoLEM");
      module.exportFunction(prefix2 + "_toAffine");
      module.exportFunction(prefix2 + "_toJacobian");
      module.exportFunction(prefix2 + "_batchToAffine");
      module.exportFunction(prefix2 + "_batchToJacobian");
      module.exportFunction(prefix2 + "_inCurve");
      module.exportFunction(prefix2 + "_inCurveAffine");
      return prefix2;
    };
    ({ isOdd: isOdd$2, modInv: modInv$1, modPow } = bigint);
    utils$3 = utils$6;
    build_fft = function buildFFT(module, prefix2, gPrefix, fPrefix, opGtimesF) {
      const n64f = module.modules[fPrefix].n64;
      const n8f = n64f * 8;
      const n64g = module.modules[gPrefix].n64;
      const n8g = n64g * 8;
      const q2 = module.modules[fPrefix].q;
      let rem = q2 - 1n;
      let maxBits = 0;
      while (!isOdd$2(rem)) {
        maxBits++;
        rem = rem >> 1n;
      }
      let nr = 2n;
      while (modPow(nr, q2 >> 1n, q2) === 1n) nr = nr + 1n;
      const w2 = new Array(maxBits + 1);
      w2[maxBits] = modPow(nr, rem, q2);
      let n = maxBits - 1;
      while (n >= 0) {
        w2[n] = modPow(w2[n + 1], 2n, q2);
        n--;
      }
      const bytes = [];
      const R2 = (1n << BigInt(n8f * 8)) % q2;
      for (let i3 = 0; i3 < w2.length; i3++) {
        const m2 = w2[i3] * R2 % q2;
        bytes.push(...utils$3.bigInt2BytesLE(m2, n8f));
      }
      const ROOTs = module.alloc(bytes);
      const i2 = new Array(maxBits + 1);
      i2[0] = 1n;
      for (let i3 = 1; i3 <= maxBits; i3++) {
        i2[i3] = i2[i3 - 1] * 2n;
      }
      const bytesi2 = [];
      for (let i3 = 0; i3 <= maxBits; i3++) {
        const m2 = modInv$1(i2[i3], q2) * R2 % q2;
        bytesi2.push(...utils$3.bigInt2BytesLE(m2, n8f));
      }
      const INV2 = module.alloc(bytesi2);
      const shift = modPow(nr, 2n, q2);
      const bytesShiftToSmallM = [];
      const bytesSConst = [];
      for (let i3 = 0; i3 <= maxBits; i3++) {
        const shiftToSmallM = modPow(shift, 2n ** BigInt(i3), q2);
        const sConst = modInv$1(q2 + 1n - shiftToSmallM, q2);
        bytesShiftToSmallM.push(...utils$3.bigInt2BytesLE(shiftToSmallM * R2 % q2, n8f));
        bytesSConst.push(...utils$3.bigInt2BytesLE(sConst * R2 % q2, n8f));
      }
      const SHIFT_TO_M = module.alloc(bytesShiftToSmallM);
      const SCONST = module.alloc(bytesSConst);
      function rev(x2) {
        let r2 = 0;
        for (let i3 = 0; i3 < 8; i3++) {
          if (x2 & 1 << i3) {
            r2 = r2 | 128 >> i3;
          }
        }
        return r2;
      }
      const rtable = Array(256);
      for (let i3 = 0; i3 < 256; i3++) {
        rtable[i3] = rev(i3);
      }
      const REVTABLE = module.alloc(rtable);
      function buildLog2() {
        const f2 = module.addFunction(prefix2 + "__log2");
        f2.addParam("n", "i32");
        f2.setReturnType("i32");
        f2.addLocal("bits", "i32");
        f2.addLocal("aux", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "aux",
            c2.i32_shr_u(
              c2.getLocal("n"),
              c2.i32_const(1)
            )
          )
        );
        f2.addCode(c2.setLocal("bits", c2.i32_const(0)));
        f2.addCode(c2.block(c2.loop(
          c2.br_if(
            1,
            c2.i32_eqz(c2.getLocal("aux"))
          ),
          c2.setLocal(
            "aux",
            c2.i32_shr_u(
              c2.getLocal("aux"),
              c2.i32_const(1)
            )
          ),
          c2.setLocal(
            "bits",
            c2.i32_add(
              c2.getLocal("bits"),
              c2.i32_const(1)
            )
          ),
          c2.br(0)
        )));
        f2.addCode(c2.if(
          c2.i32_ne(
            c2.getLocal("n"),
            c2.i32_shl(
              c2.i32_const(1),
              c2.getLocal("bits")
            )
          ),
          c2.unreachable()
        ));
        f2.addCode(c2.if(
          c2.i32_gt_u(
            c2.getLocal("bits"),
            c2.i32_const(maxBits)
          ),
          c2.unreachable()
        ));
        f2.addCode(c2.getLocal("bits"));
      }
      function buildFFT3() {
        const f2 = module.addFunction(prefix2 + "_fft");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("bits", "i32");
        const c2 = f2.getCodeBuilder();
        const One = c2.i32_const(module.alloc(n8f));
        f2.addCode(
          c2.setLocal(
            "bits",
            c2.call(
              prefix2 + "__log2",
              c2.getLocal("n")
            )
          ),
          c2.call(fPrefix + "_one", One),
          c2.call(
            prefix2 + "_rawfft",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.i32_const(0),
            One
          )
        );
      }
      function buildIFFT() {
        const f2 = module.addFunction(prefix2 + "_ifft");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("bits", "i32");
        f2.addLocal("pInv2", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal(
            "bits",
            c2.call(
              prefix2 + "__log2",
              c2.getLocal("n")
            )
          ),
          c2.setLocal(
            "pInv2",
            c2.i32_add(
              c2.i32_const(INV2),
              c2.i32_mul(
                c2.getLocal("bits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(
            prefix2 + "_rawfft",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.i32_const(1),
            c2.getLocal("pInv2")
          )
        );
      }
      function buildRawFFT() {
        const f2 = module.addFunction(prefix2 + "_rawfft");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addParam("reverse", "i32");
        f2.addParam("mulFactor", "i32");
        f2.addLocal("s", "i32");
        f2.addLocal("k", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("mdiv2", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("pwm", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const T2 = c2.i32_const(module.alloc(n8g));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.call(prefix2 + "__reversePermutation", c2.getLocal("px"), c2.getLocal("bits")),
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("s", c2.i32_const(1)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_gt_u(
                c2.getLocal("s"),
                c2.getLocal("bits")
              )
            ),
            c2.setLocal("m", c2.i32_shl(c2.i32_const(1), c2.getLocal("s"))),
            c2.setLocal(
              "pwm",
              c2.i32_add(
                c2.i32_const(ROOTs),
                c2.i32_mul(
                  c2.getLocal("s"),
                  c2.i32_const(n8f)
                )
              )
            ),
            c2.setLocal("k", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_ge_u(
                  c2.getLocal("k"),
                  c2.getLocal("n")
                )
              ),
              c2.call(fPrefix + "_one", W2),
              c2.setLocal("mdiv2", c2.i32_shr_u(c2.getLocal("m"), c2.i32_const(1))),
              c2.setLocal("j", c2.i32_const(0)),
              c2.block(c2.loop(
                c2.br_if(
                  1,
                  c2.i32_ge_u(
                    c2.getLocal("j"),
                    c2.getLocal("mdiv2")
                  )
                ),
                c2.setLocal(
                  "idx1",
                  c2.i32_add(
                    c2.getLocal("px"),
                    c2.i32_mul(
                      c2.i32_add(
                        c2.getLocal("k"),
                        c2.getLocal("j")
                      ),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                c2.setLocal(
                  "idx2",
                  c2.i32_add(
                    c2.getLocal("idx1"),
                    c2.i32_mul(
                      c2.getLocal("mdiv2"),
                      c2.i32_const(n8g)
                    )
                  )
                ),
                c2.call(
                  opGtimesF,
                  c2.getLocal("idx2"),
                  W2,
                  T2
                ),
                c2.call(
                  gPrefix + "_copy",
                  c2.getLocal("idx1"),
                  U2
                ),
                c2.call(
                  gPrefix + "_add",
                  U2,
                  T2,
                  c2.getLocal("idx1")
                ),
                c2.call(
                  gPrefix + "_sub",
                  U2,
                  T2,
                  c2.getLocal("idx2")
                ),
                c2.call(
                  fPrefix + "_mul",
                  W2,
                  c2.getLocal("pwm"),
                  W2
                ),
                c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
                c2.br(0)
              )),
              c2.setLocal("k", c2.i32_add(c2.getLocal("k"), c2.getLocal("m"))),
              c2.br(0)
            )),
            c2.setLocal("s", c2.i32_add(c2.getLocal("s"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(
            prefix2 + "__fftFinal",
            c2.getLocal("px"),
            c2.getLocal("bits"),
            c2.getLocal("reverse"),
            c2.getLocal("mulFactor")
          )
        );
      }
      function buildFinalInverse() {
        const f2 = module.addFunction(prefix2 + "__fftFinal");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addParam("reverse", "i32");
        f2.addParam("mulFactor", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("ndiv2", "i32");
        f2.addLocal("pInv2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("mask", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const T2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.if(
            c2.i32_and(
              c2.i32_eqz(c2.getLocal("reverse")),
              c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor"))
            ),
            c2.ret([])
          ),
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("mask", c2.i32_sub(c2.getLocal("n"), c2.i32_const(1))),
          c2.setLocal("i", c2.i32_const(1)),
          c2.setLocal(
            "ndiv2",
            c2.i32_shr_u(
              c2.getLocal("n"),
              c2.i32_const(1)
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_ge_u(
                c2.getLocal("i"),
                c2.getLocal("ndiv2")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.getLocal("n"),
                    c2.getLocal("i")
                  ),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.if(
              c2.getLocal("reverse"),
              c2.if(
                c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
                [
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T2),
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx2"), c2.getLocal("idx1")),
                  ...c2.call(gPrefix + "_copy", T2, c2.getLocal("idx2"))
                ],
                [
                  ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T2),
                  ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx1")),
                  ...c2.call(opGtimesF, T2, c2.getLocal("mulFactor"), c2.getLocal("idx2"))
                ]
              ),
              c2.if(
                c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
                [
                  // Do nothing (It should not be here)
                ],
                [
                  ...c2.call(opGtimesF, c2.getLocal("idx1"), c2.getLocal("mulFactor"), c2.getLocal("idx1")),
                  ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx2"))
                ]
              )
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.if(
            c2.call(fPrefix + "_isOne", c2.getLocal("mulFactor")),
            [
              // Do nothing (It should not be here)
            ],
            [
              ...c2.call(opGtimesF, c2.getLocal("px"), c2.getLocal("mulFactor"), c2.getLocal("px")),
              ...c2.setLocal(
                "idx2",
                c2.i32_add(
                  c2.getLocal("px"),
                  c2.i32_mul(
                    c2.getLocal("ndiv2"),
                    c2.i32_const(n8g)
                  )
                )
              ),
              ...c2.call(opGtimesF, c2.getLocal("idx2"), c2.getLocal("mulFactor"), c2.getLocal("idx2"))
            ]
          )
        );
      }
      function buildReversePermutation() {
        const f2 = module.addFunction(prefix2 + "__reversePermutation");
        f2.addParam("px", "i32");
        f2.addParam("bits", "i32");
        f2.addLocal("n", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("ri", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        const c2 = f2.getCodeBuilder();
        const T2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal("n", c2.i32_shl(c2.i32_const(1), c2.getLocal("bits"))),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal("ri", c2.call(prefix2 + "__rev", c2.getLocal("i"), c2.getLocal("bits"))),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("px"),
                c2.i32_mul(
                  c2.getLocal("ri"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.if(
              c2.i32_lt_u(
                c2.getLocal("i"),
                c2.getLocal("ri")
              ),
              [
                ...c2.call(gPrefix + "_copy", c2.getLocal("idx1"), T2),
                ...c2.call(gPrefix + "_copy", c2.getLocal("idx2"), c2.getLocal("idx1")),
                ...c2.call(gPrefix + "_copy", T2, c2.getLocal("idx2"))
              ]
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildRev() {
        const f2 = module.addFunction(prefix2 + "__rev");
        f2.addParam("x", "i32");
        f2.addParam("bits", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.i32_rotl(
            c2.i32_add(
              c2.i32_add(
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.getLocal("x"),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(24)
                ),
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.i32_shr_u(
                        c2.getLocal("x"),
                        c2.i32_const(8)
                      ),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(16)
                )
              ),
              c2.i32_add(
                c2.i32_shl(
                  c2.i32_load8_u(
                    c2.i32_and(
                      c2.i32_shr_u(
                        c2.getLocal("x"),
                        c2.i32_const(16)
                      ),
                      c2.i32_const(255)
                    ),
                    REVTABLE,
                    0
                  ),
                  c2.i32_const(8)
                ),
                c2.i32_load8_u(
                  c2.i32_and(
                    c2.i32_shr_u(
                      c2.getLocal("x"),
                      c2.i32_const(24)
                    ),
                    c2.i32_const(255)
                  ),
                  REVTABLE,
                  0
                )
              )
            ),
            c2.getLocal("bits")
          )
        );
      }
      function buildFFTJoin() {
        const f2 = module.addFunction(prefix2 + "_fftJoin");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const T2 = c2.i32_const(module.alloc(n8g));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W2),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W2,
              T2
            ),
            c2.call(
              gPrefix + "_copy",
              c2.getLocal("idx1"),
              U2
            ),
            c2.call(
              gPrefix + "_add",
              U2,
              T2,
              c2.getLocal("idx1")
            ),
            c2.call(
              gPrefix + "_sub",
              U2,
              T2,
              c2.getLocal("idx2")
            ),
            c2.call(
              fPrefix + "_mul",
              W2,
              c2.getLocal("inc"),
              W2
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTJoinExt() {
        const f2 = module.addFunction(prefix2 + "_fftJoinExt");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W2),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              gPrefix + "_add",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              U2
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("pShiftToM"),
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_add",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W2,
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_copy",
              U2,
              c2.getLocal("idx1")
            ),
            c2.call(
              fPrefix + "_mul",
              W2,
              c2.getLocal("inc"),
              W2
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTJoinExtInv() {
        const f2 = module.addFunction(prefix2 + "_fftJoinExtInv");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        f2.addLocal("pSConst", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal(
            "pSConst",
            c2.i32_add(
              c2.i32_const(SCONST),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W2),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W2,
              U2
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx1"),
              U2,
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("pSConst"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pShiftToM"),
              c2.getLocal("idx1")
            ),
            c2.call(
              gPrefix + "_sub",
              U2,
              c2.getLocal("idx1"),
              c2.getLocal("idx1")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pSConst"),
              c2.getLocal("idx1")
            ),
            c2.call(
              fPrefix + "_mul",
              W2,
              c2.getLocal("inc"),
              W2
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildPrepareLagrangeEvaluation() {
        const f2 = module.addFunction(prefix2 + "_prepareLagrangeEvaluation");
        f2.addParam("pBuff1", "i32");
        f2.addParam("pBuff2", "i32");
        f2.addParam("n", "i32");
        f2.addParam("first", "i32");
        f2.addParam("inc", "i32");
        f2.addParam("totalBits", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("pShiftToM", "i32");
        f2.addLocal("pSConst", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal(
            "pShiftToM",
            c2.i32_add(
              c2.i32_const(SHIFT_TO_M),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal(
            "pSConst",
            c2.i32_add(
              c2.i32_const(SCONST),
              c2.i32_mul(
                c2.getLocal("totalBits"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.call(fPrefix + "_copy", c2.getLocal("first"), W2),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("n")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff1"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff2"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("pShiftToM"),
              U2
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx2"),
              U2,
              U2
            ),
            c2.call(
              gPrefix + "_sub",
              c2.getLocal("idx1"),
              c2.getLocal("idx2"),
              c2.getLocal("idx2")
            ),
            c2.call(
              opGtimesF,
              U2,
              c2.getLocal("pSConst"),
              c2.getLocal("idx1")
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              W2,
              c2.getLocal("idx2")
            ),
            c2.call(
              fPrefix + "_mul",
              W2,
              c2.getLocal("inc"),
              W2
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTMix() {
        const f2 = module.addFunction(prefix2 + "_fftMix");
        f2.addParam("pBuff", "i32");
        f2.addParam("n", "i32");
        f2.addParam("exp", "i32");
        f2.addLocal("nGroups", "i32");
        f2.addLocal("nPerGroup", "i32");
        f2.addLocal("nPerGroupDiv2", "i32");
        f2.addLocal("pairOffset", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("pwm", "i32");
        const c2 = f2.getCodeBuilder();
        const W2 = c2.i32_const(module.alloc(n8f));
        const T2 = c2.i32_const(module.alloc(n8g));
        const U2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal("nPerGroup", c2.i32_shl(c2.i32_const(1), c2.getLocal("exp"))),
          c2.setLocal("nPerGroupDiv2", c2.i32_shr_u(c2.getLocal("nPerGroup"), c2.i32_const(1))),
          c2.setLocal("nGroups", c2.i32_shr_u(c2.getLocal("n"), c2.getLocal("exp"))),
          c2.setLocal("pairOffset", c2.i32_mul(c2.getLocal("nPerGroupDiv2"), c2.i32_const(n8g))),
          c2.setLocal(
            "pwm",
            c2.i32_add(
              c2.i32_const(ROOTs),
              c2.i32_mul(
                c2.getLocal("exp"),
                c2.i32_const(n8f)
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("nGroups")
              )
            ),
            c2.call(fPrefix + "_one", W2),
            c2.setLocal("j", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_eq(
                  c2.getLocal("j"),
                  c2.getLocal("nPerGroupDiv2")
                )
              ),
              c2.setLocal(
                "idx1",
                c2.i32_add(
                  c2.getLocal("pBuff"),
                  c2.i32_mul(
                    c2.i32_add(
                      c2.i32_mul(
                        c2.getLocal("i"),
                        c2.getLocal("nPerGroup")
                      ),
                      c2.getLocal("j")
                    ),
                    c2.i32_const(n8g)
                  )
                )
              ),
              c2.setLocal(
                "idx2",
                c2.i32_add(
                  c2.getLocal("idx1"),
                  c2.getLocal("pairOffset")
                )
              ),
              c2.call(
                opGtimesF,
                c2.getLocal("idx2"),
                W2,
                T2
              ),
              c2.call(
                gPrefix + "_copy",
                c2.getLocal("idx1"),
                U2
              ),
              c2.call(
                gPrefix + "_add",
                U2,
                T2,
                c2.getLocal("idx1")
              ),
              c2.call(
                gPrefix + "_sub",
                U2,
                T2,
                c2.getLocal("idx2")
              ),
              c2.call(
                fPrefix + "_mul",
                W2,
                c2.getLocal("pwm"),
                W2
              ),
              c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFFTFinal() {
        const f2 = module.addFunction(prefix2 + "_fftFinal");
        f2.addParam("pBuff", "i32");
        f2.addParam("n", "i32");
        f2.addParam("factor", "i32");
        f2.addLocal("idx1", "i32");
        f2.addLocal("idx2", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("ndiv2", "i32");
        const c2 = f2.getCodeBuilder();
        const T2 = c2.i32_const(module.alloc(n8g));
        f2.addCode(
          c2.setLocal("ndiv2", c2.i32_shr_u(c2.getLocal("n"), c2.i32_const(1))),
          c2.if(
            c2.i32_and(
              c2.getLocal("n"),
              c2.i32_const(1)
            ),
            c2.call(
              opGtimesF,
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("ndiv2"),
                  c2.i32_const(n8g)
                )
              ),
              c2.getLocal("factor"),
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("ndiv2"),
                  c2.i32_const(n8g)
                )
              )
            )
          ),
          c2.setLocal("i", c2.i32_const(0)),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_ge_u(
                c2.getLocal("i"),
                c2.getLocal("ndiv2")
              )
            ),
            c2.setLocal(
              "idx1",
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.getLocal("i"),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.setLocal(
              "idx2",
              c2.i32_add(
                c2.getLocal("pBuff"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.i32_sub(
                      c2.getLocal("n"),
                      c2.i32_const(1)
                    ),
                    c2.getLocal("i")
                  ),
                  c2.i32_const(n8g)
                )
              )
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx2"),
              c2.getLocal("factor"),
              T2
            ),
            c2.call(
              opGtimesF,
              c2.getLocal("idx1"),
              c2.getLocal("factor"),
              c2.getLocal("idx2")
            ),
            c2.call(
              gPrefix + "_copy",
              T2,
              c2.getLocal("idx1")
            ),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      buildRev();
      buildReversePermutation();
      buildFinalInverse();
      buildRawFFT();
      buildLog2();
      buildFFT3();
      buildIFFT();
      buildFFTJoin();
      buildFFTJoinExt();
      buildFFTJoinExtInv();
      buildFFTMix();
      buildFFTFinal();
      buildPrepareLagrangeEvaluation();
      module.exportFunction(prefix2 + "_fft");
      module.exportFunction(prefix2 + "_ifft");
      module.exportFunction(prefix2 + "_rawfft");
      module.exportFunction(prefix2 + "_fftJoin");
      module.exportFunction(prefix2 + "_fftJoinExt");
      module.exportFunction(prefix2 + "_fftJoinExtInv");
      module.exportFunction(prefix2 + "_fftMix");
      module.exportFunction(prefix2 + "_fftFinal");
      module.exportFunction(prefix2 + "_prepareLagrangeEvaluation");
    };
    build_pol = function buildPol(module, prefix2, prefixField) {
      const n64 = module.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildZero() {
        const f2 = module.addFunction(prefix2 + "_zero");
        f2.addParam("px", "i32");
        f2.addParam("n", "i32");
        f2.addLocal("lastp", "i32");
        f2.addLocal("p", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal("p", c2.getLocal("px")),
          c2.setLocal(
            "lastp",
            c2.i32_add(
              c2.getLocal("px"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("p"),
                c2.getLocal("lastp")
              )
            ),
            c2.call(prefixField + "_zero", c2.getLocal("p")),
            c2.setLocal("p", c2.i32_add(c2.getLocal("p"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildConstructLC() {
        const f2 = module.addFunction(prefix2 + "_constructLC");
        f2.addParam("ppolynomials", "i32");
        f2.addParam("psignals", "i32");
        f2.addParam("nSignals", "i32");
        f2.addParam("pres", "i32");
        f2.addLocal("i", "i32");
        f2.addLocal("j", "i32");
        f2.addLocal("pp", "i32");
        f2.addLocal("ps", "i32");
        f2.addLocal("pd", "i32");
        f2.addLocal("ncoefs", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.setLocal("i", c2.i32_const(0)),
          c2.setLocal("pp", c2.getLocal("ppolynomials")),
          c2.setLocal("ps", c2.getLocal("psignals")),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("i"),
                c2.getLocal("nSignals")
              )
            ),
            c2.setLocal("ncoefs", c2.i32_load(c2.getLocal("pp"))),
            c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(4))),
            c2.setLocal("j", c2.i32_const(0)),
            c2.block(c2.loop(
              c2.br_if(
                1,
                c2.i32_eq(
                  c2.getLocal("j"),
                  c2.getLocal("ncoefs")
                )
              ),
              c2.setLocal(
                "pd",
                c2.i32_add(
                  c2.getLocal("pres"),
                  c2.i32_mul(
                    c2.i32_load(c2.getLocal("pp")),
                    c2.i32_const(n8)
                  )
                )
              ),
              c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(4))),
              c2.call(
                prefixField + "_mul",
                c2.getLocal("ps"),
                c2.getLocal("pp"),
                aux
              ),
              c2.call(
                prefixField + "_add",
                aux,
                c2.getLocal("pd"),
                c2.getLocal("pd")
              ),
              c2.setLocal("pp", c2.i32_add(c2.getLocal("pp"), c2.i32_const(n8))),
              c2.setLocal("j", c2.i32_add(c2.getLocal("j"), c2.i32_const(1))),
              c2.br(0)
            )),
            c2.setLocal("ps", c2.i32_add(c2.getLocal("ps"), c2.i32_const(n8))),
            c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      buildZero();
      buildConstructLC();
      module.exportFunction(prefix2 + "_zero");
      module.exportFunction(prefix2 + "_constructLC");
      return prefix2;
    };
    build_qap = function buildQAP(module, prefix2, prefixField) {
      const n64 = module.modules[prefixField].n64;
      const n8 = n64 * 8;
      function buildBuildABC() {
        const f2 = module.addFunction(prefix2 + "_buildABC");
        f2.addParam("pCoefs", "i32");
        f2.addParam("nCoefs", "i32");
        f2.addParam("pWitness", "i32");
        f2.addParam("pA", "i32");
        f2.addParam("pB", "i32");
        f2.addParam("pC", "i32");
        f2.addParam("offsetOut", "i32");
        f2.addParam("nOut", "i32");
        f2.addParam("offsetWitness", "i32");
        f2.addParam("nWitness", "i32");
        f2.addLocal("it", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("last", "i32");
        f2.addLocal("m", "i32");
        f2.addLocal("c", "i32");
        f2.addLocal("s", "i32");
        f2.addLocal("pOut", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module.alloc(n8));
        f2.addCode(
          // Set output a and b to 0
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("nOut"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(prefixField + "_zero", c2.getLocal("ita")),
            c2.call(prefixField + "_zero", c2.getLocal("itb")),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.br(0)
          )),
          c2.setLocal("it", c2.getLocal("pCoefs")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pCoefs"),
              c2.i32_mul(
                c2.getLocal("nCoefs"),
                c2.i32_const(n8 + 12)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("it"),
                c2.getLocal("last")
              )
            ),
            c2.setLocal(
              "s",
              c2.i32_load(c2.getLocal("it"), 8)
            ),
            c2.if(
              c2.i32_or(
                c2.i32_lt_u(
                  c2.getLocal("s"),
                  c2.getLocal("offsetWitness")
                ),
                c2.i32_ge_u(
                  c2.getLocal("s"),
                  c2.i32_add(
                    c2.getLocal("offsetWitness"),
                    c2.getLocal("nWitness")
                  )
                )
              ),
              [
                ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                ...c2.br(1)
              ]
            ),
            c2.setLocal(
              "m",
              c2.i32_load(c2.getLocal("it"))
            ),
            c2.if(
              c2.i32_eq(c2.getLocal("m"), c2.i32_const(0)),
              c2.setLocal("pOut", c2.getLocal("pA")),
              c2.if(
                c2.i32_eq(c2.getLocal("m"), c2.i32_const(1)),
                c2.setLocal("pOut", c2.getLocal("pB")),
                [
                  ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                  ...c2.br(1)
                ]
              )
            ),
            c2.setLocal(
              "c",
              c2.i32_load(c2.getLocal("it"), 4)
            ),
            c2.if(
              c2.i32_or(
                c2.i32_lt_u(
                  c2.getLocal("c"),
                  c2.getLocal("offsetOut")
                ),
                c2.i32_ge_u(
                  c2.getLocal("c"),
                  c2.i32_add(
                    c2.getLocal("offsetOut"),
                    c2.getLocal("nOut")
                  )
                )
              ),
              [
                ...c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
                ...c2.br(1)
              ]
            ),
            c2.setLocal(
              "pOut",
              c2.i32_add(
                c2.getLocal("pOut"),
                c2.i32_mul(
                  c2.i32_sub(
                    c2.getLocal("c"),
                    c2.getLocal("offsetOut")
                  ),
                  c2.i32_const(n8)
                )
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.i32_add(
                c2.getLocal("pWitness"),
                c2.i32_mul(
                  c2.i32_sub(c2.getLocal("s"), c2.getLocal("offsetWitness")),
                  c2.i32_const(n8)
                )
              ),
              c2.i32_add(c2.getLocal("it"), c2.i32_const(12)),
              aux
            ),
            c2.call(
              prefixField + "_add",
              c2.getLocal("pOut"),
              aux,
              c2.getLocal("pOut")
            ),
            c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8 + 12))),
            c2.br(0)
          )),
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal("it", c2.getLocal("pC")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("nOut"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              c2.getLocal("it")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("it", c2.i32_add(c2.getLocal("it"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildJoinABC() {
        const f2 = module.addFunction(prefix2 + "_joinABC");
        f2.addParam("pA", "i32");
        f2.addParam("pB", "i32");
        f2.addParam("pC", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pP", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("itc", "i32");
        f2.addLocal("itp", "i32");
        f2.addLocal("last", "i32");
        const c2 = f2.getCodeBuilder();
        const aux = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.setLocal("ita", c2.getLocal("pA")),
          c2.setLocal("itb", c2.getLocal("pB")),
          c2.setLocal("itc", c2.getLocal("pC")),
          c2.setLocal("itp", c2.getLocal("pP")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pA"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_mul",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              aux
            ),
            c2.call(
              prefixField + "_sub",
              aux,
              c2.getLocal("itc"),
              c2.getLocal("itp")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("itc", c2.i32_add(c2.getLocal("itc"), c2.i32_const(n8))),
            c2.setLocal("itp", c2.i32_add(c2.getLocal("itp"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      function buildBatchAdd() {
        const f2 = module.addFunction(prefix2 + "_batchAdd");
        f2.addParam("pa", "i32");
        f2.addParam("pb", "i32");
        f2.addParam("n", "i32");
        f2.addParam("pr", "i32");
        f2.addLocal("ita", "i32");
        f2.addLocal("itb", "i32");
        f2.addLocal("itr", "i32");
        f2.addLocal("last", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.setLocal("ita", c2.getLocal("pa")),
          c2.setLocal("itb", c2.getLocal("pb")),
          c2.setLocal("itr", c2.getLocal("pr")),
          c2.setLocal(
            "last",
            c2.i32_add(
              c2.getLocal("pa"),
              c2.i32_mul(
                c2.getLocal("n"),
                c2.i32_const(n8)
              )
            )
          ),
          c2.block(c2.loop(
            c2.br_if(
              1,
              c2.i32_eq(
                c2.getLocal("ita"),
                c2.getLocal("last")
              )
            ),
            c2.call(
              prefixField + "_add",
              c2.getLocal("ita"),
              c2.getLocal("itb"),
              c2.getLocal("itr")
            ),
            c2.setLocal("ita", c2.i32_add(c2.getLocal("ita"), c2.i32_const(n8))),
            c2.setLocal("itb", c2.i32_add(c2.getLocal("itb"), c2.i32_const(n8))),
            c2.setLocal("itr", c2.i32_add(c2.getLocal("itr"), c2.i32_const(n8))),
            c2.br(0)
          ))
        );
      }
      buildBuildABC();
      buildJoinABC();
      buildBatchAdd();
      module.exportFunction(prefix2 + "_buildABC");
      module.exportFunction(prefix2 + "_joinABC");
      module.exportFunction(prefix2 + "_batchAdd");
      return prefix2;
    };
    build_applykey = function buildApplyKey(module, fnName, gPrefix, frPrefix, sizeGIn, sizeGOut, sizeF, opGtimesF) {
      const f2 = module.addFunction(fnName);
      f2.addParam("pIn", "i32");
      f2.addParam("n", "i32");
      f2.addParam("pFirst", "i32");
      f2.addParam("pInc", "i32");
      f2.addParam("pOut", "i32");
      f2.addLocal("pOldFree", "i32");
      f2.addLocal("i", "i32");
      f2.addLocal("pFrom", "i32");
      f2.addLocal("pTo", "i32");
      const c2 = f2.getCodeBuilder();
      const t = c2.i32_const(module.alloc(sizeF));
      f2.addCode(
        c2.setLocal("pFrom", c2.getLocal("pIn")),
        c2.setLocal("pTo", c2.getLocal("pOut"))
      );
      f2.addCode(
        c2.call(
          frPrefix + "_copy",
          c2.getLocal("pFirst"),
          t
        )
      );
      f2.addCode(
        c2.setLocal("i", c2.i32_const(0)),
        c2.block(c2.loop(
          c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.getLocal("n"))),
          c2.call(
            opGtimesF,
            c2.getLocal("pFrom"),
            t,
            c2.getLocal("pTo")
          ),
          c2.setLocal("pFrom", c2.i32_add(c2.getLocal("pFrom"), c2.i32_const(sizeGIn))),
          c2.setLocal("pTo", c2.i32_add(c2.getLocal("pTo"), c2.i32_const(sizeGOut))),
          // t = t* inc
          c2.call(
            frPrefix + "_mul",
            t,
            c2.getLocal("pInc"),
            t
          ),
          c2.setLocal("i", c2.i32_add(c2.getLocal("i"), c2.i32_const(1))),
          c2.br(0)
        ))
      );
      module.exportFunction(fnName);
    };
    utils$2 = utils$6;
    buildF1m$1 = build_f1m;
    buildF1$1 = build_f1;
    buildF2m$1 = build_f2m;
    buildF3m$1 = build_f3m;
    buildCurve$1 = build_curve_jacobian_a0;
    buildFFT$2 = build_fft;
    buildPol$1 = build_pol;
    buildQAP$1 = build_qap;
    buildApplyKey$1 = build_applykey;
    ({ bitLength: bitLength$2, modInv, isOdd: isOdd$1, isNegative: isNegative$2 } = bigint);
    build_bn128 = function buildBN128(module, _prefix) {
      const prefix2 = _prefix || "bn128";
      if (module.modules[prefix2]) return prefix2;
      const q2 = 21888242871839275222246405745257275088696311157297823662689037894645226208583n;
      const r2 = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
      const n64 = Math.floor((bitLength$2(q2 - 1n) - 1) / 64) + 1;
      const n8 = n64 * 8;
      const frsize = n8;
      const f1size = n8;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const pr = module.alloc(utils$2.bigInt2BytesLE(r2, frsize));
      const f1mPrefix = buildF1m$1(module, q2, "f1m");
      buildF1$1(module, r2, "fr", "frm");
      const pG1b = module.alloc(utils$2.bigInt2BytesLE(toMontgomery(3n), f1size));
      const g1mPrefix = buildCurve$1(module, "g1m", "f1m", pG1b);
      buildFFT$2(module, "frm", "frm", "frm", "frm_mul");
      buildPol$1(module, "pol", "frm");
      buildQAP$1(module, "qap", "frm");
      const f2mPrefix = buildF2m$1(module, "f1m_neg", "f2m", "f1m");
      const pG2b = module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      const g2mPrefix = buildCurve$1(module, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f2 = module.addFunction(fnName);
        f2.addParam("pG", "i32");
        f2.addParam("pFr", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8));
        f2.addCode(
          c2.call("frm_fromMontgomery", c2.getLocal("pFr"), AUX),
          c2.call(
            opMul,
            c2.getLocal("pG"),
            AUX,
            c2.i32_const(n8),
            c2.getLocal("pr")
          )
        );
        module.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT$2(module, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT$2(module, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey$1(module, "frm_batchApplyKey", "fmr", "frm", n8, n8, n8, "frm_mul");
      buildApplyKey$1(module, "g1m_batchApplyKey", "g1m", "frm", n8 * 3, n8 * 3, n8, "g1m_timesFr");
      buildApplyKey$1(module, "g1m_batchApplyKeyMixed", "g1m", "frm", n8 * 2, n8 * 3, n8, "g1m_timesFrAffine");
      buildApplyKey$1(module, "g2m_batchApplyKey", "g2m", "frm", n8 * 2 * 3, n8 * 3 * 2, n8, "g2m_timesFr");
      buildApplyKey$1(module, "g2m_batchApplyKeyMixed", "g2m", "frm", n8 * 2 * 2, n8 * 3 * 2, n8, "g2m_timesFrAffine");
      function toMontgomery(a2) {
        return BigInt(a2) * (1n << BigInt(f1size * 8)) % q2;
      }
      const G1gen = [
        1n,
        2n,
        1n
      ];
      const pG1gen = module.alloc(
        [
          ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module.alloc(
        [
          ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          10857046999023057135944570762232829481370756359578518086990519993285655852781n,
          11559732032986387107991004021392285783925812861821192530917403151452391805634n
        ],
        [
          8495653923123431417604973247489272438418190587263600148770280649306958101930n,
          4082367875863433681332203403145435568316851327593401208105741076214120093531n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module.alloc(
        [
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module.alloc(
        [
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery(1), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(0), f1size)
      ]);
      const pNonResidueF6 = module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery(9), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(1), f1size)
      ]);
      const pTwoInv = module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery(modInv(2n, q2)), f1size),
        ...utils$2.bigInt2BytesLE(0n, f1size)
      ]);
      const pAltBn128Twist = pNonResidueF6;
      const pTwistCoefB = module.alloc([
        ...utils$2.bigInt2BytesLE(toMontgomery(19485874751759354771024239261021720505790618469301721065564631296452457478373n), f1size),
        ...utils$2.bigInt2BytesLE(toMontgomery(266929791119991161246907387137283842545076965332900288569378510910307636690n), f1size)
      ]);
      function build_mulNR6() {
        const f2 = module.addFunction(prefix2 + "_mulNR6");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(
            f2mPrefix + "_mul",
            c2.i32_const(pNonResidueF6),
            c2.getLocal("x"),
            c2.getLocal("pr")
          )
        );
      }
      build_mulNR6();
      const f6mPrefix = buildF3m$1(module, prefix2 + "_mulNR6", "f6m", "f2m");
      function build_mulNR12() {
        const f2 = module.addFunction(prefix2 + "_mulNR12");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(
            f2mPrefix + "_mul",
            c2.i32_const(pNonResidueF6),
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8 * 4)),
            c2.getLocal("pr")
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.getLocal("x"),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 2))
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8 * 2)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8 * 4))
          )
        );
      }
      build_mulNR12();
      const ftmPrefix = buildF2m$1(module, prefix2 + "_mulNR12", "ftm", f6mPrefix);
      const ateLoopCount = 29793968203157093288n;
      const ateLoopBitBytes = bits2(ateLoopCount);
      const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b2) => acc + (b2 != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8;
      const preQSize = 3 * n8 * 2 + ateNCoefs * ateCoefSize;
      module.modules[prefix2] = {
        n64,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module.modules["f1m"].pq,
        pr,
        pOneT,
        prePSize,
        preQSize,
        r: r2.toString(),
        q: q2.toString()
      };
      const finalExpZ = 4965661367192848881n;
      function naf2(n) {
        let E2 = n;
        const res = [];
        while (E2 > 0n) {
          if (isOdd$1(E2)) {
            const z2 = 2 - Number(E2 % 4n);
            res.push(z2);
            E2 = E2 - BigInt(z2);
          } else {
            res.push(0);
          }
          E2 = E2 >> 1n;
        }
        return res;
      }
      function bits2(n) {
        let E2 = n;
        const res = [];
        while (E2 > 0n) {
          if (isOdd$1(E2)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E2 = E2 >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f2 = module.addFunction(prefix2 + "_prepareG1");
        f2.addParam("pP", "i32");
        f2.addParam("ppreP", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(g1mPrefix + "_normalize", c2.getLocal("pP"), c2.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepAddStep() {
        const f2 = module.addFunction(prefix2 + "_prepAddStep");
        f2.addParam("pQ", "i32");
        f2.addParam("pR", "i32");
        f2.addParam("pCoef", "i32");
        const c2 = f2.getCodeBuilder();
        const X2 = c2.getLocal("pQ");
        const Y2 = c2.i32_add(c2.getLocal("pQ"), c2.i32_const(f2size));
        const X1 = c2.getLocal("pR");
        const Y1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f2size));
        const Z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * f2size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const D2 = ELL_VW;
        const E2 = c2.i32_const(module.alloc(f2size));
        const F2 = c2.i32_const(module.alloc(f2size));
        const G2 = c2.i32_const(module.alloc(f2size));
        const H2 = c2.i32_const(module.alloc(f2size));
        const I2 = c2.i32_const(module.alloc(f2size));
        const J2 = c2.i32_const(module.alloc(f2size));
        const AUX = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          // D = X1 - X2*Z1
          c2.call(f2mPrefix + "_mul", X2, Z1, D2),
          c2.call(f2mPrefix + "_sub", X1, D2, D2),
          // E = Y1 - Y2*Z1
          c2.call(f2mPrefix + "_mul", Y2, Z1, E2),
          c2.call(f2mPrefix + "_sub", Y1, E2, E2),
          // F = D^2
          c2.call(f2mPrefix + "_square", D2, F2),
          // G = E^2
          c2.call(f2mPrefix + "_square", E2, G2),
          // H = D*F
          c2.call(f2mPrefix + "_mul", D2, F2, H2),
          // I = X1 * F
          c2.call(f2mPrefix + "_mul", X1, F2, I2),
          // J = H + Z1*G - (I+I)
          c2.call(f2mPrefix + "_add", I2, I2, AUX),
          c2.call(f2mPrefix + "_mul", Z1, G2, J2),
          c2.call(f2mPrefix + "_add", H2, J2, J2),
          c2.call(f2mPrefix + "_sub", J2, AUX, J2),
          // X3 (X1) = D*J
          c2.call(f2mPrefix + "_mul", D2, J2, X1),
          // Y3 (Y1) = E*(I-J)-(H*Y1)
          c2.call(f2mPrefix + "_mul", H2, Y1, Y1),
          c2.call(f2mPrefix + "_sub", I2, J2, AUX),
          c2.call(f2mPrefix + "_mul", E2, AUX, AUX),
          c2.call(f2mPrefix + "_sub", AUX, Y1, Y1),
          // Z3 (Z1) = Z1*H
          c2.call(f2mPrefix + "_mul", Z1, H2, Z1),
          // ell_0 = xi * (E * X2 - D * Y2)
          c2.call(f2mPrefix + "_mul", D2, Y2, AUX),
          c2.call(f2mPrefix + "_mul", E2, X2, ELL_0),
          c2.call(f2mPrefix + "_sub", ELL_0, AUX, ELL_0),
          c2.call(f2mPrefix + "_mul", ELL_0, c2.i32_const(pAltBn128Twist), ELL_0),
          // ell_VV = - E (later: * xP)
          c2.call(f2mPrefix + "_neg", E2, ELL_VV)
          // ell_VW = D (later: * yP    )
          // Already assigned
        );
      }
      function buildPrepDoubleStep() {
        const f2 = module.addFunction(prefix2 + "_prepDblStep");
        f2.addParam("pR", "i32");
        f2.addParam("pCoef", "i32");
        const c2 = f2.getCodeBuilder();
        const X1 = c2.getLocal("pR");
        const Y1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f2size));
        const Z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * f2size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const A2 = c2.i32_const(module.alloc(f2size));
        const B2 = c2.i32_const(module.alloc(f2size));
        const C2 = c2.i32_const(module.alloc(f2size));
        const D2 = c2.i32_const(module.alloc(f2size));
        const E2 = c2.i32_const(module.alloc(f2size));
        const F2 = c2.i32_const(module.alloc(f2size));
        const G2 = c2.i32_const(module.alloc(f2size));
        const H2 = c2.i32_const(module.alloc(f2size));
        const I2 = c2.i32_const(module.alloc(f2size));
        const J2 = c2.i32_const(module.alloc(f2size));
        const E22 = c2.i32_const(module.alloc(f2size));
        const AUX = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          // A = X1 * Y1 / 2
          c2.call(f2mPrefix + "_mul", Y1, c2.i32_const(pTwoInv), A2),
          c2.call(f2mPrefix + "_mul", X1, A2, A2),
          // B = Y1^2
          c2.call(f2mPrefix + "_square", Y1, B2),
          // C = Z1^2
          c2.call(f2mPrefix + "_square", Z1, C2),
          // D = 3 * C
          c2.call(f2mPrefix + "_add", C2, C2, D2),
          c2.call(f2mPrefix + "_add", D2, C2, D2),
          // E = twist_b * D
          c2.call(f2mPrefix + "_mul", c2.i32_const(pTwistCoefB), D2, E2),
          // F = 3 * E
          c2.call(f2mPrefix + "_add", E2, E2, F2),
          c2.call(f2mPrefix + "_add", E2, F2, F2),
          // G = (B+F)/2
          c2.call(f2mPrefix + "_add", B2, F2, G2),
          c2.call(f2mPrefix + "_mul", G2, c2.i32_const(pTwoInv), G2),
          // H = (Y1+Z1)^2-(B+C)
          c2.call(f2mPrefix + "_add", B2, C2, AUX),
          c2.call(f2mPrefix + "_add", Y1, Z1, H2),
          c2.call(f2mPrefix + "_square", H2, H2),
          c2.call(f2mPrefix + "_sub", H2, AUX, H2),
          // I = E-B
          c2.call(f2mPrefix + "_sub", E2, B2, I2),
          // J = X1^2
          c2.call(f2mPrefix + "_square", X1, J2),
          // E_squared = E^2
          c2.call(f2mPrefix + "_square", E2, E22),
          // X3 (X1) = A * (B-F)
          c2.call(f2mPrefix + "_sub", B2, F2, AUX),
          c2.call(f2mPrefix + "_mul", A2, AUX, X1),
          // Y3 (Y1) = G^2 - 3*E^2
          c2.call(f2mPrefix + "_add", E22, E22, AUX),
          c2.call(f2mPrefix + "_add", E22, AUX, AUX),
          c2.call(f2mPrefix + "_square", G2, Y1),
          c2.call(f2mPrefix + "_sub", Y1, AUX, Y1),
          // Z3 (Z1) = B * H
          c2.call(f2mPrefix + "_mul", B2, H2, Z1),
          // ell_0 = xi * I
          c2.call(f2mPrefix + "_mul", c2.i32_const(pAltBn128Twist), I2, ELL_0),
          // ell_VW = - H (later: * yP)
          c2.call(f2mPrefix + "_neg", H2, ELL_VW),
          // ell_VV = 3*J (later: * xP)
          c2.call(f2mPrefix + "_add", J2, J2, ELL_VV),
          c2.call(f2mPrefix + "_add", J2, ELL_VV, ELL_VV)
        );
      }
      function buildMulByQ() {
        const f2 = module.addFunction(prefix2 + "_mulByQ");
        f2.addParam("p1", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("p1");
        const y2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(f2size));
        const z2 = c2.i32_add(c2.getLocal("p1"), c2.i32_const(f2size * 2));
        const x3 = c2.getLocal("pr");
        const y3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f2size));
        const z3 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f2size * 2));
        const MulByQX = c2.i32_const(module.alloc([
          ...utils$2.bigInt2BytesLE(toMontgomery("21575463638280843010398324269430826099269044274347216827212613867836435027261"), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery("10307601595873709700152284273816112264069230130616436755625194854815875713954"), f1size)
        ]));
        const MulByQY = c2.i32_const(module.alloc([
          ...utils$2.bigInt2BytesLE(toMontgomery("2821565182194536844548159561693502659359617185244120367078079554186484126554"), f1size),
          ...utils$2.bigInt2BytesLE(toMontgomery("3505843767911556378687030309984248845540243509899259641013678093033130930403"), f1size)
        ]));
        f2.addCode(
          // The frobeniusMap(1) in this field, is the conjugate
          c2.call(f2mPrefix + "_conjugate", x2, x3),
          c2.call(f2mPrefix + "_mul", MulByQX, x3, x3),
          c2.call(f2mPrefix + "_conjugate", y2, y3),
          c2.call(f2mPrefix + "_mul", MulByQY, y3, y3),
          c2.call(f2mPrefix + "_conjugate", z2, z3)
        );
      }
      function buildPrepareG2() {
        buildMulByQ();
        const f2 = module.addFunction(prefix2 + "_prepareG2");
        f2.addParam("pQ", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const QX = c2.getLocal("pQ");
        const pR = module.alloc(f2size * 3);
        const R2 = c2.i32_const(pR);
        const RX = c2.i32_const(pR);
        const RY = c2.i32_const(pR + f2size);
        const RZ = c2.i32_const(pR + 2 * f2size);
        const cQX = c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(0));
        const cQY = c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size));
        const pQ1 = module.alloc(f2size * 3);
        const Q1 = c2.i32_const(pQ1);
        const pQ2 = module.alloc(f2size * 3);
        const Q2 = c2.i32_const(pQ2);
        const Q2Y = c2.i32_const(pQ2 + f2size);
        f2.addCode(
          c2.call(g2mPrefix + "_normalize", QX, cQX),
          // TODO Remove if already in affine
          c2.call(f2mPrefix + "_copy", cQX, RX),
          c2.call(f2mPrefix + "_copy", cQY, RY),
          c2.call(f2mPrefix + "_one", RZ)
        );
        f2.addCode(
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix2 + "_prepDblStep", R2, c2.getLocal("pCoef")),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix2 + "_prepAddStep", cQX, R2, c2.getLocal("pCoef")),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        f2.addCode(
          c2.call(prefix2 + "_mulByQ", cQX, Q1),
          c2.call(prefix2 + "_mulByQ", Q1, Q2)
        );
        f2.addCode(
          c2.call(f2mPrefix + "_neg", Q2Y, Q2Y),
          c2.call(prefix2 + "_prepAddStep", Q1, R2, c2.getLocal("pCoef")),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
          c2.call(prefix2 + "_prepAddStep", Q2, R2, c2.getLocal("pCoef")),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
        );
      }
      function buildMulBy024Old() {
        const f2 = module.addFunction(prefix2 + "__mulBy024Old");
        f2.addParam("pEll0", "i32");
        f2.addParam("pEllVW", "i32");
        f2.addParam("pEllVV", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("pEll0");
        const x2 = c2.getLocal("pEllVV");
        const x4 = c2.getLocal("pEllVW");
        const z0 = c2.getLocal("pR");
        const pAUX12 = module.alloc(ftsize);
        const AUX12 = c2.i32_const(pAUX12);
        const AUX12_0 = c2.i32_const(pAUX12);
        const AUX12_2 = c2.i32_const(pAUX12 + f2size);
        const AUX12_4 = c2.i32_const(pAUX12 + f2size * 2);
        const AUX12_6 = c2.i32_const(pAUX12 + f2size * 3);
        const AUX12_8 = c2.i32_const(pAUX12 + f2size * 4);
        const AUX12_10 = c2.i32_const(pAUX12 + f2size * 5);
        f2.addCode(
          c2.call(f2mPrefix + "_copy", x0, AUX12_0),
          c2.call(f2mPrefix + "_zero", AUX12_2),
          c2.call(f2mPrefix + "_copy", x2, AUX12_4),
          c2.call(f2mPrefix + "_zero", AUX12_6),
          c2.call(f2mPrefix + "_copy", x4, AUX12_8),
          c2.call(f2mPrefix + "_zero", AUX12_10),
          c2.call(ftmPrefix + "_mul", AUX12, z0, z0)
        );
      }
      function buildMulBy024() {
        const f2 = module.addFunction(prefix2 + "__mulBy024");
        f2.addParam("pEll0", "i32");
        f2.addParam("pEllVW", "i32");
        f2.addParam("pEllVV", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("pEll0");
        const x2 = c2.getLocal("pEllVV");
        const x4 = c2.getLocal("pEllVW");
        const z0 = c2.getLocal("pR");
        const z1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(2 * n8));
        const z2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(4 * n8));
        const z3 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(6 * n8));
        const z4 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(8 * n8));
        const z5 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(10 * n8));
        const t0 = c2.i32_const(module.alloc(f2size));
        const t1 = c2.i32_const(module.alloc(f2size));
        const t2 = c2.i32_const(module.alloc(f2size));
        const s0 = c2.i32_const(module.alloc(f2size));
        const T3 = c2.i32_const(module.alloc(f2size));
        const T4 = c2.i32_const(module.alloc(f2size));
        const D0 = c2.i32_const(module.alloc(f2size));
        const D2 = c2.i32_const(module.alloc(f2size));
        const D4 = c2.i32_const(module.alloc(f2size));
        const S1 = c2.i32_const(module.alloc(f2size));
        const AUX = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          // D0 = z0 * x0;
          c2.call(f2mPrefix + "_mul", z0, x0, D0),
          // D2 = z2 * x2;
          c2.call(f2mPrefix + "_mul", z2, x2, D2),
          // D4 = z4 * x4;
          c2.call(f2mPrefix + "_mul", z4, x4, D4),
          // t2 = z0 + z4;
          c2.call(f2mPrefix + "_add", z0, z4, t2),
          // t1 = z0 + z2;
          c2.call(f2mPrefix + "_add", z0, z2, t1),
          // s0 = z1 + z3 + z5;
          c2.call(f2mPrefix + "_add", z1, z3, s0),
          c2.call(f2mPrefix + "_add", s0, z5, s0),
          // For z.a_.a_ = z0.
          // S1 = z1 * x2;
          c2.call(f2mPrefix + "_mul", z1, x2, S1),
          // T3 = S1 + D4;
          c2.call(f2mPrefix + "_add", S1, D4, T3),
          // T4 = my_Fp6::non_residue * T3 + D0;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T3, T4),
          c2.call(f2mPrefix + "_add", T4, D0, z0),
          // z0 = T4;
          // For z.a_.b_ = z1
          // T3 = z5 * x4;
          c2.call(f2mPrefix + "_mul", z5, x4, T3),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S1, T3, S1),
          // T3 = T3 + D2;
          c2.call(f2mPrefix + "_add", T3, D2, T3),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T3, T4),
          // T3 = z1 * x0;
          c2.call(f2mPrefix + "_mul", z1, x0, T3),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T4, T3, z1),
          // z1 = T4;
          // For z.a_.c_ = z2
          // t0 = x0 + x2;
          c2.call(f2mPrefix + "_add", x0, x2, t0),
          // T3 = t1 * t0 - D0 - D2;
          c2.call(f2mPrefix + "_mul", t1, t0, T3),
          c2.call(f2mPrefix + "_add", D0, D2, AUX),
          c2.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = z3 * x4;
          c2.call(f2mPrefix + "_mul", z3, x4, T4),
          // S1 = S1 + T4;
          c2.call(f2mPrefix + "_add", S1, T4, S1),
          // For z.b_.a_ = z3 (z3 needs z2)
          // t0 = z2 + z4;
          c2.call(f2mPrefix + "_add", z2, z4, t0),
          // T3 = T3 + T4;
          // z2 = T3;
          c2.call(f2mPrefix + "_add", T3, T4, z2),
          // t1 = x2 + x4;
          c2.call(f2mPrefix + "_add", x2, x4, t1),
          // T3 = t0 * t1 - D2 - D4;
          c2.call(f2mPrefix + "_mul", t1, t0, T3),
          c2.call(f2mPrefix + "_add", D2, D4, AUX),
          c2.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T3, T4),
          // T3 = z3 * x0;
          c2.call(f2mPrefix + "_mul", z3, x0, T3),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T4, T3, z3),
          // z3 = T4;
          // For z.b_.b_ = z4
          // T3 = z5 * x2;
          c2.call(f2mPrefix + "_mul", z5, x2, T3),
          // S1 = S1 + T3;
          c2.call(f2mPrefix + "_add", S1, T3, S1),
          // T4 = my_Fp6::non_residue * T3;
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), T3, T4),
          // t0 = x0 + x4;
          c2.call(f2mPrefix + "_add", x0, x4, t0),
          // T3 = t2 * t0 - D0 - D4;
          c2.call(f2mPrefix + "_mul", t2, t0, T3),
          c2.call(f2mPrefix + "_add", D0, D4, AUX),
          c2.call(f2mPrefix + "_sub", T3, AUX, T3),
          // T4 = T4 + T3;
          c2.call(f2mPrefix + "_add", T4, T3, z4),
          // z4 = T4;
          // For z.b_.c_ = z5.
          // t0 = x0 + x2 + x4;
          c2.call(f2mPrefix + "_add", x0, x2, t0),
          c2.call(f2mPrefix + "_add", t0, x4, t0),
          // T3 = s0 * t0 - S1;
          c2.call(f2mPrefix + "_mul", s0, t0, T3),
          c2.call(f2mPrefix + "_sub", T3, S1, z5)
          // z5 = T3;
        );
      }
      function buildMillerLoop() {
        const f2 = module.addFunction(prefix2 + "_millerLoop");
        f2.addParam("ppreP", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const preP_PX = c2.getLocal("ppreP");
        const preP_PY = c2.i32_add(c2.getLocal("ppreP"), c2.i32_const(f1size));
        const ELL_0 = c2.getLocal("pCoef");
        const ELL_VW = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(f2size));
        const ELL_VV = c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(2 * f2size));
        const pVW = module.alloc(f2size);
        const VW = c2.i32_const(pVW);
        const pVV = module.alloc(f2size);
        const VV = c2.i32_const(pVV);
        const F2 = c2.getLocal("r");
        f2.addCode(
          c2.call(ftmPrefix + "_one", F2),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(ftmPrefix + "_square", F2, F2),
            c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
            c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
            c2.call(prefix2 + "__mulBy024", ELL_0, VW, VV, F2),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
                ...c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
                ...c2.call(prefix2 + "__mulBy024", ELL_0, VW, VV, F2),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        f2.addCode(
          c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c2.call(prefix2 + "__mulBy024", ELL_0, VW, VV, F2),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
          c2.call(f2mPrefix + "_mul1", ELL_VW, preP_PY, VW),
          c2.call(f2mPrefix + "_mul1", ELL_VV, preP_PX, VV),
          c2.call(prefix2 + "__mulBy024", ELL_0, VW, VV, F2),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
        );
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [8376118865763821496583973867626364092589906065868298776909617916018768340080n, 16469823323077808223889137241176536799009286646108169935659301613961712198316n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556617n, 0n],
            [11697423496358154304825782922584725312912383441159505038794027105778954184319n, 303847389135065887422783454877609941456349188919719272345083954437860409601n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3321304630594332808241809054958361220322477375291206261884409189760185844239n, 5722266937896532885780051958958348231143373700109372999374820235121374419868n],
            [21888242871839275222246405745257275088696311157297823662689037894645226208582n, 0n],
            [13512124006075453725662431877630910996106405091429524885779419978626457868503n, 5418419548761466998357268504080738289687024511189653727029736280683514010267n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [10190819375481120917420622822672549775783927716138318623895010788866272024264n, 21584395482704209334823622290379665147239961968378104390343953940207365798982n],
            [2203960485148121921418603742825762020974279258880205651967n, 0n],
            [18566938241244942414004596690298913868373833782006617400804628704885040364344n, 16165975933942742336466353786298926857552937457188450663314217659523851788715n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [21575463638280843010398324269430826099269044274347216827212613867836435027261n, 10307601595873709700152284273816112264069230130616436755625194854815875713954n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [3772000881919853776433695186713858239009073593817195771773381919316419345261n, 2236595495967245188281701248203181795121068902605861227855261137820944008926n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [18429021223477853657660792034369865839114504446431234726392080002137598044644n, 9344045779998320333812420223237981029506012124075525679208581902008406485703n]
          ],
          [
            [1n, 0n],
            [2581911344467009335267311115468803099551665605076196740867805258568234346338n, 19937756971775647987995932169929341994314640652964949448313374472400716661030n],
            [2203960485148121921418603742825762020974279258880205651966n, 0n],
            [5324479202449903542726783395506214481928257762400643279780343368557297135718n, 16208900380737693084919495127334387981393726419856888799917914180988844123039n],
            [21888242871839275220042445260109153167277707414472061641714758635765020556616n, 0n],
            [13981852324922362344252311234282257507216387789820983642040889267519694726527n, 7629828391165209371577384193250820201684255241773809077146787135900891633097n]
          ]
        ];
        const f2 = module.addFunction(prefix2 + "__frobeniusMap" + n);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < 6; i2++) {
          const X2 = i2 == 0 ? c2.getLocal("x") : c2.i32_add(c2.getLocal("x"), c2.i32_const(i2 * f2size));
          const Xc0 = X2;
          const Xc1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(i2 * f2size + f1size));
          const R2 = i2 == 0 ? c2.getLocal("r") : c2.i32_add(c2.getLocal("r"), c2.i32_const(i2 * f2size));
          const Rc0 = R2;
          const Rc1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(i2 * f2size + f1size));
          const coef = mul2(F12[Math.floor(i2 / 3)][n % 12], F6[i2 % 3][n % 6]);
          const pCoef = module.alloc([
            ...utils$2.bigInt2BytesLE(toMontgomery(coef[0]), 32),
            ...utils$2.bigInt2BytesLE(toMontgomery(coef[1]), 32)
          ]);
          if (n % 2 == 1) {
            f2.addCode(
              c2.call(f1mPrefix + "_copy", Xc0, Rc0),
              c2.call(f1mPrefix + "_neg", Xc1, Rc1),
              c2.call(f2mPrefix + "_mul", R2, c2.i32_const(pCoef), R2)
            );
          } else {
            f2.addCode(c2.call(f2mPrefix + "_mul", X2, c2.i32_const(pCoef), R2));
          }
        }
        function mul2(a2, b2) {
          const ac0 = BigInt(a2[0]);
          const ac1 = BigInt(a2[1]);
          const bc0 = BigInt(b2[0]);
          const bc1 = BigInt(b2[1]);
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q2,
            (ac0 * bc1 + ac1 * bc0) % q2
          ];
          if (isNegative$2(res[0])) res[0] = res[0] + q2;
          return res;
        }
      }
      function buildFinalExponentiationFirstChunk() {
        const f2 = module.addFunction(prefix2 + "__finalExponentiationFirstChunk");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const eltC0 = elt;
        const eltC1 = c2.i32_add(elt, c2.i32_const(n8 * 6));
        const r3 = c2.getLocal("r");
        const pA = module.alloc(ftsize);
        const A2 = c2.i32_const(pA);
        const Ac0 = A2;
        const Ac1 = c2.i32_const(pA + n8 * 6);
        const B2 = c2.i32_const(module.alloc(ftsize));
        const C2 = c2.i32_const(module.alloc(ftsize));
        const D2 = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          // const alt_bn128_Fq12 A = alt_bn128_Fq12(elt.c0,-elt.c1);
          c2.call(f6mPrefix + "_copy", eltC0, Ac0),
          c2.call(f6mPrefix + "_neg", eltC1, Ac1),
          // const alt_bn128_Fq12 B = elt.inverse();
          c2.call(ftmPrefix + "_inverse", elt, B2),
          // const alt_bn128_Fq12 C = A * B;
          c2.call(ftmPrefix + "_mul", A2, B2, C2),
          // const alt_bn128_Fq12 D = C.Frobenius_map(2);
          c2.call(prefix2 + "__frobeniusMap2", C2, D2),
          // const alt_bn128_Fq12 result = D * C;
          c2.call(ftmPrefix + "_mul", C2, D2, r3)
        );
      }
      function buildCyclotomicSquare() {
        const f2 = module.addFunction(prefix2 + "__cyclotomicSquare");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x4 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f2size));
        const x3 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f2size));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(3 * f2size));
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(4 * f2size));
        const x5 = c2.i32_add(c2.getLocal("x"), c2.i32_const(5 * f2size));
        const r0 = c2.getLocal("r");
        const r4 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f2size));
        const r3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f2size));
        const r22 = c2.i32_add(c2.getLocal("r"), c2.i32_const(3 * f2size));
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * f2size));
        const r5 = c2.i32_add(c2.getLocal("r"), c2.i32_const(5 * f2size));
        const t0 = c2.i32_const(module.alloc(f2size));
        const t1 = c2.i32_const(module.alloc(f2size));
        const t2 = c2.i32_const(module.alloc(f2size));
        const t3 = c2.i32_const(module.alloc(f2size));
        const t4 = c2.i32_const(module.alloc(f2size));
        const t5 = c2.i32_const(module.alloc(f2size));
        const tmp = c2.i32_const(module.alloc(f2size));
        const AUX = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x0, x1, tmp),
          c2.call(f2mPrefix + "_mul", x1, c2.i32_const(pNonResidueF6), t0),
          c2.call(f2mPrefix + "_add", x0, t0, t0),
          c2.call(f2mPrefix + "_add", x0, x1, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t0, t0),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t0, AUX, t0),
          c2.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x2, x3, tmp),
          c2.call(f2mPrefix + "_mul", x3, c2.i32_const(pNonResidueF6), t2),
          c2.call(f2mPrefix + "_add", x2, t2, t2),
          c2.call(f2mPrefix + "_add", x2, x3, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t2, t2),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t2, AUX, t2),
          c2.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x4, x5, tmp),
          c2.call(f2mPrefix + "_mul", x5, c2.i32_const(pNonResidueF6), t4),
          c2.call(f2mPrefix + "_add", x4, t4, t4),
          c2.call(f2mPrefix + "_add", x4, x5, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t4, t4),
          c2.call(f2mPrefix + "_mul", c2.i32_const(pNonResidueF6), tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t4, AUX, t4),
          c2.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c2.call(f2mPrefix + "_sub", t0, x0, r0),
          c2.call(f2mPrefix + "_add", r0, r0, r0),
          c2.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c2.call(f2mPrefix + "_add", t1, x1, r1),
          c2.call(f2mPrefix + "_add", r1, r1, r1),
          c2.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c2.call(f2mPrefix + "_mul", t5, c2.i32_const(pAltBn128Twist), AUX),
          c2.call(f2mPrefix + "_add", AUX, x2, r22),
          c2.call(f2mPrefix + "_add", r22, r22, r22),
          c2.call(f2mPrefix + "_add", AUX, r22, r22),
          // z3 = 3 * t4 - 2 * z3
          c2.call(f2mPrefix + "_sub", t4, x3, r3),
          c2.call(f2mPrefix + "_add", r3, r3, r3),
          c2.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c2.call(f2mPrefix + "_sub", t2, x4, r4),
          c2.call(f2mPrefix + "_add", r4, r4, r4),
          c2.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c2.call(f2mPrefix + "_add", t3, x5, r5),
          c2.call(f2mPrefix + "_add", r5, r5, r5),
          c2.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, fnName) {
        const exponentNafBytes = naf2(exponent).map((b2) => b2 == -1 ? 255 : b2);
        const pExponentNafBytes = module.alloc(exponentNafBytes);
        const f2 = module.addFunction(prefix2 + "__cyclotomicExp_" + fnName);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("bit", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("x");
        const res = c2.getLocal("r");
        const inverse = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          c2.call(ftmPrefix + "_conjugate", x2, inverse),
          c2.call(ftmPrefix + "_one", res),
          c2.if(
            c2.teeLocal("bit", c2.i32_load8_s(c2.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c2.if(
              c2.i32_eq(
                c2.getLocal("bit"),
                c2.i32_const(1)
              ),
              c2.call(ftmPrefix + "_mul", res, x2, res),
              c2.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c2.setLocal("i", c2.i32_const(exponentNafBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix2 + "__cyclotomicSquare", res, res),
            c2.if(
              c2.teeLocal("bit", c2.i32_load8_s(c2.getLocal("i"), pExponentNafBytes)),
              c2.if(
                c2.i32_eq(
                  c2.getLocal("bit"),
                  c2.i32_const(1)
                ),
                c2.call(ftmPrefix + "_mul", res, x2, res),
                c2.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildFinalExponentiationLastChunk() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, "w0");
        const f2 = module.addFunction(prefix2 + "__finalExponentiationLastChunk");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const result = c2.getLocal("r");
        const A2 = c2.i32_const(module.alloc(ftsize));
        const B2 = c2.i32_const(module.alloc(ftsize));
        const C2 = c2.i32_const(module.alloc(ftsize));
        const D2 = c2.i32_const(module.alloc(ftsize));
        const E2 = c2.i32_const(module.alloc(ftsize));
        const F2 = c2.i32_const(module.alloc(ftsize));
        const G2 = c2.i32_const(module.alloc(ftsize));
        const H2 = c2.i32_const(module.alloc(ftsize));
        const I2 = c2.i32_const(module.alloc(ftsize));
        const J2 = c2.i32_const(module.alloc(ftsize));
        const K2 = c2.i32_const(module.alloc(ftsize));
        const L2 = c2.i32_const(module.alloc(ftsize));
        const M2 = c2.i32_const(module.alloc(ftsize));
        const N2 = c2.i32_const(module.alloc(ftsize));
        const O2 = c2.i32_const(module.alloc(ftsize));
        const P2 = c2.i32_const(module.alloc(ftsize));
        const Q2 = c2.i32_const(module.alloc(ftsize));
        const R2 = c2.i32_const(module.alloc(ftsize));
        const S2 = c2.i32_const(module.alloc(ftsize));
        const T2 = c2.i32_const(module.alloc(ftsize));
        const U2 = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          // A = exp_by_neg_z(elt)  // = elt^(-z)
          c2.call(prefix2 + "__cyclotomicExp_w0", elt, A2),
          c2.call(ftmPrefix + "_conjugate", A2, A2),
          // B = A^2                // = elt^(-2*z)
          c2.call(prefix2 + "__cyclotomicSquare", A2, B2),
          // C = B^2                // = elt^(-4*z)
          c2.call(prefix2 + "__cyclotomicSquare", B2, C2),
          // D = C * B              // = elt^(-6*z)
          c2.call(ftmPrefix + "_mul", C2, B2, D2),
          // E = exp_by_neg_z(D)    // = elt^(6*z^2)
          c2.call(prefix2 + "__cyclotomicExp_w0", D2, E2),
          c2.call(ftmPrefix + "_conjugate", E2, E2),
          // F = E^2                // = elt^(12*z^2)
          c2.call(prefix2 + "__cyclotomicSquare", E2, F2),
          // G = epx_by_neg_z(F)    // = elt^(-12*z^3)
          c2.call(prefix2 + "__cyclotomicExp_w0", F2, G2),
          c2.call(ftmPrefix + "_conjugate", G2, G2),
          // H = conj(D)            // = elt^(6*z)
          c2.call(ftmPrefix + "_conjugate", D2, H2),
          // I = conj(G)            // = elt^(12*z^3)
          c2.call(ftmPrefix + "_conjugate", G2, I2),
          // J = I * E              // = elt^(12*z^3 + 6*z^2)
          c2.call(ftmPrefix + "_mul", I2, E2, J2),
          // K = J * H              // = elt^(12*z^3 + 6*z^2 + 6*z)
          c2.call(ftmPrefix + "_mul", J2, H2, K2),
          // L = K * B              // = elt^(12*z^3 + 6*z^2 + 4*z)
          c2.call(ftmPrefix + "_mul", K2, B2, L2),
          // M = K * E              // = elt^(12*z^3 + 12*z^2 + 6*z)
          c2.call(ftmPrefix + "_mul", K2, E2, M2),
          // N = M * elt            // = elt^(12*z^3 + 12*z^2 + 6*z + 1)
          c2.call(ftmPrefix + "_mul", M2, elt, N2),
          // O = L.Frobenius_map(1) // = elt^(q*(12*z^3 + 6*z^2 + 4*z))
          c2.call(prefix2 + "__frobeniusMap1", L2, O2),
          // P = O * N              // = elt^(q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", O2, N2, P2),
          // Q = K.Frobenius_map(2) // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z))
          c2.call(prefix2 + "__frobeniusMap2", K2, Q2),
          // R = Q * P              // = elt^(q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", Q2, P2, R2),
          // S = conj(elt)          // = elt^(-1)
          c2.call(ftmPrefix + "_conjugate", elt, S2),
          // T = S * L              // = elt^(12*z^3 + 6*z^2 + 4*z - 1)
          c2.call(ftmPrefix + "_mul", S2, L2, T2),
          // U = T.Frobenius_map(3) // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1))
          c2.call(prefix2 + "__frobeniusMap3", T2, U2),
          // V = U * R              // = elt^(q^3(12*z^3 + 6*z^2 + 4*z - 1) + q^2 * (12*z^3 + 6*z^2 + 6*z) + q*(12*z^3 + 6*z^2 + 4*z) * (12*z^3 + 12*z^2 + 6*z + 1))
          c2.call(ftmPrefix + "_mul", U2, R2, result)
          // result = V
        );
      }
      function buildFinalExponentiation() {
        buildFinalExponentiationFirstChunk();
        buildFinalExponentiationLastChunk();
        const f2 = module.addFunction(prefix2 + "_finalExponentiation");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const result = c2.getLocal("r");
        const eltToFirstChunk = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          c2.call(prefix2 + "__finalExponentiationFirstChunk", elt, eltToFirstChunk),
          c2.call(prefix2 + "__finalExponentiationLastChunk", eltToFirstChunk, result)
        );
      }
      function buildFinalExponentiationOld() {
        const f2 = module.addFunction(prefix2 + "_finalExponentiationOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const exponent = 552484233613224096312617126783173147097382103762957654188882734314196910839907541213974502761540629817009608548654680343627701153829446747810907373256841551006201639677726139946029199968412598804882391702273019083653272047566316584365559776493027495458238373902875937659943504873220554161550525926302303331747463515644711876653177129578303191095900909191624817826566688241804408081892785725967931714097716709526092261278071952560171111444072049229123565057483750161460024353346284167282452756217662335528813519139808291170539072125381230815729071544861602750936964829313608137325426383735122175229541155376346436093930287402089517426973178917569713384748081827255472576937471496195752727188261435633271238710131736096299798168852925540549342330775279877006784354801422249722573783561685179618816480037695005515426162362431072245638324744480n;
        const pExponent = module.alloc(utils$2.bigInt2BytesLE(exponent, 352));
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(ftmPrefix + "_exp", c2.getLocal("x"), c2.i32_const(pExponent), c2.i32_const(352), c2.getLocal("r"))
        );
      }
      const pPreP = module.alloc(prePSize);
      const pPreQ = module.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f2 = module.addFunction(prefix2 + "_pairingEq" + nPairings);
        for (let i2 = 0; i2 < nPairings; i2++) {
          f2.addParam("p_" + i2, "i32");
          f2.addParam("q_" + i2, "i32");
        }
        f2.addParam("c", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module.alloc(ftsize));
        const auxT = c2.i32_const(module.alloc(ftsize));
        f2.addCode(c2.call(ftmPrefix + "_one", resT));
        for (let i2 = 0; i2 < nPairings; i2++) {
          f2.addCode(c2.call(prefix2 + "_prepareG1", c2.getLocal("p_" + i2), c2.i32_const(pPreP)));
          f2.addCode(c2.call(prefix2 + "_prepareG2", c2.getLocal("q_" + i2), c2.i32_const(pPreQ)));
          f2.addCode(c2.call(prefix2 + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), auxT));
          f2.addCode(c2.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f2.addCode(c2.call(prefix2 + "_finalExponentiation", resT, resT));
        f2.addCode(c2.call(ftmPrefix + "_eq", resT, c2.getLocal("c")));
      }
      function buildPairing2() {
        const f2 = module.addFunction(prefix2 + "_pairing");
        f2.addParam("p", "i32");
        f2.addParam("q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module.alloc(ftsize));
        f2.addCode(c2.call(prefix2 + "_prepareG1", c2.getLocal("p"), c2.i32_const(pPreP)));
        f2.addCode(c2.call(prefix2 + "_prepareG2", c2.getLocal("q"), c2.i32_const(pPreQ)));
        f2.addCode(c2.call(prefix2 + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), resT));
        f2.addCode(c2.call(prefix2 + "_finalExponentiation", resT, c2.getLocal("r")));
      }
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMulBy024();
      buildMulBy024Old();
      buildMillerLoop();
      for (let i2 = 0; i2 < 10; i2++) {
        buildFrobeniusMap(i2);
        module.exportFunction(prefix2 + "__frobeniusMap" + i2);
      }
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i2 = 1; i2 <= 5; i2++) {
        buildPairingEquation(i2);
        module.exportFunction(prefix2 + "_pairingEq" + i2);
      }
      buildPairing2();
      module.exportFunction(prefix2 + "_pairing");
      module.exportFunction(prefix2 + "_prepareG1");
      module.exportFunction(prefix2 + "_prepareG2");
      module.exportFunction(prefix2 + "_millerLoop");
      module.exportFunction(prefix2 + "_finalExponentiation");
      module.exportFunction(prefix2 + "_finalExponentiationOld");
      module.exportFunction(prefix2 + "__mulBy024");
      module.exportFunction(prefix2 + "__mulBy024Old");
      module.exportFunction(prefix2 + "__cyclotomicSquare");
      module.exportFunction(prefix2 + "__cyclotomicExp_w0");
    };
    utils$1 = utils$6;
    buildF1m2 = build_f1m;
    buildF12 = build_f1;
    buildF2m2 = build_f2m;
    buildF3m2 = build_f3m;
    buildCurve2 = build_curve_jacobian_a0;
    buildFFT$1 = build_fft;
    buildPol2 = build_pol;
    buildQAP2 = build_qap;
    buildApplyKey2 = build_applykey;
    ({ bitLength: bitLength$1, isOdd, isNegative: isNegative$1 } = bigint);
    build_bls12381 = function buildBLS12381(module, _prefix) {
      const prefix2 = _prefix || "bls12381";
      if (module.modules[prefix2]) return prefix2;
      const q2 = 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
      const r2 = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001n;
      const n64q = Math.floor((bitLength$1(q2 - 1n) - 1) / 64) + 1;
      const n8q = n64q * 8;
      const f1size = n8q;
      const f2size = f1size * 2;
      const ftsize = f1size * 12;
      const n64r = Math.floor((bitLength$1(r2 - 1n) - 1) / 64) + 1;
      const n8r = n64r * 8;
      const frsize = n8r;
      const pr = module.alloc(utils$1.bigInt2BytesLE(r2, frsize));
      const f1mPrefix = buildF1m2(module, q2, "f1m", "intq");
      buildF12(module, r2, "fr", "frm", "intr");
      const pG1b = module.alloc(utils$1.bigInt2BytesLE(toMontgomery(4n), f1size));
      const g1mPrefix = buildCurve2(module, "g1m", "f1m", pG1b);
      buildFFT$1(module, "frm", "frm", "frm", "frm_mul");
      buildPol2(module, "pol", "frm");
      buildQAP2(module, "qap", "frm");
      const f2mPrefix = buildF2m2(module, "f1m_neg", "f2m", "f1m");
      const pG2b = module.alloc([
        ...utils$1.bigInt2BytesLE(toMontgomery(4n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(4n), f1size)
      ]);
      const g2mPrefix = buildCurve2(module, "g2m", "f2m", pG2b);
      function buildGTimesFr(fnName, opMul) {
        const f2 = module.addFunction(fnName);
        f2.addParam("pG", "i32");
        f2.addParam("pFr", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const AUX = c2.i32_const(module.alloc(n8r));
        f2.addCode(
          c2.call("frm_fromMontgomery", c2.getLocal("pFr"), AUX),
          c2.call(
            opMul,
            c2.getLocal("pG"),
            AUX,
            c2.i32_const(n8r),
            c2.getLocal("pr")
          )
        );
        module.exportFunction(fnName);
      }
      buildGTimesFr("g1m_timesFr", "g1m_timesScalar");
      buildFFT$1(module, "g1m", "g1m", "frm", "g1m_timesFr");
      buildGTimesFr("g2m_timesFr", "g2m_timesScalar");
      buildFFT$1(module, "g2m", "g2m", "frm", "g2m_timesFr");
      buildGTimesFr("g1m_timesFrAffine", "g1m_timesScalarAffine");
      buildGTimesFr("g2m_timesFrAffine", "g2m_timesScalarAffine");
      buildApplyKey2(module, "frm_batchApplyKey", "fmr", "frm", n8r, n8r, n8r, "frm_mul");
      buildApplyKey2(module, "g1m_batchApplyKey", "g1m", "frm", n8q * 3, n8q * 3, n8r, "g1m_timesFr");
      buildApplyKey2(module, "g1m_batchApplyKeyMixed", "g1m", "frm", n8q * 2, n8q * 3, n8r, "g1m_timesFrAffine");
      buildApplyKey2(module, "g2m_batchApplyKey", "g2m", "frm", n8q * 2 * 3, n8q * 3 * 2, n8r, "g2m_timesFr");
      buildApplyKey2(module, "g2m_batchApplyKeyMixed", "g2m", "frm", n8q * 2 * 2, n8q * 3 * 2, n8r, "g2m_timesFrAffine");
      function toMontgomery(a2) {
        return BigInt(a2) * (1n << BigInt(f1size * 8)) % q2;
      }
      const G1gen = [
        3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507n,
        1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569n,
        1n
      ];
      const pG1gen = module.alloc(
        [
          ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G1gen[2]), f1size)
        ]
      );
      const G1zero = [
        0n,
        1n,
        0n
      ];
      const pG1zero = module.alloc(
        [
          ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G1zero[2]), f1size)
        ]
      );
      const G2gen = [
        [
          352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160n,
          3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758n
        ],
        [
          1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905n,
          927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582n
        ],
        [
          1n,
          0n
        ]
      ];
      const pG2gen = module.alloc(
        [
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[0][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[0][1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[1][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[1][1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[2][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2gen[2][1]), f1size)
        ]
      );
      const G2zero = [
        [
          0n,
          0n
        ],
        [
          1n,
          0n
        ],
        [
          0n,
          0n
        ]
      ];
      const pG2zero = module.alloc(
        [
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[0][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[0][1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[1][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[1][1]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[2][0]), f1size),
          ...utils$1.bigInt2BytesLE(toMontgomery(G2zero[2][1]), f1size)
        ]
      );
      const pOneT = module.alloc([
        ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(0n), f1size)
      ]);
      const pBls12381Twist = module.alloc([
        ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size),
        ...utils$1.bigInt2BytesLE(toMontgomery(1n), f1size)
      ]);
      function build_mulNR2() {
        const f2 = module.addFunction(f2mPrefix + "_mulNR");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const x0c = c2.i32_const(module.alloc(f1size));
        const x0 = c2.getLocal("x");
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f1size));
        const r0 = c2.getLocal("pr");
        const r1 = c2.i32_add(c2.getLocal("pr"), c2.i32_const(f1size));
        f2.addCode(
          c2.call(f1mPrefix + "_copy", x0, x0c),
          c2.call(f1mPrefix + "_sub", x0, x1, r0),
          c2.call(f1mPrefix + "_add", x0c, x1, r1)
        );
      }
      build_mulNR2();
      const f6mPrefix = buildF3m2(module, f2mPrefix + "_mulNR", "f6m", "f2m");
      function build_mulNR6() {
        const f2 = module.addFunction(f6mPrefix + "_mulNR");
        f2.addParam("x", "i32");
        f2.addParam("pr", "i32");
        const c2 = f2.getCodeBuilder();
        const c0copy = c2.i32_const(module.alloc(f1size * 2));
        f2.addCode(
          c2.call(
            f2mPrefix + "_copy",
            c2.getLocal("x"),
            c0copy
          ),
          c2.call(
            f2mPrefix + "_mulNR",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8q * 4)),
            c2.getLocal("pr")
          ),
          c2.call(
            f2mPrefix + "_copy",
            c2.i32_add(c2.getLocal("x"), c2.i32_const(n8q * 2)),
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8q * 4))
          ),
          c2.call(
            f2mPrefix + "_copy",
            c0copy,
            c2.i32_add(c2.getLocal("pr"), c2.i32_const(n8q * 2))
          )
        );
      }
      build_mulNR6();
      const ftmPrefix = buildF2m2(module, f6mPrefix + "_mulNR", "ftm", f6mPrefix);
      const ateLoopCount = 0xd201000000010000n;
      const ateLoopBitBytes = bits2(ateLoopCount);
      const pAteLoopBitBytes = module.alloc(ateLoopBitBytes);
      const ateCoefSize = 3 * f2size;
      const ateNDblCoefs = ateLoopBitBytes.length - 1;
      const ateNAddCoefs = ateLoopBitBytes.reduce((acc, b2) => acc + (b2 != 0 ? 1 : 0), 0);
      const ateNCoefs = ateNAddCoefs + ateNDblCoefs + 1;
      const prePSize = 3 * 2 * n8q;
      const preQSize = 3 * n8q * 2 + ateNCoefs * ateCoefSize;
      const finalExpIsNegative = true;
      const finalExpZ = 15132376222941642752n;
      module.modules[prefix2] = {
        n64q,
        n64r,
        n8q,
        n8r,
        pG1gen,
        pG1zero,
        pG1b,
        pG2gen,
        pG2zero,
        pG2b,
        pq: module.modules["f1m"].pq,
        pr,
        pOneT,
        r: r2,
        q: q2,
        prePSize,
        preQSize
      };
      function naf2(n) {
        let E2 = n;
        const res = [];
        while (E2 > 0n) {
          if (isOdd(E2)) {
            const z2 = 2 - Number(E2 % 4n);
            res.push(z2);
            E2 = E2 - BigInt(z2);
          } else {
            res.push(0);
          }
          E2 = E2 >> 1n;
        }
        return res;
      }
      function bits2(n) {
        let E2 = n;
        const res = [];
        while (E2 > 0n) {
          if (isOdd(E2)) {
            res.push(1);
          } else {
            res.push(0);
          }
          E2 = E2 >> 1n;
        }
        return res;
      }
      function buildPrepareG1() {
        const f2 = module.addFunction(prefix2 + "_prepareG1");
        f2.addParam("pP", "i32");
        f2.addParam("ppreP", "i32");
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(g1mPrefix + "_normalize", c2.getLocal("pP"), c2.getLocal("ppreP"))
          // TODO Remove if already in affine
        );
      }
      function buildPrepDoubleStep() {
        const f2 = module.addFunction(prefix2 + "_prepDblStep");
        f2.addParam("R", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const Rx = c2.getLocal("R");
        const Ry = c2.i32_add(c2.getLocal("R"), c2.i32_const(2 * n8q));
        const Rz = c2.i32_add(c2.getLocal("R"), c2.i32_const(4 * n8q));
        const t0 = c2.getLocal("r");
        const t3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * n8q));
        const t6 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * n8q));
        const zsquared = c2.i32_const(module.alloc(f2size));
        const t1 = c2.i32_const(module.alloc(f2size));
        const t2 = c2.i32_const(module.alloc(f2size));
        const t4 = c2.i32_const(module.alloc(f2size));
        const t5 = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          // tmp0 = r.x.square();
          c2.call(f2mPrefix + "_square", Rx, t0),
          // tmp1 = r.y.square();
          c2.call(f2mPrefix + "_square", Ry, t1),
          // tmp2 = tmp1.square();
          c2.call(f2mPrefix + "_square", t1, t2),
          // tmp3 = (tmp1 + r.x).square() - tmp0 - tmp2;
          c2.call(f2mPrefix + "_add", t1, Rx, t3),
          c2.call(f2mPrefix + "_square", t3, t3),
          c2.call(f2mPrefix + "_sub", t3, t0, t3),
          c2.call(f2mPrefix + "_sub", t3, t2, t3),
          // tmp3 = tmp3 + tmp3;
          c2.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp4 = tmp0 + tmp0 + tmp0;
          c2.call(f2mPrefix + "_add", t0, t0, t4),
          c2.call(f2mPrefix + "_add", t4, t0, t4),
          // tmp6 = r.x + tmp4;
          c2.call(f2mPrefix + "_add", Rx, t4, t6),
          // tmp5 = tmp4.square();
          c2.call(f2mPrefix + "_square", t4, t5),
          // zsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, zsquared),
          // r.x = tmp5 - tmp3 - tmp3;
          c2.call(f2mPrefix + "_sub", t5, t3, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t3, Rx),
          // r.z = (r.z + r.y).square() - tmp1 - zsquared;
          c2.call(f2mPrefix + "_add", Rz, Ry, Rz),
          c2.call(f2mPrefix + "_square", Rz, Rz),
          c2.call(f2mPrefix + "_sub", Rz, t1, Rz),
          c2.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          // r.y = (tmp3 - r.x) * tmp4;
          c2.call(f2mPrefix + "_sub", t3, Rx, Ry),
          c2.call(f2mPrefix + "_mul", Ry, t4, Ry),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // tmp2 = tmp2 + tmp2;
          c2.call(f2mPrefix + "_add", t2, t2, t2),
          // r.y -= tmp2;
          c2.call(f2mPrefix + "_sub", Ry, t2, Ry),
          // tmp3 = tmp4 * zsquared;
          c2.call(f2mPrefix + "_mul", t4, zsquared, t3),
          // tmp3 = tmp3 + tmp3;
          c2.call(f2mPrefix + "_add", t3, t3, t3),
          // tmp3 = -tmp3;
          c2.call(f2mPrefix + "_neg", t3, t3),
          // tmp6 = tmp6.square() - tmp0 - tmp5;
          c2.call(f2mPrefix + "_square", t6, t6),
          c2.call(f2mPrefix + "_sub", t6, t0, t6),
          c2.call(f2mPrefix + "_sub", t6, t5, t6),
          // tmp1 = tmp1 + tmp1;
          c2.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp1 = tmp1 + tmp1;
          c2.call(f2mPrefix + "_add", t1, t1, t1),
          // tmp6 = tmp6 - tmp1;
          c2.call(f2mPrefix + "_sub", t6, t1, t6),
          // tmp0 = r.z * zsquared;
          c2.call(f2mPrefix + "_mul", Rz, zsquared, t0),
          // tmp0 = tmp0 + tmp0;
          c2.call(f2mPrefix + "_add", t0, t0, t0)
        );
      }
      function buildPrepAddStep() {
        const f2 = module.addFunction(prefix2 + "_prepAddStep");
        f2.addParam("R", "i32");
        f2.addParam("Q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const Rx = c2.getLocal("R");
        const Ry = c2.i32_add(c2.getLocal("R"), c2.i32_const(2 * n8q));
        const Rz = c2.i32_add(c2.getLocal("R"), c2.i32_const(4 * n8q));
        const Qx = c2.getLocal("Q");
        const Qy = c2.i32_add(c2.getLocal("Q"), c2.i32_const(2 * n8q));
        const t10 = c2.getLocal("r");
        const t1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * n8q));
        const t9 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * n8q));
        const zsquared = c2.i32_const(module.alloc(f2size));
        const ysquared = c2.i32_const(module.alloc(f2size));
        const ztsquared = c2.i32_const(module.alloc(f2size));
        const t0 = c2.i32_const(module.alloc(f2size));
        const t2 = c2.i32_const(module.alloc(f2size));
        const t3 = c2.i32_const(module.alloc(f2size));
        const t4 = c2.i32_const(module.alloc(f2size));
        const t5 = c2.i32_const(module.alloc(f2size));
        const t6 = c2.i32_const(module.alloc(f2size));
        const t7 = c2.i32_const(module.alloc(f2size));
        const t8 = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          // zsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, zsquared),
          // ysquared = q.y.square();
          c2.call(f2mPrefix + "_square", Qy, ysquared),
          // t0 = zsquared * q.x;
          c2.call(f2mPrefix + "_mul", zsquared, Qx, t0),
          // t1 = ((q.y + r.z).square() - ysquared - zsquared) * zsquared;
          c2.call(f2mPrefix + "_add", Qy, Rz, t1),
          c2.call(f2mPrefix + "_square", t1, t1),
          c2.call(f2mPrefix + "_sub", t1, ysquared, t1),
          c2.call(f2mPrefix + "_sub", t1, zsquared, t1),
          c2.call(f2mPrefix + "_mul", t1, zsquared, t1),
          // t2 = t0 - r.x;
          c2.call(f2mPrefix + "_sub", t0, Rx, t2),
          // t3 = t2.square();
          c2.call(f2mPrefix + "_square", t2, t3),
          // t4 = t3 + t3;
          c2.call(f2mPrefix + "_add", t3, t3, t4),
          // t4 = t4 + t4;
          c2.call(f2mPrefix + "_add", t4, t4, t4),
          // t5 = t4 * t2;
          c2.call(f2mPrefix + "_mul", t4, t2, t5),
          // t6 = t1 - r.y - r.y;
          c2.call(f2mPrefix + "_sub", t1, Ry, t6),
          c2.call(f2mPrefix + "_sub", t6, Ry, t6),
          // t9 = t6 * q.x;
          c2.call(f2mPrefix + "_mul", t6, Qx, t9),
          // t7 = t4 * r.x;
          c2.call(f2mPrefix + "_mul", t4, Rx, t7),
          // r.x = t6.square() - t5 - t7 - t7;
          c2.call(f2mPrefix + "_square", t6, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t5, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t7, Rx),
          c2.call(f2mPrefix + "_sub", Rx, t7, Rx),
          // r.z = (r.z + t2).square() - zsquared - t3;
          c2.call(f2mPrefix + "_add", Rz, t2, Rz),
          c2.call(f2mPrefix + "_square", Rz, Rz),
          c2.call(f2mPrefix + "_sub", Rz, zsquared, Rz),
          c2.call(f2mPrefix + "_sub", Rz, t3, Rz),
          // t10 = q.y + r.z;
          c2.call(f2mPrefix + "_add", Qy, Rz, t10),
          // t8 = (t7 - r.x) * t6;
          c2.call(f2mPrefix + "_sub", t7, Rx, t8),
          c2.call(f2mPrefix + "_mul", t8, t6, t8),
          // t0 = r.y * t5;
          c2.call(f2mPrefix + "_mul", Ry, t5, t0),
          // t0 = t0 + t0;
          c2.call(f2mPrefix + "_add", t0, t0, t0),
          // r.y = t8 - t0;
          c2.call(f2mPrefix + "_sub", t8, t0, Ry),
          // t10 = t10.square() - ysquared;
          c2.call(f2mPrefix + "_square", t10, t10),
          c2.call(f2mPrefix + "_sub", t10, ysquared, t10),
          // ztsquared = r.z.square();
          c2.call(f2mPrefix + "_square", Rz, ztsquared),
          // t10 = t10 - ztsquared;
          c2.call(f2mPrefix + "_sub", t10, ztsquared, t10),
          // t9 = t9 + t9 - t10;
          c2.call(f2mPrefix + "_add", t9, t9, t9),
          c2.call(f2mPrefix + "_sub", t9, t10, t9),
          // t10 = r.z + r.z;
          c2.call(f2mPrefix + "_add", Rz, Rz, t10),
          // t6 = -t6;
          c2.call(f2mPrefix + "_neg", t6, t6),
          // t1 = t6 + t6;
          c2.call(f2mPrefix + "_add", t6, t6, t1)
        );
      }
      function buildPrepareG2() {
        const f2 = module.addFunction(prefix2 + "_prepareG2");
        f2.addParam("pQ", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const Q2 = c2.getLocal("pQ");
        const pR = module.alloc(f2size * 3);
        const R2 = c2.i32_const(pR);
        const base = c2.getLocal("ppreQ");
        f2.addCode(
          c2.call(g2mPrefix + "_normalize", Q2, base),
          c2.if(
            c2.call(g2mPrefix + "_isZero", base),
            c2.ret([])
          ),
          c2.call(g2mPrefix + "_copy", base, R2),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3)))
        );
        f2.addCode(
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix2 + "_prepDblStep", R2, c2.getLocal("pCoef")),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix2 + "_prepAddStep", R2, base, c2.getLocal("pCoef")),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
      }
      function buildF6Mul1() {
        const f2 = module.addFunction(f6mPrefix + "_mul1");
        f2.addParam("pA", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 2));
        const A_c2 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 4));
        const c1 = c2.getLocal("pC1");
        const t1 = c2.getLocal("pR");
        const t2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 2));
        const b_b = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 4));
        const Ac0_Ac1 = c2.i32_const(module.alloc(f1size * 2));
        const Ac1_Ac2 = c2.i32_const(module.alloc(f1size * 2));
        f2.addCode(
          c2.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c2.call(f2mPrefix + "_add", A_c1, A_c2, Ac1_Ac2),
          // let b_b = self.c1 * c1;
          c2.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c2.call(f2mPrefix + "_mul", Ac1_Ac2, c1, t1),
          c2.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue();
          c2.call(f2mPrefix + "_mulNR", t1, t1),
          // let t2 = (self.c0 + self.c1) * c1 - b_b;
          c2.call(f2mPrefix + "_mul", Ac0_Ac1, c1, t2),
          c2.call(f2mPrefix + "_sub", t2, b_b, t2)
        );
      }
      buildF6Mul1();
      function buildF6Mul01() {
        const f2 = module.addFunction(f6mPrefix + "_mul01");
        f2.addParam("pA", "i32");
        f2.addParam("pC0", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 2));
        const A_c2 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 4));
        const c0 = c2.getLocal("pC0");
        const c1 = c2.getLocal("pC1");
        const t1 = c2.getLocal("pR");
        const t2 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 2));
        const t3 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 4));
        const a_a = c2.i32_const(module.alloc(f1size * 2));
        const b_b = c2.i32_const(module.alloc(f1size * 2));
        const Ac0_Ac1 = c2.i32_const(module.alloc(f1size * 2));
        const Ac0_Ac2 = c2.i32_const(module.alloc(f1size * 2));
        f2.addCode(
          // let a_a = self.c0 * c0;
          c2.call(f2mPrefix + "_mul", A_c0, c0, a_a),
          // let b_b = self.c1 * c1;
          c2.call(f2mPrefix + "_mul", A_c1, c1, b_b),
          c2.call(f2mPrefix + "_add", A_c0, A_c1, Ac0_Ac1),
          c2.call(f2mPrefix + "_add", A_c0, A_c2, Ac0_Ac2),
          // let t1 = (self.c1 + self.c2) * c1 - b_b;
          c2.call(f2mPrefix + "_add", A_c1, A_c2, t1),
          c2.call(f2mPrefix + "_mul", t1, c1, t1),
          c2.call(f2mPrefix + "_sub", t1, b_b, t1),
          // let t1 = t1.mul_by_nonresidue() + a_a;
          c2.call(f2mPrefix + "_mulNR", t1, t1),
          c2.call(f2mPrefix + "_add", t1, a_a, t1),
          // let t2 = (c0 + c1) * (self.c0 + self.c1) - a_a - b_b;
          c2.call(f2mPrefix + "_add", c0, c1, t2),
          c2.call(f2mPrefix + "_mul", t2, Ac0_Ac1, t2),
          c2.call(f2mPrefix + "_sub", t2, a_a, t2),
          c2.call(f2mPrefix + "_sub", t2, b_b, t2),
          // let t3 = (self.c0 + self.c2) * c0 - a_a + b_b;
          c2.call(f2mPrefix + "_mul", Ac0_Ac2, c0, t3),
          c2.call(f2mPrefix + "_sub", t3, a_a, t3),
          c2.call(f2mPrefix + "_add", t3, b_b, t3)
        );
      }
      buildF6Mul01();
      function buildF12Mul014() {
        const f2 = module.addFunction(ftmPrefix + "_mul014");
        f2.addParam("pA", "i32");
        f2.addParam("pC0", "i32");
        f2.addParam("pC1", "i32");
        f2.addParam("pC4", "i32");
        f2.addParam("pR", "i32");
        const c2 = f2.getCodeBuilder();
        const A_c0 = c2.getLocal("pA");
        const A_c1 = c2.i32_add(c2.getLocal("pA"), c2.i32_const(f1size * 6));
        const c0 = c2.getLocal("pC0");
        const c1 = c2.getLocal("pC1");
        const c4 = c2.getLocal("pC4");
        const aa = c2.i32_const(module.alloc(f1size * 6));
        const bb = c2.i32_const(module.alloc(f1size * 6));
        const o2 = c2.i32_const(module.alloc(f1size * 2));
        const R_c0 = c2.getLocal("pR");
        const R_c1 = c2.i32_add(c2.getLocal("pR"), c2.i32_const(f1size * 6));
        f2.addCode(
          // let aa = self.c0.mul_by_01(c0, c1);
          c2.call(f6mPrefix + "_mul01", A_c0, c0, c1, aa),
          // let bb = self.c1.mul_by_1(c4);
          c2.call(f6mPrefix + "_mul1", A_c1, c4, bb),
          // let o = c1 + c4;
          c2.call(f2mPrefix + "_add", c1, c4, o2),
          // let c1 = self.c1 + self.c0;
          c2.call(f6mPrefix + "_add", A_c1, A_c0, R_c1),
          // let c1 = c1.mul_by_01(c0, &o);
          c2.call(f6mPrefix + "_mul01", R_c1, c0, o2, R_c1),
          // let c1 = c1 - aa - bb;
          c2.call(f6mPrefix + "_sub", R_c1, aa, R_c1),
          c2.call(f6mPrefix + "_sub", R_c1, bb, R_c1),
          // let c0 = bb;
          c2.call(f6mPrefix + "_copy", bb, R_c0),
          // let c0 = c0.mul_by_nonresidue();
          c2.call(f6mPrefix + "_mulNR", R_c0, R_c0),
          // let c0 = c0 + aa;
          c2.call(f6mPrefix + "_add", R_c0, aa, R_c0)
        );
      }
      buildF12Mul014();
      function buildELL() {
        const f2 = module.addFunction(prefix2 + "_ell");
        f2.addParam("pP", "i32");
        f2.addParam("pCoefs", "i32");
        f2.addParam("pF", "i32");
        const c2 = f2.getCodeBuilder();
        const Px = c2.getLocal("pP");
        const Py = c2.i32_add(c2.getLocal("pP"), c2.i32_const(n8q));
        const F2 = c2.getLocal("pF");
        const coef0_0 = c2.getLocal("pCoefs");
        const coef0_1 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size));
        const coef1_0 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 2));
        const coef1_1 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 3));
        const coef2 = c2.i32_add(c2.getLocal("pCoefs"), c2.i32_const(f1size * 4));
        const pc0 = module.alloc(f1size * 2);
        const c0 = c2.i32_const(pc0);
        const c0_c0 = c2.i32_const(pc0);
        const c0_c1 = c2.i32_const(pc0 + f1size);
        const pc1 = module.alloc(f1size * 2);
        const c1 = c2.i32_const(pc1);
        const c1_c0 = c2.i32_const(pc1);
        const c1_c1 = c2.i32_const(pc1 + f1size);
        f2.addCode(
          //     let mut c0 = coeffs.0;
          //     let mut c1 = coeffs.1;
          //
          //    c0.c0 *= p.y;
          //    c0.c1 *= p.y;
          //
          //    c1.c0 *= p.x;
          //    c1.c1 *= p.x;
          //
          //     f.mul_by_014(&coeffs.2, &c1, &c0)
          c2.call(f1mPrefix + "_mul", coef0_0, Py, c0_c0),
          c2.call(f1mPrefix + "_mul", coef0_1, Py, c0_c1),
          c2.call(f1mPrefix + "_mul", coef1_0, Px, c1_c0),
          c2.call(f1mPrefix + "_mul", coef1_1, Px, c1_c1),
          c2.call(ftmPrefix + "_mul014", F2, coef2, c1, c0, F2)
        );
      }
      buildELL();
      function buildMillerLoop() {
        const f2 = module.addFunction(prefix2 + "_millerLoop");
        f2.addParam("ppreP", "i32");
        f2.addParam("ppreQ", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("pCoef", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const preP = c2.getLocal("ppreP");
        const coefs = c2.getLocal("pCoef");
        const F2 = c2.getLocal("r");
        f2.addCode(
          c2.call(ftmPrefix + "_one", F2),
          c2.if(
            c2.call(g1mPrefix + "_isZero", preP),
            c2.ret([])
          ),
          c2.if(
            c2.call(g1mPrefix + "_isZero", c2.getLocal("ppreQ")),
            c2.ret([])
          ),
          c2.setLocal("pCoef", c2.i32_add(c2.getLocal("ppreQ"), c2.i32_const(f2size * 3))),
          c2.setLocal("i", c2.i32_const(ateLoopBitBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix2 + "_ell", preP, coefs, F2),
            c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize))),
            c2.if(
              c2.i32_load8_s(c2.getLocal("i"), pAteLoopBitBytes),
              [
                ...c2.call(prefix2 + "_ell", preP, coefs, F2),
                ...c2.setLocal("pCoef", c2.i32_add(c2.getLocal("pCoef"), c2.i32_const(ateCoefSize)))
              ]
            ),
            c2.call(ftmPrefix + "_square", F2, F2),
            c2.br_if(1, c2.i32_eq(c2.getLocal("i"), c2.i32_const(1))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          )),
          c2.call(prefix2 + "_ell", preP, coefs, F2)
        );
        {
          f2.addCode(
            c2.call(ftmPrefix + "_conjugate", F2, F2)
          );
        }
      }
      function buildFrobeniusMap(n) {
        const F12 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n, 151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n],
            [2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n, 1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n, 877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [151655185184498381465642749684540099398075398968325446656007613510403227271200139370504932015952886146304766135027n, 3850754370037169011952147076051364057158807420970682438676050522613628423219637725072182697113062777891589506424760n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [1028732146235106349975324479215795277384839936929757896155643118032610843298655225875571310552543014690878354869257n, 2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [877076961050607968509681729531255177986764537961432449499635504522207616027455086505066378536590128544573588734230n, 3125332594171059424908108096204648978570118281977575435832422631601824034463382777937621250592425535493320683825557n]
          ]
        ];
        const F6 = [
          [
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n],
            [1n, 0n]
          ],
          [
            [1n, 0n],
            [0n, 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [0n, 1n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [0n, 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n]
          ],
          [
            [1n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939437n, 0n],
            [4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n, 0n],
            [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559786n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n, 0n],
            [793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620351n, 0n]
          ]
        ];
        const f2 = module.addFunction(ftmPrefix + "_frobeniusMap" + n);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        for (let i2 = 0; i2 < 6; i2++) {
          const X2 = i2 == 0 ? c2.getLocal("x") : c2.i32_add(c2.getLocal("x"), c2.i32_const(i2 * f2size));
          const Xc0 = X2;
          const Xc1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(i2 * f2size + f1size));
          const R2 = i2 == 0 ? c2.getLocal("r") : c2.i32_add(c2.getLocal("r"), c2.i32_const(i2 * f2size));
          const Rc0 = R2;
          const Rc1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(i2 * f2size + f1size));
          const coef = mul2(F12[Math.floor(i2 / 3)][n % 12], F6[i2 % 3][n % 6]);
          const pCoef = module.alloc([
            ...utils$1.bigInt2BytesLE(toMontgomery(coef[0]), n8q),
            ...utils$1.bigInt2BytesLE(toMontgomery(coef[1]), n8q)
          ]);
          if (n % 2 == 1) {
            f2.addCode(
              c2.call(f1mPrefix + "_copy", Xc0, Rc0),
              c2.call(f1mPrefix + "_neg", Xc1, Rc1),
              c2.call(f2mPrefix + "_mul", R2, c2.i32_const(pCoef), R2)
            );
          } else {
            f2.addCode(c2.call(f2mPrefix + "_mul", X2, c2.i32_const(pCoef), R2));
          }
        }
        function mul2(a2, b2) {
          const ac0 = a2[0];
          const ac1 = a2[1];
          const bc0 = b2[0];
          const bc1 = b2[1];
          const res = [
            (ac0 * bc0 - ac1 * bc1) % q2,
            (ac0 * bc1 + ac1 * bc0) % q2
          ];
          if (isNegative$1(res[0])) res[0] = res[0] + q2;
          return res;
        }
      }
      function buildCyclotomicSquare() {
        const f2 = module.addFunction(prefix2 + "__cyclotomicSquare");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const x0 = c2.getLocal("x");
        const x4 = c2.i32_add(c2.getLocal("x"), c2.i32_const(f2size));
        const x3 = c2.i32_add(c2.getLocal("x"), c2.i32_const(2 * f2size));
        const x2 = c2.i32_add(c2.getLocal("x"), c2.i32_const(3 * f2size));
        const x1 = c2.i32_add(c2.getLocal("x"), c2.i32_const(4 * f2size));
        const x5 = c2.i32_add(c2.getLocal("x"), c2.i32_const(5 * f2size));
        const r0 = c2.getLocal("r");
        const r4 = c2.i32_add(c2.getLocal("r"), c2.i32_const(f2size));
        const r3 = c2.i32_add(c2.getLocal("r"), c2.i32_const(2 * f2size));
        const r22 = c2.i32_add(c2.getLocal("r"), c2.i32_const(3 * f2size));
        const r1 = c2.i32_add(c2.getLocal("r"), c2.i32_const(4 * f2size));
        const r5 = c2.i32_add(c2.getLocal("r"), c2.i32_const(5 * f2size));
        const t0 = c2.i32_const(module.alloc(f2size));
        const t1 = c2.i32_const(module.alloc(f2size));
        const t2 = c2.i32_const(module.alloc(f2size));
        const t3 = c2.i32_const(module.alloc(f2size));
        const t4 = c2.i32_const(module.alloc(f2size));
        const t5 = c2.i32_const(module.alloc(f2size));
        const tmp = c2.i32_const(module.alloc(f2size));
        const AUX = c2.i32_const(module.alloc(f2size));
        f2.addCode(
          //    // t0 + t1*y = (z0 + z1*y)^2 = a^2
          //    tmp = z0 * z1;
          //    t0 = (z0 + z1) * (z0 + my_Fp6::non_residue * z1) - tmp - my_Fp6::non_residue * tmp;
          //    t1 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x0, x1, tmp),
          c2.call(f2mPrefix + "_mulNR", x1, t0),
          c2.call(f2mPrefix + "_add", x0, t0, t0),
          c2.call(f2mPrefix + "_add", x0, x1, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t0, t0),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t0, AUX, t0),
          c2.call(f2mPrefix + "_add", tmp, tmp, t1),
          //  // t2 + t3*y = (z2 + z3*y)^2 = b^2
          //  tmp = z2 * z3;
          //  t2 = (z2 + z3) * (z2 + my_Fp6::non_residue * z3) - tmp - my_Fp6::non_residue * tmp;
          //  t3 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x2, x3, tmp),
          c2.call(f2mPrefix + "_mulNR", x3, t2),
          c2.call(f2mPrefix + "_add", x2, t2, t2),
          c2.call(f2mPrefix + "_add", x2, x3, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t2, t2),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t2, AUX, t2),
          c2.call(f2mPrefix + "_add", tmp, tmp, t3),
          //  // t4 + t5*y = (z4 + z5*y)^2 = c^2
          //  tmp = z4 * z5;
          //  t4 = (z4 + z5) * (z4 + my_Fp6::non_residue * z5) - tmp - my_Fp6::non_residue * tmp;
          //  t5 = tmp + tmp;
          c2.call(f2mPrefix + "_mul", x4, x5, tmp),
          c2.call(f2mPrefix + "_mulNR", x5, t4),
          c2.call(f2mPrefix + "_add", x4, t4, t4),
          c2.call(f2mPrefix + "_add", x4, x5, AUX),
          c2.call(f2mPrefix + "_mul", AUX, t4, t4),
          c2.call(f2mPrefix + "_mulNR", tmp, AUX),
          c2.call(f2mPrefix + "_add", tmp, AUX, AUX),
          c2.call(f2mPrefix + "_sub", t4, AUX, t4),
          c2.call(f2mPrefix + "_add", tmp, tmp, t5),
          // For A
          // z0 = 3 * t0 - 2 * z0
          c2.call(f2mPrefix + "_sub", t0, x0, r0),
          c2.call(f2mPrefix + "_add", r0, r0, r0),
          c2.call(f2mPrefix + "_add", t0, r0, r0),
          // z1 = 3 * t1 + 2 * z1
          c2.call(f2mPrefix + "_add", t1, x1, r1),
          c2.call(f2mPrefix + "_add", r1, r1, r1),
          c2.call(f2mPrefix + "_add", t1, r1, r1),
          // For B
          // z2 = 3 * (xi * t5) + 2 * z2
          c2.call(f2mPrefix + "_mul", t5, c2.i32_const(pBls12381Twist), AUX),
          c2.call(f2mPrefix + "_add", AUX, x2, r22),
          c2.call(f2mPrefix + "_add", r22, r22, r22),
          c2.call(f2mPrefix + "_add", AUX, r22, r22),
          // z3 = 3 * t4 - 2 * z3
          c2.call(f2mPrefix + "_sub", t4, x3, r3),
          c2.call(f2mPrefix + "_add", r3, r3, r3),
          c2.call(f2mPrefix + "_add", t4, r3, r3),
          // For C
          // z4 = 3 * t2 - 2 * z4
          c2.call(f2mPrefix + "_sub", t2, x4, r4),
          c2.call(f2mPrefix + "_add", r4, r4, r4),
          c2.call(f2mPrefix + "_add", t2, r4, r4),
          // z5 = 3 * t3 + 2 * z5
          c2.call(f2mPrefix + "_add", t3, x5, r5),
          c2.call(f2mPrefix + "_add", r5, r5, r5),
          c2.call(f2mPrefix + "_add", t3, r5, r5)
        );
      }
      function buildCyclotomicExp(exponent, isExpNegative, fnName) {
        const exponentNafBytes = naf2(exponent).map((b2) => b2 == -1 ? 255 : b2);
        const pExponentNafBytes = module.alloc(exponentNafBytes);
        const f2 = module.addFunction(prefix2 + "__cyclotomicExp_" + fnName);
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        f2.addLocal("bit", "i32");
        f2.addLocal("i", "i32");
        const c2 = f2.getCodeBuilder();
        const x2 = c2.getLocal("x");
        const res = c2.getLocal("r");
        const inverse = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          c2.call(ftmPrefix + "_conjugate", x2, inverse),
          c2.call(ftmPrefix + "_one", res),
          c2.if(
            c2.teeLocal("bit", c2.i32_load8_s(c2.i32_const(exponentNafBytes.length - 1), pExponentNafBytes)),
            c2.if(
              c2.i32_eq(
                c2.getLocal("bit"),
                c2.i32_const(1)
              ),
              c2.call(ftmPrefix + "_mul", res, x2, res),
              c2.call(ftmPrefix + "_mul", res, inverse, res)
            )
          ),
          c2.setLocal("i", c2.i32_const(exponentNafBytes.length - 2)),
          c2.block(c2.loop(
            c2.call(prefix2 + "__cyclotomicSquare", res, res),
            c2.if(
              c2.teeLocal("bit", c2.i32_load8_s(c2.getLocal("i"), pExponentNafBytes)),
              c2.if(
                c2.i32_eq(
                  c2.getLocal("bit"),
                  c2.i32_const(1)
                ),
                c2.call(ftmPrefix + "_mul", res, x2, res),
                c2.call(ftmPrefix + "_mul", res, inverse, res)
              )
            ),
            c2.br_if(1, c2.i32_eqz(c2.getLocal("i"))),
            c2.setLocal("i", c2.i32_sub(c2.getLocal("i"), c2.i32_const(1))),
            c2.br(0)
          ))
        );
        if (isExpNegative) {
          f2.addCode(
            c2.call(ftmPrefix + "_conjugate", res, res)
          );
        }
      }
      function buildFinalExponentiation() {
        buildCyclotomicSquare();
        buildCyclotomicExp(finalExpZ, finalExpIsNegative, "w0");
        const f2 = module.addFunction(prefix2 + "_finalExponentiation");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const elt = c2.getLocal("x");
        const res = c2.getLocal("r");
        const t0 = c2.i32_const(module.alloc(ftsize));
        const t1 = c2.i32_const(module.alloc(ftsize));
        const t2 = c2.i32_const(module.alloc(ftsize));
        const t3 = c2.i32_const(module.alloc(ftsize));
        const t4 = c2.i32_const(module.alloc(ftsize));
        const t5 = c2.i32_const(module.alloc(ftsize));
        const t6 = c2.i32_const(module.alloc(ftsize));
        f2.addCode(
          // let mut t0 = f.frobenius_map(6)
          c2.call(ftmPrefix + "_frobeniusMap6", elt, t0),
          // let t1 = f.invert()
          c2.call(ftmPrefix + "_inverse", elt, t1),
          // let mut t2 = t0 * t1;
          c2.call(ftmPrefix + "_mul", t0, t1, t2),
          // t1 = t2.clone();
          c2.call(ftmPrefix + "_copy", t2, t1),
          // t2 = t2.frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap2", t2, t2),
          // t2 *= t1;
          c2.call(ftmPrefix + "_mul", t2, t1, t2),
          // t1 = cyclotomic_square(t2).conjugate();
          c2.call(prefix2 + "__cyclotomicSquare", t2, t1),
          c2.call(ftmPrefix + "_conjugate", t1, t1),
          // let mut t3 = cycolotomic_exp(t2);
          c2.call(prefix2 + "__cyclotomicExp_w0", t2, t3),
          // let mut t4 = cyclotomic_square(t3);
          c2.call(prefix2 + "__cyclotomicSquare", t3, t4),
          // let mut t5 = t1 * t3;
          c2.call(ftmPrefix + "_mul", t1, t3, t5),
          // t1 = cycolotomic_exp(t5);
          c2.call(prefix2 + "__cyclotomicExp_w0", t5, t1),
          // t0 = cycolotomic_exp(t1);
          c2.call(prefix2 + "__cyclotomicExp_w0", t1, t0),
          // let mut t6 = cycolotomic_exp(t0);
          c2.call(prefix2 + "__cyclotomicExp_w0", t0, t6),
          // t6 *= t4;
          c2.call(ftmPrefix + "_mul", t6, t4, t6),
          // t4 = cycolotomic_exp(t6);
          c2.call(prefix2 + "__cyclotomicExp_w0", t6, t4),
          // t5 = t5.conjugate();
          c2.call(ftmPrefix + "_conjugate", t5, t5),
          // t4 *= t5 * t2;
          c2.call(ftmPrefix + "_mul", t4, t5, t4),
          c2.call(ftmPrefix + "_mul", t4, t2, t4),
          // t5 = t2.conjugate();
          c2.call(ftmPrefix + "_conjugate", t2, t5),
          // t1 *= t2;
          c2.call(ftmPrefix + "_mul", t1, t2, t1),
          // t1 = t1.frobenius_map().frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap3", t1, t1),
          // t6 *= t5;
          c2.call(ftmPrefix + "_mul", t6, t5, t6),
          // t6 = t6.frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap1", t6, t6),
          // t3 *= t0;
          c2.call(ftmPrefix + "_mul", t3, t0, t3),
          // t3 = t3.frobenius_map().frobenius_map();
          c2.call(ftmPrefix + "_frobeniusMap2", t3, t3),
          // t3 *= t1;
          c2.call(ftmPrefix + "_mul", t3, t1, t3),
          // t3 *= t6;
          c2.call(ftmPrefix + "_mul", t3, t6, t3),
          // f = t3 * t4;
          c2.call(ftmPrefix + "_mul", t3, t4, res)
        );
      }
      function buildFinalExponentiationOld() {
        const f2 = module.addFunction(prefix2 + "_finalExponentiationOld");
        f2.addParam("x", "i32");
        f2.addParam("r", "i32");
        const exponent = 322277361516934140462891564586510139908379969514828494218366688025288661041104682794998680497580008899973249814104447692778988208376779573819485263026159588510513834876303014016798809919343532899164848730280942609956670917565618115867287399623286813270357901731510188149934363360381614501334086825442271920079363289954510565375378443704372994881406797882676971082200626541916413184642520269678897559532260949334760604962086348898118982248842634379637598665468817769075878555493752214492790122785850202957575200176084204422751485957336465472324810982833638490904279282696134323072515220044451592646885410572234451732790590013479358343841220074174848221722017083597872017638514103174122784843925578370430843522959600095676285723737049438346544753168912974976791528535276317256904336520179281145394686565050419250614107803233314658825463117900250701199181529205942363159325765991819433914303908860460720581408201373164047773794825411011922305820065611121544561808414055302212057471395719432072209245600258134364584636810093520285711072578721435517884103526483832733289802426157301542744476740008494780363354305116978805620671467071400711358839553375340724899735460480144599782014906586543813292157922220645089192130209334926661588737007768565838519456601560804957985667880395221049249803753582637708560n;
        const pExponent = module.alloc(utils$1.bigInt2BytesLE(exponent, 544));
        const c2 = f2.getCodeBuilder();
        f2.addCode(
          c2.call(ftmPrefix + "_exp", c2.getLocal("x"), c2.i32_const(pExponent), c2.i32_const(544), c2.getLocal("r"))
        );
      }
      const pPreP = module.alloc(prePSize);
      const pPreQ = module.alloc(preQSize);
      function buildPairingEquation(nPairings) {
        const f2 = module.addFunction(prefix2 + "_pairingEq" + nPairings);
        for (let i2 = 0; i2 < nPairings; i2++) {
          f2.addParam("p_" + i2, "i32");
          f2.addParam("q_" + i2, "i32");
        }
        f2.addParam("c", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module.alloc(ftsize));
        const auxT = c2.i32_const(module.alloc(ftsize));
        f2.addCode(c2.call(ftmPrefix + "_one", resT));
        for (let i2 = 0; i2 < nPairings; i2++) {
          f2.addCode(c2.call(prefix2 + "_prepareG1", c2.getLocal("p_" + i2), c2.i32_const(pPreP)));
          f2.addCode(c2.call(prefix2 + "_prepareG2", c2.getLocal("q_" + i2), c2.i32_const(pPreQ)));
          f2.addCode(
            c2.if(
              c2.i32_eqz(c2.call(g1mPrefix + "_inGroupAffine", c2.i32_const(pPreP))),
              c2.ret(c2.i32_const(0))
            ),
            c2.if(
              c2.i32_eqz(c2.call(g2mPrefix + "_inGroupAffine", c2.i32_const(pPreQ))),
              c2.ret(c2.i32_const(0))
            )
          );
          f2.addCode(c2.call(prefix2 + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), auxT));
          f2.addCode(c2.call(ftmPrefix + "_mul", resT, auxT, resT));
        }
        f2.addCode(c2.call(prefix2 + "_finalExponentiation", resT, resT));
        f2.addCode(c2.call(ftmPrefix + "_eq", resT, c2.getLocal("c")));
      }
      function buildPairing2() {
        const f2 = module.addFunction(prefix2 + "_pairing");
        f2.addParam("p", "i32");
        f2.addParam("q", "i32");
        f2.addParam("r", "i32");
        const c2 = f2.getCodeBuilder();
        const resT = c2.i32_const(module.alloc(ftsize));
        f2.addCode(c2.call(prefix2 + "_prepareG1", c2.getLocal("p"), c2.i32_const(pPreP)));
        f2.addCode(c2.call(prefix2 + "_prepareG2", c2.getLocal("q"), c2.i32_const(pPreQ)));
        f2.addCode(c2.call(prefix2 + "_millerLoop", c2.i32_const(pPreP), c2.i32_const(pPreQ), resT));
        f2.addCode(c2.call(prefix2 + "_finalExponentiation", resT, c2.getLocal("r")));
      }
      function buildInGroupG2() {
        const f2 = module.addFunction(g2mPrefix + "_inGroupAffine");
        f2.addParam("p", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const WINV = [
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279894n,
          2001204777610833696708894912867952078278441409969503942666029068062015825245418932221343814564507832018947136279893n
        ];
        const FROB2X = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const FROB3Y = [
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n,
          2973677408986561043442465346520108879172042883009249989176415018091420807192182638567116318576472649347015917690530n
        ];
        const wInv = c2.i32_const(module.alloc([
          ...utils$1.bigInt2BytesLE(toMontgomery(WINV[0]), n8q),
          ...utils$1.bigInt2BytesLE(toMontgomery(WINV[1]), n8q)
        ]));
        const frob2X = c2.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(FROB2X), n8q)));
        const frob3Y = c2.i32_const(module.alloc([
          ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[0]), n8q),
          ...utils$1.bigInt2BytesLE(toMontgomery(FROB3Y[1]), n8q)
        ]));
        const z2 = c2.i32_const(module.alloc(utils$1.bigInt2BytesLE(finalExpZ, 8)));
        const px = c2.getLocal("p");
        const py = c2.i32_add(c2.getLocal("p"), c2.i32_const(f2size));
        const aux = c2.i32_const(module.alloc(f1size));
        const x_winv = c2.i32_const(module.alloc(f2size));
        const y_winv = c2.i32_const(module.alloc(f2size));
        const pf2 = module.alloc(f2size * 2);
        const f22 = c2.i32_const(pf2);
        const f2x = c2.i32_const(pf2);
        const f2x_c1 = c2.i32_const(pf2);
        const f2x_c2 = c2.i32_const(pf2 + f1size);
        const f2y = c2.i32_const(pf2 + f2size);
        const f2y_c1 = c2.i32_const(pf2 + f2size);
        const f2y_c2 = c2.i32_const(pf2 + f2size + f1size);
        const pf3 = module.alloc(f2size * 3);
        const f3 = c2.i32_const(pf3);
        const f3x = c2.i32_const(pf3);
        const f3x_c1 = c2.i32_const(pf3);
        const f3x_c2 = c2.i32_const(pf3 + f1size);
        const f3y = c2.i32_const(pf3 + f2size);
        const f3y_c1 = c2.i32_const(pf3 + f2size);
        const f3y_c2 = c2.i32_const(pf3 + f2size + f1size);
        const f3z = c2.i32_const(pf3 + f2size * 2);
        f2.addCode(
          c2.if(
            c2.call(g2mPrefix + "_isZeroAffine", c2.getLocal("p")),
            c2.ret(c2.i32_const(1))
          ),
          c2.if(
            c2.i32_eqz(c2.call(g2mPrefix + "_inCurveAffine", c2.getLocal("p"))),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(f2mPrefix + "_mul", px, wInv, x_winv),
          c2.call(f2mPrefix + "_mul", py, wInv, y_winv),
          c2.call(f2mPrefix + "_mul1", x_winv, frob2X, f2x),
          c2.call(f2mPrefix + "_neg", y_winv, f2y),
          c2.call(f2mPrefix + "_neg", x_winv, f3x),
          c2.call(f2mPrefix + "_mul", y_winv, frob3Y, f3y),
          c2.call(f1mPrefix + "_sub", f2x_c1, f2x_c2, aux),
          c2.call(f1mPrefix + "_add", f2x_c1, f2x_c2, f2x_c2),
          c2.call(f1mPrefix + "_copy", aux, f2x_c1),
          c2.call(f1mPrefix + "_sub", f2y_c1, f2y_c2, aux),
          c2.call(f1mPrefix + "_add", f2y_c1, f2y_c2, f2y_c2),
          c2.call(f1mPrefix + "_copy", aux, f2y_c1),
          c2.call(f1mPrefix + "_add", f3x_c1, f3x_c2, aux),
          c2.call(f1mPrefix + "_sub", f3x_c1, f3x_c2, f3x_c2),
          c2.call(f1mPrefix + "_copy", aux, f3x_c1),
          c2.call(f1mPrefix + "_sub", f3y_c2, f3y_c1, aux),
          c2.call(f1mPrefix + "_add", f3y_c1, f3y_c2, f3y_c2),
          c2.call(f1mPrefix + "_copy", aux, f3y_c1),
          c2.call(f2mPrefix + "_one", f3z),
          c2.call(g2mPrefix + "_timesScalar", f3, z2, c2.i32_const(8), f3),
          c2.call(g2mPrefix + "_addMixed", f3, f22, f3),
          c2.ret(
            c2.call(g2mPrefix + "_eqMixed", f3, c2.getLocal("p"))
          )
        );
        const fInGroup = module.addFunction(g2mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c22 = fInGroup.getCodeBuilder();
        const aux2 = c22.i32_const(module.alloc(f2size * 2));
        fInGroup.addCode(
          c22.call(g2mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
          c22.ret(
            c22.call(g2mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      function buildInGroupG1() {
        const f2 = module.addFunction(g1mPrefix + "_inGroupAffine");
        f2.addParam("p", "i32");
        f2.setReturnType("i32");
        const c2 = f2.getCodeBuilder();
        const BETA = 4002409555221667392624310435006688643935503118305586438271171395842971157480381377015405980053539358417135540939436n;
        const BETA2 = 793479390729215512621379701633421447060886740281060493010456487427281649075476305620758731620350n;
        const Z2M1D3 = (finalExpZ * finalExpZ - 1n) / 3n;
        const beta = c2.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA), n8q)));
        const beta2 = c2.i32_const(module.alloc(utils$1.bigInt2BytesLE(toMontgomery(BETA2), n8q)));
        const z2m1d3 = c2.i32_const(module.alloc(utils$1.bigInt2BytesLE(Z2M1D3, 16)));
        const px = c2.getLocal("p");
        const py = c2.i32_add(c2.getLocal("p"), c2.i32_const(f1size));
        const psp = module.alloc(f1size * 3);
        const sp = c2.i32_const(psp);
        const spx = c2.i32_const(psp);
        const spy = c2.i32_const(psp + f1size);
        const ps2p = module.alloc(f1size * 2);
        const s2p = c2.i32_const(ps2p);
        const s2px = c2.i32_const(ps2p);
        const s2py = c2.i32_const(ps2p + f1size);
        f2.addCode(
          c2.if(
            c2.call(g1mPrefix + "_isZeroAffine", c2.getLocal("p")),
            c2.ret(c2.i32_const(1))
          ),
          c2.if(
            c2.i32_eqz(c2.call(g1mPrefix + "_inCurveAffine", c2.getLocal("p"))),
            c2.ret(c2.i32_const(0))
          ),
          c2.call(f1mPrefix + "_mul", px, beta, spx),
          c2.call(f1mPrefix + "_copy", py, spy),
          c2.call(f1mPrefix + "_mul", px, beta2, s2px),
          c2.call(f1mPrefix + "_copy", py, s2py),
          c2.call(g1mPrefix + "_doubleAffine", sp, sp),
          c2.call(g1mPrefix + "_subMixed", sp, c2.getLocal("p"), sp),
          c2.call(g1mPrefix + "_subMixed", sp, s2p, sp),
          c2.call(g1mPrefix + "_timesScalar", sp, z2m1d3, c2.i32_const(16), sp),
          c2.ret(
            c2.call(g1mPrefix + "_eqMixed", sp, s2p)
          )
        );
        const fInGroup = module.addFunction(g1mPrefix + "_inGroup");
        fInGroup.addParam("pIn", "i32");
        fInGroup.setReturnType("i32");
        const c22 = fInGroup.getCodeBuilder();
        const aux2 = c22.i32_const(module.alloc(f1size * 2));
        fInGroup.addCode(
          c22.call(g1mPrefix + "_toAffine", c22.getLocal("pIn"), aux2),
          c22.ret(
            c22.call(g1mPrefix + "_inGroupAffine", aux2)
          )
        );
      }
      for (let i2 = 0; i2 < 10; i2++) {
        buildFrobeniusMap(i2);
        module.exportFunction(ftmPrefix + "_frobeniusMap" + i2);
      }
      buildInGroupG1();
      buildInGroupG2();
      buildPrepAddStep();
      buildPrepDoubleStep();
      buildPrepareG1();
      buildPrepareG2();
      buildMillerLoop();
      buildFinalExponentiationOld();
      buildFinalExponentiation();
      for (let i2 = 1; i2 <= 5; i2++) {
        buildPairingEquation(i2);
        module.exportFunction(prefix2 + "_pairingEq" + i2);
      }
      buildPairing2();
      module.exportFunction(prefix2 + "_pairing");
      module.exportFunction(prefix2 + "_prepareG1");
      module.exportFunction(prefix2 + "_prepareG2");
      module.exportFunction(prefix2 + "_millerLoop");
      module.exportFunction(prefix2 + "_finalExponentiation");
      module.exportFunction(prefix2 + "_finalExponentiationOld");
      module.exportFunction(prefix2 + "__cyclotomicSquare");
      module.exportFunction(prefix2 + "__cyclotomicExp_w0");
      module.exportFunction(f6mPrefix + "_mul1");
      module.exportFunction(f6mPrefix + "_mul01");
      module.exportFunction(ftmPrefix + "_mul014");
      module.exportFunction(g1mPrefix + "_inGroupAffine");
      module.exportFunction(g1mPrefix + "_inGroup");
      module.exportFunction(g2mPrefix + "_inGroupAffine");
      module.exportFunction(g2mPrefix + "_inGroup");
    };
    buildBn128$1 = build_bn128;
    buildBls12381$1 = build_bls12381;
    _revTable = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _revTable[i2] = _revSlow(i2, 8);
    }
    _utils = Object.freeze({
      __proto__: null,
      array2buffer,
      beBuff2int,
      beInt2Buff,
      bitReverse,
      buffReverseBits,
      buffer2array,
      leBuff2int,
      leInt2Buff,
      log2,
      stringifyBigInts,
      stringifyFElements,
      unstringifyBigInts,
      unstringifyFElements
    });
    PAGE_SIZE = 1 << 30;
    BigBuffer = class _BigBuffer {
      constructor(size) {
        this.buffers = [];
        this.byteLength = size;
        for (let i2 = 0; i2 < size; i2 += PAGE_SIZE) {
          const n = Math.min(size - i2, PAGE_SIZE);
          this.buffers.push(new Uint8Array(n));
        }
      }
      slice(fr, to) {
        if (to === void 0) to = this.byteLength;
        if (fr === void 0) fr = 0;
        const len = to - fr;
        const firstPage = Math.floor(fr / PAGE_SIZE);
        const lastPage = Math.floor((fr + len - 1) / PAGE_SIZE);
        if (firstPage == lastPage || len == 0)
          return this.buffers[firstPage].slice(fr % PAGE_SIZE, fr % PAGE_SIZE + len);
        let buff;
        let p2 = firstPage;
        let o2 = fr % PAGE_SIZE;
        let r2 = len;
        while (r2 > 0) {
          const l2 = o2 + r2 > PAGE_SIZE ? PAGE_SIZE - o2 : r2;
          const srcView = new Uint8Array(this.buffers[p2].buffer, this.buffers[p2].byteOffset + o2, l2);
          if (l2 == len) return srcView.slice();
          if (!buff) {
            if (len <= PAGE_SIZE) {
              buff = new Uint8Array(len);
            } else {
              buff = new _BigBuffer(len);
            }
          }
          buff.set(srcView, len - r2);
          r2 = r2 - l2;
          p2++;
          o2 = 0;
        }
        return buff;
      }
      set(buff, offset) {
        if (offset === void 0) offset = 0;
        const len = buff.byteLength;
        if (len == 0) return;
        const firstPage = Math.floor(offset / PAGE_SIZE);
        const lastPage = Math.floor((offset + len - 1) / PAGE_SIZE);
        if (firstPage == lastPage) {
          if (buff instanceof _BigBuffer && buff.buffers.length == 1) {
            return this.buffers[firstPage].set(buff.buffers[0], offset % PAGE_SIZE);
          } else {
            return this.buffers[firstPage].set(buff, offset % PAGE_SIZE);
          }
        }
        let p2 = firstPage;
        let o2 = offset % PAGE_SIZE;
        let r2 = len;
        while (r2 > 0) {
          const l2 = o2 + r2 > PAGE_SIZE ? PAGE_SIZE - o2 : r2;
          const srcView = buff.slice(len - r2, len - r2 + l2);
          const dstView = new Uint8Array(this.buffers[p2].buffer, this.buffers[p2].byteOffset + o2, l2);
          dstView.set(srcView);
          r2 = r2 - l2;
          p2++;
          o2 = 0;
        }
      }
    };
    WasmField1 = class {
      constructor(tm, prefix2, n8, p2) {
        this.tm = tm;
        this.prefix = prefix2;
        this.p = p2;
        this.n8 = n8;
        this.type = "F1";
        this.m = 1;
        this.half = shiftRight(p2, one);
        this.bitLength = bitLength$6(p2);
        this.mask = sub(shiftLeft(one, this.bitLength), one);
        this.pOp1 = tm.alloc(n8);
        this.pOp2 = tm.alloc(n8);
        this.pOp3 = tm.alloc(n8);
        this.tm.instance.exports[prefix2 + "_zero"](this.pOp1);
        this.zero = this.tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix2 + "_one"](this.pOp1);
        this.one = this.tm.getBuff(this.pOp1, this.n8);
        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);
        this.n64 = Math.floor(n8 / 8);
        this.n32 = Math.floor(n8 / 4);
        if (this.n64 * 8 != this.n8) {
          throw new Error("n8 must be a multiple of 8");
        }
        this.half = shiftRight(this.p, one);
        this.nqr = this.two;
        let r2 = this.exp(this.nqr, this.half);
        while (!this.eq(r2, this.negone)) {
          this.nqr = this.add(this.nqr, this.one);
          r2 = this.exp(this.nqr, this.half);
        }
        this.shift = this.mul(this.nqr, this.nqr);
        this.shiftInv = this.inv(this.shift);
        this.s = 0;
        let t = sub(this.p, one);
        while (!isOdd$5(t)) {
          this.s = this.s + 1;
          t = shiftRight(t, one);
        }
        this.w = [];
        this.w[this.s] = this.exp(this.nqr, t);
        for (let i2 = this.s - 1; i2 >= 0; i2--) {
          this.w[i2] = this.square(this.w[i2 + 1]);
        }
        if (!this.eq(this.w[0], this.one)) {
          throw new Error("Error calculating roots of unity");
        }
        this.batchToMontgomery = buildBatchConvert(tm, prefix2 + "_batchToMontgomery", this.n8, this.n8);
        this.batchFromMontgomery = buildBatchConvert(tm, prefix2 + "_batchFromMontgomery", this.n8, this.n8);
      }
      op2(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op2Bool(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
      }
      op1(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op1Bool(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      }
      add(a2, b2) {
        return this.op2("_add", a2, b2);
      }
      eq(a2, b2) {
        return this.op2Bool("_eq", a2, b2);
      }
      isZero(a2) {
        return this.op1Bool("_isZero", a2);
      }
      sub(a2, b2) {
        return this.op2("_sub", a2, b2);
      }
      neg(a2) {
        return this.op1("_neg", a2);
      }
      inv(a2) {
        return this.op1("_inverse", a2);
      }
      toMontgomery(a2) {
        return this.op1("_toMontgomery", a2);
      }
      fromMontgomery(a2) {
        return this.op1("_fromMontgomery", a2);
      }
      mul(a2, b2) {
        return this.op2("_mul", a2, b2);
      }
      div(a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      square(a2) {
        return this.op1("_square", a2);
      }
      isSquare(a2) {
        return this.op1Bool("_isSquare", a2);
      }
      sqrt(a2) {
        return this.op1("_sqrt", a2);
      }
      exp(a2, b2) {
        if (!(b2 instanceof Uint8Array)) {
          b2 = toLEBuff(e(b2));
        }
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b2.byteLength, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      isNegative(a2) {
        return this.op1Bool("_isNegative", a2);
      }
      e(a2, b2) {
        if (a2 instanceof Uint8Array) return a2;
        let ra = e(a2, b2);
        if (isNegative$4(ra)) {
          ra = neg(ra);
          if (gt(ra, this.p)) {
            ra = mod(ra, this.p);
          }
          ra = sub(this.p, ra);
        } else {
          if (gt(ra, this.p)) {
            ra = mod(ra, this.p);
          }
        }
        const buff = leInt2Buff(ra, this.n8);
        return this.toMontgomery(buff);
      }
      toString(a2, radix) {
        const an = this.fromMontgomery(a2);
        const s2 = fromRprLE(an, 0);
        return toString(s2, radix);
      }
      fromRng(rng) {
        let v2;
        const buff = new Uint8Array(this.n8);
        do {
          v2 = zero;
          for (let i2 = 0; i2 < this.n64; i2++) {
            v2 = add(v2, shiftLeft(rng.nextU64(), 64 * i2));
          }
          v2 = band(v2, this.mask);
        } while (geq(v2, this.p));
        toRprLE(buff, 0, v2, this.n8);
        return buff;
      }
      random() {
        return this.fromRng(getThreadRng());
      }
      toObject(a2) {
        const an = this.fromMontgomery(a2);
        return fromRprLE(an, 0);
      }
      fromObject(a2) {
        const buff = new Uint8Array(this.n8);
        toRprLE(buff, 0, a2, this.n8);
        return this.toMontgomery(buff);
      }
      toRprLE(buff, offset, a2) {
        buff.set(this.fromMontgomery(a2), offset);
      }
      toRprBE(buff, offset, a2) {
        const buff2 = this.fromMontgomery(a2);
        for (let i2 = 0; i2 < this.n8 / 2; i2++) {
          const aux = buff2[i2];
          buff2[i2] = buff2[this.n8 - 1 - i2];
          buff2[this.n8 - 1 - i2] = aux;
        }
        buff.set(buff2, offset);
      }
      fromRprLE(buff, offset) {
        offset = offset || 0;
        const res = buff.slice(offset, offset + this.n8);
        return this.toMontgomery(res);
      }
      async batchInverse(buffIn) {
        let returnArray = false;
        const sIn = this.n8;
        const sOut = this.n8;
        if (Array.isArray(buffIn)) {
          buffIn = array2buffer(buffIn, sIn);
          returnArray = true;
        } else {
          buffIn = buffIn.slice(0, buffIn.byteLength);
        }
        const nPoints = Math.floor(buffIn.byteLength / sIn);
        if (nPoints * sIn !== buffIn.byteLength) {
          throw new Error("Invalid buffer size");
        }
        const pointsPerChunk = Math.floor(nPoints / this.tm.concurrency);
        const opPromises = [];
        for (let i2 = 0; i2 < this.tm.concurrency; i2++) {
          let n;
          if (i2 < this.tm.concurrency - 1) {
            n = pointsPerChunk;
          } else {
            n = nPoints - i2 * pointsPerChunk;
          }
          if (n == 0) continue;
          const buffChunk = buffIn.slice(i2 * pointsPerChunk * sIn, i2 * pointsPerChunk * sIn + n * sIn);
          const task = [
            { cmd: "ALLOCSET", var: 0, buff: buffChunk },
            { cmd: "ALLOC", var: 1, len: sOut * n },
            { cmd: "CALL", fnName: this.prefix + "_batchInverse", params: [
              { var: 0 },
              { val: sIn },
              { val: n },
              { var: 1 },
              { val: sOut }
            ] },
            { cmd: "GET", out: 0, var: 1, len: sOut * n }
          ];
          opPromises.push(
            this.tm.queueAction(task)
          );
        }
        const result = await Promise.all(opPromises);
        let fullBuffOut;
        if (buffIn instanceof BigBuffer) {
          fullBuffOut = new BigBuffer(nPoints * sOut);
        } else {
          fullBuffOut = new Uint8Array(nPoints * sOut);
        }
        let p2 = 0;
        for (let i2 = 0; i2 < result.length; i2++) {
          fullBuffOut.set(result[i2][0], p2);
          p2 += result[i2][0].byteLength;
        }
        if (returnArray) {
          return buffer2array(fullBuffOut, sOut);
        } else {
          return fullBuffOut;
        }
      }
    };
    WasmField2 = class {
      constructor(tm, prefix2, F2) {
        this.tm = tm;
        this.prefix = prefix2;
        this.F = F2;
        this.type = "F2";
        this.m = F2.m * 2;
        this.n8 = this.F.n8 * 2;
        this.n32 = this.F.n32 * 2;
        this.n64 = this.F.n64 * 2;
        this.pOp1 = tm.alloc(F2.n8 * 2);
        this.pOp2 = tm.alloc(F2.n8 * 2);
        this.pOp3 = tm.alloc(F2.n8 * 2);
        this.tm.instance.exports[prefix2 + "_zero"](this.pOp1);
        this.zero = tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix2 + "_one"](this.pOp1);
        this.one = tm.getBuff(this.pOp1, this.n8);
        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);
      }
      op2(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op2Bool(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
      }
      op1(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op1Bool(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      }
      add(a2, b2) {
        return this.op2("_add", a2, b2);
      }
      eq(a2, b2) {
        return this.op2Bool("_eq", a2, b2);
      }
      isZero(a2) {
        return this.op1Bool("_isZero", a2);
      }
      sub(a2, b2) {
        return this.op2("_sub", a2, b2);
      }
      neg(a2) {
        return this.op1("_neg", a2);
      }
      inv(a2) {
        return this.op1("_inverse", a2);
      }
      isNegative(a2) {
        return this.op1Bool("_isNegative", a2);
      }
      toMontgomery(a2) {
        return this.op1("_toMontgomery", a2);
      }
      fromMontgomery(a2) {
        return this.op1("_fromMontgomery", a2);
      }
      mul(a2, b2) {
        return this.op2("_mul", a2, b2);
      }
      mul1(a2, b2) {
        return this.op2("_mul1", a2, b2);
      }
      div(a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      square(a2) {
        return this.op1("_square", a2);
      }
      isSquare(a2) {
        return this.op1Bool("_isSquare", a2);
      }
      sqrt(a2) {
        return this.op1("_sqrt", a2);
      }
      exp(a2, b2) {
        if (!(b2 instanceof Uint8Array)) {
          b2 = toLEBuff(e(b2));
        }
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b2.byteLength, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      e(a2, b2) {
        if (a2 instanceof Uint8Array) return a2;
        if (Array.isArray(a2) && a2.length == 2) {
          const c1 = this.F.e(a2[0], b2);
          const c2 = this.F.e(a2[1], b2);
          const res = new Uint8Array(this.F.n8 * 2);
          res.set(c1);
          res.set(c2, this.F.n8 * 2);
          return res;
        } else {
          throw new Error("invalid F2");
        }
      }
      toString(a2, radix) {
        const s1 = this.F.toString(a2.slice(0, this.F.n8), radix);
        const s2 = this.F.toString(a2.slice(this.F.n8), radix);
        return `[${s1}, ${s2}]`;
      }
      fromRng(rng) {
        const c1 = this.F.fromRng(rng);
        const c2 = this.F.fromRng(rng);
        const res = new Uint8Array(this.F.n8 * 2);
        res.set(c1);
        res.set(c2, this.F.n8);
        return res;
      }
      random() {
        return this.fromRng(getThreadRng());
      }
      toObject(a2) {
        const c1 = this.F.toObject(a2.slice(0, this.F.n8));
        const c2 = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
        return [c1, c2];
      }
      fromObject(a2) {
        const buff = new Uint8Array(this.F.n8 * 2);
        const b1 = this.F.fromObject(a2[0]);
        const b2 = this.F.fromObject(a2[1]);
        buff.set(b1);
        buff.set(b2, this.F.n8);
        return buff;
      }
      c1(a2) {
        return a2.slice(0, this.F.n8);
      }
      c2(a2) {
        return a2.slice(this.F.n8);
      }
    };
    WasmField3 = class {
      constructor(tm, prefix2, F2) {
        this.tm = tm;
        this.prefix = prefix2;
        this.F = F2;
        this.type = "F3";
        this.m = F2.m * 3;
        this.n8 = this.F.n8 * 3;
        this.n32 = this.F.n32 * 3;
        this.n64 = this.F.n64 * 3;
        this.pOp1 = tm.alloc(F2.n8 * 3);
        this.pOp2 = tm.alloc(F2.n8 * 3);
        this.pOp3 = tm.alloc(F2.n8 * 3);
        this.tm.instance.exports[prefix2 + "_zero"](this.pOp1);
        this.zero = tm.getBuff(this.pOp1, this.n8);
        this.tm.instance.exports[prefix2 + "_one"](this.pOp1);
        this.one = tm.getBuff(this.pOp1, this.n8);
        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);
      }
      op2(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op2Bool(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2);
      }
      op1(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      op1Bool(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      }
      eq(a2, b2) {
        return this.op2Bool("_eq", a2, b2);
      }
      isZero(a2) {
        return this.op1Bool("_isZero", a2);
      }
      add(a2, b2) {
        return this.op2("_add", a2, b2);
      }
      sub(a2, b2) {
        return this.op2("_sub", a2, b2);
      }
      neg(a2) {
        return this.op1("_neg", a2);
      }
      inv(a2) {
        return this.op1("_inverse", a2);
      }
      isNegative(a2) {
        return this.op1Bool("_isNegative", a2);
      }
      toMontgomery(a2) {
        return this.op1("_toMontgomery", a2);
      }
      fromMontgomery(a2) {
        return this.op1("_fromMontgomery", a2);
      }
      mul(a2, b2) {
        return this.op2("_mul", a2, b2);
      }
      div(a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_inverse"](this.pOp2, this.pOp2);
        this.tm.instance.exports[this.prefix + "_mul"](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.n8);
      }
      square(a2) {
        return this.op1("_square", a2);
      }
      isSquare(a2) {
        return this.op1Bool("_isSquare", a2);
      }
      sqrt(a2) {
        return this.op1("_sqrt", a2);
      }
      exp(a2, b2) {
        if (!(b2 instanceof Uint8Array)) {
          b2 = toLEBuff(e(b2));
        }
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + "_exp"](this.pOp1, this.pOp2, b2.byteLength, this.pOp3);
        return this.getBuff(this.pOp3, this.n8);
      }
      e(a2, b2) {
        if (a2 instanceof Uint8Array) return a2;
        if (Array.isArray(a2) && a2.length == 3) {
          const c1 = this.F.e(a2[0], b2);
          const c2 = this.F.e(a2[1], b2);
          const c3 = this.F.e(a2[2], b2);
          const res = new Uint8Array(this.F.n8 * 3);
          res.set(c1);
          res.set(c2, this.F.n8);
          res.set(c3, this.F.n8 * 2);
          return res;
        } else {
          throw new Error("invalid F3");
        }
      }
      toString(a2, radix) {
        const s1 = this.F.toString(a2.slice(0, this.F.n8), radix);
        const s2 = this.F.toString(a2.slice(this.F.n8, this.F.n8 * 2), radix);
        const s3 = this.F.toString(a2.slice(this.F.n8 * 2), radix);
        return `[${s1}, ${s2}, ${s3}]`;
      }
      fromRng(rng) {
        const c1 = this.F.fromRng(rng);
        const c2 = this.F.fromRng(rng);
        const c3 = this.F.fromRng(rng);
        const res = new Uint8Array(this.F.n8 * 3);
        res.set(c1);
        res.set(c2, this.F.n8);
        res.set(c3, this.F.n8 * 2);
        return res;
      }
      random() {
        return this.fromRng(getThreadRng());
      }
      toObject(a2) {
        const c1 = this.F.toObject(a2.slice(0, this.F.n8));
        const c2 = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
        const c3 = this.F.toObject(a2.slice(this.F.n8 * 2, this.F.n8 * 3));
        return [c1, c2, c3];
      }
      fromObject(a2) {
        const buff = new Uint8Array(this.F.n8 * 3);
        const b1 = this.F.fromObject(a2[0]);
        const b2 = this.F.fromObject(a2[1]);
        const b3 = this.F.fromObject(a2[2]);
        buff.set(b1);
        buff.set(b2, this.F.n8);
        buff.set(b3, this.F.n8 * 2);
        return buff;
      }
      c1(a2) {
        return a2.slice(0, this.F.n8);
      }
      c2(a2) {
        return a2.slice(this.F.n8, this.F.n8 * 2);
      }
      c3(a2) {
        return a2.slice(this.F.n8 * 2);
      }
    };
    WasmCurve = class {
      constructor(tm, prefix2, F2, pGen, pGb, cofactor) {
        this.tm = tm;
        this.prefix = prefix2;
        this.F = F2;
        this.pOp1 = tm.alloc(F2.n8 * 3);
        this.pOp2 = tm.alloc(F2.n8 * 3);
        this.pOp3 = tm.alloc(F2.n8 * 3);
        this.tm.instance.exports[prefix2 + "_zero"](this.pOp1);
        this.zero = this.tm.getBuff(this.pOp1, F2.n8 * 3);
        this.tm.instance.exports[prefix2 + "_zeroAffine"](this.pOp1);
        this.zeroAffine = this.tm.getBuff(this.pOp1, F2.n8 * 2);
        this.one = this.tm.getBuff(pGen, F2.n8 * 3);
        this.g = this.one;
        this.oneAffine = this.tm.getBuff(pGen, F2.n8 * 2);
        this.gAffine = this.oneAffine;
        this.b = this.tm.getBuff(pGb, F2.n8);
        if (cofactor) {
          this.cofactor = toLEBuff(cofactor);
        }
        this.negone = this.neg(this.one);
        this.two = this.add(this.one, this.one);
        this.batchLEMtoC = buildBatchConvert(tm, prefix2 + "_batchLEMtoC", F2.n8 * 2, F2.n8);
        this.batchLEMtoU = buildBatchConvert(tm, prefix2 + "_batchLEMtoU", F2.n8 * 2, F2.n8 * 2);
        this.batchCtoLEM = buildBatchConvert(tm, prefix2 + "_batchCtoLEM", F2.n8, F2.n8 * 2);
        this.batchUtoLEM = buildBatchConvert(tm, prefix2 + "_batchUtoLEM", F2.n8 * 2, F2.n8 * 2);
        this.batchToJacobian = buildBatchConvert(tm, prefix2 + "_batchToJacobian", F2.n8 * 2, F2.n8 * 3);
        this.batchToAffine = buildBatchConvert(tm, prefix2 + "_batchToAffine", F2.n8 * 3, F2.n8 * 2);
      }
      op2(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
      }
      op2bool(opName, a2, b2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, b2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp2, this.pOp3);
      }
      op1(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
      }
      op1Affine(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.F.n8 * 2);
      }
      op1Bool(opName, a2) {
        this.tm.setBuff(this.pOp1, a2);
        return !!this.tm.instance.exports[this.prefix + opName](this.pOp1, this.pOp3);
      }
      add(a2, b2) {
        if (a2.byteLength == this.F.n8 * 3) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2("_add", a2, b2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2("_addMixed", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else if (a2.byteLength == this.F.n8 * 2) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2("_addMixed", b2, a2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2("_addAffine", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else {
          throw new Error("invalid point size");
        }
      }
      sub(a2, b2) {
        if (a2.byteLength == this.F.n8 * 3) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2("_sub", a2, b2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2("_subMixed", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else if (a2.byteLength == this.F.n8 * 2) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2("_subMixed", b2, a2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2("_subAffine", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else {
          throw new Error("invalid point size");
        }
      }
      neg(a2) {
        if (a2.byteLength == this.F.n8 * 3) {
          return this.op1("_neg", a2);
        } else if (a2.byteLength == this.F.n8 * 2) {
          return this.op1Affine("_negAffine", a2);
        } else {
          throw new Error("invalid point size");
        }
      }
      double(a2) {
        if (a2.byteLength == this.F.n8 * 3) {
          return this.op1("_double", a2);
        } else if (a2.byteLength == this.F.n8 * 2) {
          return this.op1("_doubleAffine", a2);
        } else {
          throw new Error("invalid point size");
        }
      }
      isZero(a2) {
        if (a2.byteLength == this.F.n8 * 3) {
          return this.op1Bool("_isZero", a2);
        } else if (a2.byteLength == this.F.n8 * 2) {
          return this.op1Bool("_isZeroAffine", a2);
        } else {
          throw new Error("invalid point size");
        }
      }
      timesScalar(a2, s2) {
        if (!(s2 instanceof Uint8Array)) {
          s2 = toLEBuff(e(s2));
        }
        let fnName;
        if (a2.byteLength == this.F.n8 * 3) {
          fnName = this.prefix + "_timesScalar";
        } else if (a2.byteLength == this.F.n8 * 2) {
          fnName = this.prefix + "_timesScalarAffine";
        } else {
          throw new Error("invalid point size");
        }
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, s2);
        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, s2.byteLength, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
      }
      timesFr(a2, s2) {
        let fnName;
        if (a2.byteLength == this.F.n8 * 3) {
          fnName = this.prefix + "_timesFr";
        } else if (a2.byteLength == this.F.n8 * 2) {
          fnName = this.prefix + "_timesFrAffine";
        } else {
          throw new Error("invalid point size");
        }
        this.tm.setBuff(this.pOp1, a2);
        this.tm.setBuff(this.pOp2, s2);
        this.tm.instance.exports[fnName](this.pOp1, this.pOp2, this.pOp3);
        return this.tm.getBuff(this.pOp3, this.F.n8 * 3);
      }
      eq(a2, b2) {
        if (a2.byteLength == this.F.n8 * 3) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2bool("_eq", a2, b2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2bool("_eqMixed", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else if (a2.byteLength == this.F.n8 * 2) {
          if (b2.byteLength == this.F.n8 * 3) {
            return this.op2bool("_eqMixed", b2, a2);
          } else if (b2.byteLength == this.F.n8 * 2) {
            return this.op2bool("_eqAffine", a2, b2);
          } else {
            throw new Error("invalid point size");
          }
        } else {
          throw new Error("invalid point size");
        }
      }
      toAffine(a2) {
        if (a2.byteLength == this.F.n8 * 3) {
          return this.op1Affine("_toAffine", a2);
        } else if (a2.byteLength == this.F.n8 * 2) {
          return a2;
        } else {
          throw new Error("invalid point size");
        }
      }
      toJacobian(a2) {
        if (a2.byteLength == this.F.n8 * 3) {
          return a2;
        } else if (a2.byteLength == this.F.n8 * 2) {
          return this.op1("_toJacobian", a2);
        } else {
          throw new Error("invalid point size");
        }
      }
      toRprUncompressed(arr, offset, a2) {
        this.tm.setBuff(this.pOp1, a2);
        if (a2.byteLength == this.F.n8 * 3) {
          this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
        } else if (a2.byteLength != this.F.n8 * 2) {
          throw new Error("invalid point size");
        }
        this.tm.instance.exports[this.prefix + "_LEMtoU"](this.pOp1, this.pOp1);
        const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
        arr.set(res, offset);
      }
      fromRprUncompressed(arr, offset) {
        const buff = arr.slice(offset, offset + this.F.n8 * 2);
        this.tm.setBuff(this.pOp1, buff);
        this.tm.instance.exports[this.prefix + "_UtoLEM"](this.pOp1, this.pOp1);
        return this.tm.getBuff(this.pOp1, this.F.n8 * 2);
      }
      toRprCompressed(arr, offset, a2) {
        this.tm.setBuff(this.pOp1, a2);
        if (a2.byteLength == this.F.n8 * 3) {
          this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
        } else if (a2.byteLength != this.F.n8 * 2) {
          throw new Error("invalid point size");
        }
        this.tm.instance.exports[this.prefix + "_LEMtoC"](this.pOp1, this.pOp1);
        const res = this.tm.getBuff(this.pOp1, this.F.n8);
        arr.set(res, offset);
      }
      fromRprCompressed(arr, offset) {
        const buff = arr.slice(offset, offset + this.F.n8);
        this.tm.setBuff(this.pOp1, buff);
        this.tm.instance.exports[this.prefix + "_CtoLEM"](this.pOp1, this.pOp2);
        return this.tm.getBuff(this.pOp2, this.F.n8 * 2);
      }
      toUncompressed(a2) {
        const buff = new Uint8Array(this.F.n8 * 2);
        this.toRprUncompressed(buff, 0, a2);
        return buff;
      }
      toRprLEM(arr, offset, a2) {
        if (a2.byteLength == this.F.n8 * 2) {
          arr.set(a2, offset);
          return;
        } else if (a2.byteLength == this.F.n8 * 3) {
          this.tm.setBuff(this.pOp1, a2);
          this.tm.instance.exports[this.prefix + "_toAffine"](this.pOp1, this.pOp1);
          const res = this.tm.getBuff(this.pOp1, this.F.n8 * 2);
          arr.set(res, offset);
        } else {
          throw new Error("invalid point size");
        }
      }
      fromRprLEM(arr, offset) {
        offset = offset || 0;
        return arr.slice(offset, offset + this.F.n8 * 2);
      }
      toString(a2, radix) {
        if (a2.byteLength == this.F.n8 * 3) {
          const x2 = this.F.toString(a2.slice(0, this.F.n8), radix);
          const y2 = this.F.toString(a2.slice(this.F.n8, this.F.n8 * 2), radix);
          const z2 = this.F.toString(a2.slice(this.F.n8 * 2), radix);
          return `[ ${x2}, ${y2}, ${z2} ]`;
        } else if (a2.byteLength == this.F.n8 * 2) {
          const x2 = this.F.toString(a2.slice(0, this.F.n8), radix);
          const y2 = this.F.toString(a2.slice(this.F.n8), radix);
          return `[ ${x2}, ${y2} ]`;
        } else {
          throw new Error("invalid point size");
        }
      }
      isValid(a2) {
        if (this.isZero(a2)) return true;
        const F2 = this.F;
        const aa = this.toAffine(a2);
        const x2 = aa.slice(0, this.F.n8);
        const y2 = aa.slice(this.F.n8, this.F.n8 * 2);
        const x3b = F2.add(F2.mul(F2.square(x2), x2), this.b);
        const y22 = F2.square(y2);
        return F2.eq(x3b, y22);
      }
      fromRng(rng) {
        const F2 = this.F;
        let P2 = [];
        let greatest;
        let x3b;
        do {
          P2[0] = F2.fromRng(rng);
          greatest = rng.nextBool();
          x3b = F2.add(F2.mul(F2.square(P2[0]), P2[0]), this.b);
        } while (!F2.isSquare(x3b));
        P2[1] = F2.sqrt(x3b);
        const s2 = F2.isNegative(P2[1]);
        if (greatest ^ s2) P2[1] = F2.neg(P2[1]);
        let Pbuff = new Uint8Array(this.F.n8 * 2);
        Pbuff.set(P2[0]);
        Pbuff.set(P2[1], this.F.n8);
        if (this.cofactor) {
          Pbuff = this.timesScalar(Pbuff, this.cofactor);
        }
        return Pbuff;
      }
      toObject(a2) {
        if (this.isZero(a2)) {
          return [
            this.F.toObject(this.F.zero),
            this.F.toObject(this.F.one),
            this.F.toObject(this.F.zero)
          ];
        }
        const x2 = this.F.toObject(a2.slice(0, this.F.n8));
        const y2 = this.F.toObject(a2.slice(this.F.n8, this.F.n8 * 2));
        let z2;
        if (a2.byteLength == this.F.n8 * 3) {
          z2 = this.F.toObject(a2.slice(this.F.n8 * 2, this.F.n8 * 3));
        } else {
          z2 = this.F.toObject(this.F.one);
        }
        return [x2, y2, z2];
      }
      fromObject(a2) {
        const x2 = this.F.fromObject(a2[0]);
        const y2 = this.F.fromObject(a2[1]);
        let z2;
        if (a2.length == 3) {
          z2 = this.F.fromObject(a2[2]);
        } else {
          z2 = this.F.one;
        }
        if (this.F.isZero(z2, this.F.one)) {
          return this.zeroAffine;
        } else if (this.F.eq(z2, this.F.one)) {
          const buff = new Uint8Array(this.F.n8 * 2);
          buff.set(x2);
          buff.set(y2, this.F.n8);
          return buff;
        } else {
          const buff = new Uint8Array(this.F.n8 * 3);
          buff.set(x2);
          buff.set(y2, this.F.n8);
          buff.set(z2, this.F.n8 * 2);
          return buff;
        }
      }
      e(a2) {
        if (a2 instanceof Uint8Array) return a2;
        return this.fromObject(a2);
      }
      x(a2) {
        const tmp = this.toAffine(a2);
        return tmp.slice(0, this.F.n8);
      }
      y(a2) {
        const tmp = this.toAffine(a2);
        return tmp.slice(this.F.n8);
      }
    };
    MEM_SIZE = 25;
    Deferred = class {
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this.reject = reject;
          this.resolve = resolve;
        });
      }
    };
    threadStr = `(${'function thread(self) {\n    const MAXMEM = 32767;\n    let instance;\n    let memory;\n\n    if (self) {\n        self.onmessage = function(e) {\n            let data;\n            if (e.data) {\n                data = e.data;\n            } else {\n                data = e;\n            }\n\n            if (data[0].cmd == "INIT") {\n                init(data[0]).then(function() {\n                    self.postMessage(data.result);\n                });\n            } else if (data[0].cmd == "TERMINATE") {\n                self.close();\n            } else {\n                const res = runTask(data);\n                self.postMessage(res);\n            }\n        };\n    }\n\n    async function init(data) {\n        const code = new Uint8Array(data.code);\n        const wasmModule = await WebAssembly.compile(code);\n        memory = new WebAssembly.Memory({initial:data.init, maximum: MAXMEM});\n\n        instance = await WebAssembly.instantiate(wasmModule, {\n            env: {\n                "memory": memory\n            }\n        });\n    }\n\n\n\n    function alloc(length) {\n        const u32 = new Uint32Array(memory.buffer, 0, 1);\n        while (u32[0] & 3) u32[0]++;  // Return always aligned pointers\n        const res = u32[0];\n        u32[0] += length;\n        if (u32[0] + length > memory.buffer.byteLength) {\n            const currentPages = memory.buffer.byteLength / 0x10000;\n            let requiredPages = Math.floor((u32[0] + length) / 0x10000)+1;\n            if (requiredPages>MAXMEM) requiredPages=MAXMEM;\n            memory.grow(requiredPages-currentPages);\n        }\n        return res;\n    }\n\n    function allocBuffer(buffer) {\n        const p = alloc(buffer.byteLength);\n        setBuffer(p, buffer);\n        return p;\n    }\n\n    function getBuffer(pointer, length) {\n        const u8 = new Uint8Array(memory.buffer);\n        return new Uint8Array(u8.buffer, u8.byteOffset + pointer, length);\n    }\n\n    function setBuffer(pointer, buffer) {\n        const u8 = new Uint8Array(memory.buffer);\n        u8.set(new Uint8Array(buffer), pointer);\n    }\n\n    function runTask(task) {\n        if (task[0].cmd == "INIT") {\n            return init(task[0]);\n        }\n        const ctx = {\n            vars: [],\n            out: []\n        };\n        const u32a = new Uint32Array(memory.buffer, 0, 1);\n        const oldAlloc = u32a[0];\n        for (let i=0; i<task.length; i++) {\n            switch (task[i].cmd) {\n            case "ALLOCSET":\n                ctx.vars[task[i].var] = allocBuffer(task[i].buff);\n                break;\n            case "ALLOC":\n                ctx.vars[task[i].var] = alloc(task[i].len);\n                break;\n            case "SET":\n                setBuffer(ctx.vars[task[i].var], task[i].buff);\n                break;\n            case "CALL": {\n                const params = [];\n                for (let j=0; j<task[i].params.length; j++) {\n                    const p = task[i].params[j];\n                    if (typeof p.var !== "undefined") {\n                        params.push(ctx.vars[p.var] + (p.offset || 0));\n                    } else if (typeof p.val != "undefined") {\n                        params.push(p.val);\n                    }\n                }\n                instance.exports[task[i].fnName](...params);\n                break;\n            }\n            case "GET":\n                ctx.out[task[i].out] = getBuffer(ctx.vars[task[i].var], task[i].len).slice();\n                break;\n            default:\n                throw new Error("Invalid cmd");\n            }\n        }\n        const u32b = new Uint32Array(memory.buffer, 0, 1);\n        u32b[0] = oldAlloc;\n        return ctx.out;\n    }\n\n\n    return runTask;\n}'})(self)`;
    {
      if (globalThis?.Blob) {
        const threadBytes = new TextEncoder().encode(threadStr);
        const workerBlob = new Blob([threadBytes], { type: "application/javascript" });
        workerSource = URL.createObjectURL(workerBlob);
      } else {
        workerSource = "data:application/javascript;base64," + globalThis.btoa(threadStr);
      }
    }
    ThreadManager = class {
      constructor() {
        this.actionQueue = [];
        this.oldPFree = 0;
      }
      startSyncOp() {
        if (this.oldPFree != 0) throw new Error("Sync operation in progress");
        this.oldPFree = this.u32[0];
      }
      endSyncOp() {
        if (this.oldPFree == 0) throw new Error("No sync operation in progress");
        this.u32[0] = this.oldPFree;
        this.oldPFree = 0;
      }
      postAction(workerId, e2, transfers, _deferred) {
        if (this.working[workerId]) {
          throw new Error("Posting a job t a working worker");
        }
        this.working[workerId] = true;
        this.pendingDeferreds[workerId] = _deferred ? _deferred : new Deferred();
        this.workers[workerId].postMessage(e2, transfers);
        return this.pendingDeferreds[workerId].promise;
      }
      processWorks() {
        for (let i2 = 0; i2 < this.workers.length && this.actionQueue.length > 0; i2++) {
          if (this.working[i2] == false) {
            const work = this.actionQueue.shift();
            this.postAction(i2, work.data, work.transfers, work.deferred);
          }
        }
      }
      queueAction(actionData, transfers) {
        const d = new Deferred();
        if (this.singleThread) {
          const res = this.taskManager(actionData);
          d.resolve(res);
        } else {
          this.actionQueue.push({
            data: actionData,
            transfers,
            deferred: d
          });
          this.processWorks();
        }
        return d.promise;
      }
      resetMemory() {
        this.u32[0] = this.initalPFree;
      }
      allocBuff(buff) {
        const pointer = this.alloc(buff.byteLength);
        this.setBuff(pointer, buff);
        return pointer;
      }
      getBuff(pointer, length2) {
        return this.u8.slice(pointer, pointer + length2);
      }
      setBuff(pointer, buffer) {
        this.u8.set(new Uint8Array(buffer), pointer);
      }
      alloc(length2) {
        while (this.u32[0] & 3) this.u32[0]++;
        const res = this.u32[0];
        this.u32[0] += length2;
        return res;
      }
      async terminate() {
        for (let i2 = 0; i2 < this.workers.length; i2++) {
          this.workers[i2].postMessage([{ cmd: "TERMINATE" }]);
        }
        await sleep(200);
      }
    };
    pTSizes = [
      1,
      1,
      1,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      13,
      14,
      15,
      16,
      16,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      17,
      17
    ];
    CodeBuilder = class {
      constructor(func) {
        this.func = func;
        this.functionName = func.functionName;
        this.module = func.module;
      }
      setLocal(localName, valCode) {
        const idx = this.func.localIdxByName[localName];
        if (idx === void 0)
          throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
        return [...valCode, 33, ...varuint32(idx)];
      }
      teeLocal(localName, valCode) {
        const idx = this.func.localIdxByName[localName];
        if (idx === void 0)
          throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
        return [...valCode, 34, ...varuint32(idx)];
      }
      getLocal(localName) {
        const idx = this.func.localIdxByName[localName];
        if (idx === void 0)
          throw new Error(`Local Variable not defined: Function: ${this.functionName} local: ${localName} `);
        return [32, ...varuint32(idx)];
      }
      i64_load8_s(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 0 : _align;
        return [...idxCode, 48, align, ...varuint32(offset)];
      }
      i64_load8_u(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 0 : _align;
        return [...idxCode, 49, align, ...varuint32(offset)];
      }
      i64_load16_s(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 1 : _align;
        return [...idxCode, 50, align, ...varuint32(offset)];
      }
      i64_load16_u(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 1 : _align;
        return [...idxCode, 51, align, ...varuint32(offset)];
      }
      i64_load32_s(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 2 : _align;
        return [...idxCode, 52, align, ...varuint32(offset)];
      }
      i64_load32_u(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 2 : _align;
        return [...idxCode, 53, align, ...varuint32(offset)];
      }
      i64_load(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 3 : _align;
        return [...idxCode, 41, align, ...varuint32(offset)];
      }
      i64_store(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 3;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 3;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 55, align, ...varuint32(offset)];
      }
      i64_store32(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 2;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 2;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 62, align, ...varuint32(offset)];
      }
      i64_store16(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 1;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 1;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 61, align, ...varuint32(offset)];
      }
      i64_store8(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 0;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 0;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 60, align, ...varuint32(offset)];
      }
      i32_load8_s(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 0 : _align;
        return [...idxCode, 44, align, ...varuint32(offset)];
      }
      i32_load8_u(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 0 : _align;
        return [...idxCode, 45, align, ...varuint32(offset)];
      }
      i32_load16_s(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 1 : _align;
        return [...idxCode, 46, align, ...varuint32(offset)];
      }
      i32_load16_u(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 1 : _align;
        return [...idxCode, 47, align, ...varuint32(offset)];
      }
      i32_load(idxCode, _offset, _align) {
        const offset = _offset || 0;
        const align = _align === void 0 ? 2 : _align;
        return [...idxCode, 40, align, ...varuint32(offset)];
      }
      i32_store(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 2;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 2;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 54, align, ...varuint32(offset)];
      }
      i32_store16(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 1;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 1;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 59, align, ...varuint32(offset)];
      }
      i32_store8(idxCode, _offset, _align, _codeVal) {
        let offset, align, codeVal;
        if (Array.isArray(_offset)) {
          offset = 0;
          align = 0;
          codeVal = _offset;
        } else if (Array.isArray(_align)) {
          offset = _offset;
          align = 0;
          codeVal = _align;
        } else if (Array.isArray(_codeVal)) {
          offset = _offset;
          align = _align;
          codeVal = _codeVal;
        }
        return [...idxCode, ...codeVal, 58, align, ...varuint32(offset)];
      }
      call(fnName, ...args) {
        const idx = this.module.functionIdxByName[fnName];
        if (idx === void 0)
          throw new Error(`Function not defined: Function: ${fnName}`);
        return [...[].concat(...args), 16, ...varuint32(idx)];
      }
      call_indirect(fnIdx, ...args) {
        return [...[].concat(...args), ...fnIdx, 17, 0, 0];
      }
      if(condCode, thenCode, elseCode) {
        if (elseCode) {
          return [...condCode, 4, 64, ...thenCode, 5, ...elseCode, 11];
        } else {
          return [...condCode, 4, 64, ...thenCode, 11];
        }
      }
      block(bCode) {
        return [2, 64, ...bCode, 11];
      }
      loop(...args) {
        return [3, 64, ...[].concat(...[...args]), 11];
      }
      br_if(relPath, condCode) {
        return [...condCode, 13, ...varuint32(relPath)];
      }
      br(relPath) {
        return [12, ...varuint32(relPath)];
      }
      ret(rCode) {
        return [...rCode, 15];
      }
      drop(dCode) {
        return [...dCode, 26];
      }
      i64_const(num) {
        return [66, ...varint64(num)];
      }
      i32_const(num) {
        return [65, ...varint32(num)];
      }
      i64_eqz(opcode) {
        return [...opcode, 80];
      }
      i64_eq(op1code, op2code) {
        return [...op1code, ...op2code, 81];
      }
      i64_ne(op1code, op2code) {
        return [...op1code, ...op2code, 82];
      }
      i64_lt_s(op1code, op2code) {
        return [...op1code, ...op2code, 83];
      }
      i64_lt_u(op1code, op2code) {
        return [...op1code, ...op2code, 84];
      }
      i64_gt_s(op1code, op2code) {
        return [...op1code, ...op2code, 85];
      }
      i64_gt_u(op1code, op2code) {
        return [...op1code, ...op2code, 86];
      }
      i64_le_s(op1code, op2code) {
        return [...op1code, ...op2code, 87];
      }
      i64_le_u(op1code, op2code) {
        return [...op1code, ...op2code, 88];
      }
      i64_ge_s(op1code, op2code) {
        return [...op1code, ...op2code, 89];
      }
      i64_ge_u(op1code, op2code) {
        return [...op1code, ...op2code, 90];
      }
      i64_add(op1code, op2code) {
        return [...op1code, ...op2code, 124];
      }
      i64_sub(op1code, op2code) {
        return [...op1code, ...op2code, 125];
      }
      i64_mul(op1code, op2code) {
        return [...op1code, ...op2code, 126];
      }
      i64_div_s(op1code, op2code) {
        return [...op1code, ...op2code, 127];
      }
      i64_div_u(op1code, op2code) {
        return [...op1code, ...op2code, 128];
      }
      i64_rem_s(op1code, op2code) {
        return [...op1code, ...op2code, 129];
      }
      i64_rem_u(op1code, op2code) {
        return [...op1code, ...op2code, 130];
      }
      i64_and(op1code, op2code) {
        return [...op1code, ...op2code, 131];
      }
      i64_or(op1code, op2code) {
        return [...op1code, ...op2code, 132];
      }
      i64_xor(op1code, op2code) {
        return [...op1code, ...op2code, 133];
      }
      i64_shl(op1code, op2code) {
        return [...op1code, ...op2code, 134];
      }
      i64_shr_s(op1code, op2code) {
        return [...op1code, ...op2code, 135];
      }
      i64_shr_u(op1code, op2code) {
        return [...op1code, ...op2code, 136];
      }
      i64_extend_i32_s(op1code) {
        return [...op1code, 172];
      }
      i64_extend_i32_u(op1code) {
        return [...op1code, 173];
      }
      i64_clz(op1code) {
        return [...op1code, 121];
      }
      i64_ctz(op1code) {
        return [...op1code, 122];
      }
      i32_eqz(op1code) {
        return [...op1code, 69];
      }
      i32_eq(op1code, op2code) {
        return [...op1code, ...op2code, 70];
      }
      i32_ne(op1code, op2code) {
        return [...op1code, ...op2code, 71];
      }
      i32_lt_s(op1code, op2code) {
        return [...op1code, ...op2code, 72];
      }
      i32_lt_u(op1code, op2code) {
        return [...op1code, ...op2code, 73];
      }
      i32_gt_s(op1code, op2code) {
        return [...op1code, ...op2code, 74];
      }
      i32_gt_u(op1code, op2code) {
        return [...op1code, ...op2code, 75];
      }
      i32_le_s(op1code, op2code) {
        return [...op1code, ...op2code, 76];
      }
      i32_le_u(op1code, op2code) {
        return [...op1code, ...op2code, 77];
      }
      i32_ge_s(op1code, op2code) {
        return [...op1code, ...op2code, 78];
      }
      i32_ge_u(op1code, op2code) {
        return [...op1code, ...op2code, 79];
      }
      i32_add(op1code, op2code) {
        return [...op1code, ...op2code, 106];
      }
      i32_sub(op1code, op2code) {
        return [...op1code, ...op2code, 107];
      }
      i32_mul(op1code, op2code) {
        return [...op1code, ...op2code, 108];
      }
      i32_div_s(op1code, op2code) {
        return [...op1code, ...op2code, 109];
      }
      i32_div_u(op1code, op2code) {
        return [...op1code, ...op2code, 110];
      }
      i32_rem_s(op1code, op2code) {
        return [...op1code, ...op2code, 111];
      }
      i32_rem_u(op1code, op2code) {
        return [...op1code, ...op2code, 112];
      }
      i32_and(op1code, op2code) {
        return [...op1code, ...op2code, 113];
      }
      i32_or(op1code, op2code) {
        return [...op1code, ...op2code, 114];
      }
      i32_xor(op1code, op2code) {
        return [...op1code, ...op2code, 115];
      }
      i32_shl(op1code, op2code) {
        return [...op1code, ...op2code, 116];
      }
      i32_shr_s(op1code, op2code) {
        return [...op1code, ...op2code, 117];
      }
      i32_shr_u(op1code, op2code) {
        return [...op1code, ...op2code, 118];
      }
      i32_rotl(op1code, op2code) {
        return [...op1code, ...op2code, 119];
      }
      i32_rotr(op1code, op2code) {
        return [...op1code, ...op2code, 120];
      }
      i32_wrap_i64(op1code) {
        return [...op1code, 167];
      }
      i32_clz(op1code) {
        return [...op1code, 103];
      }
      i32_ctz(op1code) {
        return [...op1code, 104];
      }
      unreachable() {
        return [0];
      }
      current_memory() {
        return [63, 0];
      }
      comment() {
        return [];
      }
    };
    typeCodes = {
      "i32": 127,
      "i64": 126,
      "f32": 125,
      "f64": 124,
      "anyfunc": 112,
      "func": 96,
      "emptyblock": 64
    };
    FunctionBuilder = class {
      constructor(module, fnName, fnType, moduleName, fieldName) {
        if (fnType == "import") {
          this.fnType = "import";
          this.moduleName = moduleName;
          this.fieldName = fieldName;
        } else if (fnType == "internal") {
          this.fnType = "internal";
        } else {
          throw new Error("Invalid function fnType: " + fnType);
        }
        this.module = module;
        this.fnName = fnName;
        this.params = [];
        this.locals = [];
        this.localIdxByName = {};
        this.code = [];
        this.returnType = null;
        this.nextLocal = 0;
      }
      addParam(paramName, paramType) {
        if (this.localIdxByName[paramName])
          throw new Error(`param already exists. Function: ${this.fnName}, Param: ${paramName} `);
        const idx = this.nextLocal++;
        this.localIdxByName[paramName] = idx;
        this.params.push({
          type: paramType
        });
      }
      addLocal(localName, localType, _length) {
        const length2 = _length || 1;
        if (this.localIdxByName[localName])
          throw new Error(`local already exists. Function: ${this.fnName}, Param: ${localName} `);
        const idx = this.nextLocal++;
        this.localIdxByName[localName] = idx;
        this.locals.push({
          type: localType,
          length: length2
        });
      }
      setReturnType(returnType) {
        if (this.returnType)
          throw new Error(`returnType already defined. Function: ${this.fnName}`);
        this.returnType = returnType;
      }
      getSignature() {
        const params = [...varuint32(this.params.length), ...this.params.map((p2) => typeCodes[p2.type])];
        const returns = this.returnType ? [1, typeCodes[this.returnType]] : [0];
        return [96, ...params, ...returns];
      }
      getBody() {
        const locals = this.locals.map((l2) => [
          ...varuint32(l2.length),
          typeCodes[l2.type]
        ]);
        const body = [
          ...varuint32(this.locals.length),
          ...[].concat(...locals),
          ...this.code,
          11
        ];
        return [
          ...varuint32(body.length),
          ...body
        ];
      }
      addCode(...code) {
        this.code.push(...[].concat(...[...code]));
      }
      getCodeBuilder() {
        return new CodeBuilder(this);
      }
    };
    ModuleBuilder = class {
      constructor() {
        this.functions = [];
        this.functionIdxByName = {};
        this.nImportFunctions = 0;
        this.nInternalFunctions = 0;
        this.memory = {
          pagesSize: 1,
          moduleName: "env",
          fieldName: "memory"
        };
        this.free = 8;
        this.datas = [];
        this.modules = {};
        this.exports = [];
        this.functionsTable = [];
      }
      build() {
        this._setSignatures();
        return new Uint8Array([
          ...u32(1836278016),
          ...u32(1),
          ...this._buildType(),
          ...this._buildImport(),
          ...this._buildFunctionDeclarations(),
          ...this._buildFunctionsTable(),
          ...this._buildExports(),
          ...this._buildElements(),
          ...this._buildCode(),
          ...this._buildData()
        ]);
      }
      addFunction(fnName) {
        if (typeof this.functionIdxByName[fnName] !== "undefined")
          throw new Error(`Function already defined: ${fnName}`);
        const idx = this.functions.length;
        this.functionIdxByName[fnName] = idx;
        this.functions.push(new FunctionBuilder(this, fnName, "internal"));
        this.nInternalFunctions++;
        return this.functions[idx];
      }
      addIimportFunction(fnName, moduleName, _fieldName) {
        if (typeof this.functionIdxByName[fnName] !== "undefined")
          throw new Error(`Function already defined: ${fnName}`);
        if (this.functions.length > 0 && this.functions[this.functions.length - 1].type == "internal")
          throw new Error(`Import functions must be declared before internal: ${fnName}`);
        let fieldName = _fieldName || fnName;
        const idx = this.functions.length;
        this.functionIdxByName[fnName] = idx;
        this.functions.push(new FunctionBuilder(this, fnName, "import", moduleName, fieldName));
        this.nImportFunctions++;
        return this.functions[idx];
      }
      setMemory(pagesSize, moduleName, fieldName) {
        this.memory = {
          pagesSize,
          moduleName: moduleName || "env",
          fieldName: fieldName || "memory"
        };
      }
      exportFunction(fnName, _exportName) {
        const exportName = _exportName || fnName;
        if (typeof this.functionIdxByName[fnName] === "undefined")
          throw new Error(`Function not defined: ${fnName}`);
        const idx = this.functionIdxByName[fnName];
        if (exportName != fnName) {
          this.functionIdxByName[exportName] = idx;
        }
        this.exports.push({
          exportName,
          idx
        });
      }
      addFunctionToTable(fnName) {
        const idx = this.functionIdxByName[fnName];
        this.functionsTable.push(idx);
      }
      addData(offset, bytes) {
        this.datas.push({
          offset,
          bytes
        });
      }
      alloc(a2, b2) {
        let size;
        let bytes;
        if ((Array.isArray(a2) || ArrayBuffer.isView(a2)) && typeof b2 === "undefined") {
          size = a2.length;
          bytes = a2;
        } else {
          size = a2;
          bytes = b2;
        }
        size = (size - 1 >> 3) + 1 << 3;
        const p2 = this.free;
        this.free += size;
        if (bytes) {
          this.addData(p2, bytes);
        }
        return p2;
      }
      allocString(s2) {
        const encoder = new globalThis.TextEncoder();
        const uint8array = encoder.encode(s2);
        return this.alloc([...uint8array, 0]);
      }
      _setSignatures() {
        this.signatures = [];
        const signatureIdxByName = {};
        if (this.functionsTable.length > 0) {
          const signature = this.functions[this.functionsTable[0]].getSignature();
          const signatureName = "s_" + toHexString(signature);
          signatureIdxByName[signatureName] = 0;
          this.signatures.push(signature);
        }
        for (let i2 = 0; i2 < this.functions.length; i2++) {
          const signature = this.functions[i2].getSignature();
          const signatureName = "s_" + toHexString(signature);
          if (typeof signatureIdxByName[signatureName] === "undefined") {
            signatureIdxByName[signatureName] = this.signatures.length;
            this.signatures.push(signature);
          }
          this.functions[i2].signatureIdx = signatureIdxByName[signatureName];
        }
      }
      _buildSection(sectionType, section) {
        return [sectionType, ...varuint32(section.length), ...section];
      }
      _buildType() {
        return this._buildSection(
          1,
          [
            ...varuint32(this.signatures.length),
            ...[].concat(...this.signatures)
          ]
        );
      }
      _buildImport() {
        const entries = [];
        entries.push([
          ...string(this.memory.moduleName),
          ...string(this.memory.fieldName),
          2,
          0,
          //Flags no init valua
          ...varuint32(this.memory.pagesSize)
        ]);
        for (let i2 = 0; i2 < this.nImportFunctions; i2++) {
          entries.push([
            ...string(this.functions[i2].moduleName),
            ...string(this.functions[i2].fieldName),
            0,
            ...varuint32(this.functions[i2].signatureIdx)
          ]);
        }
        return this._buildSection(
          2,
          varuint32(entries.length).concat(...entries)
        );
      }
      _buildFunctionDeclarations() {
        const entries = [];
        for (let i2 = this.nImportFunctions; i2 < this.nImportFunctions + this.nInternalFunctions; i2++) {
          entries.push(...varuint32(this.functions[i2].signatureIdx));
        }
        return this._buildSection(
          3,
          [
            ...varuint32(entries.length),
            ...[...entries]
          ]
        );
      }
      _buildFunctionsTable() {
        if (this.functionsTable.length == 0) return [];
        return this._buildSection(
          4,
          [
            ...varuint32(1),
            112,
            0,
            ...varuint32(this.functionsTable.length)
          ]
        );
      }
      _buildElements() {
        if (this.functionsTable.length == 0) return [];
        const entries = [];
        for (let i2 = 0; i2 < this.functionsTable.length; i2++) {
          entries.push(...varuint32(this.functionsTable[i2]));
        }
        return this._buildSection(
          9,
          [
            ...varuint32(1),
            // 1 entry
            ...varuint32(0),
            // Table (0 in MVP)
            65,
            // offset 0
            ...varint32(0),
            11,
            ...varuint32(this.functionsTable.length),
            // Number of elements
            ...[...entries]
          ]
        );
      }
      _buildExports() {
        const entries = [];
        for (let i2 = 0; i2 < this.exports.length; i2++) {
          entries.push([
            ...string(this.exports[i2].exportName),
            0,
            ...varuint32(this.exports[i2].idx)
          ]);
        }
        return this._buildSection(
          7,
          varuint32(entries.length).concat(...entries)
        );
      }
      _buildCode() {
        const entries = [];
        for (let i2 = this.nImportFunctions; i2 < this.nImportFunctions + this.nInternalFunctions; i2++) {
          entries.push(this.functions[i2].getBody());
        }
        return this._buildSection(
          10,
          varuint32(entries.length).concat(...entries)
        );
      }
      _buildData() {
        const entries = [];
        entries.push([
          0,
          65,
          0,
          11,
          4,
          ...u32(this.free)
        ]);
        for (let i2 = 0; i2 < this.datas.length; i2++) {
          entries.push([
            0,
            65,
            ...varint32(this.datas[i2].offset),
            11,
            ...varuint32(this.datas[i2].bytes.length),
            ...this.datas[i2].bytes
          ]);
        }
        return this._buildSection(
          11,
          varuint32(entries.length).concat(...entries)
        );
      }
    };
    globalThis.curve_bn128 = null;
    globalThis.curve_bls12381 = null;
    bls12381r = e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
    bn128r = e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    bls12381q = e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
    bn128q = e("21888242871839275222246405745257275088696311157297823662689037894645226208583");
    Scalar = _Scalar;
    utils = _utils;
  }
});

// node_modules/snarkjs/build/browser.esm.js
var browser_esm_exports = {};
__export(browser_esm_exports, {
  fflonk: () => fflonk,
  groth16: () => groth16,
  plonk: () => plonk,
  powersOfTau: () => powersoftau,
  r1cs: () => r1cs,
  wtns: () => wtns,
  zKey: () => zkey
});
async function open(fileName, openFlags, cacheSize, pageSize) {
  cacheSize = cacheSize || 4096 * 64;
  if (typeof openFlags !== "number" && ["w+", "wx+", "r", "ax+", "a+"].indexOf(openFlags) < 0)
    throw new Error("Invalid open option");
  const fd = await fs.promises.open(fileName, openFlags);
  const stats = await fd.stat();
  return new FastFile(fd, stats, cacheSize, pageSize, fileName);
}
function createNew$1(o2) {
  const initialSize = o2.initialSize || 1 << 20;
  const fd = new MemFile();
  fd.o = o2;
  fd.o.data = new Uint8Array(initialSize);
  fd.allocSize = initialSize;
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting$2(o2) {
  const fd = new MemFile();
  fd.o = o2;
  fd.allocSize = o2.data.byteLength;
  fd.totalSize = o2.data.byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
function createNew(o2) {
  const initialSize = o2.initialSize || 0;
  const fd = new BigMemFile();
  fd.o = o2;
  const nPages = initialSize ? Math.floor((initialSize - 1) / PAGE_SIZE2) + 1 : 0;
  fd.o.data = [];
  for (let i2 = 0; i2 < nPages - 1; i2++) {
    fd.o.data.push(new Uint8Array(PAGE_SIZE2));
  }
  if (nPages) fd.o.data.push(new Uint8Array(initialSize - PAGE_SIZE2 * (nPages - 1)));
  fd.totalSize = 0;
  fd.readOnly = false;
  fd.pos = 0;
  return fd;
}
function readExisting$1(o2) {
  const fd = new BigMemFile();
  fd.o = o2;
  fd.totalSize = (o2.data.length - 1) * PAGE_SIZE2 + o2.data[o2.data.length - 1].byteLength;
  fd.readOnly = true;
  fd.pos = 0;
  return fd;
}
async function createOverride(o2, b2, c2) {
  if (typeof o2 === "string") {
    o2 = {
      type: "file",
      fileName: o2,
      cacheSize: b2 || DEFAULT_CACHE_SIZE,
      pageSize: c2 || DEFAULT_PAGE_SIZE
    };
  }
  if (o2.type == "file") {
    return await open(o2.fileName, O_TRUNC | O_CREAT | O_RDWR, o2.cacheSize, o2.pageSize);
  } else if (o2.type == "mem") {
    return createNew$1(o2);
  } else if (o2.type == "bigMem") {
    return createNew(o2);
  } else {
    throw new Error("Invalid FastFile type: " + o2.type);
  }
}
async function readExisting(o2, b2, c2) {
  if (o2 instanceof Uint8Array) {
    o2 = {
      type: "mem",
      data: o2
    };
  }
  {
    if (typeof o2 === "string") {
      const buff = await fetch(o2).then(function(res) {
        return res.arrayBuffer();
      }).then(function(ab) {
        return new Uint8Array(ab);
      });
      o2 = {
        type: "mem",
        data: buff
      };
    }
  }
  if (o2.type == "file") {
    return await open(o2.fileName, O_RDONLY, o2.cacheSize, o2.pageSize);
  } else if (o2.type == "mem") {
    return await readExisting$2(o2);
  } else if (o2.type == "bigMem") {
    return await readExisting$1(o2);
  } else {
    throw new Error("Invalid FastFile type: " + o2.type);
  }
}
async function readBinFile(fileName, type, maxVersion, cacheSize, pageSize) {
  const fd = await readExisting(fileName);
  const b2 = await fd.read(4);
  let readedType = "";
  for (let i2 = 0; i2 < 4; i2++) readedType += String.fromCharCode(b2[i2]);
  if (readedType != type) throw new Error(fileName + ": Invalid File format");
  let v2 = await fd.readULE32();
  if (v2 > maxVersion) throw new Error("Version not supported");
  const nSections = await fd.readULE32();
  let sections = [];
  for (let i2 = 0; i2 < nSections; i2++) {
    let ht2 = await fd.readULE32();
    let hl = await fd.readULE64();
    if (typeof sections[ht2] == "undefined") sections[ht2] = [];
    sections[ht2].push({
      p: fd.pos,
      size: hl
    });
    fd.pos += hl;
  }
  return { fd, sections };
}
async function createBinFile(fileName, type, version, nSections, cacheSize, pageSize) {
  const fd = await createOverride(fileName, cacheSize, pageSize);
  const buff = new Uint8Array(4);
  for (let i2 = 0; i2 < 4; i2++) buff[i2] = type.charCodeAt(i2);
  await fd.write(buff, 0);
  await fd.writeULE32(version);
  await fd.writeULE32(nSections);
  return fd;
}
async function startWriteSection(fd, idSection) {
  if (typeof fd.writingSection !== "undefined") throw new Error("Already writing a section");
  await fd.writeULE32(idSection);
  fd.writingSection = {
    pSectionSize: fd.pos
  };
  await fd.writeULE64(0);
}
async function endWriteSection(fd) {
  if (typeof fd.writingSection === "undefined") throw new Error("Not writing a section");
  const sectionSize = fd.pos - fd.writingSection.pSectionSize - 8;
  const oldPos = fd.pos;
  fd.pos = fd.writingSection.pSectionSize;
  await fd.writeULE64(sectionSize);
  fd.pos = oldPos;
  delete fd.writingSection;
}
async function startReadUniqueSection(fd, sections, idSection) {
  if (typeof fd.readingSection !== "undefined") throw new Error("Already reading a section");
  if (!sections[idSection]) throw new Error(fd.fileName + ": Missing section " + idSection);
  if (sections[idSection].length > 1) throw new Error(fd.fileName + ": Section Duplicated " + idSection);
  fd.pos = sections[idSection][0].p;
  fd.readingSection = sections[idSection][0];
}
async function endReadSection(fd, noCheck) {
  if (typeof fd.readingSection === "undefined") throw new Error("Not reading a section");
  if (!noCheck) {
    if (fd.pos - fd.readingSection.p != fd.readingSection.size) throw new Error("Invalid section size reading");
  }
  delete fd.readingSection;
}
async function writeBigInt(fd, n, n8, pos) {
  const buff = new Uint8Array(n8);
  Scalar.toRprLE(buff, 0, n, n8);
  await fd.write(buff, pos);
}
async function readBigInt(fd, n8, pos) {
  const buff = await fd.read(n8, pos);
  return Scalar.fromRprLE(buff, 0, n8);
}
async function copySection(fdFrom, sections, fdTo, sectionId, size) {
  if (typeof size === "undefined") {
    size = sections[sectionId][0].size;
  }
  const chunkSize = fdFrom.pageSize;
  await startReadUniqueSection(fdFrom, sections, sectionId);
  await startWriteSection(fdTo, sectionId);
  for (let p2 = 0; p2 < size; p2 += chunkSize) {
    const l2 = Math.min(size - p2, chunkSize);
    const buff = await fdFrom.read(l2);
    await fdTo.write(buff);
  }
  await endWriteSection(fdTo);
  await endReadSection(fdFrom, size != sections[sectionId][0].size);
}
async function readSection(fd, sections, idSection, offset, length2) {
  offset = typeof offset === "undefined" ? 0 : offset;
  length2 = typeof length2 === "undefined" ? sections[idSection][0].size - offset : length2;
  if (offset + length2 > sections[idSection][0].size) {
    throw new Error("Reading out of the range of the section");
  }
  let buff;
  if (length2 < 1 << 30) {
    buff = new Uint8Array(length2);
  } else {
    buff = new BigBuffer(length2);
  }
  await fd.readToBuffer(buff, 0, length2, sections[idSection][0].p + offset);
  return buff;
}
async function sectionIsEqual(fd1, sections1, fd2, sections2, idSection) {
  const MAX_BUFF_SIZE = fd1.pageSize * 16;
  await startReadUniqueSection(fd1, sections1, idSection);
  await startReadUniqueSection(fd2, sections2, idSection);
  if (sections1[idSection][0].size != sections2[idSection][0].size) return false;
  const totalBytes = sections1[idSection][0].size;
  for (let i2 = 0; i2 < totalBytes; i2 += MAX_BUFF_SIZE) {
    const n = Math.min(totalBytes - i2, MAX_BUFF_SIZE);
    const buff1 = await fd1.read(n);
    const buff2 = await fd2.read(n);
    for (let j2 = 0; j2 < n; j2++) if (buff1[j2] != buff2[j2]) return false;
  }
  await endReadSection(fd1);
  await endReadSection(fd2);
  return true;
}
async function getCurveFromR2(r2) {
  let curve2;
  if (Scalar.eq(r2, bn128r$1)) {
    curve2 = await buildBn128();
  } else if (Scalar.eq(r2, bls12381r$1)) {
    curve2 = await buildBls12381();
  } else {
    throw new Error(`Curve not supported: ${Scalar.toString(r2)}`);
  }
  return curve2;
}
async function getCurveFromQ(q2) {
  let curve2;
  if (Scalar.eq(q2, bn128q2)) {
    curve2 = await buildBn128();
  } else if (Scalar.eq(q2, bls12381q2)) {
    curve2 = await buildBls12381();
  } else {
    throw new Error(`Curve not supported: ${Scalar.toString(q2)}`);
  }
  return curve2;
}
async function getCurveFromName(name) {
  let curve2;
  const normName = normalizeName(name);
  if (["BN128", "BN254", "ALTBN128"].indexOf(normName) >= 0) {
    curve2 = await buildBn128();
  } else if (["BLS12381"].indexOf(normName) >= 0) {
    curve2 = await buildBls12381();
  } else {
    throw new Error(`Curve not supported: ${name}`);
  }
  return curve2;
  function normalizeName(n) {
    return n.toUpperCase().match(/[A-Za-z0-9]+/g).join("");
  }
}
function assert$1(t, m2) {
  if (!t) {
    var err = new AssertionError(m2);
    if (Error.captureStackTrace) Error.captureStackTrace(err, assert$1);
    throw err;
  }
}
function byteLength$4(string2) {
  return string2.length;
}
function toString$4(buffer) {
  const len = buffer.byteLength;
  let result = "";
  for (let i2 = 0; i2 < len; i2++) {
    result += String.fromCharCode(buffer[i2]);
  }
  return result;
}
function write$5(buffer, string2, offset = 0, length2 = byteLength$4(string2)) {
  const len = Math.min(length2, buffer.byteLength - offset);
  for (let i2 = 0; i2 < len; i2++) {
    buffer[offset + i2] = string2.charCodeAt(i2);
  }
  return len;
}
function byteLength$3(string2) {
  let len = string2.length;
  if (string2.charCodeAt(len - 1) === 61) len--;
  if (len > 1 && string2.charCodeAt(len - 1) === 61) len--;
  return len * 3 >>> 2;
}
function toString$3(buffer) {
  const len = buffer.byteLength;
  let result = "";
  for (let i2 = 0; i2 < len; i2 += 3) {
    result += alphabet[buffer[i2] >> 2] + alphabet[(buffer[i2] & 3) << 4 | buffer[i2 + 1] >> 4] + alphabet[(buffer[i2 + 1] & 15) << 2 | buffer[i2 + 2] >> 6] + alphabet[buffer[i2 + 2] & 63];
  }
  if (len % 3 === 2) {
    result = result.substring(0, result.length - 1) + "=";
  } else if (len % 3 === 1) {
    result = result.substring(0, result.length - 2) + "==";
  }
  return result;
}
function write$4(buffer, string2, offset = 0, length2 = byteLength$3(string2)) {
  const len = Math.min(length2, buffer.byteLength - offset);
  for (let i2 = 0, j2 = 0; j2 < len; i2 += 4) {
    const a2 = codes[string2.charCodeAt(i2)];
    const b2 = codes[string2.charCodeAt(i2 + 1)];
    const c2 = codes[string2.charCodeAt(i2 + 2)];
    const d = codes[string2.charCodeAt(i2 + 3)];
    buffer[j2++] = a2 << 2 | b2 >> 4;
    buffer[j2++] = (b2 & 15) << 4 | c2 >> 2;
    buffer[j2++] = (c2 & 3) << 6 | d & 63;
  }
  return len;
}
function byteLength$2(string2) {
  return string2.length >>> 1;
}
function toString$2(buffer) {
  const len = buffer.byteLength;
  buffer = new DataView(buffer.buffer, buffer.byteOffset, len);
  let result = "";
  let i2 = 0;
  for (let n = len - len % 4; i2 < n; i2 += 4) {
    result += buffer.getUint32(i2).toString(16).padStart(8, "0");
  }
  for (; i2 < len; i2++) {
    result += buffer.getUint8(i2).toString(16).padStart(2, "0");
  }
  return result;
}
function write$3(buffer, string2, offset = 0, length2 = byteLength$2(string2)) {
  const len = Math.min(length2, buffer.byteLength - offset);
  for (let i2 = 0; i2 < len; i2++) {
    const a2 = hexValue(string2.charCodeAt(i2 * 2));
    const b2 = hexValue(string2.charCodeAt(i2 * 2 + 1));
    if (a2 === void 0 || b2 === void 0) {
      return buffer.subarray(0, i2);
    }
    buffer[offset + i2] = a2 << 4 | b2;
  }
  return len;
}
function hexValue(char2) {
  if (char2 >= 48 && char2 <= 57) return char2 - 48;
  if (char2 >= 65 && char2 <= 70) return char2 - 65 + 10;
  if (char2 >= 97 && char2 <= 102) return char2 - 97 + 10;
}
function byteLength$1(string2) {
  let length2 = 0;
  for (let i2 = 0, n = string2.length; i2 < n; i2++) {
    const code = string2.charCodeAt(i2);
    if (code >= 55296 && code <= 56319 && i2 + 1 < n) {
      const code2 = string2.charCodeAt(i2 + 1);
      if (code2 >= 56320 && code2 <= 57343) {
        length2 += 4;
        i2++;
        continue;
      }
    }
    if (code <= 127) length2 += 1;
    else if (code <= 2047) length2 += 2;
    else length2 += 3;
  }
  return length2;
}
function byteLength(string2) {
  return string2.length * 2;
}
function toString2(buffer) {
  const len = buffer.byteLength;
  let result = "";
  for (let i2 = 0; i2 < len - 1; i2 += 2) {
    result += String.fromCharCode(buffer[i2] + buffer[i2 + 1] * 256);
  }
  return result;
}
function write$1(buffer, string2, offset = 0, length2 = byteLength(string2)) {
  const len = Math.min(length2, buffer.byteLength - offset);
  let units = len;
  for (let i2 = 0; i2 < string2.length; ++i2) {
    if ((units -= 2) < 0) break;
    const c2 = string2.charCodeAt(i2);
    const hi = c2 >> 8;
    const lo = c2 % 256;
    buffer[offset + i2 * 2] = lo;
    buffer[offset + i2 * 2 + 1] = hi;
  }
  return len;
}
function requireBlake2b() {
  if (hasRequiredBlake2b) return blake2b;
  hasRequiredBlake2b = 1;
  var __commonJS2 = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __toBinary = (() => {
    var table = new Uint8Array(128);
    for (var i2 = 0; i2 < 64; i2++)
      table[i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 * 4 - 205] = i2;
    return (base642) => {
      var n = base642.length, bytes2 = new Uint8Array((n - (base642[n - 1] == "=") - (base642[n - 2] == "=")) * 3 / 4 | 0);
      for (var i22 = 0, j2 = 0; i22 < n; ) {
        var c0 = table[base642.charCodeAt(i22++)], c1 = table[base642.charCodeAt(i22++)];
        var c2 = table[base642.charCodeAt(i22++)], c3 = table[base642.charCodeAt(i22++)];
        bytes2[j2++] = c0 << 2 | c1 >> 4;
        bytes2[j2++] = c1 << 4 | c2 >> 2;
        bytes2[j2++] = c2 << 6 | c3;
      }
      return bytes2;
    };
  })();
  var require_blake2b = __commonJS2({
    "wasm-binary:./blake2b.wat"(exports2, module2) {
      module2.exports = __toBinary("AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMKvz8EwAIAIABCADcDACAAQgA3AwggAEIANwMQIABCADcDGCAAQgA3AyAgAEIANwMoIABCADcDMCAAQgA3AzggAEIANwNAIABCADcDSCAAQgA3A1AgAEIANwNYIABCADcDYCAAQgA3A2ggAEIANwNwIABCADcDeCAAQoiS853/zPmE6gBBACkDAIU3A4ABIABCu86qptjQ67O7f0EIKQMAhTcDiAEgAEKr8NP0r+68tzxBECkDAIU3A5ABIABC8e30+KWn/aelf0EYKQMAhTcDmAEgAELRhZrv+s+Uh9EAQSApAwCFNwOgASAAQp/Y+dnCkdqCm39BKCkDAIU3A6gBIABC6/qG2r+19sEfQTApAwCFNwOwASAAQvnC+JuRo7Pw2wBBOCkDAIU3A7gBIABCADcDwAEgAEIANwPIASAAQgA3A9ABC20BA38gAEHAAWohAyAAQcgBaiEEIAQpAwCnIQUCQANAIAEgAkYNASAFQYABRgRAIAMgAykDACAFrXw3AwBBACEFIAAQAwsgACAFaiABLQAAOgAAIAVBAWohBSABQQFqIQEMAAsLIAQgBa03AwALYQEDfyAAQcABaiEBIABByAFqIQIgASABKQMAIAIpAwB8NwMAIABCfzcD0AEgAikDAKchAwJAA0AgA0GAAUYNASAAIANqQQA6AAAgA0EBaiEDDAALCyACIAOtNwMAIAAQAwuqOwIgfgl/IABBgAFqISEgAEGIAWohIiAAQZABaiEjIABBmAFqISQgAEGgAWohJSAAQagBaiEmIABBsAFqIScgAEG4AWohKCAhKQMAIQEgIikDACECICMpAwAhAyAkKQMAIQQgJSkDACEFICYpAwAhBiAnKQMAIQcgKCkDACEIQoiS853/zPmE6gAhCUK7zqqm2NDrs7t/IQpCq/DT9K/uvLc8IQtC8e30+KWn/aelfyEMQtGFmu/6z5SH0QAhDUKf2PnZwpHagpt/IQ5C6/qG2r+19sEfIQ9C+cL4m5Gjs/DbACEQIAApAwAhESAAKQMIIRIgACkDECETIAApAxghFCAAKQMgIRUgACkDKCEWIAApAzAhFyAAKQM4IRggACkDQCEZIAApA0ghGiAAKQNQIRsgACkDWCEcIAApA2AhHSAAKQNoIR4gACkDcCEfIAApA3ghICANIAApA8ABhSENIA8gACkD0AGFIQ8gASAFIBF8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSASfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgE3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBR8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAVfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBd8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAYfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgGXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBp8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAbfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgHHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIB18fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAefHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgH3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFICB8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAffHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgG3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBV8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAZfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHICB8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAefHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggF3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBJ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAdfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgEXx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBN8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAcfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGHx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBZ8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAUfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHHx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBl8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAdfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgEXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBZ8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByATfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggIHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIB58fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAbfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgH3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBR8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAXfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBJ8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAafHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFXx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBh8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAafHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFHx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBJ8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAefHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHXx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBx8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAffHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgE3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBd8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAWfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgG3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBV8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCARfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgIHx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBl8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAafHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEXx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBZ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAYfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgE3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBV8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAbfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggIHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIB98fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiASfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgHHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB18fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAXfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggGXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBR8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAefHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgE3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIB18fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAXfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgG3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBF8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAcfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggGXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBR8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAVfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBh8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAWfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggIHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB98fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSASfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgGnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB18fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAWfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgEnx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGICB8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAffHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHnx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBV8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAbfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBh8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAXfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBp8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCATfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGXx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBx8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAefHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgHHx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBh8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAffHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBJ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAUfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBZ8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiARfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgIHx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBV8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAZfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggF3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBN8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAbfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgF3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFICB8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAffHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGnx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBx8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAUfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggEXx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBl8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAdfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgE3x8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIB58fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAYfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggEnx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBV8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAbfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBt8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSATfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgGXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBV8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAYfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgF3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBJ8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAWfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgIHx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBx8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAafHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgH3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBR8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAdfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgHnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBF8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgISAhKQMAIAEgCYWFNwMAICIgIikDACACIAqFhTcDACAjICMpAwAgAyALhYU3AwAgJCAkKQMAIAQgDIWFNwMAICUgJSkDACAFIA2FhTcDACAmICYpAwAgBiAOhYU3AwAgJyAnKQMAIAcgD4WFNwMAICggKCkDACAIIBCFhTcDAAs=");
    }
  });
  var bytes = require_blake2b();
  var compiled = WebAssembly.compile(bytes);
  blake2b = async (imports) => {
    const instance = await WebAssembly.instantiate(await compiled, imports);
    return instance.exports;
  };
  return blake2b;
}
function Blake2b(digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
  if (!wasm) throw new Error("WASM not loaded. Wait for Blake2b.ready(cb)");
  if (!digestLength) digestLength = 32;
  if (noAssert !== true) {
    assert(digestLength >= BYTES_MIN, "digestLength must be at least " + BYTES_MIN + ", was given " + digestLength);
    assert(digestLength <= BYTES_MAX, "digestLength must be at most " + BYTES_MAX + ", was given " + digestLength);
    if (key != null) {
      assert(key instanceof Uint8Array, "key must be Uint8Array or Buffer");
      assert(key.length >= KEYBYTES_MIN, "key must be at least " + KEYBYTES_MIN + ", was given " + key.length);
      assert(key.length <= KEYBYTES_MAX, "key must be at least " + KEYBYTES_MAX + ", was given " + key.length);
    }
    if (salt != null) {
      assert(salt instanceof Uint8Array, "salt must be Uint8Array or Buffer");
      assert(salt.length === SALTBYTES, "salt must be exactly " + SALTBYTES + ", was given " + salt.length);
    }
    if (personal != null) {
      assert(personal instanceof Uint8Array, "personal must be Uint8Array or Buffer");
      assert(personal.length === PERSONALBYTES, "personal must be exactly " + PERSONALBYTES + ", was given " + personal.length);
    }
  }
  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }
  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();
  this._memory = new Uint8Array(wasm.memory.buffer);
  this._memory.fill(0, 0, 64);
  this._memory[0] = this.digestLength;
  this._memory[1] = key ? key.length : 0;
  this._memory[2] = 1;
  this._memory[3] = 1;
  if (salt) this._memory.set(salt, 32);
  if (personal) this._memory.set(personal, 48);
  if (this.pointer + 216 > this._memory.length) this._realloc(this.pointer + 216);
  wasm.blake2b_init(this.pointer, this.digestLength);
  if (key) {
    this.update(key);
    this._memory.fill(0, head, head + key.length);
    this._memory[this.pointer + 200] = 128;
  }
}
function noop() {
}
function log22(V2) {
  return ((V2 & 4294901760) !== 0 ? (V2 &= 4294901760, 16) : 0) | ((V2 & 4278255360) !== 0 ? (V2 &= 4278255360, 8) : 0) | ((V2 & 4042322160) !== 0 ? (V2 &= 4042322160, 4) : 0) | ((V2 & 3435973836) !== 0 ? (V2 &= 3435973836, 2) : 0) | (V2 & 2863311530) !== 0;
}
function formatHash(b2, title) {
  const a2 = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
  let S2 = "";
  for (let i2 = 0; i2 < 4; i2++) {
    if (i2 > 0) S2 += "\n";
    S2 += "		";
    for (let j2 = 0; j2 < 4; j2++) {
      if (j2 > 0) S2 += " ";
      S2 += a2.getUint32(i2 * 16 + j2 * 4).toString(16).padStart(8, "0");
    }
  }
  if (title) S2 = title + "\n" + S2;
  return S2;
}
function hashIsEqual(h1, h2) {
  if (h1.byteLength != h2.byteLength) return false;
  var dv1 = new Int8Array(h1);
  var dv2 = new Int8Array(h2);
  for (var i2 = 0; i2 != h1.byteLength; i2++) {
    if (dv1[i2] != dv2[i2]) return false;
  }
  return true;
}
function cloneHasher(h) {
  const ph = h.getPartialHash();
  const res = blake2bWasm.exports(64);
  res.setPartialHash(ph);
  return res;
}
async function sameRatio$2(curve2, g1s, g1sx, g2s, g2sx) {
  if (curve2.G1.isZero(g1s)) return false;
  if (curve2.G1.isZero(g1sx)) return false;
  if (curve2.G2.isZero(g2s)) return false;
  if (curve2.G2.isZero(g2sx)) return false;
  const res = await curve2.pairingEq(g1s, g2sx, curve2.G1.neg(g1sx), g2s);
  return res;
}
function askEntropy() {
  {
    return window.prompt("Enter a random text. (Entropy): ", "");
  }
}
function getRandomBytes2(n) {
  let array = new Uint8Array(n);
  {
    globalThis.crypto.getRandomValues(array);
  }
  return array;
}
async function sha256digest(data) {
  {
    const buffer = await globalThis.crypto.subtle.digest("SHA-256", data.buffer);
    return new Uint8Array(buffer);
  }
}
function readUInt32BE(data, offset) {
  return new DataView(data.buffer).getUint32(offset, false);
}
async function getRandomRng(entropy) {
  while (!entropy) {
    entropy = await askEntropy();
  }
  const hasher = blake2bWasm.exports(64);
  hasher.update(getRandomBytes2(64));
  const enc = new TextEncoder();
  hasher.update(enc.encode(entropy));
  const hash2 = hasher.digest();
  const seed = [];
  for (let i2 = 0; i2 < 8; i2++) {
    seed[i2] = readUInt32BE(hash2, i2 * 4);
  }
  const rng = new ChaCha(seed);
  return rng;
}
async function rngFromBeaconParams(beaconHash, numIterationsExp) {
  let nIterationsInner;
  let nIterationsOuter;
  if (numIterationsExp < 32) {
    nIterationsInner = 1 << numIterationsExp >>> 0;
    nIterationsOuter = 1;
  } else {
    nIterationsInner = 4294967296;
    nIterationsOuter = 1 << numIterationsExp - 32 >>> 0;
  }
  let curHash = beaconHash;
  for (let i2 = 0; i2 < nIterationsOuter; i2++) {
    for (let j2 = 0; j2 < nIterationsInner; j2++) {
      curHash = await sha256digest(curHash);
    }
  }
  const curHashV = new DataView(curHash.buffer, curHash.byteOffset, curHash.byteLength);
  const seed = [];
  for (let i2 = 0; i2 < 8; i2++) {
    seed[i2] = curHashV.getUint32(i2 * 4, false);
  }
  const rng = new ChaCha(seed);
  return rng;
}
function hex2ByteArray(s2) {
  if (s2 instanceof Uint8Array) return s2;
  if (s2.slice(0, 2) == "0x") s2 = s2.slice(2);
  return new Uint8Array(s2.match(/[\da-f]{2}/gi).map(function(h) {
    return parseInt(h, 16);
  }));
}
function byteArray2hex(byteArray) {
  return Array.prototype.map.call(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}
function stringifyBigIntsWithField(Fr, o2) {
  if (o2 instanceof Uint8Array) {
    return Fr.toString(o2);
  } else if (Array.isArray(o2)) {
    return o2.map(stringifyBigIntsWithField.bind(null, Fr));
  } else if (typeof o2 == "object") {
    const res = {};
    const keys = Object.keys(o2);
    keys.forEach((k2) => {
      res[k2] = stringifyBigIntsWithField(Fr, o2[k2]);
    });
    return res;
  } else if (typeof o2 == "bigint" || o2.eq !== void 0) {
    return o2.toString(10);
  } else {
    return o2;
  }
}
async function writeHeader(fd, zkey2) {
  await startWriteSection(fd, 1);
  await fd.writeULE32(1);
  await endWriteSection(fd);
  const curve2 = await getCurveFromQ(zkey2.q);
  await startWriteSection(fd, 2);
  const primeQ = curve2.q;
  const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;
  const primeR = curve2.r;
  const n8r = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;
  await fd.writeULE32(n8q);
  await writeBigInt(fd, primeQ, n8q);
  await fd.writeULE32(n8r);
  await writeBigInt(fd, primeR, n8r);
  await fd.writeULE32(zkey2.nVars);
  await fd.writeULE32(zkey2.nPublic);
  await fd.writeULE32(zkey2.domainSize);
  await writeG1(fd, curve2, zkey2.vk_alpha_1);
  await writeG1(fd, curve2, zkey2.vk_beta_1);
  await writeG2(fd, curve2, zkey2.vk_beta_2);
  await writeG2(fd, curve2, zkey2.vk_gamma_2);
  await writeG1(fd, curve2, zkey2.vk_delta_1);
  await writeG2(fd, curve2, zkey2.vk_delta_2);
  await endWriteSection(fd);
}
async function writeG1(fd, curve2, p2) {
  const buff = new Uint8Array(curve2.G1.F.n8 * 2);
  curve2.G1.toRprLEM(buff, 0, p2);
  await fd.write(buff);
}
async function writeG2(fd, curve2, p2) {
  const buff = new Uint8Array(curve2.G2.F.n8 * 2);
  curve2.G2.toRprLEM(buff, 0, p2);
  await fd.write(buff);
}
async function readG1(fd, curve2, toObject) {
  const buff = await fd.read(curve2.G1.F.n8 * 2);
  const res = curve2.G1.fromRprLEM(buff, 0);
  return toObject ? curve2.G1.toObject(res) : res;
}
async function readG2(fd, curve2, toObject) {
  const buff = await fd.read(curve2.G2.F.n8 * 2);
  const res = curve2.G2.fromRprLEM(buff, 0);
  return toObject ? curve2.G2.toObject(res) : res;
}
async function readHeader$1(fd, sections, toObject) {
  await startReadUniqueSection(fd, sections, 1);
  const protocolId = await fd.readULE32();
  await endReadSection(fd);
  if (protocolId === GROTH16_PROTOCOL_ID) {
    return await readHeaderGroth16(fd, sections, toObject);
  } else if (protocolId === PLONK_PROTOCOL_ID) {
    return await readHeaderPlonk(fd, sections, toObject);
  } else if (protocolId === FFLONK_PROTOCOL_ID) {
    return await readHeaderFFlonk(fd, sections, toObject);
  } else {
    throw new Error("Protocol not supported: ");
  }
}
async function readHeaderGroth16(fd, sections, toObject) {
  const zkey2 = {};
  zkey2.protocol = "groth16";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey2.n8q = n8q;
  zkey2.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey2.n8r = n8r;
  zkey2.r = await readBigInt(fd, n8r);
  zkey2.curve = await getCurveFromQ(zkey2.q);
  zkey2.nVars = await fd.readULE32();
  zkey2.nPublic = await fd.readULE32();
  zkey2.domainSize = await fd.readULE32();
  zkey2.power = log22(zkey2.domainSize);
  zkey2.vk_alpha_1 = await readG1(fd, zkey2.curve, toObject);
  zkey2.vk_beta_1 = await readG1(fd, zkey2.curve, toObject);
  zkey2.vk_beta_2 = await readG2(fd, zkey2.curve, toObject);
  zkey2.vk_gamma_2 = await readG2(fd, zkey2.curve, toObject);
  zkey2.vk_delta_1 = await readG1(fd, zkey2.curve, toObject);
  zkey2.vk_delta_2 = await readG2(fd, zkey2.curve, toObject);
  await endReadSection(fd);
  return zkey2;
}
async function readHeaderPlonk(fd, sections, toObject) {
  const zkey2 = {};
  zkey2.protocol = "plonk";
  await startReadUniqueSection(fd, sections, 2);
  const n8q = await fd.readULE32();
  zkey2.n8q = n8q;
  zkey2.q = await readBigInt(fd, n8q);
  const n8r = await fd.readULE32();
  zkey2.n8r = n8r;
  zkey2.r = await readBigInt(fd, n8r);
  zkey2.curve = await getCurveFromQ(zkey2.q);
  zkey2.nVars = await fd.readULE32();
  zkey2.nPublic = await fd.readULE32();
  zkey2.domainSize = await fd.readULE32();
  zkey2.power = log22(zkey2.domainSize);
  zkey2.nAdditions = await fd.readULE32();
  zkey2.nConstraints = await fd.readULE32();
  zkey2.k1 = await fd.read(n8r);
  zkey2.k2 = await fd.read(n8r);
  zkey2.Qm = await readG1(fd, zkey2.curve, toObject);
  zkey2.Ql = await readG1(fd, zkey2.curve, toObject);
  zkey2.Qr = await readG1(fd, zkey2.curve, toObject);
  zkey2.Qo = await readG1(fd, zkey2.curve, toObject);
  zkey2.Qc = await readG1(fd, zkey2.curve, toObject);
  zkey2.S1 = await readG1(fd, zkey2.curve, toObject);
  zkey2.S2 = await readG1(fd, zkey2.curve, toObject);
  zkey2.S3 = await readG1(fd, zkey2.curve, toObject);
  zkey2.X_2 = await readG2(fd, zkey2.curve, toObject);
  await endReadSection(fd);
  return zkey2;
}
async function readHeaderFFlonk(fd, sections, toObject) {
  const zkey2 = {};
  zkey2.protocol = "fflonk";
  zkey2.protocolId = FFLONK_PROTOCOL_ID;
  await startReadUniqueSection(fd, sections, ZKEY_FF_HEADER_SECTION);
  const n8q = await fd.readULE32();
  zkey2.n8q = n8q;
  zkey2.q = await readBigInt(fd, n8q);
  zkey2.curve = await getCurveFromQ(zkey2.q);
  const n8r = await fd.readULE32();
  zkey2.n8r = n8r;
  zkey2.r = await readBigInt(fd, n8r);
  zkey2.nVars = await fd.readULE32();
  zkey2.nPublic = await fd.readULE32();
  zkey2.domainSize = await fd.readULE32();
  zkey2.power = log22(zkey2.domainSize);
  zkey2.nAdditions = await fd.readULE32();
  zkey2.nConstraints = await fd.readULE32();
  zkey2.k1 = await fd.read(n8r);
  zkey2.k2 = await fd.read(n8r);
  zkey2.w3 = await fd.read(n8r);
  zkey2.w4 = await fd.read(n8r);
  zkey2.w8 = await fd.read(n8r);
  zkey2.wr = await fd.read(n8r);
  zkey2.X_2 = await readG2(fd, zkey2.curve, toObject);
  zkey2.C0 = await readG1(fd, zkey2.curve, toObject);
  await endReadSection(fd);
  return zkey2;
}
async function readZKey(fileName, toObject) {
  const { fd, sections } = await readBinFile(fileName, "zkey", 1);
  const zkey2 = await readHeader$1(fd, sections, toObject);
  const Fr = new ZqField(zkey2.r);
  const Rr = Scalar.mod(Scalar.shl(1, zkey2.n8r * 8), zkey2.r);
  const Rri = Fr.inv(Rr);
  const Rri2 = Fr.mul(Rri, Rri);
  let curve2 = await getCurveFromQ(zkey2.q);
  await startReadUniqueSection(fd, sections, 3);
  zkey2.IC = [];
  for (let i2 = 0; i2 <= zkey2.nPublic; i2++) {
    const P2 = await readG1(fd, curve2, toObject);
    zkey2.IC.push(P2);
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 4);
  const nCCoefs = await fd.readULE32();
  zkey2.ccoefs = [];
  for (let i2 = 0; i2 < nCCoefs; i2++) {
    const m2 = await fd.readULE32();
    const c2 = await fd.readULE32();
    const s2 = await fd.readULE32();
    const v2 = await readFr2();
    zkey2.ccoefs.push({
      matrix: m2,
      constraint: c2,
      signal: s2,
      value: v2
    });
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 5);
  zkey2.A = [];
  for (let i2 = 0; i2 < zkey2.nVars; i2++) {
    const A2 = await readG1(fd, curve2, toObject);
    zkey2.A[i2] = A2;
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 6);
  zkey2.B1 = [];
  for (let i2 = 0; i2 < zkey2.nVars; i2++) {
    const B1 = await readG1(fd, curve2, toObject);
    zkey2.B1[i2] = B1;
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 7);
  zkey2.B2 = [];
  for (let i2 = 0; i2 < zkey2.nVars; i2++) {
    const B2 = await readG2(fd, curve2, toObject);
    zkey2.B2[i2] = B2;
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 8);
  zkey2.C = [];
  for (let i2 = zkey2.nPublic + 1; i2 < zkey2.nVars; i2++) {
    const C2 = await readG1(fd, curve2, toObject);
    zkey2.C[i2] = C2;
  }
  await endReadSection(fd);
  await startReadUniqueSection(fd, sections, 9);
  zkey2.hExps = [];
  for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
    const H2 = await readG1(fd, curve2, toObject);
    zkey2.hExps.push(H2);
  }
  await endReadSection(fd);
  await fd.close();
  return zkey2;
  async function readFr2() {
    const n = await readBigInt(fd, zkey2.n8r);
    return Fr.mul(n, Rri2);
  }
}
async function readContribution$1(fd, curve2, toObject) {
  const c2 = { delta: {} };
  c2.deltaAfter = await readG1(fd, curve2, toObject);
  c2.delta.g1_s = await readG1(fd, curve2, toObject);
  c2.delta.g1_sx = await readG1(fd, curve2, toObject);
  c2.delta.g2_spx = await readG2(fd, curve2, toObject);
  c2.transcript = await fd.read(64);
  c2.type = await fd.readULE32();
  const paramLength = await fd.readULE32();
  const curPos = fd.pos;
  let lastType = 0;
  while (fd.pos - curPos < paramLength) {
    const buffType = await fd.read(1);
    if (buffType[0] <= lastType) throw new Error("Parameters in the contribution must be sorted");
    lastType = buffType[0];
    if (buffType[0] == 1) {
      const buffLen = await fd.read(1);
      const buffStr = await fd.read(buffLen[0]);
      c2.name = new TextDecoder().decode(buffStr);
    } else if (buffType[0] == 2) {
      const buffExp = await fd.read(1);
      c2.numIterationsExp = buffExp[0];
    } else if (buffType[0] == 3) {
      const buffLen = await fd.read(1);
      c2.beaconHash = await fd.read(buffLen[0]);
    } else {
      throw new Error("Parameter not recognized");
    }
  }
  if (fd.pos != curPos + paramLength) {
    throw new Error("Parametes do not match");
  }
  return c2;
}
async function readMPCParams(fd, curve2, sections) {
  await startReadUniqueSection(fd, sections, 10);
  const res = { contributions: [] };
  res.csHash = await fd.read(64);
  const n = await fd.readULE32();
  for (let i2 = 0; i2 < n; i2++) {
    const c2 = await readContribution$1(fd, curve2);
    res.contributions.push(c2);
  }
  await endReadSection(fd);
  return res;
}
async function writeContribution$1(fd, curve2, c2) {
  await writeG1(fd, curve2, c2.deltaAfter);
  await writeG1(fd, curve2, c2.delta.g1_s);
  await writeG1(fd, curve2, c2.delta.g1_sx);
  await writeG2(fd, curve2, c2.delta.g2_spx);
  await fd.write(c2.transcript);
  await fd.writeULE32(c2.type || 0);
  const params = [];
  if (c2.name) {
    params.push(1);
    const nameData = new TextEncoder("utf-8").encode(c2.name.substring(0, 64));
    params.push(nameData.byteLength);
    for (let i2 = 0; i2 < nameData.byteLength; i2++) params.push(nameData[i2]);
  }
  if (c2.type == 1) {
    params.push(2);
    params.push(c2.numIterationsExp);
    params.push(3);
    params.push(c2.beaconHash.byteLength);
    for (let i2 = 0; i2 < c2.beaconHash.byteLength; i2++) params.push(c2.beaconHash[i2]);
  }
  if (params.length > 0) {
    const paramsBuff = new Uint8Array(params);
    await fd.writeULE32(paramsBuff.byteLength);
    await fd.write(paramsBuff);
  } else {
    await fd.writeULE32(0);
  }
}
async function writeMPCParams(fd, curve2, mpcParams) {
  await startWriteSection(fd, 10);
  await fd.write(mpcParams.csHash);
  await fd.writeULE32(mpcParams.contributions.length);
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    await writeContribution$1(fd, curve2, mpcParams.contributions[i2]);
  }
  await endWriteSection(fd);
}
function hashG1(hasher, curve2, p2) {
  const buff = new Uint8Array(curve2.G1.F.n8 * 2);
  curve2.G1.toRprUncompressed(buff, 0, p2);
  hasher.update(buff);
}
function hashG2(hasher, curve2, p2) {
  const buff = new Uint8Array(curve2.G2.F.n8 * 2);
  curve2.G2.toRprUncompressed(buff, 0, p2);
  hasher.update(buff);
}
function hashPubKey(hasher, curve2, c2) {
  hashG1(hasher, curve2, c2.deltaAfter);
  hashG1(hasher, curve2, c2.delta.g1_s);
  hashG1(hasher, curve2, c2.delta.g1_sx);
  hashG2(hasher, curve2, c2.delta.g2_spx);
  hasher.update(c2.transcript);
}
async function write(fd, witness, prime) {
  await startWriteSection(fd, 1);
  const n8 = (Math.floor((Scalar.bitLength(prime) - 1) / 64) + 1) * 8;
  await fd.writeULE32(n8);
  await writeBigInt(fd, prime, n8);
  await fd.writeULE32(witness.length);
  await endWriteSection(fd);
  await startWriteSection(fd, 2);
  for (let i2 = 0; i2 < witness.length; i2++) {
    await writeBigInt(fd, witness[i2], n8);
  }
  await endWriteSection(fd);
}
async function writeBin(fd, witnessBin, prime) {
  await startWriteSection(fd, 1);
  const n8 = (Math.floor((Scalar.bitLength(prime) - 1) / 64) + 1) * 8;
  await fd.writeULE32(n8);
  await writeBigInt(fd, prime, n8);
  if (witnessBin.byteLength % n8 != 0) {
    throw new Error("Invalid witness length");
  }
  await fd.writeULE32(witnessBin.byteLength / n8);
  await endWriteSection(fd);
  await startWriteSection(fd, 2);
  await fd.write(witnessBin);
  await endWriteSection(fd);
}
async function readHeader(fd, sections) {
  await startReadUniqueSection(fd, sections, 1);
  const n8 = await fd.readULE32();
  const q2 = await readBigInt(fd, n8);
  const nWitness = await fd.readULE32();
  await endReadSection(fd);
  return { n8, q: q2, nWitness };
}
async function read(fileName) {
  const { fd, sections } = await readBinFile(fileName, "wtns", 2);
  const { n8, nWitness } = await readHeader(fd, sections);
  await startReadUniqueSection(fd, sections, 2);
  const res = [];
  for (let i2 = 0; i2 < nWitness; i2++) {
    const v2 = await readBigInt(fd, n8);
    res.push(v2);
  }
  await endReadSection(fd);
  await fd.close();
  return res;
}
async function groth16Prove(zkeyFileName, witnessFileName, logger) {
  const { fd: fdWtns, sections: sectionsWtns } = await readBinFile(witnessFileName, "wtns", 2);
  const wtns2 = await readHeader(fdWtns, sectionsWtns);
  const { fd: fdZKey, sections: sectionsZKey } = await readBinFile(zkeyFileName, "zkey", 2);
  const zkey2 = await readHeader$1(fdZKey, sectionsZKey);
  if (zkey2.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  if (!Scalar.eq(zkey2.r, wtns2.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  if (wtns2.nWitness != zkey2.nVars) {
    throw new Error(`Invalid witness length. Circuit: ${zkey2.nVars}, witness: ${wtns2.nWitness}`);
  }
  const curve2 = zkey2.curve;
  const Fr = curve2.Fr;
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  const power = log22(zkey2.domainSize);
  if (logger) logger.debug("Reading Wtns");
  const buffWitness = await readSection(fdWtns, sectionsWtns, 2);
  if (logger) logger.debug("Reading Coeffs");
  const buffCoeffs = await readSection(fdZKey, sectionsZKey, 4);
  if (logger) logger.debug("Building ABC");
  const [buffA_T, buffB_T, buffC_T] = await buildABC1(curve2, zkey2, buffWitness, buffCoeffs, logger);
  const inc = power == Fr.s ? curve2.Fr.shift : curve2.Fr.w[power + 1];
  const buffA = await Fr.ifft(buffA_T, "", "", logger, "IFFT_A");
  const buffAodd = await Fr.batchApplyKey(buffA, Fr.e(1), inc);
  const buffAodd_T = await Fr.fft(buffAodd, "", "", logger, "FFT_A");
  const buffB = await Fr.ifft(buffB_T, "", "", logger, "IFFT_B");
  const buffBodd = await Fr.batchApplyKey(buffB, Fr.e(1), inc);
  const buffBodd_T = await Fr.fft(buffBodd, "", "", logger, "FFT_B");
  const buffC = await Fr.ifft(buffC_T, "", "", logger, "IFFT_C");
  const buffCodd = await Fr.batchApplyKey(buffC, Fr.e(1), inc);
  const buffCodd_T = await Fr.fft(buffCodd, "", "", logger, "FFT_C");
  if (logger) logger.debug("Join ABC");
  const buffPodd_T = await joinABC(curve2, zkey2, buffAodd_T, buffBodd_T, buffCodd_T, logger);
  let proof = {};
  if (logger) logger.debug("Reading A Points");
  const buffBasesA = await readSection(fdZKey, sectionsZKey, 5);
  proof.pi_a = await curve2.G1.multiExpAffine(buffBasesA, buffWitness, logger, "multiexp A");
  if (logger) logger.debug("Reading B1 Points");
  const buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);
  let pib1 = await curve2.G1.multiExpAffine(buffBasesB1, buffWitness, logger, "multiexp B1");
  if (logger) logger.debug("Reading B2 Points");
  const buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);
  proof.pi_b = await curve2.G2.multiExpAffine(buffBasesB2, buffWitness, logger, "multiexp B2");
  if (logger) logger.debug("Reading C Points");
  const buffBasesC = await readSection(fdZKey, sectionsZKey, 8);
  proof.pi_c = await curve2.G1.multiExpAffine(buffBasesC, buffWitness.slice((zkey2.nPublic + 1) * curve2.Fr.n8), logger, "multiexp C");
  if (logger) logger.debug("Reading H Points");
  const buffBasesH = await readSection(fdZKey, sectionsZKey, 9);
  const resH = await curve2.G1.multiExpAffine(buffBasesH, buffPodd_T, logger, "multiexp H");
  const r2 = curve2.Fr.random();
  const s2 = curve2.Fr.random();
  proof.pi_a = G1.add(proof.pi_a, zkey2.vk_alpha_1);
  proof.pi_a = G1.add(proof.pi_a, G1.timesFr(zkey2.vk_delta_1, r2));
  proof.pi_b = G2.add(proof.pi_b, zkey2.vk_beta_2);
  proof.pi_b = G2.add(proof.pi_b, G2.timesFr(zkey2.vk_delta_2, s2));
  pib1 = G1.add(pib1, zkey2.vk_beta_1);
  pib1 = G1.add(pib1, G1.timesFr(zkey2.vk_delta_1, s2));
  proof.pi_c = G1.add(proof.pi_c, resH);
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(proof.pi_a, s2));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(pib1, r2));
  proof.pi_c = G1.add(proof.pi_c, G1.timesFr(zkey2.vk_delta_1, Fr.neg(Fr.mul(r2, s2))));
  let publicSignals = [];
  for (let i2 = 1; i2 <= zkey2.nPublic; i2++) {
    const b2 = buffWitness.slice(i2 * Fr.n8, i2 * Fr.n8 + Fr.n8);
    publicSignals.push(Scalar.fromRprLE(b2));
  }
  proof.pi_a = G1.toObject(G1.toAffine(proof.pi_a));
  proof.pi_b = G2.toObject(G2.toAffine(proof.pi_b));
  proof.pi_c = G1.toObject(G1.toAffine(proof.pi_c));
  proof.protocol = "groth16";
  proof.curve = curve2.name;
  await fdZKey.close();
  await fdWtns.close();
  proof = stringifyBigInts$4(proof);
  publicSignals = stringifyBigInts$4(publicSignals);
  return { proof, publicSignals };
}
async function buildABC1(curve2, zkey2, witness, coeffs, logger) {
  const n8 = curve2.Fr.n8;
  const sCoef = 4 * 3 + zkey2.n8r;
  const nCoef = (coeffs.byteLength - 4) / sCoef;
  const outBuffA = new BigBuffer(zkey2.domainSize * n8);
  const outBuffB = new BigBuffer(zkey2.domainSize * n8);
  const outBuffC = new BigBuffer(zkey2.domainSize * n8);
  const outBuf = [outBuffA, outBuffB];
  for (let i2 = 0; i2 < nCoef; i2++) {
    if (logger && i2 % 1e6 == 0) logger.debug(`QAP AB: ${i2}/${nCoef}`);
    const buffCoef = coeffs.slice(4 + i2 * sCoef, 4 + i2 * sCoef + sCoef);
    const buffCoefV = new DataView(buffCoef.buffer);
    const m2 = buffCoefV.getUint32(0, true);
    const c2 = buffCoefV.getUint32(4, true);
    const s2 = buffCoefV.getUint32(8, true);
    const coef = buffCoef.slice(12, 12 + n8);
    outBuf[m2].set(
      curve2.Fr.add(
        outBuf[m2].slice(c2 * n8, c2 * n8 + n8),
        curve2.Fr.mul(coef, witness.slice(s2 * n8, s2 * n8 + n8))
      ),
      c2 * n8
    );
  }
  for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
    if (logger && i2 % 1e6 == 0) logger.debug(`QAP C: ${i2}/${zkey2.domainSize}`);
    outBuffC.set(
      curve2.Fr.mul(
        outBuffA.slice(i2 * n8, i2 * n8 + n8),
        outBuffB.slice(i2 * n8, i2 * n8 + n8)
      ),
      i2 * n8
    );
  }
  return [outBuffA, outBuffB, outBuffC];
}
async function joinABC(curve2, zkey2, a2, b2, c2, logger) {
  const MAX_CHUNK_SIZE = 1 << 22;
  const n8 = curve2.Fr.n8;
  const nElements = Math.floor(a2.byteLength / curve2.Fr.n8);
  const promises = [];
  for (let i2 = 0; i2 < nElements; i2 += MAX_CHUNK_SIZE) {
    if (logger) logger.debug(`JoinABC: ${i2}/${nElements}`);
    const n = Math.min(nElements - i2, MAX_CHUNK_SIZE);
    const task = [];
    const aChunk = a2.slice(i2 * n8, (i2 + n) * n8);
    const bChunk = b2.slice(i2 * n8, (i2 + n) * n8);
    const cChunk = c2.slice(i2 * n8, (i2 + n) * n8);
    task.push({ cmd: "ALLOCSET", var: 0, buff: aChunk });
    task.push({ cmd: "ALLOCSET", var: 1, buff: bChunk });
    task.push({ cmd: "ALLOCSET", var: 2, buff: cChunk });
    task.push({ cmd: "ALLOC", var: 3, len: n * n8 });
    task.push({ cmd: "CALL", fnName: "qap_joinABC", params: [
      { var: 0 },
      { var: 1 },
      { var: 2 },
      { val: n },
      { var: 3 }
    ] });
    task.push({ cmd: "CALL", fnName: "frm_batchFromMontgomery", params: [
      { var: 3 },
      { val: n },
      { var: 3 }
    ] });
    task.push({ cmd: "GET", out: 0, var: 3, len: n * n8 });
    promises.push(curve2.tm.queueAction(task));
  }
  const result = await Promise.all(promises);
  let outBuff;
  if (a2 instanceof BigBuffer) {
    outBuff = new BigBuffer(a2.byteLength);
  } else {
    outBuff = new Uint8Array(a2.byteLength);
  }
  let p2 = 0;
  for (let i2 = 0; i2 < result.length; i2++) {
    outBuff.set(result[i2][0], p2);
    p2 += result[i2][0].byteLength;
  }
  return outBuff;
}
function flatArray(a2) {
  var res = [];
  fillArray(res, a2);
  return res;
  function fillArray(res2, a3) {
    if (Array.isArray(a3)) {
      for (let i2 = 0; i2 < a3.length; i2++) {
        fillArray(res2, a3[i2]);
      }
    } else {
      res2.push(a3);
    }
  }
}
function normalize(n, prime) {
  let res = BigInt(n) % prime;
  if (res < 0) res += prime;
  return res;
}
function fnvHash(str) {
  const uint64_max = BigInt(2) ** BigInt(64);
  let hash2 = BigInt("0xCBF29CE484222325");
  for (var i2 = 0; i2 < str.length; i2++) {
    hash2 ^= BigInt(str[i2].charCodeAt());
    hash2 *= BigInt(1099511628211);
    hash2 %= uint64_max;
  }
  let shash = hash2.toString(16);
  let n = 16 - shash.length;
  shash = "0".repeat(n).concat(shash);
  return shash;
}
function toArray32(s2, size) {
  const res = [];
  let rem = BigInt(s2);
  const radix = BigInt(4294967296);
  while (rem) {
    res.unshift(Number(rem % radix));
    rem = rem / radix;
  }
  if (size) {
    var i2 = size - res.length;
    while (i2 > 0) {
      res.unshift(0);
      i2--;
    }
  }
  return res;
}
async function builder(code, options) {
  options = options || {};
  let memorySize = 32767;
  let memory;
  let memoryAllocated = false;
  while (!memoryAllocated) {
    try {
      memory = new WebAssembly.Memory({ initial: memorySize });
      memoryAllocated = true;
    } catch (err) {
      if (memorySize === 1) {
        throw err;
      }
      console.warn("Could not allocate " + memorySize * 1024 * 64 + " bytes. This may cause severe instability. Trying with " + memorySize * 1024 * 64 / 2 + " bytes");
      memorySize = Math.floor(memorySize / 2);
    }
  }
  const wasmModule = await WebAssembly.compile(code);
  let wc;
  let errStr = "";
  let msgStr = "";
  let majorVersion = 1;
  let minorVersion = 0;
  let patchVersion = 0;
  const instance = await WebAssembly.instantiate(wasmModule, {
    env: {
      "memory": memory
    },
    runtime: {
      exceptionHandler: function(code2) {
        let err;
        if (code2 == 1) {
          err = "Signal not found. ";
        } else if (code2 == 2) {
          err = "Too many signals set. ";
        } else if (code2 == 3) {
          err = "Signal already set. ";
        } else if (code2 == 4) {
          err = "Assert Failed. ";
        } else if (code2 == 5) {
          err = "Not enough memory. ";
        } else if (code2 == 6) {
          err = "Input signal array access exceeds the size. ";
        } else {
          err = "Unknown error. ";
        }
        console.error("ERROR: ", code2, errStr);
        throw new Error(err + errStr);
      },
      // A new way of logging messages was added in Circom 2.0.7 that requires 2 new imports
      // `printErrorMessage` and `writeBufferMessage`.
      printErrorMessage: function() {
        errStr += getMessage() + "\n";
      },
      writeBufferMessage: function() {
        const msg = getMessage();
        if (msg === "\n") {
          console.log(msgStr);
          msgStr = "";
        } else {
          if (msgStr !== "") {
            msgStr += " ";
          }
          msgStr += msg;
        }
      },
      showSharedRWMemory: function() {
        const shared_rw_memory_size = instance.exports.getFieldNumLen32();
        const arr = new Uint32Array(shared_rw_memory_size);
        for (let j2 = 0; j2 < shared_rw_memory_size; j2++) {
          arr[shared_rw_memory_size - 1 - j2] = instance.exports.readSharedRWMemory(j2);
        }
        if (majorVersion >= 2 && (minorVersion >= 1 || patchVersion >= 7)) {
          if (msgStr !== "") {
            msgStr += " ";
          }
          const msg = Scalar.fromArray(arr, 4294967296).toString();
          msgStr += msg;
        } else {
          console.log(Scalar.fromArray(arr, 4294967296));
        }
      },
      error: function(code2, pstr, a2, b2, c2, d) {
        let errStr2;
        if (code2 == 7) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b2).toString() + " != " + wc.getFr(c2).toString() + " " + p2str(d);
        } else if (code2 == 9) {
          errStr2 = p2str(pstr) + " " + wc.getFr(b2).toString() + " " + p2str(c2);
        } else if (code2 == 5 && options.sym) {
          errStr2 = p2str(pstr) + " " + options.sym.labelIdx2Name[c2];
        } else {
          errStr2 = p2str(pstr) + " " + a2 + " " + b2 + " " + c2 + " " + d;
        }
        console.log("ERROR: ", code2, errStr2);
        throw new Error(errStr2);
      },
      log: function(a2) {
        console.log(wc.getFr(a2).toString());
      },
      logGetSignal: function(signal, pVal) {
        if (options.logGetSignal) {
          options.logGetSignal(signal, wc.getFr(pVal));
        }
      },
      logSetSignal: function(signal, pVal) {
        if (options.logSetSignal) {
          options.logSetSignal(signal, wc.getFr(pVal));
        }
      },
      logStartComponent: function(cIdx) {
        if (options.logStartComponent) {
          options.logStartComponent(cIdx);
        }
      },
      logFinishComponent: function(cIdx) {
        if (options.logFinishComponent) {
          options.logFinishComponent(cIdx);
        }
      }
    }
  });
  if (typeof instance.exports.getVersion == "function") {
    majorVersion = instance.exports.getVersion();
  }
  if (typeof instance.exports.getMinorVersion == "function") {
    minorVersion = instance.exports.getMinorVersion();
  }
  if (typeof instance.exports.getPatchVersion == "function") {
    patchVersion = instance.exports.getPatchVersion();
  }
  const sanityCheck = options && (options.sanityCheck || options.logGetSignal || options.logSetSignal || options.logStartComponent || options.logFinishComponent);
  if (majorVersion === 2) {
    wc = new WitnessCalculatorCircom2(instance, sanityCheck);
  } else {
    wc = new WitnessCalculatorCircom1(memory, instance, sanityCheck);
  }
  return wc;
  function getMessage() {
    var message = "";
    var c2 = instance.exports.getMessageChar();
    while (c2 != 0) {
      message += String.fromCharCode(c2);
      c2 = instance.exports.getMessageChar();
    }
    return message;
  }
  function p2str(p2) {
    const i8 = new Uint8Array(memory.buffer);
    const bytes = [];
    for (let i2 = 0; i8[p2 + i2] > 0; i2++) bytes.push(i8[p2 + i2]);
    return String.fromCharCode.apply(null, bytes);
  }
}
async function wtnsCalculate(_input, wasmFileName, wtnsFileName, options) {
  const input = unstringifyBigInts$b(_input);
  const fdWasm = await readExisting(wasmFileName);
  const wasm2 = await fdWasm.read(fdWasm.totalSize);
  await fdWasm.close();
  const wc = await builder(wasm2);
  if (wc.circom_version() == 1) {
    const w2 = await wc.calculateBinWitness(input);
    const fdWtns = await createBinFile(wtnsFileName, "wtns", 2, 2);
    await writeBin(fdWtns, w2, wc.prime);
    await fdWtns.close();
  } else {
    const fdWtns = await createOverride(wtnsFileName);
    const w2 = await wc.calculateWTNSBin(input);
    await fdWtns.write(w2);
    await fdWtns.close();
  }
}
async function groth16FullProve(_input, wasmFile, zkeyFileName, logger) {
  const input = unstringifyBigInts$a(_input);
  const wtns2 = {
    type: "mem"
  };
  await wtnsCalculate(input, wasmFile, wtns2);
  return await groth16Prove(zkeyFileName, wtns2, logger);
}
async function groth16Verify(_vk_verifier, _publicSignals, _proof, logger) {
  const vk_verifier = unstringifyBigInts$9(_vk_verifier);
  const proof = unstringifyBigInts$9(_proof);
  const publicSignals = unstringifyBigInts$9(_publicSignals);
  const curve2 = await getCurveFromName(vk_verifier.curve);
  const IC0 = curve2.G1.fromObject(vk_verifier.IC[0]);
  const IC = new Uint8Array(curve2.G1.F.n8 * 2 * publicSignals.length);
  const w2 = new Uint8Array(curve2.Fr.n8 * publicSignals.length);
  if (!publicInputsAreValid$1(curve2, publicSignals)) {
    if (logger) logger.error("Public inputs are not valid.");
    return false;
  }
  for (let i2 = 0; i2 < publicSignals.length; i2++) {
    const buffP = curve2.G1.fromObject(vk_verifier.IC[i2 + 1]);
    IC.set(buffP, i2 * curve2.G1.F.n8 * 2);
    Scalar.toRprLE(w2, curve2.Fr.n8 * i2, publicSignals[i2], curve2.Fr.n8);
  }
  let cpub = await curve2.G1.multiExpAffine(IC, w2);
  cpub = curve2.G1.add(cpub, IC0);
  const pi_a = curve2.G1.fromObject(proof.pi_a);
  const pi_b = curve2.G2.fromObject(proof.pi_b);
  const pi_c = curve2.G1.fromObject(proof.pi_c);
  if (!isWellConstructed$1(curve2, { pi_a, pi_b, pi_c })) {
    if (logger) logger.error("Proof commitments are not valid.");
    return false;
  }
  const vk_gamma_2 = curve2.G2.fromObject(vk_verifier.vk_gamma_2);
  const vk_delta_2 = curve2.G2.fromObject(vk_verifier.vk_delta_2);
  const vk_alpha_1 = curve2.G1.fromObject(vk_verifier.vk_alpha_1);
  const vk_beta_2 = curve2.G2.fromObject(vk_verifier.vk_beta_2);
  const res = await curve2.pairingEq(
    curve2.G1.neg(pi_a),
    pi_b,
    cpub,
    vk_gamma_2,
    pi_c,
    vk_delta_2,
    vk_alpha_1,
    vk_beta_2
  );
  if (!res) {
    if (logger) logger.error("Invalid proof");
    return false;
  }
  if (logger) logger.info("OK!");
  return true;
}
function isWellConstructed$1(curve2, proof) {
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  return G1.isValid(proof.pi_a) && G2.isValid(proof.pi_b) && G1.isValid(proof.pi_c);
}
function publicInputsAreValid$1(curve2, publicInputs) {
  for (let i2 = 0; i2 < publicInputs.length; i2++) {
    if (!Scalar.lt(publicInputs[i2], curve2.r)) {
      return false;
    }
  }
  return true;
}
function p256$2(n) {
  let nstr = n.toString(16);
  while (nstr.length < 64) nstr = "0" + nstr;
  nstr = `"0x${nstr}"`;
  return nstr;
}
async function groth16ExportSolidityCallData(_proof, _pub) {
  const proof = unstringifyBigInts$8(_proof);
  const pub = unstringifyBigInts$8(_pub);
  let inputs = "";
  for (let i2 = 0; i2 < pub.length; i2++) {
    if (inputs != "") inputs = inputs + ",";
    inputs = inputs + p256$2(pub[i2]);
  }
  let S2;
  S2 = `[${p256$2(proof.pi_a[0])}, ${p256$2(proof.pi_a[1])}],[[${p256$2(proof.pi_b[0][1])}, ${p256$2(proof.pi_b[0][0])}],[${p256$2(proof.pi_b[1][1])}, ${p256$2(proof.pi_b[1][0])}]],[${p256$2(proof.pi_c[0])}, ${p256$2(proof.pi_c[1])}],[${inputs}]`;
  return S2;
}
function hashToG2(curve2, hash2) {
  const hashV = new DataView(hash2.buffer, hash2.byteOffset, hash2.byteLength);
  const seed = [];
  for (let i2 = 0; i2 < 8; i2++) {
    seed[i2] = hashV.getUint32(i2 * 4);
  }
  const rng = new ChaCha(seed);
  const g2_sp = curve2.G2.fromRng(rng);
  return g2_sp;
}
function getG2sp(curve2, persinalization, challenge, g1s, g1sx) {
  const h = blake2bWasm.exports(64);
  const b1 = new Uint8Array([persinalization]);
  h.update(b1);
  h.update(challenge);
  const b3 = curve2.G1.toUncompressed(g1s);
  h.update(b3);
  const b4 = curve2.G1.toUncompressed(g1sx);
  h.update(b4);
  const hash2 = h.digest();
  return hashToG2(curve2, hash2);
}
function calculatePubKey(k2, curve2, personalization, challengeHash, rng) {
  k2.g1_s = curve2.G1.toAffine(curve2.G1.fromRng(rng));
  k2.g1_sx = curve2.G1.toAffine(curve2.G1.timesFr(k2.g1_s, k2.prvKey));
  k2.g2_sp = curve2.G2.toAffine(getG2sp(curve2, personalization, challengeHash, k2.g1_s, k2.g1_sx));
  k2.g2_spx = curve2.G2.toAffine(curve2.G2.timesFr(k2.g2_sp, k2.prvKey));
  return k2;
}
function createPTauKey(curve2, challengeHash, rng) {
  const key = {
    tau: {},
    alpha: {},
    beta: {}
  };
  key.tau.prvKey = curve2.Fr.fromRng(rng);
  key.alpha.prvKey = curve2.Fr.fromRng(rng);
  key.beta.prvKey = curve2.Fr.fromRng(rng);
  calculatePubKey(key.tau, curve2, 0, challengeHash, rng);
  calculatePubKey(key.alpha, curve2, 1, challengeHash, rng);
  calculatePubKey(key.beta, curve2, 2, challengeHash, rng);
  return key;
}
async function writePTauHeader(fd, curve2, power, ceremonyPower) {
  if (!ceremonyPower) ceremonyPower = power;
  await fd.writeULE32(1);
  const pHeaderSize = fd.pos;
  await fd.writeULE64(0);
  await fd.writeULE32(curve2.F1.n64 * 8);
  const buff = new Uint8Array(curve2.F1.n8);
  Scalar.toRprLE(buff, 0, curve2.q, curve2.F1.n8);
  await fd.write(buff);
  await fd.writeULE32(power);
  await fd.writeULE32(ceremonyPower);
  const headerSize = fd.pos - pHeaderSize - 8;
  const oldPos = fd.pos;
  await fd.writeULE64(headerSize, pHeaderSize);
  fd.pos = oldPos;
}
async function readPTauHeader(fd, sections) {
  if (!sections[1]) throw new Error(fd.fileName + ": File has no  header");
  if (sections[1].length > 1) throw new Error(fd.fileName + ": File has more than one header");
  fd.pos = sections[1][0].p;
  const n8 = await fd.readULE32();
  const buff = await fd.read(n8);
  const q2 = Scalar.fromRprLE(buff);
  const curve2 = await getCurveFromQ(q2);
  if (curve2.F1.n64 * 8 != n8) throw new Error(fd.fileName + ": Invalid size");
  const power = await fd.readULE32();
  const ceremonyPower = await fd.readULE32();
  if (fd.pos - sections[1][0].p != sections[1][0].size) throw new Error("Invalid PTau header size");
  return { curve: curve2, power, ceremonyPower };
}
async function readPtauPubKey(fd, curve2, montgomery) {
  const buff = await fd.read(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  return fromPtauPubKeyRpr(buff, 0, curve2, montgomery);
}
function fromPtauPubKeyRpr(buff, pos, curve2, montgomery) {
  const key = {
    tau: {},
    alpha: {},
    beta: {}
  };
  key.tau.g1_s = readG12();
  key.tau.g1_sx = readG12();
  key.alpha.g1_s = readG12();
  key.alpha.g1_sx = readG12();
  key.beta.g1_s = readG12();
  key.beta.g1_sx = readG12();
  key.tau.g2_spx = readG22();
  key.alpha.g2_spx = readG22();
  key.beta.g2_spx = readG22();
  return key;
  function readG12() {
    let p2;
    if (montgomery) {
      p2 = curve2.G1.fromRprLEM(buff, pos);
    } else {
      p2 = curve2.G1.fromRprUncompressed(buff, pos);
    }
    pos += curve2.G1.F.n8 * 2;
    return p2;
  }
  function readG22() {
    let p2;
    if (montgomery) {
      p2 = curve2.G2.fromRprLEM(buff, pos);
    } else {
      p2 = curve2.G2.fromRprUncompressed(buff, pos);
    }
    pos += curve2.G2.F.n8 * 2;
    return p2;
  }
}
function toPtauPubKeyRpr(buff, pos, curve2, key, montgomery) {
  writeG12(key.tau.g1_s);
  writeG12(key.tau.g1_sx);
  writeG12(key.alpha.g1_s);
  writeG12(key.alpha.g1_sx);
  writeG12(key.beta.g1_s);
  writeG12(key.beta.g1_sx);
  writeG22(key.tau.g2_spx);
  writeG22(key.alpha.g2_spx);
  writeG22(key.beta.g2_spx);
  async function writeG12(p2) {
    if (montgomery) {
      curve2.G1.toRprLEM(buff, pos, p2);
    } else {
      curve2.G1.toRprUncompressed(buff, pos, p2);
    }
    pos += curve2.F1.n8 * 2;
  }
  async function writeG22(p2) {
    if (montgomery) {
      curve2.G2.toRprLEM(buff, pos, p2);
    } else {
      curve2.G2.toRprUncompressed(buff, pos, p2);
    }
    pos += curve2.F2.n8 * 2;
  }
  return buff;
}
async function writePtauPubKey(fd, curve2, key, montgomery) {
  const buff = new Uint8Array(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  toPtauPubKeyRpr(buff, 0, curve2, key, montgomery);
  await fd.write(buff);
}
async function readContribution(fd, curve2) {
  const c2 = {};
  c2.tauG1 = await readG12();
  c2.tauG2 = await readG22();
  c2.alphaG1 = await readG12();
  c2.betaG1 = await readG12();
  c2.betaG2 = await readG22();
  c2.key = await readPtauPubKey(fd, curve2, true);
  c2.partialHash = await fd.read(216);
  c2.nextChallenge = await fd.read(64);
  c2.type = await fd.readULE32();
  const buffV = new Uint8Array(curve2.G1.F.n8 * 2 * 6 + curve2.G2.F.n8 * 2 * 3);
  toPtauPubKeyRpr(buffV, 0, curve2, c2.key, false);
  const responseHasher = blake2bWasm.exports(64);
  responseHasher.setPartialHash(c2.partialHash);
  responseHasher.update(buffV);
  c2.responseHash = responseHasher.digest();
  const paramLength = await fd.readULE32();
  const curPos = fd.pos;
  let lastType = 0;
  while (fd.pos - curPos < paramLength) {
    const buffType = await readDV(1);
    if (buffType[0] <= lastType) throw new Error("Parameters in the contribution must be sorted");
    lastType = buffType[0];
    if (buffType[0] == 1) {
      const buffLen = await readDV(1);
      const buffStr = await readDV(buffLen[0]);
      c2.name = new TextDecoder().decode(buffStr);
    } else if (buffType[0] == 2) {
      const buffExp = await readDV(1);
      c2.numIterationsExp = buffExp[0];
    } else if (buffType[0] == 3) {
      const buffLen = await readDV(1);
      c2.beaconHash = await readDV(buffLen[0]);
    } else {
      throw new Error("Parameter not recognized");
    }
  }
  if (fd.pos != curPos + paramLength) {
    throw new Error("Parametes do not match");
  }
  return c2;
  async function readG12() {
    const pBuff = await fd.read(curve2.G1.F.n8 * 2);
    return curve2.G1.fromRprLEM(pBuff);
  }
  async function readG22() {
    const pBuff = await fd.read(curve2.G2.F.n8 * 2);
    return curve2.G2.fromRprLEM(pBuff);
  }
  async function readDV(n) {
    const b2 = await fd.read(n);
    return new Uint8Array(b2);
  }
}
async function readContributions(fd, curve2, sections) {
  if (!sections[7]) throw new Error(fd.fileName + ": File has no  contributions");
  if (sections[7][0].length > 1) throw new Error(fd.fileName + ": File has more than one contributions section");
  fd.pos = sections[7][0].p;
  const nContributions = await fd.readULE32();
  const contributions = [];
  for (let i2 = 0; i2 < nContributions; i2++) {
    const c2 = await readContribution(fd, curve2);
    c2.id = i2 + 1;
    contributions.push(c2);
  }
  if (fd.pos - sections[7][0].p != sections[7][0].size) throw new Error("Invalid contribution section size");
  return contributions;
}
async function writeContribution(fd, curve2, contribution) {
  const buffG1 = new Uint8Array(curve2.F1.n8 * 2);
  const buffG2 = new Uint8Array(curve2.F2.n8 * 2);
  await writeG12(contribution.tauG1);
  await writeG22(contribution.tauG2);
  await writeG12(contribution.alphaG1);
  await writeG12(contribution.betaG1);
  await writeG22(contribution.betaG2);
  await writePtauPubKey(fd, curve2, contribution.key, true);
  await fd.write(contribution.partialHash);
  await fd.write(contribution.nextChallenge);
  await fd.writeULE32(contribution.type || 0);
  const params = [];
  if (contribution.name) {
    params.push(1);
    const nameData = new TextEncoder("utf-8").encode(contribution.name.substring(0, 64));
    params.push(nameData.byteLength);
    for (let i2 = 0; i2 < nameData.byteLength; i2++) params.push(nameData[i2]);
  }
  if (contribution.type == 1) {
    params.push(2);
    params.push(contribution.numIterationsExp);
    params.push(3);
    params.push(contribution.beaconHash.byteLength);
    for (let i2 = 0; i2 < contribution.beaconHash.byteLength; i2++) params.push(contribution.beaconHash[i2]);
  }
  if (params.length > 0) {
    const paramsBuff = new Uint8Array(params);
    await fd.writeULE32(paramsBuff.byteLength);
    await fd.write(paramsBuff);
  } else {
    await fd.writeULE32(0);
  }
  async function writeG12(p2) {
    curve2.G1.toRprLEM(buffG1, 0, p2);
    await fd.write(buffG1);
  }
  async function writeG22(p2) {
    curve2.G2.toRprLEM(buffG2, 0, p2);
    await fd.write(buffG2);
  }
}
async function writeContributions(fd, curve2, contributions) {
  await fd.writeULE32(7);
  const pContributionsSize = fd.pos;
  await fd.writeULE64(0);
  await fd.writeULE32(contributions.length);
  for (let i2 = 0; i2 < contributions.length; i2++) {
    await writeContribution(fd, curve2, contributions[i2]);
  }
  const contributionsSize = fd.pos - pContributionsSize - 8;
  const oldPos = fd.pos;
  await fd.writeULE64(contributionsSize, pContributionsSize);
  fd.pos = oldPos;
}
function calculateFirstChallengeHash(curve2, power, logger) {
  if (logger) logger.debug("Calculating First Challenge Hash");
  const hasher = new blake2bWasm.exports(64);
  const vG1 = new Uint8Array(curve2.G1.F.n8 * 2);
  const vG2 = new Uint8Array(curve2.G2.F.n8 * 2);
  curve2.G1.toRprUncompressed(vG1, 0, curve2.G1.g);
  curve2.G2.toRprUncompressed(vG2, 0, curve2.G2.g);
  hasher.update(blake2bWasm.exports(64).digest());
  let n;
  n = 2 ** power * 2 - 1;
  if (logger) logger.debug("Calculate Initial Hash: tauG1");
  hashBlock(vG1, n);
  n = 2 ** power;
  if (logger) logger.debug("Calculate Initial Hash: tauG2");
  hashBlock(vG2, n);
  if (logger) logger.debug("Calculate Initial Hash: alphaTauG1");
  hashBlock(vG1, n);
  if (logger) logger.debug("Calculate Initial Hash: betaTauG1");
  hashBlock(vG1, n);
  hasher.update(vG2);
  return hasher.digest();
  function hashBlock(buff, n2) {
    const blockSize = 341e3;
    const nBlocks = Math.floor(n2 / blockSize);
    const rem = n2 % blockSize;
    const bigBuff = new Uint8Array(blockSize * buff.byteLength);
    for (let i2 = 0; i2 < blockSize; i2++) {
      bigBuff.set(buff, i2 * buff.byteLength);
    }
    for (let i2 = 0; i2 < nBlocks; i2++) {
      hasher.update(bigBuff);
      if (logger) logger.debug("Initial hash: " + i2 * blockSize);
    }
    for (let i2 = 0; i2 < rem; i2++) {
      hasher.update(buff);
    }
  }
}
async function keyFromBeacon(curve2, challengeHash, beaconHash, numIterationsExp) {
  const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);
  const key = createPTauKey(curve2, challengeHash, rng);
  return key;
}
async function newAccumulator(curve2, power, fileName, logger) {
  await blake2bWasm.exports.ready();
  const fd = await createBinFile(fileName, "ptau", 1, 7);
  await writePTauHeader(fd, curve2, power, 0);
  const buffG1 = curve2.G1.oneAffine;
  const buffG2 = curve2.G2.oneAffine;
  await startWriteSection(fd, 2);
  const nTauG1 = 2 ** power * 2 - 1;
  for (let i2 = 0; i2 < nTauG1; i2++) {
    await fd.write(buffG1);
    if (logger && i2 % 1e5 == 0 && i2) logger.log("tauG1: " + i2);
  }
  await endWriteSection(fd);
  await startWriteSection(fd, 3);
  const nTauG2 = 2 ** power;
  for (let i2 = 0; i2 < nTauG2; i2++) {
    await fd.write(buffG2);
    if (logger && i2 % 1e5 == 0 && i2) logger.log("tauG2: " + i2);
  }
  await endWriteSection(fd);
  await startWriteSection(fd, 4);
  const nAlfaTauG1 = 2 ** power;
  for (let i2 = 0; i2 < nAlfaTauG1; i2++) {
    await fd.write(buffG1);
    if (logger && i2 % 1e5 == 0 && i2) logger.log("alphaTauG1: " + i2);
  }
  await endWriteSection(fd);
  await startWriteSection(fd, 5);
  const nBetaTauG1 = 2 ** power;
  for (let i2 = 0; i2 < nBetaTauG1; i2++) {
    await fd.write(buffG1);
    if (logger && i2 % 1e5 == 0 && i2) logger.log("betaTauG1: " + i2);
  }
  await endWriteSection(fd);
  await startWriteSection(fd, 6);
  await fd.write(buffG2);
  await endWriteSection(fd);
  await startWriteSection(fd, 7);
  await fd.writeULE32(0);
  await endWriteSection(fd);
  await fd.close();
  const firstChallengeHash = calculateFirstChallengeHash(curve2, power, logger);
  if (logger) logger.debug(formatHash(blake2bWasm.exports(64).digest(), "Blank Contribution Hash:"));
  if (logger) logger.info(formatHash(firstChallengeHash, "First Contribution Hash:"));
  return firstChallengeHash;
}
async function exportChallenge(pTauFilename, challengeFilename, logger) {
  await blake2bWasm.exports.ready();
  const { fd: fdFrom, sections } = await readBinFile(pTauFilename, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdFrom, sections);
  const contributions = await readContributions(fdFrom, curve2, sections);
  let lastResponseHash, curChallengeHash;
  if (contributions.length == 0) {
    lastResponseHash = blake2bWasm.exports(64).digest();
    curChallengeHash = calculateFirstChallengeHash(curve2, power);
  } else {
    lastResponseHash = contributions[contributions.length - 1].responseHash;
    curChallengeHash = contributions[contributions.length - 1].nextChallenge;
  }
  if (logger) logger.info(formatHash(lastResponseHash, "Last Response Hash: "));
  if (logger) logger.info(formatHash(curChallengeHash, "New Challenge Hash: "));
  const fdTo = await createOverride(challengeFilename);
  const toHash = blake2bWasm.exports(64);
  await fdTo.write(lastResponseHash);
  toHash.update(lastResponseHash);
  await exportSection(2, "G1", 2 ** power * 2 - 1, "tauG1");
  await exportSection(3, "G2", 2 ** power, "tauG2");
  await exportSection(4, "G1", 2 ** power, "alphaTauG1");
  await exportSection(5, "G1", 2 ** power, "betaTauG1");
  await exportSection(6, "G2", 1, "betaG2");
  await fdFrom.close();
  await fdTo.close();
  const calcCurChallengeHash = toHash.digest();
  if (!hashIsEqual(curChallengeHash, calcCurChallengeHash)) {
    if (logger) logger.info(formatHash(calcCurChallengeHash, "Calc Curret Challenge Hash: "));
    if (logger) logger.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");
    throw new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");
  }
  return curChallengeHash;
  async function exportSection(sectionId, groupName, nPoints, sectionName) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const nPointsChunk = Math.floor((1 << 24) / sG);
    await startReadUniqueSection(fdFrom, sections, sectionId);
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger) logger.debug(`Exporting ${sectionName}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, nPointsChunk);
      let buff;
      buff = await fdFrom.read(n * sG);
      buff = await G2.batchLEMtoU(buff);
      await fdTo.write(buff);
      toHash.update(buff);
    }
    await endReadSection(fdFrom);
  }
}
async function importResponse(oldPtauFilename, contributionFilename, newPTauFilename, name, importPoints, logger) {
  await blake2bWasm.exports.ready();
  const noHash = new Uint8Array(64);
  for (let i2 = 0; i2 < 64; i2++) noHash[i2] = 255;
  const { fd: fdOld, sections } = await readBinFile(oldPtauFilename, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdOld, sections);
  const contributions = await readContributions(fdOld, curve2, sections);
  const currentContribution = {};
  if (name) currentContribution.name = name;
  const sG1 = curve2.F1.n8 * 2;
  const scG1 = curve2.F1.n8;
  const sG2 = curve2.F2.n8 * 2;
  const scG2 = curve2.F2.n8;
  const fdResponse = await readExisting(contributionFilename);
  if (fdResponse.totalSize != 64 + // Old Hash
  (2 ** power * 2 - 1) * scG1 + 2 ** power * scG2 + 2 ** power * scG1 + 2 ** power * scG1 + scG2 + sG1 * 6 + sG2 * 3)
    throw new Error("Size of the contribution is invalid");
  let lastChallengeHash;
  if (contributions.length > 0) {
    lastChallengeHash = contributions[contributions.length - 1].nextChallenge;
  } else {
    lastChallengeHash = calculateFirstChallengeHash(curve2, power, logger);
  }
  const fdNew = await createBinFile(newPTauFilename, "ptau", 1, importPoints ? 7 : 2);
  await writePTauHeader(fdNew, curve2, power);
  const contributionPreviousHash = await fdResponse.read(64);
  if (hashIsEqual(noHash, lastChallengeHash)) {
    lastChallengeHash = contributionPreviousHash;
    contributions[contributions.length - 1].nextChallenge = lastChallengeHash;
  }
  if (!hashIsEqual(contributionPreviousHash, lastChallengeHash))
    throw new Error("Wrong contribution. this contribution is not based on the previus hash");
  const hasherResponse = new blake2bWasm.exports(64);
  hasherResponse.update(contributionPreviousHash);
  const startSections = [];
  let res;
  res = await processSection(fdResponse, fdNew, "G1", 2, 2 ** power * 2 - 1, [1], "tauG1");
  currentContribution.tauG1 = res[0];
  res = await processSection(fdResponse, fdNew, "G2", 3, 2 ** power, [1], "tauG2");
  currentContribution.tauG2 = res[0];
  res = await processSection(fdResponse, fdNew, "G1", 4, 2 ** power, [0], "alphaG1");
  currentContribution.alphaG1 = res[0];
  res = await processSection(fdResponse, fdNew, "G1", 5, 2 ** power, [0], "betaG1");
  currentContribution.betaG1 = res[0];
  res = await processSection(fdResponse, fdNew, "G2", 6, 1, [0], "betaG2");
  currentContribution.betaG2 = res[0];
  currentContribution.partialHash = hasherResponse.getPartialHash();
  const buffKey = await fdResponse.read(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  currentContribution.key = fromPtauPubKeyRpr(buffKey, 0, curve2, false);
  hasherResponse.update(new Uint8Array(buffKey));
  const hashResponse = hasherResponse.digest();
  if (logger) logger.info(formatHash(hashResponse, "Contribution Response Hash imported: "));
  if (importPoints) {
    const nextChallengeHasher = new blake2bWasm.exports(64);
    nextChallengeHasher.update(hashResponse);
    await hashSection(nextChallengeHasher, fdNew, "G1", 2, 2 ** power * 2 - 1, "tauG1", logger);
    await hashSection(nextChallengeHasher, fdNew, "G2", 3, 2 ** power, "tauG2", logger);
    await hashSection(nextChallengeHasher, fdNew, "G1", 4, 2 ** power, "alphaTauG1", logger);
    await hashSection(nextChallengeHasher, fdNew, "G1", 5, 2 ** power, "betaTauG1", logger);
    await hashSection(nextChallengeHasher, fdNew, "G2", 6, 1, "betaG2", logger);
    currentContribution.nextChallenge = nextChallengeHasher.digest();
    if (logger) logger.info(formatHash(currentContribution.nextChallenge, "Next Challenge Hash: "));
  } else {
    currentContribution.nextChallenge = noHash;
  }
  contributions.push(currentContribution);
  await writeContributions(fdNew, curve2, contributions);
  await fdResponse.close();
  await fdNew.close();
  await fdOld.close();
  return currentContribution.nextChallenge;
  async function processSection(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {
    if (importPoints) {
      return await processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);
    } else {
      return await processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName);
    }
  }
  async function processSectionImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {
    const G2 = curve2[groupName];
    const scG = G2.F.n8;
    const sG = G2.F.n8 * 2;
    const singularPoints = [];
    await startWriteSection(fdTo, sectionId);
    const nPointsChunk = Math.floor((1 << 24) / sG);
    startSections[sectionId] = fdTo.pos;
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger) logger.debug(`Importing ${sectionName}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, nPointsChunk);
      const buffC = await fdFrom.read(n * scG);
      hasherResponse.update(buffC);
      const buffLEM = await G2.batchCtoLEM(buffC);
      await fdTo.write(buffLEM);
      for (let j2 = 0; j2 < singularPointIndexes.length; j2++) {
        const sp = singularPointIndexes[j2];
        if (sp >= i2 && sp < i2 + n) {
          const P2 = G2.fromRprLEM(buffLEM, (sp - i2) * sG);
          singularPoints.push(P2);
        }
      }
    }
    await endWriteSection(fdTo);
    return singularPoints;
  }
  async function processSectionNoImportPoints(fdFrom, fdTo, groupName, sectionId, nPoints, singularPointIndexes, sectionName) {
    const G2 = curve2[groupName];
    const scG = G2.F.n8;
    const singularPoints = [];
    const nPointsChunk = Math.floor((1 << 24) / scG);
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger) logger.debug(`Importing ${sectionName}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, nPointsChunk);
      const buffC = await fdFrom.read(n * scG);
      hasherResponse.update(buffC);
      for (let j2 = 0; j2 < singularPointIndexes.length; j2++) {
        const sp = singularPointIndexes[j2];
        if (sp >= i2 && sp < i2 + n) {
          const P2 = G2.fromRprCompressed(buffC, (sp - i2) * scG);
          singularPoints.push(P2);
        }
      }
    }
    return singularPoints;
  }
  async function hashSection(nextChallengeHasher, fdTo, groupName, sectionId, nPoints, sectionName, logger2) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const nPointsChunk = Math.floor((1 << 24) / sG);
    const oldPos = fdTo.pos;
    fdTo.pos = startSections[sectionId];
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger2) logger2.debug(`Hashing ${sectionName}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, nPointsChunk);
      const buffLEM = await fdTo.read(n * sG);
      const buffU = await G2.batchLEMtoU(buffLEM);
      nextChallengeHasher.update(buffU);
    }
    fdTo.pos = oldPos;
  }
}
async function verifyContribution(curve2, cur, prev3, logger) {
  let sr;
  if (cur.type == 1) {
    const beaconKey = await keyFromBeacon(curve2, prev3.nextChallenge, cur.beaconHash, cur.numIterationsExp);
    if (!curve2.G1.eq(cur.key.tau.g1_s, beaconKey.tau.g1_s)) {
      if (logger) logger.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G1.eq(cur.key.tau.g1_sx, beaconKey.tau.g1_sx)) {
      if (logger) logger.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G2.eq(cur.key.tau.g2_spx, beaconKey.tau.g2_spx)) {
      if (logger) logger.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G1.eq(cur.key.alpha.g1_s, beaconKey.alpha.g1_s)) {
      if (logger) logger.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G1.eq(cur.key.alpha.g1_sx, beaconKey.alpha.g1_sx)) {
      if (logger) logger.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G2.eq(cur.key.alpha.g2_spx, beaconKey.alpha.g2_spx)) {
      if (logger) logger.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G1.eq(cur.key.beta.g1_s, beaconKey.beta.g1_s)) {
      if (logger) logger.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G1.eq(cur.key.beta.g1_sx, beaconKey.beta.g1_sx)) {
      if (logger) logger.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
    if (!curve2.G2.eq(cur.key.beta.g2_spx, beaconKey.beta.g2_spx)) {
      if (logger) logger.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${cur.id}  ${cur.name || ""}`);
      return false;
    }
  }
  cur.key.tau.g2_sp = curve2.G2.toAffine(getG2sp(curve2, 0, prev3.nextChallenge, cur.key.tau.g1_s, cur.key.tau.g1_sx));
  cur.key.alpha.g2_sp = curve2.G2.toAffine(getG2sp(curve2, 1, prev3.nextChallenge, cur.key.alpha.g1_s, cur.key.alpha.g1_sx));
  cur.key.beta.g2_sp = curve2.G2.toAffine(getG2sp(curve2, 2, prev3.nextChallenge, cur.key.beta.g1_s, cur.key.beta.g1_sx));
  sr = await sameRatio$1(curve2, cur.key.tau.g1_s, cur.key.tau.g1_sx, cur.key.tau.g2_sp, cur.key.tau.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID key (tau) in challenge #" + cur.id);
    return false;
  }
  sr = await sameRatio$1(curve2, cur.key.alpha.g1_s, cur.key.alpha.g1_sx, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID key (alpha) in challenge #" + cur.id);
    return false;
  }
  sr = await sameRatio$1(curve2, cur.key.beta.g1_s, cur.key.beta.g1_sx, cur.key.beta.g2_sp, cur.key.beta.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID key (beta) in challenge #" + cur.id);
    return false;
  }
  sr = await sameRatio$1(curve2, prev3.tauG1, cur.tauG1, cur.key.tau.g2_sp, cur.key.tau.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID tau*G1. challenge #" + cur.id + " It does not follow the previous contribution");
    return false;
  }
  sr = await sameRatio$1(curve2, cur.key.tau.g1_s, cur.key.tau.g1_sx, prev3.tauG2, cur.tauG2);
  if (sr !== true) {
    if (logger) logger.error("INVALID tau*G2. challenge #" + cur.id + " It does not follow the previous contribution");
    return false;
  }
  sr = await sameRatio$1(curve2, prev3.alphaG1, cur.alphaG1, cur.key.alpha.g2_sp, cur.key.alpha.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID alpha*G1. challenge #" + cur.id + " It does not follow the previous contribution");
    return false;
  }
  sr = await sameRatio$1(curve2, prev3.betaG1, cur.betaG1, cur.key.beta.g2_sp, cur.key.beta.g2_spx);
  if (sr !== true) {
    if (logger) logger.error("INVALID beta*G1. challenge #" + cur.id + " It does not follow the previous contribution");
    return false;
  }
  sr = await sameRatio$1(curve2, cur.key.beta.g1_s, cur.key.beta.g1_sx, prev3.betaG2, cur.betaG2);
  if (sr !== true) {
    if (logger) logger.error("INVALID beta*G2. challenge #" + cur.id + "It does not follow the previous contribution");
    return false;
  }
  if (logger) logger.info("Powers Of tau file OK!");
  return true;
}
async function verify(tauFilename, logger) {
  let sr;
  await blake2bWasm.exports.ready();
  const { fd, sections } = await readBinFile(tauFilename, "ptau", 1);
  const { curve: curve2, power, ceremonyPower } = await readPTauHeader(fd, sections);
  const contrs = await readContributions(fd, curve2, sections);
  if (logger) logger.debug("power: 2**" + power);
  if (logger) logger.debug("Computing initial contribution hash");
  const initialContribution = {
    tauG1: curve2.G1.g,
    tauG2: curve2.G2.g,
    alphaG1: curve2.G1.g,
    betaG1: curve2.G1.g,
    betaG2: curve2.G2.g,
    nextChallenge: calculateFirstChallengeHash(curve2, ceremonyPower, logger),
    responseHash: blake2bWasm.exports(64).digest()
  };
  if (contrs.length == 0) {
    if (logger) logger.error("This file has no contribution! It cannot be used in production");
    return false;
  }
  let prevContr;
  if (contrs.length > 1) {
    prevContr = contrs[contrs.length - 2];
  } else {
    prevContr = initialContribution;
  }
  const curContr = contrs[contrs.length - 1];
  if (logger) logger.debug("Validating contribution #" + contrs[contrs.length - 1].id);
  const res = await verifyContribution(curve2, curContr, prevContr, logger);
  if (!res) return false;
  const nextContributionHasher = blake2bWasm.exports(64);
  nextContributionHasher.update(curContr.responseHash);
  if (logger) logger.debug("Verifying powers in tau*G1 section");
  const rTau1 = await processSection(2, "G1", "tauG1", 2 ** power * 2 - 1, [0, 1], logger);
  sr = await sameRatio$1(curve2, rTau1.R1, rTau1.R2, curve2.G2.g, curContr.tauG2);
  if (sr !== true) {
    if (logger) logger.error("tauG1 section. Powers do not match");
    return false;
  }
  if (!curve2.G1.eq(curve2.G1.g, rTau1.singularPoints[0])) {
    if (logger) logger.error("First element of tau*G1 section must be the generator");
    return false;
  }
  if (!curve2.G1.eq(curContr.tauG1, rTau1.singularPoints[1])) {
    if (logger) logger.error("Second element of tau*G1 section does not match the one in the contribution section");
    return false;
  }
  if (logger) logger.debug("Verifying powers in tau*G2 section");
  const rTau2 = await processSection(3, "G2", "tauG2", 2 ** power, [0, 1], logger);
  sr = await sameRatio$1(curve2, curve2.G1.g, curContr.tauG1, rTau2.R1, rTau2.R2);
  if (sr !== true) {
    if (logger) logger.error("tauG2 section. Powers do not match");
    return false;
  }
  if (!curve2.G2.eq(curve2.G2.g, rTau2.singularPoints[0])) {
    if (logger) logger.error("First element of tau*G2 section must be the generator");
    return false;
  }
  if (!curve2.G2.eq(curContr.tauG2, rTau2.singularPoints[1])) {
    if (logger) logger.error("Second element of tau*G2 section does not match the one in the contribution section");
    return false;
  }
  if (logger) logger.debug("Verifying powers in alpha*tau*G1 section");
  const rAlphaTauG1 = await processSection(4, "G1", "alphatauG1", 2 ** power, [0], logger);
  sr = await sameRatio$1(curve2, rAlphaTauG1.R1, rAlphaTauG1.R2, curve2.G2.g, curContr.tauG2);
  if (sr !== true) {
    if (logger) logger.error("alphaTauG1 section. Powers do not match");
    return false;
  }
  if (!curve2.G1.eq(curContr.alphaG1, rAlphaTauG1.singularPoints[0])) {
    if (logger) logger.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section");
    return false;
  }
  if (logger) logger.debug("Verifying powers in beta*tau*G1 section");
  const rBetaTauG1 = await processSection(5, "G1", "betatauG1", 2 ** power, [0], logger);
  sr = await sameRatio$1(curve2, rBetaTauG1.R1, rBetaTauG1.R2, curve2.G2.g, curContr.tauG2);
  if (sr !== true) {
    if (logger) logger.error("betaTauG1 section. Powers do not match");
    return false;
  }
  if (!curve2.G1.eq(curContr.betaG1, rBetaTauG1.singularPoints[0])) {
    if (logger) logger.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section");
    return false;
  }
  const betaG2 = await processSectionBetaG2(logger);
  if (!curve2.G2.eq(curContr.betaG2, betaG2)) {
    if (logger) logger.error("betaG2 element in betaG2 section does not match the one in the contribution section");
    return false;
  }
  const nextContributionHash = nextContributionHasher.digest();
  if (power == ceremonyPower) {
    if (!hashIsEqual(nextContributionHash, curContr.nextChallenge)) {
      if (logger) logger.error("Hash of the values does not match the next challenge of the last contributor in the contributions section");
      return false;
    }
  }
  if (logger) logger.info(formatHash(nextContributionHash, "Next challenge hash: "));
  printContribution(curContr, prevContr);
  for (let i2 = contrs.length - 2; i2 >= 0; i2--) {
    const curContr2 = contrs[i2];
    const prevContr2 = i2 > 0 ? contrs[i2 - 1] : initialContribution;
    const res2 = await verifyContribution(curve2, curContr2, prevContr2, logger);
    if (!res2) return false;
    printContribution(curContr2, prevContr2);
  }
  if (logger) logger.info("-----------------------------------------------------");
  if (!sections[12] || !sections[13] || !sections[14] || !sections[15]) {
    if (logger) logger.warn(
      'this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.'
    );
  } else {
    let res2;
    res2 = await verifyLagrangeEvaluations("G1", 2, 12, "tauG1", logger);
    if (!res2) return false;
    res2 = await verifyLagrangeEvaluations("G2", 3, 13, "tauG2", logger);
    if (!res2) return false;
    res2 = await verifyLagrangeEvaluations("G1", 4, 14, "alphaTauG1", logger);
    if (!res2) return false;
    res2 = await verifyLagrangeEvaluations("G1", 5, 15, "betaTauG1", logger);
    if (!res2) return false;
  }
  await fd.close();
  if (logger) logger.info("Powers of Tau Ok!");
  return true;
  function printContribution(curContr2, prevContr2) {
    if (!logger) return;
    logger.info("-----------------------------------------------------");
    logger.info(`Contribution #${curContr2.id}: ${curContr2.name || ""}`);
    logger.info(formatHash(curContr2.nextChallenge, "Next Challenge: "));
    const buffV = new Uint8Array(curve2.G1.F.n8 * 2 * 6 + curve2.G2.F.n8 * 2 * 3);
    toPtauPubKeyRpr(buffV, 0, curve2, curContr2.key, false);
    const responseHasher = blake2bWasm.exports(64);
    responseHasher.setPartialHash(curContr2.partialHash);
    responseHasher.update(buffV);
    const responseHash = responseHasher.digest();
    logger.info(formatHash(responseHash, "Response Hash:"));
    logger.info(formatHash(prevContr2.nextChallenge, "Response Hash:"));
    if (curContr2.type == 1) {
      logger.info(`Beacon generator: ${byteArray2hex(curContr2.beaconHash)}`);
      logger.info(`Beacon iterations Exp: ${curContr2.numIterationsExp}`);
    }
  }
  async function processSectionBetaG2(logger2) {
    const G2 = curve2.G2;
    const sG = G2.F.n8 * 2;
    const buffUv = new Uint8Array(sG);
    if (!sections[6]) {
      logger2.error("File has no BetaG2 section");
      throw new Error("File has no BetaG2 section");
    }
    if (sections[6].length > 1) {
      logger2.error("File has no BetaG2 section");
      throw new Error("File has more than one GetaG2 section");
    }
    fd.pos = sections[6][0].p;
    const buff = await fd.read(sG);
    const P2 = G2.fromRprLEM(buff);
    G2.toRprUncompressed(buffUv, 0, P2);
    nextContributionHasher.update(buffUv);
    return P2;
  }
  async function processSection(idSection, groupName, sectionName, nPoints, singularPointIndexes, logger2) {
    const MAX_CHUNK_SIZE = 1 << 16;
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    await startReadUniqueSection(fd, sections, idSection);
    const singularPoints = [];
    let R1 = G2.zero;
    let R2 = G2.zero;
    let lastBase = G2.zero;
    for (let i2 = 0; i2 < nPoints; i2 += MAX_CHUNK_SIZE) {
      if (logger2) logger2.debug(`points relations: ${sectionName}: ${i2}/${nPoints} `);
      const n = Math.min(nPoints - i2, MAX_CHUNK_SIZE);
      const bases = await fd.read(n * sG);
      const basesU = await G2.batchLEMtoU(bases);
      nextContributionHasher.update(basesU);
      const scalars = getRandomBytes2(4 * (n - 1));
      if (i2 > 0) {
        const firstBase = G2.fromRprLEM(bases, 0);
        const r3 = readUInt32BE(getRandomBytes2(4), 0);
        R1 = G2.add(R1, G2.timesScalar(lastBase, r3));
        R2 = G2.add(R2, G2.timesScalar(firstBase, r3));
      }
      const r1 = await G2.multiExpAffine(bases.slice(0, (n - 1) * sG), scalars);
      const r2 = await G2.multiExpAffine(bases.slice(sG), scalars);
      R1 = G2.add(R1, r1);
      R2 = G2.add(R2, r2);
      lastBase = G2.fromRprLEM(bases, (n - 1) * sG);
      for (let j2 = 0; j2 < singularPointIndexes.length; j2++) {
        const sp = singularPointIndexes[j2];
        if (sp >= i2 && sp < i2 + n) {
          const P2 = G2.fromRprLEM(bases, (sp - i2) * sG);
          singularPoints.push(P2);
        }
      }
    }
    await endReadSection(fd);
    return {
      R1,
      R2,
      singularPoints
    };
  }
  async function verifyLagrangeEvaluations(gName, tauSection, lagrangeSection, sectionName, logger2) {
    if (logger2) logger2.debug(`Verifying phase2 calculated values ${sectionName}...`);
    const G2 = curve2[gName];
    const sG = G2.F.n8 * 2;
    const seed = new Array(8);
    for (let i2 = 0; i2 < 8; i2++) {
      seed[i2] = readUInt32BE(getRandomBytes2(4), 0);
    }
    for (let p2 = 0; p2 <= power; p2++) {
      const res2 = await verifyPower(p2);
      if (!res2) return false;
    }
    if (tauSection == 2) {
      const res2 = await verifyPower(power + 1);
      if (!res2) return false;
    }
    return true;
    async function verifyPower(p2) {
      if (logger2) logger2.debug(`Power ${p2}...`);
      const n8r = curve2.Fr.n8;
      const nPoints = 2 ** p2;
      let buff_r = new Uint32Array(nPoints);
      let buffG;
      let rng = new ChaCha(seed);
      if (logger2) logger2.debug(`Creating random numbers Powers${p2}...`);
      for (let i2 = 0; i2 < nPoints; i2++) {
        if (p2 == power + 1 && i2 == nPoints - 1) {
          buff_r[i2] = 0;
        } else {
          buff_r[i2] = rng.nextU32();
        }
      }
      buff_r = new Uint8Array(buff_r.buffer, buff_r.byteOffset, buff_r.byteLength);
      if (logger2) logger2.debug(`reading points Powers${p2}...`);
      await startReadUniqueSection(fd, sections, tauSection);
      buffG = new BigBuffer(nPoints * sG);
      if (p2 == power + 1) {
        await fd.readToBuffer(buffG, 0, (nPoints - 1) * sG);
        buffG.set(curve2.G1.zeroAffine, (nPoints - 1) * sG);
      } else {
        await fd.readToBuffer(buffG, 0, nPoints * sG);
      }
      await endReadSection(fd, true);
      const resTau = await G2.multiExpAffine(buffG, buff_r, logger2, sectionName + "_" + p2);
      buff_r = new BigBuffer(nPoints * n8r);
      rng = new ChaCha(seed);
      const buff4 = new Uint8Array(4);
      const buff4V = new DataView(buff4.buffer);
      if (logger2) logger2.debug(`Creating random numbers Powers${p2}...`);
      for (let i2 = 0; i2 < nPoints; i2++) {
        if (i2 != nPoints - 1 || p2 != power + 1) {
          buff4V.setUint32(0, rng.nextU32(), true);
          buff_r.set(buff4, i2 * n8r);
        }
      }
      if (logger2) logger2.debug(`batchToMontgomery ${p2}...`);
      buff_r = await curve2.Fr.batchToMontgomery(buff_r);
      if (logger2) logger2.debug(`fft ${p2}...`);
      buff_r = await curve2.Fr.fft(buff_r);
      if (logger2) logger2.debug(`batchFromMontgomery ${p2}...`);
      buff_r = await curve2.Fr.batchFromMontgomery(buff_r);
      if (logger2) logger2.debug(`reading points Lagrange${p2}...`);
      await startReadUniqueSection(fd, sections, lagrangeSection);
      fd.pos += sG * (2 ** p2 - 1);
      await fd.readToBuffer(buffG, 0, nPoints * sG);
      await endReadSection(fd, true);
      const resLagrange = await G2.multiExpAffine(buffG, buff_r, logger2, sectionName + "_" + p2 + "_transformed");
      if (!G2.eq(resTau, resLagrange)) {
        if (logger2) logger2.error("Phase2 caclutation does not match with powers of tau");
        return false;
      }
      return true;
    }
  }
}
async function applyKeyToSection(fdOld, sections, fdNew, idSection, curve2, groupName, first, inc, sectionName, logger) {
  const MAX_CHUNK_SIZE = 1 << 16;
  const G2 = curve2[groupName];
  const sG = G2.F.n8 * 2;
  const nPoints = sections[idSection][0].size / sG;
  await startReadUniqueSection(fdOld, sections, idSection);
  await startWriteSection(fdNew, idSection);
  let t = first;
  for (let i2 = 0; i2 < nPoints; i2 += MAX_CHUNK_SIZE) {
    if (logger) logger.debug(`Applying key: ${sectionName}: ${i2}/${nPoints}`);
    const n = Math.min(nPoints - i2, MAX_CHUNK_SIZE);
    let buff;
    buff = await fdOld.read(n * sG);
    buff = await G2.batchApplyKey(buff, t, inc);
    await fdNew.write(buff);
    t = curve2.Fr.mul(t, curve2.Fr.exp(inc, n));
  }
  await endWriteSection(fdNew);
  await endReadSection(fdOld);
}
async function applyKeyToChallengeSection(fdOld, fdNew, responseHasher, curve2, groupName, nPoints, first, inc, formatOut, sectionName, logger) {
  const G2 = curve2[groupName];
  const sG = G2.F.n8 * 2;
  const chunkSize = Math.floor((1 << 20) / sG);
  let t = first;
  for (let i2 = 0; i2 < nPoints; i2 += chunkSize) {
    if (logger) logger.debug(`Applying key ${sectionName}: ${i2}/${nPoints}`);
    const n = Math.min(nPoints - i2, chunkSize);
    const buffInU = await fdOld.read(n * sG);
    const buffInLEM = await G2.batchUtoLEM(buffInU);
    const buffOutLEM = await G2.batchApplyKey(buffInLEM, t, inc);
    let buffOut;
    if (formatOut == "COMPRESSED") {
      buffOut = await G2.batchLEMtoC(buffOutLEM);
    } else {
      buffOut = await G2.batchLEMtoU(buffOutLEM);
    }
    if (responseHasher) responseHasher.update(buffOut);
    await fdNew.write(buffOut);
    t = curve2.Fr.mul(t, curve2.Fr.exp(inc, n));
  }
}
async function challengeContribute(curve2, challengeFilename, responesFileName, entropy, logger) {
  await blake2bWasm.exports.ready();
  const fdFrom = await readExisting(challengeFilename);
  const sG1 = curve2.F1.n64 * 8 * 2;
  const sG2 = curve2.F2.n64 * 8 * 2;
  const domainSize = (fdFrom.totalSize + sG1 - 64 - sG2) / (4 * sG1 + sG2);
  let e2 = domainSize;
  let power = 0;
  while (e2 > 1) {
    e2 = e2 / 2;
    power += 1;
  }
  if (2 ** power != domainSize) throw new Error("Invalid file size");
  if (logger) logger.debug("Power to tau size: " + power);
  const rng = await getRandomRng(entropy);
  const fdTo = await createOverride(responesFileName);
  const challengeHasher = blake2bWasm.exports(64);
  for (let i2 = 0; i2 < fdFrom.totalSize; i2 += fdFrom.pageSize) {
    if (logger) logger.debug(`Hashing challenge ${i2}/${fdFrom.totalSize}`);
    const s2 = Math.min(fdFrom.totalSize - i2, fdFrom.pageSize);
    const buff = await fdFrom.read(s2);
    challengeHasher.update(buff);
  }
  const claimedHash = await fdFrom.read(64, 0);
  if (logger) logger.info(formatHash(claimedHash, "Claimed Previous Response Hash: "));
  const challengeHash = challengeHasher.digest();
  if (logger) logger.info(formatHash(challengeHash, "Current Challenge Hash: "));
  const key = createPTauKey(curve2, challengeHash, rng);
  if (logger) {
    ["tau", "alpha", "beta"].forEach((k2) => {
      logger.debug(k2 + ".g1_s: " + curve2.G1.toString(key[k2].g1_s, 16));
      logger.debug(k2 + ".g1_sx: " + curve2.G1.toString(key[k2].g1_sx, 16));
      logger.debug(k2 + ".g2_sp: " + curve2.G2.toString(key[k2].g2_sp, 16));
      logger.debug(k2 + ".g2_spx: " + curve2.G2.toString(key[k2].g2_spx, 16));
      logger.debug("");
    });
  }
  const responseHasher = blake2bWasm.exports(64);
  await fdTo.write(challengeHash);
  responseHasher.update(challengeHash);
  await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve2, "G1", 2 ** power * 2 - 1, curve2.Fr.one, key.tau.prvKey, "COMPRESSED", "tauG1", logger);
  await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve2, "G2", 2 ** power, curve2.Fr.one, key.tau.prvKey, "COMPRESSED", "tauG2", logger);
  await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve2, "G1", 2 ** power, key.alpha.prvKey, key.tau.prvKey, "COMPRESSED", "alphaTauG1", logger);
  await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve2, "G1", 2 ** power, key.beta.prvKey, key.tau.prvKey, "COMPRESSED", "betaTauG1", logger);
  await applyKeyToChallengeSection(fdFrom, fdTo, responseHasher, curve2, "G2", 1, key.beta.prvKey, key.tau.prvKey, "COMPRESSED", "betaTauG2", logger);
  const buffKey = new Uint8Array(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  toPtauPubKeyRpr(buffKey, 0, curve2, key, false);
  await fdTo.write(buffKey);
  responseHasher.update(buffKey);
  const responseHash = responseHasher.digest();
  if (logger) logger.info(formatHash(responseHash, "Contribution Response Hash: "));
  await fdTo.close();
  await fdFrom.close();
}
async function beacon$1(oldPtauFilename, newPTauFilename, name, beaconHashStr, numIterationsExp, logger) {
  const beaconHash = hex2ByteArray(beaconHashStr);
  if (beaconHash.byteLength == 0 || beaconHash.byteLength * 2 != beaconHashStr.length) {
    if (logger) logger.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)");
    return false;
  }
  if (beaconHash.length >= 256) {
    if (logger) logger.error("Maximum lenght of beacon hash is 255 bytes");
    return false;
  }
  numIterationsExp = parseInt(numIterationsExp);
  if (numIterationsExp < 10 || numIterationsExp > 63) {
    if (logger) logger.error("Invalid numIterationsExp. (Must be between 10 and 63)");
    return false;
  }
  await blake2bWasm.exports.ready();
  const { fd: fdOld, sections } = await readBinFile(oldPtauFilename, "ptau", 1);
  const { curve: curve2, power, ceremonyPower } = await readPTauHeader(fdOld, sections);
  if (power != ceremonyPower) {
    if (logger) logger.error("This file has been reduced. You cannot contribute into a reduced file.");
    return false;
  }
  if (sections[12]) {
    if (logger) logger.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");
  }
  const contributions = await readContributions(fdOld, curve2, sections);
  const curContribution = {
    name,
    type: 1,
    // Beacon
    numIterationsExp,
    beaconHash
  };
  let lastChallengeHash;
  if (contributions.length > 0) {
    lastChallengeHash = contributions[contributions.length - 1].nextChallenge;
  } else {
    lastChallengeHash = calculateFirstChallengeHash(curve2, power, logger);
  }
  curContribution.key = await keyFromBeacon(curve2, lastChallengeHash, beaconHash, numIterationsExp);
  const responseHasher = new blake2bWasm.exports(64);
  responseHasher.update(lastChallengeHash);
  const fdNew = await createBinFile(newPTauFilename, "ptau", 1, 7);
  await writePTauHeader(fdNew, curve2, power);
  const startSections = [];
  let firstPoints;
  firstPoints = await processSection(2, "G1", 2 ** power * 2 - 1, curve2.Fr.e(1), curContribution.key.tau.prvKey, "tauG1", logger);
  curContribution.tauG1 = firstPoints[1];
  firstPoints = await processSection(3, "G2", 2 ** power, curve2.Fr.e(1), curContribution.key.tau.prvKey, "tauG2", logger);
  curContribution.tauG2 = firstPoints[1];
  firstPoints = await processSection(4, "G1", 2 ** power, curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, "alphaTauG1", logger);
  curContribution.alphaG1 = firstPoints[0];
  firstPoints = await processSection(5, "G1", 2 ** power, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, "betaTauG1", logger);
  curContribution.betaG1 = firstPoints[0];
  firstPoints = await processSection(6, "G2", 1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, "betaTauG2", logger);
  curContribution.betaG2 = firstPoints[0];
  curContribution.partialHash = responseHasher.getPartialHash();
  const buffKey = new Uint8Array(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  toPtauPubKeyRpr(buffKey, 0, curve2, curContribution.key, false);
  responseHasher.update(new Uint8Array(buffKey));
  const hashResponse = responseHasher.digest();
  if (logger) logger.info(formatHash(hashResponse, "Contribution Response Hash imported: "));
  const nextChallengeHasher = new blake2bWasm.exports(64);
  nextChallengeHasher.update(hashResponse);
  await hashSection(fdNew, "G1", 2, 2 ** power * 2 - 1, "tauG1", logger);
  await hashSection(fdNew, "G2", 3, 2 ** power, "tauG2", logger);
  await hashSection(fdNew, "G1", 4, 2 ** power, "alphaTauG1", logger);
  await hashSection(fdNew, "G1", 5, 2 ** power, "betaTauG1", logger);
  await hashSection(fdNew, "G2", 6, 1, "betaG2", logger);
  curContribution.nextChallenge = nextChallengeHasher.digest();
  if (logger) logger.info(formatHash(curContribution.nextChallenge, "Next Challenge Hash: "));
  contributions.push(curContribution);
  await writeContributions(fdNew, curve2, contributions);
  await fdOld.close();
  await fdNew.close();
  return hashResponse;
  async function processSection(sectionId, groupName, NPoints, first, inc, sectionName, logger2) {
    const res = [];
    fdOld.pos = sections[sectionId][0].p;
    await startWriteSection(fdNew, sectionId);
    startSections[sectionId] = fdNew.pos;
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const chunkSize = Math.floor((1 << 20) / sG);
    let t = first;
    for (let i2 = 0; i2 < NPoints; i2 += chunkSize) {
      if (logger2) logger2.debug(`applying key${sectionName}: ${i2}/${NPoints}`);
      const n = Math.min(NPoints - i2, chunkSize);
      const buffIn = await fdOld.read(n * sG);
      const buffOutLEM = await G2.batchApplyKey(buffIn, t, inc);
      const promiseWrite = fdNew.write(buffOutLEM);
      const buffOutC = await G2.batchLEMtoC(buffOutLEM);
      responseHasher.update(buffOutC);
      await promiseWrite;
      if (i2 == 0)
        for (let j2 = 0; j2 < Math.min(2, NPoints); j2++)
          res.push(G2.fromRprLEM(buffOutLEM, j2 * sG));
      t = curve2.Fr.mul(t, curve2.Fr.exp(inc, n));
    }
    await endWriteSection(fdNew);
    return res;
  }
  async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName, logger2) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const nPointsChunk = Math.floor((1 << 24) / sG);
    const oldPos = fdTo.pos;
    fdTo.pos = startSections[sectionId];
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger2) logger2.debug(`Hashing ${sectionName}: ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, nPointsChunk);
      const buffLEM = await fdTo.read(n * sG);
      const buffU = await G2.batchLEMtoU(buffLEM);
      nextChallengeHasher.update(buffU);
    }
    fdTo.pos = oldPos;
  }
}
async function contribute(oldPtauFilename, newPTauFilename, name, entropy, logger) {
  await blake2bWasm.exports.ready();
  const { fd: fdOld, sections } = await readBinFile(oldPtauFilename, "ptau", 1);
  const { curve: curve2, power, ceremonyPower } = await readPTauHeader(fdOld, sections);
  if (power != ceremonyPower) {
    if (logger) logger.error("This file has been reduced. You cannot contribute into a reduced file.");
    throw new Error("This file has been reduced. You cannot contribute into a reduced file.");
  }
  if (sections[12]) {
    if (logger) logger.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");
  }
  const contributions = await readContributions(fdOld, curve2, sections);
  const curContribution = {
    name,
    type: 0
    // Beacon
  };
  let lastChallengeHash;
  const rng = await getRandomRng(entropy);
  if (contributions.length > 0) {
    lastChallengeHash = contributions[contributions.length - 1].nextChallenge;
  } else {
    lastChallengeHash = calculateFirstChallengeHash(curve2, power, logger);
  }
  curContribution.key = createPTauKey(curve2, lastChallengeHash, rng);
  const responseHasher = new blake2bWasm.exports(64);
  responseHasher.update(lastChallengeHash);
  const fdNew = await createBinFile(newPTauFilename, "ptau", 1, 7);
  await writePTauHeader(fdNew, curve2, power);
  const startSections = [];
  let firstPoints;
  firstPoints = await processSection(2, "G1", 2 ** power * 2 - 1, curve2.Fr.e(1), curContribution.key.tau.prvKey, "tauG1");
  curContribution.tauG1 = firstPoints[1];
  firstPoints = await processSection(3, "G2", 2 ** power, curve2.Fr.e(1), curContribution.key.tau.prvKey, "tauG2");
  curContribution.tauG2 = firstPoints[1];
  firstPoints = await processSection(4, "G1", 2 ** power, curContribution.key.alpha.prvKey, curContribution.key.tau.prvKey, "alphaTauG1");
  curContribution.alphaG1 = firstPoints[0];
  firstPoints = await processSection(5, "G1", 2 ** power, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, "betaTauG1");
  curContribution.betaG1 = firstPoints[0];
  firstPoints = await processSection(6, "G2", 1, curContribution.key.beta.prvKey, curContribution.key.tau.prvKey, "betaTauG2");
  curContribution.betaG2 = firstPoints[0];
  curContribution.partialHash = responseHasher.getPartialHash();
  const buffKey = new Uint8Array(curve2.F1.n8 * 2 * 6 + curve2.F2.n8 * 2 * 3);
  toPtauPubKeyRpr(buffKey, 0, curve2, curContribution.key, false);
  responseHasher.update(new Uint8Array(buffKey));
  const hashResponse = responseHasher.digest();
  if (logger) logger.info(formatHash(hashResponse, "Contribution Response Hash imported: "));
  const nextChallengeHasher = new blake2bWasm.exports(64);
  nextChallengeHasher.update(hashResponse);
  await hashSection(fdNew, "G1", 2, 2 ** power * 2 - 1, "tauG1");
  await hashSection(fdNew, "G2", 3, 2 ** power, "tauG2");
  await hashSection(fdNew, "G1", 4, 2 ** power, "alphaTauG1");
  await hashSection(fdNew, "G1", 5, 2 ** power, "betaTauG1");
  await hashSection(fdNew, "G2", 6, 1, "betaG2");
  curContribution.nextChallenge = nextChallengeHasher.digest();
  if (logger) logger.info(formatHash(curContribution.nextChallenge, "Next Challenge Hash: "));
  contributions.push(curContribution);
  await writeContributions(fdNew, curve2, contributions);
  await fdOld.close();
  await fdNew.close();
  return hashResponse;
  async function processSection(sectionId, groupName, NPoints, first, inc, sectionName) {
    const res = [];
    fdOld.pos = sections[sectionId][0].p;
    await startWriteSection(fdNew, sectionId);
    startSections[sectionId] = fdNew.pos;
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const chunkSize = Math.floor((1 << 20) / sG);
    let t = first;
    for (let i2 = 0; i2 < NPoints; i2 += chunkSize) {
      if (logger) logger.debug(`processing: ${sectionName}: ${i2}/${NPoints}`);
      const n = Math.min(NPoints - i2, chunkSize);
      const buffIn = await fdOld.read(n * sG);
      const buffOutLEM = await G2.batchApplyKey(buffIn, t, inc);
      const promiseWrite = fdNew.write(buffOutLEM);
      const buffOutC = await G2.batchLEMtoC(buffOutLEM);
      responseHasher.update(buffOutC);
      await promiseWrite;
      if (i2 == 0)
        for (let j2 = 0; j2 < Math.min(2, NPoints); j2++)
          res.push(G2.fromRprLEM(buffOutLEM, j2 * sG));
      t = curve2.Fr.mul(t, curve2.Fr.exp(inc, n));
    }
    await endWriteSection(fdNew);
    return res;
  }
  async function hashSection(fdTo, groupName, sectionId, nPoints, sectionName) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const nPointsChunk = Math.floor((1 << 24) / sG);
    const oldPos = fdTo.pos;
    fdTo.pos = startSections[sectionId];
    for (let i2 = 0; i2 < nPoints; i2 += nPointsChunk) {
      if (logger && i2) logger.debug(`Hashing ${sectionName}: ` + i2);
      const n = Math.min(nPoints - i2, nPointsChunk);
      const buffLEM = await fdTo.read(n * sG);
      const buffU = await G2.batchLEMtoU(buffLEM);
      nextChallengeHasher.update(buffU);
    }
    fdTo.pos = oldPos;
  }
}
async function preparePhase2(oldPtauFilename, newPTauFilename, logger) {
  const { fd: fdOld, sections } = await readBinFile(oldPtauFilename, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdOld, sections);
  const fdNew = await createBinFile(newPTauFilename, "ptau", 1, 11);
  await writePTauHeader(fdNew, curve2, power);
  await copySection(fdOld, sections, fdNew, 2);
  await copySection(fdOld, sections, fdNew, 3);
  await copySection(fdOld, sections, fdNew, 4);
  await copySection(fdOld, sections, fdNew, 5);
  await copySection(fdOld, sections, fdNew, 6);
  await copySection(fdOld, sections, fdNew, 7);
  await processSection(2, 12, "G1", "tauG1");
  await processSection(3, 13, "G2", "tauG2");
  await processSection(4, 14, "G1", "alphaTauG1");
  await processSection(5, 15, "G1", "betaTauG1");
  await fdOld.close();
  await fdNew.close();
  return;
  async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {
    if (logger) logger.debug("Starting section: " + sectionName);
    await startWriteSection(fdNew, newSectionId);
    for (let p2 = 0; p2 <= power; p2++) {
      await processSectionPower(p2);
    }
    if (oldSectionId == 2) {
      await processSectionPower(power + 1);
    }
    await endWriteSection(fdNew);
    async function processSectionPower(p2) {
      const nPoints = 2 ** p2;
      const G2 = curve2[Gstr];
      const sGin = G2.F.n8 * 2;
      let buff;
      buff = new BigBuffer(nPoints * sGin);
      await startReadUniqueSection(fdOld, sections, oldSectionId);
      if (oldSectionId == 2 && p2 == power + 1) {
        await fdOld.readToBuffer(buff, 0, (nPoints - 1) * sGin);
        buff.set(curve2.G1.zeroAffine, (nPoints - 1) * sGin);
      } else {
        await fdOld.readToBuffer(buff, 0, nPoints * sGin);
      }
      await endReadSection(fdOld, true);
      buff = await G2.lagrangeEvaluations(buff, "affine", "affine", logger, sectionName);
      await fdNew.write(buff);
    }
  }
}
async function truncate(ptauFilename, template, logger) {
  const { fd: fdOld, sections } = await readBinFile(ptauFilename, "ptau", 1);
  const { curve: curve2, power, ceremonyPower } = await readPTauHeader(fdOld, sections);
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  for (let p2 = 1; p2 < power; p2++) {
    await generateTruncate(p2);
  }
  await fdOld.close();
  return true;
  async function generateTruncate(p2) {
    let sP = p2.toString();
    while (sP.length < 2) sP = "0" + sP;
    if (logger) logger.debug("Writing Power: " + sP);
    const fdNew = await createBinFile(template + sP + ".ptau", "ptau", 1, 11);
    await writePTauHeader(fdNew, curve2, p2, ceremonyPower);
    await copySection(fdOld, sections, fdNew, 2, (2 ** p2 * 2 - 1) * sG1);
    await copySection(fdOld, sections, fdNew, 3, 2 ** p2 * sG2);
    await copySection(fdOld, sections, fdNew, 4, 2 ** p2 * sG1);
    await copySection(fdOld, sections, fdNew, 5, 2 ** p2 * sG1);
    await copySection(fdOld, sections, fdNew, 6, sG2);
    await copySection(fdOld, sections, fdNew, 7);
    await copySection(fdOld, sections, fdNew, 12, (2 ** (p2 + 1) * 2 - 1) * sG1);
    await copySection(fdOld, sections, fdNew, 13, (2 ** p2 * 2 - 1) * sG2);
    await copySection(fdOld, sections, fdNew, 14, (2 ** p2 * 2 - 1) * sG1);
    await copySection(fdOld, sections, fdNew, 15, (2 ** p2 * 2 - 1) * sG1);
    await fdNew.close();
  }
}
async function convert(oldPtauFilename, newPTauFilename, logger) {
  const { fd: fdOld, sections } = await readBinFile(oldPtauFilename, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdOld, sections);
  const fdNew = await createBinFile(newPTauFilename, "ptau", 1, 11);
  await writePTauHeader(fdNew, curve2, power);
  await copySection(fdOld, sections, fdNew, 2);
  await copySection(fdOld, sections, fdNew, 3);
  await copySection(fdOld, sections, fdNew, 4);
  await copySection(fdOld, sections, fdNew, 5);
  await copySection(fdOld, sections, fdNew, 6);
  await copySection(fdOld, sections, fdNew, 7);
  await processSection(2, 12, "G1", "tauG1");
  await copySection(fdOld, sections, fdNew, 13);
  await copySection(fdOld, sections, fdNew, 14);
  await copySection(fdOld, sections, fdNew, 15);
  await fdOld.close();
  await fdNew.close();
  return;
  async function processSection(oldSectionId, newSectionId, Gstr, sectionName) {
    if (logger) logger.debug("Starting section: " + sectionName);
    await startWriteSection(fdNew, newSectionId);
    const size = sections[newSectionId][0].size;
    const chunkSize = fdOld.pageSize;
    await startReadUniqueSection(fdOld, sections, newSectionId);
    for (let p2 = 0; p2 < size; p2 += chunkSize) {
      const l2 = Math.min(size - p2, chunkSize);
      const buff = await fdOld.read(l2);
      await fdNew.write(buff);
    }
    await endReadSection(fdOld);
    if (oldSectionId == 2) {
      await processSectionPower(power + 1);
    }
    await endWriteSection(fdNew);
    async function processSectionPower(p2) {
      const nPoints = 2 ** p2;
      const G2 = curve2[Gstr];
      const sGin = G2.F.n8 * 2;
      let buff;
      buff = new BigBuffer(nPoints * sGin);
      await startReadUniqueSection(fdOld, sections, oldSectionId);
      if (oldSectionId == 2 && p2 == power + 1) {
        await fdOld.readToBuffer(buff, 0, (nPoints - 1) * sGin);
        buff.set(curve2.G1.zeroAffine, (nPoints - 1) * sGin);
      } else {
        await fdOld.readToBuffer(buff, 0, nPoints * sGin);
      }
      await endReadSection(fdOld, true);
      buff = await G2.lagrangeEvaluations(buff, "affine", "affine", logger, sectionName);
      await fdNew.write(buff);
    }
  }
}
async function exportJson(pTauFilename, verbose) {
  const { fd, sections } = await readBinFile(pTauFilename, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fd, sections);
  const pTau = {};
  pTau.q = curve2.q;
  pTau.power = power;
  pTau.contributions = await readContributions(fd, curve2, sections);
  pTau.tauG1 = await exportSection(2, "G1", 2 ** power * 2 - 1, "tauG1");
  pTau.tauG2 = await exportSection(3, "G2", 2 ** power, "tauG2");
  pTau.alphaTauG1 = await exportSection(4, "G1", 2 ** power, "alphaTauG1");
  pTau.betaTauG1 = await exportSection(5, "G1", 2 ** power, "betaTauG1");
  pTau.betaG2 = await exportSection(6, "G2", 1, "betaG2");
  pTau.lTauG1 = await exportLagrange(12, "G1", "lTauG1");
  pTau.lTauG2 = await exportLagrange(13, "G2", "lTauG2");
  pTau.lAlphaTauG1 = await exportLagrange(14, "G1", "lAlphaTauG2");
  pTau.lBetaTauG1 = await exportLagrange(15, "G1", "lBetaTauG2");
  await fd.close();
  return stringifyBigIntsWithField(curve2.Fr, pTau);
  async function exportSection(sectionId, groupName, nPoints, sectionName) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const res = [];
    await startReadUniqueSection(fd, sections, sectionId);
    for (let i2 = 0; i2 < nPoints; i2++) {
      if (verbose && i2 && i2 % 1e4 == 0) console.log(`${sectionName}: ` + i2);
      const buff = await fd.read(sG);
      res.push(G2.fromRprLEM(buff, 0));
    }
    await endReadSection(fd);
    return res;
  }
  async function exportLagrange(sectionId, groupName, sectionName) {
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    const res = [];
    await startReadUniqueSection(fd, sections, sectionId);
    for (let p2 = 0; p2 <= power; p2++) {
      if (verbose) console.log(`${sectionName}: Power: ${p2}`);
      res[p2] = [];
      const nPoints = 2 ** p2;
      for (let i2 = 0; i2 < nPoints; i2++) {
        if (verbose && i2 && i2 % 1e4 == 0) console.log(`${sectionName}: ${i2}/${nPoints}`);
        const buff = await fd.read(sG);
        res[p2].push(G2.fromRprLEM(buff, 0));
      }
    }
    await endReadSection(fd, true);
    return res;
  }
}
function r1csPrint(r1cs2, syms, logger) {
  for (let i2 = 0; i2 < r1cs2.constraints.length; i2++) {
    printCostraint(r1cs2.constraints[i2]);
  }
  function printCostraint(c2) {
    const lc2str = (lc) => {
      let S3 = "";
      const keys = Object.keys(lc);
      keys.forEach((k2) => {
        let name = syms.varIdx2Name[k2];
        if (name == "one") name = "1";
        let vs = r1cs2.curve.Fr.toString(lc[k2]);
        if (vs == "1") vs = "";
        if (vs == "-1") vs = "-";
        if (S3 != "" && vs[0] != "-") vs = "+" + vs;
        if (S3 != "") vs = " " + vs;
        S3 = S3 + vs + name;
      });
      return S3;
    };
    const S2 = `[ ${lc2str(c2[0])} ] * [ ${lc2str(c2[1])} ] - [ ${lc2str(c2[2])} ] = 0`;
    if (logger) logger.info(S2);
  }
}
async function readR1csHeader(fd, sections, singleThread) {
  let options;
  if (typeof singleThread === "object") {
    options = singleThread;
  } else if (typeof singleThread === "undefined") {
    options = {
      singleThread: false
    };
  } else {
    options = {
      singleThread
    };
  }
  const res = {};
  await startReadUniqueSection(fd, sections, 1);
  res.n8 = await fd.readULE32();
  res.prime = await readBigInt(fd, res.n8);
  if (options.F) {
    if (options.F.p != res.prime) throw new Error("Different Prime");
    res.F = options.F;
  } else if (options.getFieldFromPrime) {
    res.F = await options.getFieldFromPrime(res.prime, options.singleThread);
  } else if (options.getCurveFromPrime) {
    res.curve = await options.getCurveFromPrime(res.prime, options.singleThread);
    res.F = res.curve.Fr;
  } else {
    try {
      res.curve = await getCurveFromR(res.prime, options.singleThread);
      res.F = res.curve.Fr;
    } catch (err) {
      res.F = new ZqField(res.prime);
    }
  }
  res.nVars = await fd.readULE32();
  res.nOutputs = await fd.readULE32();
  res.nPubInputs = await fd.readULE32();
  res.nPrvInputs = await fd.readULE32();
  res.nLabels = await fd.readULE64();
  res.nConstraints = await fd.readULE32();
  res.useCustomGates = typeof sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== "undefined" && sections[R1CS_FILE_CUSTOM_GATES_LIST_SECTION] !== null && typeof sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== "undefined" && sections[R1CS_FILE_CUSTOM_GATES_USES_SECTION] !== null;
  await endReadSection(fd);
  return res;
}
async function readConstraints(fd, sections, r1cs2, logger, loggerCtx) {
  let options;
  if (typeof logger === "object") {
    options = logger;
  } else if (typeof logger === "undefined") {
    options = {};
  } else {
    options = {
      logger,
      loggerCtx
    };
  }
  const bR1cs = await readSection(fd, sections, 2);
  let bR1csPos = 0;
  let constraints;
  if (r1cs2.nConstraints > 1 << 20) {
    constraints = new BigArray$3();
  } else {
    constraints = [];
  }
  for (let i2 = 0; i2 < r1cs2.nConstraints; i2++) {
    if (options.logger && i2 % 1e5 == 0) options.logger.info(`${options.loggerCtx}: Loading constraints: ${i2}/${r1cs2.nConstraints}`);
    const c2 = readConstraint();
    constraints.push(c2);
  }
  return constraints;
  function readConstraint() {
    const c2 = [];
    c2[0] = readLC();
    c2[1] = readLC();
    c2[2] = readLC();
    return c2;
  }
  function readLC() {
    const lc = {};
    const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);
    bR1csPos += 4;
    const buffUL32V = new DataView(buffUL32.buffer);
    const nIdx = buffUL32V.getUint32(0, true);
    const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs2.n8) * nIdx);
    bR1csPos += (4 + r1cs2.n8) * nIdx;
    const buffV = new DataView(buff.buffer);
    for (let i2 = 0; i2 < nIdx; i2++) {
      const idx = buffV.getUint32(i2 * (4 + r1cs2.n8), true);
      const val = r1cs2.F.fromRprLE(buff, i2 * (4 + r1cs2.n8) + 4);
      lc[idx] = val;
    }
    return lc;
  }
}
async function readMap(fd, sections, r1cs2, logger, loggerCtx) {
  let options;
  if (typeof logger === "object") {
    options = logger;
  } else if (typeof logger === "undefined") {
    options = {};
  } else {
    options = {
      logger,
      loggerCtx
    };
  }
  const bMap = await readSection(fd, sections, 3);
  let bMapPos = 0;
  let map;
  if (r1cs2.nVars > 1 << 20) {
    map = new BigArray$3();
  } else {
    map = [];
  }
  for (let i2 = 0; i2 < r1cs2.nVars; i2++) {
    if (options.logger && i2 % 1e4 == 0) options.logger.info(`${options.loggerCtx}: Loading map: ${i2}/${r1cs2.nVars}`);
    const idx = readULE64();
    map.push(idx);
  }
  return map;
  function readULE64() {
    const buffULE64 = bMap.slice(bMapPos, bMapPos + 8);
    bMapPos += 8;
    const buffULE64V = new DataView(buffULE64.buffer);
    const LSB = buffULE64V.getUint32(0, true);
    const MSB = buffULE64V.getUint32(4, true);
    return MSB * 4294967296 + LSB;
  }
}
async function readR1csFd(fd, sections, options) {
  if (typeof options !== "object") {
    throw new Error("readR1csFd: options must be an object");
  }
  options.loadConstraints = "loadConstraints" in options ? options.loadConstraints : true;
  options.loadMap = "loadMap" in options ? options.loadMap : false;
  options.loadCustomGates = "loadCustomGates" in options ? options.loadCustomGates : true;
  const res = await readR1csHeader(fd, sections, options);
  if (options.loadConstraints) {
    res.constraints = await readConstraints(fd, sections, res, options);
  }
  if (options.loadMap) {
    res.map = await readMap(fd, sections, res, options);
  }
  if (options.loadCustomGates) {
    if (res.useCustomGates) {
      res.customGates = await readCustomGatesListSection(fd, sections, res);
      res.customGatesUses = await readCustomGatesUsesSection(fd, sections, options);
    } else {
      res.customGates = [];
      res.customGatesUses = [];
    }
  }
  return res;
}
async function readR1cs(fileName, loadConstraints, loadMap, singleThread, logger, loggerCtx) {
  let options;
  if (typeof loadConstraints === "object") {
    options = loadConstraints;
  } else if (typeof loadConstraints === "undefined") {
    options = {
      loadConstraints: true,
      loadMap: false,
      loadCustomGates: true
    };
  } else {
    options = {
      loadConstraints,
      loadMap,
      singleThread,
      logger,
      loggerCtx
    };
  }
  const { fd, sections } = await readBinFile(fileName, "r1cs", 1);
  const res = await readR1csFd(fd, sections, options);
  await fd.close();
  return res;
}
async function readCustomGatesListSection(fd, sections, res) {
  await startReadUniqueSection(fd, sections, R1CS_FILE_CUSTOM_GATES_LIST_SECTION);
  let num = await fd.readULE32();
  let customGates = [];
  for (let i2 = 0; i2 < num; i2++) {
    let customGate = {};
    customGate.templateName = await fd.readString();
    let numParameters = await fd.readULE32();
    customGate.parameters = Array(numParameters);
    let buff = await fd.read(res.n8 * numParameters);
    for (let j2 = 0; j2 < numParameters; j2++) {
      customGate.parameters[j2] = res.F.fromRprLE(buff, j2 * res.n8, res.n8);
    }
    customGates.push(customGate);
  }
  await endReadSection(fd);
  return customGates;
}
async function readCustomGatesUsesSection(fd, sections, options) {
  const bR1cs = await readSection(fd, sections, R1CS_FILE_CUSTOM_GATES_USES_SECTION);
  const bR1cs32 = new Uint32Array(bR1cs.buffer, bR1cs.byteOffset, bR1cs.byteLength / 4);
  const nCustomGateUses = bR1cs32[0];
  let bR1csPos = 1;
  let customGatesUses;
  if (nCustomGateUses > 1 << 20) {
    customGatesUses = new BigArray$3();
  } else {
    customGatesUses = [];
  }
  for (let i2 = 0; i2 < nCustomGateUses; i2++) {
    if (options.logger && i2 % 1e5 == 0) options.logger.info(`${options.loggerCtx}: Loading custom gate uses: ${i2}/${nCustomGateUses}`);
    let c2 = {};
    c2.id = bR1cs32[bR1csPos++];
    let numSignals = bR1cs32[bR1csPos++];
    c2.signals = [];
    for (let j2 = 0; j2 < numSignals; j2++) {
      const LSB = bR1cs32[bR1csPos++];
      const MSB = bR1cs32[bR1csPos++];
      c2.signals.push(MSB * 4294967296 + LSB);
    }
    customGatesUses.push(c2);
  }
  return customGatesUses;
}
async function r1csInfo(r1csName, logger) {
  const cir = await readR1cs(r1csName);
  if (Scalar.eq(cir.prime, bn128r2)) {
    if (logger) logger.info("Curve: bn-128");
  } else if (Scalar.eq(cir.prime, bls12381r2)) {
    if (logger) logger.info("Curve: bls12-381");
  } else {
    if (logger) logger.info(`Unknown Curve. Prime: ${Scalar.toString(cir.prime)}`);
  }
  if (logger) logger.info(`# of Wires: ${cir.nVars}`);
  if (logger) logger.info(`# of Constraints: ${cir.nConstraints}`);
  if (logger) logger.info(`# of Private Inputs: ${cir.nPrvInputs}`);
  if (logger) logger.info(`# of Public Inputs: ${cir.nPubInputs}`);
  if (logger) logger.info(`# of Labels: ${cir.nLabels}`);
  if (logger) logger.info(`# of Outputs: ${cir.nOutputs}`);
  return cir;
}
async function r1csExportJson(r1csFileName, logger) {
  const cir = await readR1cs(r1csFileName, true, true, true, logger);
  const Fr = cir.curve.Fr;
  delete cir.curve;
  delete cir.F;
  return stringifyBigIntsWithField(Fr, cir);
}
async function loadSymbols(symFileName) {
  const sym = {
    labelIdx2Name: ["one"],
    varIdx2Name: ["one"],
    componentIdx2Name: []
  };
  const fd = await readExisting(symFileName);
  const buff = await fd.read(fd.totalSize);
  const symsStr = new TextDecoder("utf-8").decode(buff);
  const lines = symsStr.split("\n");
  for (let i2 = 0; i2 < lines.length; i2++) {
    const arr = lines[i2].split(",");
    if (arr.length != 4) continue;
    if (sym.varIdx2Name[arr[1]]) {
      sym.varIdx2Name[arr[1]] += "|" + arr[3];
    } else {
      sym.varIdx2Name[arr[1]] = arr[3];
    }
    sym.labelIdx2Name[arr[0]] = arr[3];
    if (!sym.componentIdx2Name[arr[2]]) {
      sym.componentIdx2Name[arr[2]] = extractComponent(arr[3]);
    }
  }
  await fd.close();
  return sym;
  function extractComponent(name) {
    const arr = name.split(".");
    arr.pop();
    return arr.join(".");
  }
}
async function wtnsDebug(_input, wasmFileName, wtnsFileName, symName, options, logger) {
  const input = unstringifyBigInts$7(_input);
  const fdWasm = await readExisting(wasmFileName);
  const wasm2 = await fdWasm.read(fdWasm.totalSize);
  await fdWasm.close();
  let wcOps = {
    sanityCheck: true
  };
  let sym = await loadSymbols(symName);
  if (options.set) {
    if (!sym) sym = await loadSymbols(symName);
    wcOps.logSetSignal = function(labelIdx, value) {
      if (logger) logger.info("SET " + sym.labelIdx2Name[labelIdx] + " <-- " + value.toString());
    };
  }
  if (options.get) {
    if (!sym) sym = await loadSymbols(symName);
    wcOps.logGetSignal = function(varIdx, value) {
      if (logger) logger.info("GET " + sym.labelIdx2Name[varIdx] + " --> " + value.toString());
    };
  }
  if (options.trigger) {
    if (!sym) sym = await loadSymbols(symName);
    wcOps.logStartComponent = function(cIdx) {
      if (logger) logger.info("START: " + sym.componentIdx2Name[cIdx]);
    };
    wcOps.logFinishComponent = function(cIdx) {
      if (logger) logger.info("FINISH: " + sym.componentIdx2Name[cIdx]);
    };
  }
  wcOps.sym = sym;
  const wc = await builder(wasm2, wcOps);
  const w2 = await wc.calculateWitness(input);
  const fdWtns = await createBinFile(wtnsFileName, "wtns", 2, 2);
  await write(fdWtns, w2, wc.prime);
  await fdWtns.close();
}
async function wtnsExportJson(wtnsFileName) {
  const w2 = await read(wtnsFileName);
  return w2;
}
async function wtnsCheck(r1csFilename, wtnsFilename, logger) {
  if (logger) logger.info("WITNESS CHECKING STARTED");
  if (logger) logger.info("> Reading r1cs file");
  const {
    fd: fdR1cs,
    sections: sectionsR1cs
  } = await readBinFile(r1csFilename, "r1cs", 1);
  const r1cs2 = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: false });
  if (logger) logger.info("> Reading witness file");
  const {
    fd: fdWtns,
    sections: wtnsSections
  } = await readBinFile(wtnsFilename, "wtns", 2);
  const wtnsHeader = await readHeader(fdWtns, wtnsSections);
  if (!Scalar.eq(r1cs2.prime, wtnsHeader.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  const buffWitness = await readSection(fdWtns, wtnsSections, 2);
  await fdWtns.close();
  const curve2 = await getCurveFromR2(r1cs2.prime);
  const Fr = curve2.Fr;
  const sFr = Fr.n8;
  const bR1cs = await readSection(fdR1cs, sectionsR1cs, 2);
  if (logger) {
    logger.info("----------------------------");
    logger.info("  WITNESS CHECK");
    logger.info(`  Curve:          ${r1cs2.curve.name}`);
    logger.info(`  Vars (wires):   ${r1cs2.nVars}`);
    logger.info(`  Ouputs:         ${r1cs2.nOutputs}`);
    logger.info(`  Public Inputs:  ${r1cs2.nPubInputs}`);
    logger.info(`  Private Inputs: ${r1cs2.nPrvInputs}`);
    logger.info(`  Labels:         ${r1cs2.nLabels}`);
    logger.info(`  Constraints:    ${r1cs2.nConstraints}`);
    logger.info(`  Custom Gates:   ${r1cs2.useCustomGates}`);
    logger.info("----------------------------");
  }
  if (logger) logger.info("> Checking witness correctness");
  let bR1csPos = 0;
  let res = true;
  for (let i2 = 0; i2 < r1cs2.nConstraints; i2++) {
    if (logger && i2 !== 0 && i2 % 5e5 === 0) {
      logger.info(` processing r1cs constraints ${i2}/${r1cs2.nConstraints}`);
    }
    const lcA = readLC();
    const lcB = readLC();
    const lcC = readLC();
    const evalA = EvaluateLinearCombination(lcA);
    const evalB = EvaluateLinearCombination(lcB);
    const evalC = EvaluateLinearCombination(lcC);
    if (!Fr.eq(Fr.sub(Fr.mul(evalA, evalB), evalC), Fr.zero)) {
      logger.warn(" aborting checking process at constraint " + i2);
      res = false;
      break;
    }
  }
  fdR1cs.close();
  if (logger) {
    if (res) {
      logger.info("WITNESS IS CORRECT");
      logger.info("WITNESS CHECKING FINISHED SUCCESSFULLY");
    } else {
      logger.warn("WITNESS IS NOT CORRECT");
      logger.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY");
    }
  }
  return res;
  function EvaluateLinearCombination(lc) {
    let res2 = Fr.zero;
    const keys = Object.keys(lc);
    keys.forEach((signalId) => {
      const signalValue = getWitnessValue(signalId);
      const signalFactor = lc[signalId];
      res2 = Fr.add(res2, Fr.mul(signalValue, signalFactor));
    });
    return res2;
  }
  function readLC() {
    const lc = {};
    const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);
    bR1csPos += 4;
    const buffUL32V = new DataView(buffUL32.buffer);
    const nIdx = buffUL32V.getUint32(0, true);
    const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs2.n8) * nIdx);
    bR1csPos += (4 + r1cs2.n8) * nIdx;
    const buffV = new DataView(buff.buffer);
    for (let i2 = 0; i2 < nIdx; i2++) {
      const idx = buffV.getUint32(i2 * (4 + r1cs2.n8), true);
      const val = r1cs2.F.fromRprLE(buff, i2 * (4 + r1cs2.n8) + 4);
      lc[idx] = val;
    }
    return lc;
  }
  function getWitnessValue(signalId) {
    return Fr.fromRprLE(buffWitness.slice(signalId * sFr, signalId * sFr + sFr));
  }
}
async function newZKey(r1csName, ptauName, zkeyName, logger) {
  const TAU_G1 = 0;
  const TAU_G2 = 1;
  const ALPHATAU_G1 = 2;
  const BETATAU_G1 = 3;
  await blake2bWasm.exports.ready();
  const csHasher = blake2bWasm.exports(64);
  const { fd: fdPTau, sections: sectionsPTau } = await readBinFile(ptauName, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdPTau, sectionsPTau);
  const { fd: fdR1cs, sections: sectionsR1cs } = await readBinFile(r1csName, "r1cs", 1);
  const r1cs2 = await readR1csHeader(fdR1cs, sectionsR1cs, false);
  const fdZKey = await createBinFile(zkeyName, "zkey", 1, 10, 1 << 22, 1 << 24);
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  if (r1cs2.prime != curve2.r) {
    if (logger) logger.error("r1cs curve does not match powers of tau ceremony curve");
    return -1;
  }
  const cirPower = log22(r1cs2.nConstraints + r1cs2.nPubInputs + r1cs2.nOutputs + 1 - 1) + 1;
  if (cirPower > power) {
    if (logger) logger.error(`circuit too big for this power of tau ceremony. ${r1cs2.nConstraints}*2 > 2**${power}`);
    return -1;
  }
  if (!sectionsPTau[12]) {
    if (logger) logger.error("Powers of tau is not prepared.");
    return -1;
  }
  const nPublic = r1cs2.nOutputs + r1cs2.nPubInputs;
  const domainSize = 2 ** cirPower;
  await startWriteSection(fdZKey, 1);
  await fdZKey.writeULE32(1);
  await endWriteSection(fdZKey);
  await startWriteSection(fdZKey, 2);
  const primeQ = curve2.q;
  const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;
  const primeR = curve2.r;
  const n8r = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;
  const Rr = Scalar.mod(Scalar.shl(1, n8r * 8), primeR);
  const R2r = curve2.Fr.e(Scalar.mod(Scalar.mul(Rr, Rr), primeR));
  await fdZKey.writeULE32(n8q);
  await writeBigInt(fdZKey, primeQ, n8q);
  await fdZKey.writeULE32(n8r);
  await writeBigInt(fdZKey, primeR, n8r);
  await fdZKey.writeULE32(r1cs2.nVars);
  await fdZKey.writeULE32(nPublic);
  await fdZKey.writeULE32(domainSize);
  let bAlpha1;
  bAlpha1 = await fdPTau.read(sG1, sectionsPTau[4][0].p);
  await fdZKey.write(bAlpha1);
  bAlpha1 = await curve2.G1.batchLEMtoU(bAlpha1);
  csHasher.update(bAlpha1);
  let bBeta1;
  bBeta1 = await fdPTau.read(sG1, sectionsPTau[5][0].p);
  await fdZKey.write(bBeta1);
  bBeta1 = await curve2.G1.batchLEMtoU(bBeta1);
  csHasher.update(bBeta1);
  let bBeta2;
  bBeta2 = await fdPTau.read(sG2, sectionsPTau[6][0].p);
  await fdZKey.write(bBeta2);
  bBeta2 = await curve2.G2.batchLEMtoU(bBeta2);
  csHasher.update(bBeta2);
  const bg1 = new Uint8Array(sG1);
  curve2.G1.toRprLEM(bg1, 0, curve2.G1.g);
  const bg2 = new Uint8Array(sG2);
  curve2.G2.toRprLEM(bg2, 0, curve2.G2.g);
  const bg1U = new Uint8Array(sG1);
  curve2.G1.toRprUncompressed(bg1U, 0, curve2.G1.g);
  const bg2U = new Uint8Array(sG2);
  curve2.G2.toRprUncompressed(bg2U, 0, curve2.G2.g);
  await fdZKey.write(bg2);
  await fdZKey.write(bg1);
  await fdZKey.write(bg2);
  csHasher.update(bg2U);
  csHasher.update(bg1U);
  csHasher.update(bg2U);
  await endWriteSection(fdZKey);
  if (logger) logger.info("Reading r1cs");
  let sR1cs = await readSection(fdR1cs, sectionsR1cs, 2);
  const A2 = new BigArray$1(r1cs2.nVars);
  const B1 = new BigArray$1(r1cs2.nVars);
  const B2 = new BigArray$1(r1cs2.nVars);
  const C2 = new BigArray$1(r1cs2.nVars - nPublic - 1);
  const IC = new Array(nPublic + 1);
  if (logger) logger.info("Reading tauG1");
  let sTauG1 = await readSection(fdPTau, sectionsPTau, 12, (domainSize - 1) * sG1, domainSize * sG1);
  if (logger) logger.info("Reading tauG2");
  let sTauG2 = await readSection(fdPTau, sectionsPTau, 13, (domainSize - 1) * sG2, domainSize * sG2);
  if (logger) logger.info("Reading alphatauG1");
  let sAlphaTauG1 = await readSection(fdPTau, sectionsPTau, 14, (domainSize - 1) * sG1, domainSize * sG1);
  if (logger) logger.info("Reading betatauG1");
  let sBetaTauG1 = await readSection(fdPTau, sectionsPTau, 15, (domainSize - 1) * sG1, domainSize * sG1);
  await processConstraints();
  await composeAndWritePoints(3, "G1", IC, "IC");
  await writeHs();
  await hashHPoints();
  await composeAndWritePoints(8, "G1", C2, "C");
  await composeAndWritePoints(5, "G1", A2, "A");
  await composeAndWritePoints(6, "G1", B1, "B1");
  await composeAndWritePoints(7, "G2", B2, "B2");
  const csHash = csHasher.digest();
  await startWriteSection(fdZKey, 10);
  await fdZKey.write(csHash);
  await fdZKey.writeULE32(0);
  await endWriteSection(fdZKey);
  if (logger) logger.info(formatHash(csHash, "Circuit hash: "));
  await fdZKey.close();
  await fdR1cs.close();
  await fdPTau.close();
  return csHash;
  async function writeHs() {
    await startWriteSection(fdZKey, 9);
    const buffOut = new BigBuffer(domainSize * sG1);
    if (cirPower < curve2.Fr.s) {
      let sTauG12 = await readSection(fdPTau, sectionsPTau, 12, (domainSize * 2 - 1) * sG1, domainSize * 2 * sG1);
      for (let i2 = 0; i2 < domainSize; i2++) {
        if (logger && i2 % 1e4 == 0) logger.debug(`spliting buffer: ${i2}/${domainSize}`);
        const buff = sTauG12.slice((i2 * 2 + 1) * sG1, (i2 * 2 + 1) * sG1 + sG1);
        buffOut.set(buff, i2 * sG1);
      }
    } else if (cirPower == curve2.Fr.s) {
      const o2 = sectionsPTau[12][0].p + (2 ** (cirPower + 1) - 1) * sG1;
      await fdPTau.readToBuffer(buffOut, 0, domainSize * sG1, o2 + domainSize * sG1);
    } else {
      if (logger) logger.error("Circuit too big");
      throw new Error("Circuit too big for this curve");
    }
    await fdZKey.write(buffOut);
    await endWriteSection(fdZKey);
  }
  async function processConstraints() {
    const buffCoeff = new Uint8Array(12 + curve2.Fr.n8);
    const buffCoeffV = new DataView(buffCoeff.buffer);
    const bOne = new Uint8Array(curve2.Fr.n8);
    curve2.Fr.toRprLE(bOne, 0, curve2.Fr.e(1));
    let r1csPos = 0;
    function r1cs_readULE32() {
      const buff = sR1cs.slice(r1csPos, r1csPos + 4);
      r1csPos += 4;
      const buffV = new DataView(buff.buffer);
      return buffV.getUint32(0, true);
    }
    const coefs = new BigArray$1();
    for (let c2 = 0; c2 < r1cs2.nConstraints; c2++) {
      if (logger && c2 % 1e4 == 0) logger.debug(`processing constraints: ${c2}/${r1cs2.nConstraints}`);
      const nA = r1cs_readULE32();
      for (let i2 = 0; i2 < nA; i2++) {
        const s2 = r1cs_readULE32();
        const coefp = r1csPos;
        r1csPos += curve2.Fr.n8;
        const l1t = TAU_G1;
        const l1 = sG1 * c2;
        const l2t = BETATAU_G1;
        const l2 = sG1 * c2;
        if (typeof A2[s2] === "undefined") A2[s2] = [];
        A2[s2].push([l1t, l1, coefp]);
        if (s2 <= nPublic) {
          if (typeof IC[s2] === "undefined") IC[s2] = [];
          IC[s2].push([l2t, l2, coefp]);
        } else {
          if (typeof C2[s2 - nPublic - 1] === "undefined") C2[s2 - nPublic - 1] = [];
          C2[s2 - nPublic - 1].push([l2t, l2, coefp]);
        }
        coefs.push([0, c2, s2, coefp]);
      }
      const nB = r1cs_readULE32();
      for (let i2 = 0; i2 < nB; i2++) {
        const s2 = r1cs_readULE32();
        const coefp = r1csPos;
        r1csPos += curve2.Fr.n8;
        const l1t = TAU_G1;
        const l1 = sG1 * c2;
        const l2t = TAU_G2;
        const l2 = sG2 * c2;
        const l3t = ALPHATAU_G1;
        const l3 = sG1 * c2;
        if (typeof B1[s2] === "undefined") B1[s2] = [];
        B1[s2].push([l1t, l1, coefp]);
        if (typeof B2[s2] === "undefined") B2[s2] = [];
        B2[s2].push([l2t, l2, coefp]);
        if (s2 <= nPublic) {
          if (typeof IC[s2] === "undefined") IC[s2] = [];
          IC[s2].push([l3t, l3, coefp]);
        } else {
          if (typeof C2[s2 - nPublic - 1] === "undefined") C2[s2 - nPublic - 1] = [];
          C2[s2 - nPublic - 1].push([l3t, l3, coefp]);
        }
        coefs.push([1, c2, s2, coefp]);
      }
      const nC = r1cs_readULE32();
      for (let i2 = 0; i2 < nC; i2++) {
        const s2 = r1cs_readULE32();
        const coefp = r1csPos;
        r1csPos += curve2.Fr.n8;
        const l1t = TAU_G1;
        const l1 = sG1 * c2;
        if (s2 <= nPublic) {
          if (typeof IC[s2] === "undefined") IC[s2] = [];
          IC[s2].push([l1t, l1, coefp]);
        } else {
          if (typeof C2[s2 - nPublic - 1] === "undefined") C2[s2 - nPublic - 1] = [];
          C2[s2 - nPublic - 1].push([l1t, l1, coefp]);
        }
      }
    }
    for (let s2 = 0; s2 <= nPublic; s2++) {
      const l1t = TAU_G1;
      const l1 = sG1 * (r1cs2.nConstraints + s2);
      const l2t = BETATAU_G1;
      const l2 = sG1 * (r1cs2.nConstraints + s2);
      if (typeof A2[s2] === "undefined") A2[s2] = [];
      A2[s2].push([l1t, l1, -1]);
      if (typeof IC[s2] === "undefined") IC[s2] = [];
      IC[s2].push([l2t, l2, -1]);
      coefs.push([0, r1cs2.nConstraints + s2, s2, -1]);
    }
    await startWriteSection(fdZKey, 4);
    const buffSection = new BigBuffer(coefs.length * (12 + curve2.Fr.n8) + 4);
    const buff4 = new Uint8Array(4);
    const buff4V = new DataView(buff4.buffer);
    buff4V.setUint32(0, coefs.length, true);
    buffSection.set(buff4);
    let coefsPos = 4;
    for (let i2 = 0; i2 < coefs.length; i2++) {
      if (logger && i2 % 1e5 == 0) logger.debug(`writing coeffs: ${i2}/${coefs.length}`);
      writeCoef(coefs[i2]);
    }
    await fdZKey.write(buffSection);
    await endWriteSection(fdZKey);
    function writeCoef(c2) {
      buffCoeffV.setUint32(0, c2[0], true);
      buffCoeffV.setUint32(4, c2[1], true);
      buffCoeffV.setUint32(8, c2[2], true);
      let n;
      if (c2[3] >= 0) {
        n = curve2.Fr.fromRprLE(sR1cs.slice(c2[3], c2[3] + curve2.Fr.n8), 0);
      } else {
        n = curve2.Fr.fromRprLE(bOne, 0);
      }
      const nR2 = curve2.Fr.mul(n, R2r);
      curve2.Fr.toRprLE(buffCoeff, 12, nR2);
      buffSection.set(buffCoeff, coefsPos);
      coefsPos += buffCoeff.length;
    }
  }
  async function composeAndWritePoints(idSection, groupName, arr, sectionName) {
    const CHUNK_SIZE = 1 << 15;
    const G2 = curve2[groupName];
    hashU32(arr.length);
    await startWriteSection(fdZKey, idSection);
    let opPromises = [];
    let i2 = 0;
    while (i2 < arr.length) {
      let t = 0;
      while (i2 < arr.length && t < curve2.tm.concurrency) {
        if (logger) logger.debug(`Writing points start ${sectionName}: ${i2}/${arr.length}`);
        let n = 1;
        let nP = arr[i2] ? arr[i2].length : 0;
        while (i2 + n < arr.length && nP + (arr[i2 + n] ? arr[i2 + n].length : 0) < CHUNK_SIZE && n < CHUNK_SIZE) {
          nP += arr[i2 + n] ? arr[i2 + n].length : 0;
          n++;
        }
        const subArr = arr.slice(i2, i2 + n);
        const _i = i2;
        opPromises.push(composeAndWritePointsThread(groupName, subArr, logger, sectionName).then((r2) => {
          if (logger) logger.debug(`Writing points end ${sectionName}: ${_i}/${arr.length}`);
          return r2;
        }));
        i2 += n;
        t++;
      }
      const result = await Promise.all(opPromises);
      for (let k2 = 0; k2 < result.length; k2++) {
        await fdZKey.write(result[k2][0]);
        const buff = await G2.batchLEMtoU(result[k2][0]);
        csHasher.update(buff);
      }
      opPromises = [];
    }
    await endWriteSection(fdZKey);
  }
  async function composeAndWritePointsThread(groupName, arr, logger2, sectionName) {
    const G2 = curve2[groupName];
    const sGin = G2.F.n8 * 2;
    const sGmid = G2.F.n8 * 3;
    const sGout = G2.F.n8 * 2;
    let fnExp, fnMultiExp, fnBatchToAffine, fnZero;
    if (groupName == "G1") {
      fnExp = "g1m_timesScalarAffine";
      fnMultiExp = "g1m_multiexpAffine";
      fnBatchToAffine = "g1m_batchToAffine";
      fnZero = "g1m_zero";
    } else if (groupName == "G2") {
      fnExp = "g2m_timesScalarAffine";
      fnMultiExp = "g2m_multiexpAffine";
      fnBatchToAffine = "g2m_batchToAffine";
      fnZero = "g2m_zero";
    } else {
      throw new Error("Invalid group");
    }
    let acc = 0;
    for (let i2 = 0; i2 < arr.length; i2++) acc += arr[i2] ? arr[i2].length : 0;
    let bBases, bScalars;
    if (acc > 2 << 14) {
      bBases = new BigBuffer(acc * sGin);
      bScalars = new BigBuffer(acc * curve2.Fr.n8);
    } else {
      bBases = new Uint8Array(acc * sGin);
      bScalars = new Uint8Array(acc * curve2.Fr.n8);
    }
    let pB = 0;
    let pS = 0;
    const sBuffs = [
      sTauG1,
      sTauG2,
      sAlphaTauG1,
      sBetaTauG1
    ];
    const bOne = new Uint8Array(curve2.Fr.n8);
    curve2.Fr.toRprLE(bOne, 0, curve2.Fr.e(1));
    let offset = 0;
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (!arr[i2]) continue;
      for (let j2 = 0; j2 < arr[i2].length; j2++) {
        if (logger2 && j2 && j2 % 1e4 == 0) logger2.debug(`Configuring big array ${sectionName}: ${j2}/${arr[i2].length}`);
        bBases.set(
          sBuffs[arr[i2][j2][0]].slice(
            arr[i2][j2][1],
            arr[i2][j2][1] + sGin
          ),
          offset * sGin
        );
        if (arr[i2][j2][2] >= 0) {
          bScalars.set(
            sR1cs.slice(
              arr[i2][j2][2],
              arr[i2][j2][2] + curve2.Fr.n8
            ),
            offset * curve2.Fr.n8
          );
        } else {
          bScalars.set(bOne, offset * curve2.Fr.n8);
        }
        offset++;
      }
    }
    if (arr.length > 1) {
      const task = [];
      task.push({ cmd: "ALLOCSET", var: 0, buff: bBases });
      task.push({ cmd: "ALLOCSET", var: 1, buff: bScalars });
      task.push({ cmd: "ALLOC", var: 2, len: arr.length * sGmid });
      pB = 0;
      pS = 0;
      let pD = 0;
      for (let i2 = 0; i2 < arr.length; i2++) {
        if (!arr[i2]) {
          task.push({ cmd: "CALL", fnName: fnZero, params: [
            { var: 2, offset: pD }
          ] });
          pD += sGmid;
          continue;
        }
        if (arr[i2].length == 1) {
          task.push({ cmd: "CALL", fnName: fnExp, params: [
            { var: 0, offset: pB },
            { var: 1, offset: pS },
            { val: curve2.Fr.n8 },
            { var: 2, offset: pD }
          ] });
        } else {
          task.push({ cmd: "CALL", fnName: fnMultiExp, params: [
            { var: 0, offset: pB },
            { var: 1, offset: pS },
            { val: curve2.Fr.n8 },
            { val: arr[i2].length },
            { var: 2, offset: pD }
          ] });
        }
        pB += sGin * arr[i2].length;
        pS += curve2.Fr.n8 * arr[i2].length;
        pD += sGmid;
      }
      task.push({ cmd: "CALL", fnName: fnBatchToAffine, params: [
        { var: 2 },
        { val: arr.length },
        { var: 2 }
      ] });
      task.push({ cmd: "GET", out: 0, var: 2, len: arr.length * sGout });
      const res = await curve2.tm.queueAction(task);
      return res;
    } else {
      let res = await G2.multiExpAffine(bBases, bScalars, logger2, sectionName);
      res = [G2.toAffine(res)];
      return res;
    }
  }
  async function hashHPoints() {
    const CHUNK_SIZE = 1 << 14;
    hashU32(domainSize - 1);
    for (let i2 = 0; i2 < domainSize - 1; i2 += CHUNK_SIZE) {
      if (logger) logger.debug(`HashingHPoints: ${i2}/${domainSize}`);
      const n = Math.min(domainSize - 1, CHUNK_SIZE);
      await hashHPointsChunk(i2, n);
    }
  }
  async function hashHPointsChunk(offset, nPoints) {
    const buff1 = await fdPTau.read(nPoints * sG1, sectionsPTau[2][0].p + (offset + domainSize) * sG1);
    const buff2 = await fdPTau.read(nPoints * sG1, sectionsPTau[2][0].p + offset * sG1);
    const concurrency = curve2.tm.concurrency;
    const nPointsPerThread = Math.floor(nPoints / concurrency);
    const opPromises = [];
    for (let i2 = 0; i2 < concurrency; i2++) {
      let n;
      if (i2 < concurrency - 1) {
        n = nPointsPerThread;
      } else {
        n = nPoints - i2 * nPointsPerThread;
      }
      if (n == 0) continue;
      const subBuff1 = buff1.slice(i2 * nPointsPerThread * sG1, (i2 * nPointsPerThread + n) * sG1);
      const subBuff2 = buff2.slice(i2 * nPointsPerThread * sG1, (i2 * nPointsPerThread + n) * sG1);
      opPromises.push(hashHPointsThread(subBuff1, subBuff2));
    }
    const result = await Promise.all(opPromises);
    for (let i2 = 0; i2 < result.length; i2++) {
      csHasher.update(result[i2][0]);
    }
  }
  async function hashHPointsThread(buff1, buff2) {
    const nPoints = buff1.byteLength / sG1;
    const sGmid = curve2.G1.F.n8 * 3;
    const task = [];
    task.push({ cmd: "ALLOCSET", var: 0, buff: buff1 });
    task.push({ cmd: "ALLOCSET", var: 1, buff: buff2 });
    task.push({ cmd: "ALLOC", var: 2, len: nPoints * sGmid });
    for (let i2 = 0; i2 < nPoints; i2++) {
      task.push({
        cmd: "CALL",
        fnName: "g1m_subAffine",
        params: [
          { var: 0, offset: i2 * sG1 },
          { var: 1, offset: i2 * sG1 },
          { var: 2, offset: i2 * sGmid }
        ]
      });
    }
    task.push({ cmd: "CALL", fnName: "g1m_batchToAffine", params: [
      { var: 2 },
      { val: nPoints },
      { var: 2 }
    ] });
    task.push({ cmd: "CALL", fnName: "g1m_batchLEMtoU", params: [
      { var: 2 },
      { val: nPoints },
      { var: 2 }
    ] });
    task.push({ cmd: "GET", out: 0, var: 2, len: nPoints * sG1 });
    const res = await curve2.tm.queueAction(task);
    return res;
  }
  function hashU32(n) {
    const buff = new Uint8Array(4);
    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
    buffV.setUint32(0, n, false);
    csHasher.update(buff);
  }
}
async function phase2exportMPCParams(zkeyName, mpcparamsName, logger) {
  const { fd: fdZKey, sections: sectionsZKey } = await readBinFile(zkeyName, "zkey", 2);
  const zkey2 = await readHeader$1(fdZKey, sectionsZKey);
  if (zkey2.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  const curve2 = await getCurveFromQ(zkey2.q);
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  const mpcParams = await readMPCParams(fdZKey, curve2, sectionsZKey);
  const fdMPCParams = await createOverride(mpcparamsName);
  await writeG12(zkey2.vk_alpha_1);
  await writeG12(zkey2.vk_beta_1);
  await writeG22(zkey2.vk_beta_2);
  await writeG22(zkey2.vk_gamma_2);
  await writeG12(zkey2.vk_delta_1);
  await writeG22(zkey2.vk_delta_2);
  let buffBasesIC;
  buffBasesIC = await readSection(fdZKey, sectionsZKey, 3);
  buffBasesIC = await curve2.G1.batchLEMtoU(buffBasesIC);
  await writePointArray("G1", buffBasesIC);
  const buffBasesH_Lodd = await readSection(fdZKey, sectionsZKey, 9);
  let buffBasesH_Tau;
  buffBasesH_Tau = await curve2.G1.fft(buffBasesH_Lodd, "affine", "jacobian", logger);
  buffBasesH_Tau = await curve2.G1.batchApplyKey(buffBasesH_Tau, curve2.Fr.neg(curve2.Fr.e(2)), curve2.Fr.w[zkey2.power + 1], "jacobian", "affine", logger);
  buffBasesH_Tau = buffBasesH_Tau.slice(0, buffBasesH_Tau.byteLength - sG1);
  buffBasesH_Tau = await curve2.G1.batchLEMtoU(buffBasesH_Tau);
  await writePointArray("G1", buffBasesH_Tau);
  let buffBasesC;
  buffBasesC = await readSection(fdZKey, sectionsZKey, 8);
  buffBasesC = await curve2.G1.batchLEMtoU(buffBasesC);
  await writePointArray("G1", buffBasesC);
  let buffBasesA;
  buffBasesA = await readSection(fdZKey, sectionsZKey, 5);
  buffBasesA = await curve2.G1.batchLEMtoU(buffBasesA);
  await writePointArray("G1", buffBasesA);
  let buffBasesB1;
  buffBasesB1 = await readSection(fdZKey, sectionsZKey, 6);
  buffBasesB1 = await curve2.G1.batchLEMtoU(buffBasesB1);
  await writePointArray("G1", buffBasesB1);
  let buffBasesB2;
  buffBasesB2 = await readSection(fdZKey, sectionsZKey, 7);
  buffBasesB2 = await curve2.G2.batchLEMtoU(buffBasesB2);
  await writePointArray("G2", buffBasesB2);
  await fdMPCParams.write(mpcParams.csHash);
  await writeU32(mpcParams.contributions.length);
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    const c2 = mpcParams.contributions[i2];
    await writeG12(c2.deltaAfter);
    await writeG12(c2.delta.g1_s);
    await writeG12(c2.delta.g1_sx);
    await writeG22(c2.delta.g2_spx);
    await fdMPCParams.write(c2.transcript);
  }
  await fdZKey.close();
  await fdMPCParams.close();
  async function writeG12(P2) {
    const buff = new Uint8Array(sG1);
    curve2.G1.toRprUncompressed(buff, 0, P2);
    await fdMPCParams.write(buff);
  }
  async function writeG22(P2) {
    const buff = new Uint8Array(sG2);
    curve2.G2.toRprUncompressed(buff, 0, P2);
    await fdMPCParams.write(buff);
  }
  async function writePointArray(groupName, buff) {
    let sG;
    if (groupName == "G1") {
      sG = sG1;
    } else {
      sG = sG2;
    }
    const buffSize = new Uint8Array(4);
    const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);
    buffSizeV.setUint32(0, buff.byteLength / sG, false);
    await fdMPCParams.write(buffSize);
    await fdMPCParams.write(buff);
  }
  async function writeU32(n) {
    const buffSize = new Uint8Array(4);
    const buffSizeV = new DataView(buffSize.buffer, buffSize.byteOffset, buffSize.byteLength);
    buffSizeV.setUint32(0, n, false);
    await fdMPCParams.write(buffSize);
  }
}
async function phase2importMPCParams(zkeyNameOld, mpcparamsName, zkeyNameNew, name, logger) {
  const { fd: fdZKeyOld, sections: sectionsZKeyOld } = await readBinFile(zkeyNameOld, "zkey", 2);
  const zkeyHeader = await readHeader$1(fdZKeyOld, sectionsZKeyOld, false);
  if (zkeyHeader.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  const curve2 = await getCurveFromQ(zkeyHeader.q);
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  const oldMPCParams = await readMPCParams(fdZKeyOld, curve2, sectionsZKeyOld);
  const newMPCParams = {};
  const fdMPCParams = await readExisting(mpcparamsName);
  fdMPCParams.pos = sG1 * 3 + sG2 * 3 + // vKey
  8 + sG1 * zkeyHeader.nVars + // IC + C
  4 + sG1 * (zkeyHeader.domainSize - 1) + // H
  4 + sG1 * zkeyHeader.nVars + // A
  4 + sG1 * zkeyHeader.nVars + // B1
  4 + sG2 * zkeyHeader.nVars;
  newMPCParams.csHash = await fdMPCParams.read(64);
  const nConttributions = await fdMPCParams.readUBE32();
  newMPCParams.contributions = [];
  for (let i2 = 0; i2 < nConttributions; i2++) {
    const c2 = { delta: {} };
    c2.deltaAfter = await readG12(fdMPCParams);
    c2.delta.g1_s = await readG12(fdMPCParams);
    c2.delta.g1_sx = await readG12(fdMPCParams);
    c2.delta.g2_spx = await readG22(fdMPCParams);
    c2.transcript = await fdMPCParams.read(64);
    if (i2 < oldMPCParams.contributions.length) {
      c2.type = oldMPCParams.contributions[i2].type;
      if (c2.type == 1) {
        c2.beaconHash = oldMPCParams.contributions[i2].beaconHash;
        c2.numIterationsExp = oldMPCParams.contributions[i2].numIterationsExp;
      }
      if (oldMPCParams.contributions[i2].name) {
        c2.name = oldMPCParams.contributions[i2].name;
      }
    }
    newMPCParams.contributions.push(c2);
  }
  if (!hashIsEqual(newMPCParams.csHash, oldMPCParams.csHash)) {
    if (logger) logger.error("Hash of the original circuit does not match with the MPC one");
    return false;
  }
  if (oldMPCParams.contributions.length > newMPCParams.contributions.length) {
    if (logger) logger.error("The impoerted file does not include new contributions");
    return false;
  }
  for (let i2 = 0; i2 < oldMPCParams.contributions.length; i2++) {
    if (!contributionIsEqual(oldMPCParams.contributions[i2], newMPCParams.contributions[i2])) {
      if (logger) logger.error(`Previos contribution ${i2} does not match`);
      return false;
    }
  }
  if (name) {
    for (let i2 = oldMPCParams.contributions.length; i2 < newMPCParams.contributions.length; i2++) {
      newMPCParams.contributions[i2].name = name;
    }
  }
  const fdZKeyNew = await createBinFile(zkeyNameNew, "zkey", 1, 10);
  fdMPCParams.pos = 0;
  fdMPCParams.pos += sG1;
  fdMPCParams.pos += sG1;
  fdMPCParams.pos += sG2;
  fdMPCParams.pos += sG2;
  zkeyHeader.vk_delta_1 = await readG12(fdMPCParams);
  zkeyHeader.vk_delta_2 = await readG22(fdMPCParams);
  await writeHeader(fdZKeyNew, zkeyHeader);
  const nIC = await fdMPCParams.readUBE32();
  if (nIC != zkeyHeader.nPublic + 1) {
    if (logger) logger.error("Invalid number of points in IC");
    await fdZKeyNew.discard();
    return false;
  }
  fdMPCParams.pos += sG1 * (zkeyHeader.nPublic + 1);
  await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 3);
  await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 4);
  const nH = await fdMPCParams.readUBE32();
  if (nH != zkeyHeader.domainSize - 1) {
    if (logger) logger.error("Invalid number of points in H");
    await fdZKeyNew.discard();
    return false;
  }
  let buffH;
  const buffTauU = await fdMPCParams.read(sG1 * (zkeyHeader.domainSize - 1));
  const buffTauLEM = await curve2.G1.batchUtoLEM(buffTauU);
  buffH = new Uint8Array(zkeyHeader.domainSize * sG1);
  buffH.set(buffTauLEM);
  curve2.G1.toRprLEM(buffH, sG1 * (zkeyHeader.domainSize - 1), curve2.G1.zeroAffine);
  const n2Inv = curve2.Fr.neg(curve2.Fr.inv(curve2.Fr.e(2)));
  const wInv = curve2.Fr.inv(curve2.Fr.w[zkeyHeader.power + 1]);
  buffH = await curve2.G1.batchApplyKey(buffH, n2Inv, wInv, "affine", "jacobian", logger);
  buffH = await curve2.G1.ifft(buffH, "jacobian", "affine", logger);
  await startWriteSection(fdZKeyNew, 9);
  await fdZKeyNew.write(buffH);
  await endWriteSection(fdZKeyNew);
  const nL = await fdMPCParams.readUBE32();
  if (nL != zkeyHeader.nVars - zkeyHeader.nPublic - 1) {
    if (logger) logger.error("Invalid number of points in L");
    await fdZKeyNew.discard();
    return false;
  }
  let buffL;
  buffL = await fdMPCParams.read(sG1 * (zkeyHeader.nVars - zkeyHeader.nPublic - 1));
  buffL = await curve2.G1.batchUtoLEM(buffL);
  await startWriteSection(fdZKeyNew, 8);
  await fdZKeyNew.write(buffL);
  await endWriteSection(fdZKeyNew);
  const nA = await fdMPCParams.readUBE32();
  if (nA != zkeyHeader.nVars) {
    if (logger) logger.error("Invalid number of points in A");
    await fdZKeyNew.discard();
    return false;
  }
  fdMPCParams.pos += sG1 * zkeyHeader.nVars;
  await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 5);
  const nB1 = await fdMPCParams.readUBE32();
  if (nB1 != zkeyHeader.nVars) {
    if (logger) logger.error("Invalid number of points in B1");
    await fdZKeyNew.discard();
    return false;
  }
  fdMPCParams.pos += sG1 * zkeyHeader.nVars;
  await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 6);
  const nB2 = await fdMPCParams.readUBE32();
  if (nB2 != zkeyHeader.nVars) {
    if (logger) logger.error("Invalid number of points in B2");
    await fdZKeyNew.discard();
    return false;
  }
  fdMPCParams.pos += sG2 * zkeyHeader.nVars;
  await copySection(fdZKeyOld, sectionsZKeyOld, fdZKeyNew, 7);
  await writeMPCParams(fdZKeyNew, curve2, newMPCParams);
  await fdMPCParams.close();
  await fdZKeyNew.close();
  await fdZKeyOld.close();
  return true;
  async function readG12(fd) {
    const buff = await fd.read(curve2.G1.F.n8 * 2);
    return curve2.G1.fromRprUncompressed(buff, 0);
  }
  async function readG22(fd) {
    const buff = await fd.read(curve2.G2.F.n8 * 2);
    return curve2.G2.fromRprUncompressed(buff, 0);
  }
  function contributionIsEqual(c1, c2) {
    if (!curve2.G1.eq(c1.deltaAfter, c2.deltaAfter)) return false;
    if (!curve2.G1.eq(c1.delta.g1_s, c2.delta.g1_s)) return false;
    if (!curve2.G1.eq(c1.delta.g1_sx, c2.delta.g1_sx)) return false;
    if (!curve2.G2.eq(c1.delta.g2_spx, c2.delta.g2_spx)) return false;
    if (!hashIsEqual(c1.transcript, c2.transcript)) return false;
    return true;
  }
}
async function phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger) {
  let sr;
  await blake2bWasm.exports.ready();
  const { fd, sections } = await readBinFile(zkeyFileName, "zkey", 2);
  const zkey2 = await readHeader$1(fd, sections, false);
  if (zkey2.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  const curve2 = await getCurveFromQ(zkey2.q);
  const sG1 = curve2.G1.F.n8 * 2;
  const mpcParams = await readMPCParams(fd, curve2, sections);
  const accumulatedHasher = blake2bWasm.exports(64);
  accumulatedHasher.update(mpcParams.csHash);
  let curDelta = curve2.G1.g;
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    const c2 = mpcParams.contributions[i2];
    const ourHasher = cloneHasher(accumulatedHasher);
    hashG1(ourHasher, curve2, c2.delta.g1_s);
    hashG1(ourHasher, curve2, c2.delta.g1_sx);
    if (!hashIsEqual(ourHasher.digest(), c2.transcript)) {
      console.log(`INVALID(${i2}): Inconsistent transcript `);
      return false;
    }
    const delta_g2_sp = hashToG2(curve2, c2.transcript);
    sr = await sameRatio(curve2, c2.delta.g1_s, c2.delta.g1_sx, delta_g2_sp, c2.delta.g2_spx);
    if (sr !== true) {
      console.log(`INVALID(${i2}): public key G1 and G2 do not have the same ration `);
      return false;
    }
    sr = await sameRatio(curve2, curDelta, c2.deltaAfter, delta_g2_sp, c2.delta.g2_spx);
    if (sr !== true) {
      console.log(`INVALID(${i2}): deltaAfter does not fillow the public key `);
      return false;
    }
    if (c2.type == 1) {
      const rng = await rngFromBeaconParams(c2.beaconHash, c2.numIterationsExp);
      const expected_prvKey = curve2.Fr.fromRng(rng);
      const expected_g1_s = curve2.G1.toAffine(curve2.G1.fromRng(rng));
      const expected_g1_sx = curve2.G1.toAffine(curve2.G1.timesFr(expected_g1_s, expected_prvKey));
      if (curve2.G1.eq(expected_g1_s, c2.delta.g1_s) !== true) {
        console.log(`INVALID(${i2}): Key of the beacon does not match. g1_s `);
        return false;
      }
      if (curve2.G1.eq(expected_g1_sx, c2.delta.g1_sx) !== true) {
        console.log(`INVALID(${i2}): Key of the beacon does not match. g1_sx `);
        return false;
      }
    }
    hashPubKey(accumulatedHasher, curve2, c2);
    const contributionHasher = blake2bWasm.exports(64);
    hashPubKey(contributionHasher, curve2, c2);
    c2.contributionHash = contributionHasher.digest();
    curDelta = c2.deltaAfter;
  }
  const { fd: fdInit, sections: sectionsInit } = await readBinFile(initFileName, "zkey", 2);
  const zkeyInit = await readHeader$1(fdInit, sectionsInit, false);
  if (zkeyInit.protocol != "groth16") {
    throw new Error("zkeyinit file is not groth16");
  }
  if (!Scalar.eq(zkeyInit.q, zkey2.q) || !Scalar.eq(zkeyInit.r, zkey2.r) || zkeyInit.n8q != zkey2.n8q || zkeyInit.n8r != zkey2.n8r) {
    if (logger) logger.error("INVALID:  Different curves");
    return false;
  }
  if (zkeyInit.nVars != zkey2.nVars || zkeyInit.nPublic != zkey2.nPublic || zkeyInit.domainSize != zkey2.domainSize) {
    if (logger) logger.error("INVALID:  Different circuit parameters");
    return false;
  }
  if (!curve2.G1.eq(zkey2.vk_alpha_1, zkeyInit.vk_alpha_1)) {
    if (logger) logger.error("INVALID:  Invalid alpha1");
    return false;
  }
  if (!curve2.G1.eq(zkey2.vk_beta_1, zkeyInit.vk_beta_1)) {
    if (logger) logger.error("INVALID:  Invalid beta1");
    return false;
  }
  if (!curve2.G2.eq(zkey2.vk_beta_2, zkeyInit.vk_beta_2)) {
    if (logger) logger.error("INVALID:  Invalid beta2");
    return false;
  }
  if (!curve2.G2.eq(zkey2.vk_gamma_2, zkeyInit.vk_gamma_2)) {
    if (logger) logger.error("INVALID:  Invalid gamma2");
    return false;
  }
  if (!curve2.G1.eq(zkey2.vk_delta_1, curDelta)) {
    if (logger) logger.error("INVALID:  Invalid delta1");
    return false;
  }
  sr = await sameRatio(curve2, curve2.G1.g, curDelta, curve2.G2.g, zkey2.vk_delta_2);
  if (sr !== true) {
    if (logger) logger.error("INVALID:  Invalid delta2");
    return false;
  }
  const mpcParamsInit = await readMPCParams(fdInit, curve2, sectionsInit);
  if (!hashIsEqual(mpcParams.csHash, mpcParamsInit.csHash)) {
    if (logger) logger.error("INVALID:  Circuit does not match");
    return false;
  }
  if (sections[8][0].size != sG1 * (zkey2.nVars - zkey2.nPublic - 1)) {
    if (logger) logger.error("INVALID:  Invalid L section size");
    return false;
  }
  if (sections[9][0].size != sG1 * zkey2.domainSize) {
    if (logger) logger.error("INVALID:  Invalid H section size");
    return false;
  }
  let ss;
  ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 3);
  if (!ss) {
    if (logger) logger.error("INVALID:  IC section is not identical");
    return false;
  }
  ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 4);
  if (!ss) {
    if (logger) logger.error("Coeffs section is not identical");
    return false;
  }
  ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 5);
  if (!ss) {
    if (logger) logger.error("A section is not identical");
    return false;
  }
  ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 6);
  if (!ss) {
    if (logger) logger.error("B1 section is not identical");
    return false;
  }
  ss = await sectionIsEqual(fd, sections, fdInit, sectionsInit, 7);
  if (!ss) {
    if (logger) logger.error("B2 section is not identical");
    return false;
  }
  sr = await sectionHasSameRatio("G1", fdInit, sectionsInit, fd, sections, 8, zkey2.vk_delta_2, zkeyInit.vk_delta_2, "L section");
  if (sr !== true) {
    if (logger) logger.error("L section does not match");
    return false;
  }
  sr = await sameRatioH();
  if (sr !== true) {
    if (logger) logger.error("H section does not match");
    return false;
  }
  if (logger) logger.info(formatHash(mpcParams.csHash, "Circuit Hash: "));
  await fd.close();
  await fdInit.close();
  for (let i2 = mpcParams.contributions.length - 1; i2 >= 0; i2--) {
    const c2 = mpcParams.contributions[i2];
    if (logger) logger.info("-------------------------");
    if (logger) logger.info(formatHash(c2.contributionHash, `contribution #${i2 + 1} ${c2.name ? c2.name : ""}:`));
    if (c2.type == 1) {
      if (logger) logger.info(`Beacon generator: ${byteArray2hex(c2.beaconHash)}`);
      if (logger) logger.info(`Beacon iterations Exp: ${c2.numIterationsExp}`);
    }
  }
  if (logger) logger.info("-------------------------");
  if (logger) logger.info("ZKey Ok!");
  return true;
  async function sectionHasSameRatio(groupName, fd1, sections1, fd2, sections2, idSection, g2sp, g2spx, sectionName) {
    const MAX_CHUNK_SIZE = 1 << 20;
    const G2 = curve2[groupName];
    const sG = G2.F.n8 * 2;
    await startReadUniqueSection(fd1, sections1, idSection);
    await startReadUniqueSection(fd2, sections2, idSection);
    let R1 = G2.zero;
    let R2 = G2.zero;
    const nPoints = sections1[idSection][0].size / sG;
    for (let i2 = 0; i2 < nPoints; i2 += MAX_CHUNK_SIZE) {
      if (logger) logger.debug(`Same ratio check ${sectionName}:  ${i2}/${nPoints}`);
      const n = Math.min(nPoints - i2, MAX_CHUNK_SIZE);
      const bases1 = await fd1.read(n * sG);
      const bases2 = await fd2.read(n * sG);
      const scalars = getRandomBytes2(4 * n);
      const r1 = await G2.multiExpAffine(bases1, scalars);
      const r2 = await G2.multiExpAffine(bases2, scalars);
      R1 = G2.add(R1, r1);
      R2 = G2.add(R2, r2);
    }
    await endReadSection(fd1);
    await endReadSection(fd2);
    if (nPoints == 0) return true;
    sr = await sameRatio(curve2, R1, R2, g2sp, g2spx);
    if (sr !== true) return false;
    return true;
  }
  async function sameRatioH() {
    const MAX_CHUNK_SIZE = 1 << 20;
    const G2 = curve2.G1;
    const Fr = curve2.Fr;
    const sG = G2.F.n8 * 2;
    const { fd: fdPTau, sections: sectionsPTau } = await readBinFile(pTauFileName, "ptau", 1);
    let buff_r = new BigBuffer(zkey2.domainSize * zkey2.n8r);
    const seed = new Array(8);
    for (let i2 = 0; i2 < 8; i2++) {
      seed[i2] = readUInt32BE(getRandomBytes2(4), 0);
    }
    const rng = new ChaCha(seed);
    for (let i2 = 0; i2 < zkey2.domainSize - 1; i2++) {
      const e2 = Fr.fromRng(rng);
      Fr.toRprLE(buff_r, i2 * zkey2.n8r, e2);
    }
    Fr.toRprLE(buff_r, (zkey2.domainSize - 1) * zkey2.n8r, Fr.zero);
    let R1 = G2.zero;
    for (let i2 = 0; i2 < zkey2.domainSize; i2 += MAX_CHUNK_SIZE) {
      if (logger) logger.debug(`H Verificaition(tau):  ${i2}/${zkey2.domainSize}`);
      const n = Math.min(zkey2.domainSize - i2, MAX_CHUNK_SIZE);
      const buff1 = await fdPTau.read(sG * n, sectionsPTau[2][0].p + zkey2.domainSize * sG + i2 * sG);
      const buff2 = await fdPTau.read(sG * n, sectionsPTau[2][0].p + i2 * sG);
      const buffB = await batchSubstract(buff1, buff2);
      const buffS = buff_r.slice(i2 * zkey2.n8r, (i2 + n) * zkey2.n8r);
      const r2 = await G2.multiExpAffine(buffB, buffS);
      R1 = G2.add(R1, r2);
    }
    buff_r = await Fr.batchToMontgomery(buff_r);
    let first;
    if (zkey2.power < Fr.s) {
      first = Fr.neg(Fr.e(2));
    } else {
      const small_m = 2 ** Fr.s;
      const shift_to_small_m = Fr.exp(Fr.shift, small_m);
      first = Fr.sub(shift_to_small_m, Fr.one);
    }
    const inc = zkey2.power < Fr.s ? Fr.w[zkey2.power + 1] : Fr.shift;
    buff_r = await Fr.batchApplyKey(buff_r, first, inc);
    buff_r = await Fr.fft(buff_r);
    buff_r = await Fr.batchFromMontgomery(buff_r);
    await startReadUniqueSection(fd, sections, 9);
    let R2 = G2.zero;
    for (let i2 = 0; i2 < zkey2.domainSize; i2 += MAX_CHUNK_SIZE) {
      if (logger) logger.debug(`H Verificaition(lagrange):  ${i2}/${zkey2.domainSize}`);
      const n = Math.min(zkey2.domainSize - i2, MAX_CHUNK_SIZE);
      const buff = await fd.read(sG * n);
      const buffS = buff_r.slice(i2 * zkey2.n8r, (i2 + n) * zkey2.n8r);
      const r2 = await G2.multiExpAffine(buff, buffS);
      R2 = G2.add(R2, r2);
    }
    await endReadSection(fd);
    sr = await sameRatio(curve2, R1, R2, zkey2.vk_delta_2, zkeyInit.vk_delta_2);
    if (sr !== true) return false;
    return true;
  }
  async function batchSubstract(buff1, buff2) {
    const sG = curve2.G1.F.n8 * 2;
    const nPoints = buff1.byteLength / sG;
    const concurrency = curve2.tm.concurrency;
    const nPointsPerThread = Math.floor(nPoints / concurrency);
    const opPromises = [];
    for (let i2 = 0; i2 < concurrency; i2++) {
      let n;
      if (i2 < concurrency - 1) {
        n = nPointsPerThread;
      } else {
        n = nPoints - i2 * nPointsPerThread;
      }
      if (n == 0) continue;
      const subBuff1 = buff1.slice(i2 * nPointsPerThread * sG1, (i2 * nPointsPerThread + n) * sG1);
      const subBuff2 = buff2.slice(i2 * nPointsPerThread * sG1, (i2 * nPointsPerThread + n) * sG1);
      opPromises.push(batchSubstractThread(subBuff1, subBuff2));
    }
    const result = await Promise.all(opPromises);
    const fullBuffOut = new Uint8Array(nPoints * sG);
    let p2 = 0;
    for (let i2 = 0; i2 < result.length; i2++) {
      fullBuffOut.set(result[i2][0], p2);
      p2 += result[i2][0].byteLength;
    }
    return fullBuffOut;
  }
  async function batchSubstractThread(buff1, buff2) {
    const sG12 = curve2.G1.F.n8 * 2;
    const sGmid = curve2.G1.F.n8 * 3;
    const nPoints = buff1.byteLength / sG12;
    const task = [];
    task.push({ cmd: "ALLOCSET", var: 0, buff: buff1 });
    task.push({ cmd: "ALLOCSET", var: 1, buff: buff2 });
    task.push({ cmd: "ALLOC", var: 2, len: nPoints * sGmid });
    for (let i2 = 0; i2 < nPoints; i2++) {
      task.push({
        cmd: "CALL",
        fnName: "g1m_subAffine",
        params: [
          { var: 0, offset: i2 * sG12 },
          { var: 1, offset: i2 * sG12 },
          { var: 2, offset: i2 * sGmid }
        ]
      });
    }
    task.push({ cmd: "CALL", fnName: "g1m_batchToAffine", params: [
      { var: 2 },
      { val: nPoints },
      { var: 2 }
    ] });
    task.push({ cmd: "GET", out: 0, var: 2, len: nPoints * sG12 });
    const res = await curve2.tm.queueAction(task);
    return res;
  }
}
async function phase2verifyFromR1cs(r1csFileName, pTauFileName, zkeyFileName, logger) {
  const initFileName = { type: "bigMem" };
  await newZKey(r1csFileName, pTauFileName, initFileName, logger);
  return await phase2verifyFromInit(initFileName, pTauFileName, zkeyFileName, logger);
}
async function phase2contribute(zkeyNameOld, zkeyNameNew, name, entropy, logger) {
  await blake2bWasm.exports.ready();
  const { fd: fdOld, sections } = await readBinFile(zkeyNameOld, "zkey", 2);
  const zkey2 = await readHeader$1(fdOld, sections);
  if (zkey2.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  const curve2 = await getCurveFromQ(zkey2.q);
  const mpcParams = await readMPCParams(fdOld, curve2, sections);
  const fdNew = await createBinFile(zkeyNameNew, "zkey", 1, 10);
  const rng = await getRandomRng(entropy);
  const transcriptHasher = blake2bWasm.exports(64);
  transcriptHasher.update(mpcParams.csHash);
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    hashPubKey(transcriptHasher, curve2, mpcParams.contributions[i2]);
  }
  const curContribution = {};
  curContribution.delta = {};
  curContribution.delta.prvKey = curve2.Fr.fromRng(rng);
  curContribution.delta.g1_s = curve2.G1.toAffine(curve2.G1.fromRng(rng));
  curContribution.delta.g1_sx = curve2.G1.toAffine(curve2.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_s);
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_sx);
  curContribution.transcript = transcriptHasher.digest();
  curContribution.delta.g2_sp = hashToG2(curve2, curContribution.transcript);
  curContribution.delta.g2_spx = curve2.G2.toAffine(curve2.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));
  zkey2.vk_delta_1 = curve2.G1.timesFr(zkey2.vk_delta_1, curContribution.delta.prvKey);
  zkey2.vk_delta_2 = curve2.G2.timesFr(zkey2.vk_delta_2, curContribution.delta.prvKey);
  curContribution.deltaAfter = zkey2.vk_delta_1;
  curContribution.type = 0;
  if (name) curContribution.name = name;
  mpcParams.contributions.push(curContribution);
  await writeHeader(fdNew, zkey2);
  await copySection(fdOld, sections, fdNew, 3);
  await copySection(fdOld, sections, fdNew, 4);
  await copySection(fdOld, sections, fdNew, 5);
  await copySection(fdOld, sections, fdNew, 6);
  await copySection(fdOld, sections, fdNew, 7);
  const invDelta = curve2.Fr.inv(curContribution.delta.prvKey);
  await applyKeyToSection(fdOld, sections, fdNew, 8, curve2, "G1", invDelta, curve2.Fr.e(1), "L Section", logger);
  await applyKeyToSection(fdOld, sections, fdNew, 9, curve2, "G1", invDelta, curve2.Fr.e(1), "H Section", logger);
  await writeMPCParams(fdNew, curve2, mpcParams);
  await fdOld.close();
  await fdNew.close();
  const contributionHasher = blake2bWasm.exports(64);
  hashPubKey(contributionHasher, curve2, curContribution);
  const contribuionHash = contributionHasher.digest();
  if (logger) logger.info(formatHash(mpcParams.csHash, "Circuit Hash: "));
  if (logger) logger.info(formatHash(contribuionHash, "Contribution Hash: "));
  return contribuionHash;
}
async function beacon(zkeyNameOld, zkeyNameNew, name, beaconHashStr, numIterationsExp, logger) {
  await blake2bWasm.exports.ready();
  const beaconHash = hex2ByteArray(beaconHashStr);
  if (beaconHash.byteLength == 0 || beaconHash.byteLength * 2 != beaconHashStr.length) {
    if (logger) logger.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)");
    return false;
  }
  if (beaconHash.length >= 256) {
    if (logger) logger.error("Maximum lenght of beacon hash is 255 bytes");
    return false;
  }
  numIterationsExp = parseInt(numIterationsExp);
  if (numIterationsExp < 10 || numIterationsExp > 63) {
    if (logger) logger.error("Invalid numIterationsExp. (Must be between 10 and 63)");
    return false;
  }
  const { fd: fdOld, sections } = await readBinFile(zkeyNameOld, "zkey", 2);
  const zkey2 = await readHeader$1(fdOld, sections);
  if (zkey2.protocol != "groth16") {
    throw new Error("zkey file is not groth16");
  }
  const curve2 = await getCurveFromQ(zkey2.q);
  const mpcParams = await readMPCParams(fdOld, curve2, sections);
  const fdNew = await createBinFile(zkeyNameNew, "zkey", 1, 10);
  const rng = await rngFromBeaconParams(beaconHash, numIterationsExp);
  const transcriptHasher = blake2bWasm.exports(64);
  transcriptHasher.update(mpcParams.csHash);
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    hashPubKey(transcriptHasher, curve2, mpcParams.contributions[i2]);
  }
  const curContribution = {};
  curContribution.delta = {};
  curContribution.delta.prvKey = curve2.Fr.fromRng(rng);
  curContribution.delta.g1_s = curve2.G1.toAffine(curve2.G1.fromRng(rng));
  curContribution.delta.g1_sx = curve2.G1.toAffine(curve2.G1.timesFr(curContribution.delta.g1_s, curContribution.delta.prvKey));
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_s);
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_sx);
  curContribution.transcript = transcriptHasher.digest();
  curContribution.delta.g2_sp = hashToG2(curve2, curContribution.transcript);
  curContribution.delta.g2_spx = curve2.G2.toAffine(curve2.G2.timesFr(curContribution.delta.g2_sp, curContribution.delta.prvKey));
  zkey2.vk_delta_1 = curve2.G1.timesFr(zkey2.vk_delta_1, curContribution.delta.prvKey);
  zkey2.vk_delta_2 = curve2.G2.timesFr(zkey2.vk_delta_2, curContribution.delta.prvKey);
  curContribution.deltaAfter = zkey2.vk_delta_1;
  curContribution.type = 1;
  curContribution.numIterationsExp = numIterationsExp;
  curContribution.beaconHash = beaconHash;
  if (name) curContribution.name = name;
  mpcParams.contributions.push(curContribution);
  await writeHeader(fdNew, zkey2);
  await copySection(fdOld, sections, fdNew, 3);
  await copySection(fdOld, sections, fdNew, 4);
  await copySection(fdOld, sections, fdNew, 5);
  await copySection(fdOld, sections, fdNew, 6);
  await copySection(fdOld, sections, fdNew, 7);
  const invDelta = curve2.Fr.inv(curContribution.delta.prvKey);
  await applyKeyToSection(fdOld, sections, fdNew, 8, curve2, "G1", invDelta, curve2.Fr.e(1), "L Section", logger);
  await applyKeyToSection(fdOld, sections, fdNew, 9, curve2, "G1", invDelta, curve2.Fr.e(1), "H Section", logger);
  await writeMPCParams(fdNew, curve2, mpcParams);
  await fdOld.close();
  await fdNew.close();
  const contributionHasher = blake2bWasm.exports(64);
  hashPubKey(contributionHasher, curve2, curContribution);
  const contribuionHash = contributionHasher.digest();
  if (logger) logger.info(formatHash(contribuionHash, "Contribution Hash: "));
  return contribuionHash;
}
async function zkeyExportJson(zkeyFileName) {
  const zKey = await readZKey(zkeyFileName, true);
  delete zKey.curve;
  delete zKey.F;
  return utils.stringifyBigInts(zKey);
}
async function bellmanContribute(curve2, challengeFilename, responesFileName, entropy, logger) {
  await blake2bWasm.exports.ready();
  const rng = await getRandomRng(entropy);
  const delta = curve2.Fr.fromRng(rng);
  const invDelta = curve2.Fr.inv(delta);
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  const fdFrom = await readExisting(challengeFilename);
  const fdTo = await createOverride(responesFileName);
  await copy2(sG1);
  await copy2(sG1);
  await copy2(sG2);
  await copy2(sG2);
  const oldDelta1 = await readG12();
  const delta1 = curve2.G1.timesFr(oldDelta1, delta);
  await writeG12(delta1);
  const oldDelta2 = await readG22();
  const delta2 = curve2.G2.timesFr(oldDelta2, delta);
  await writeG22(delta2);
  const nIC = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nIC);
  await copy2(nIC * sG1);
  const nH = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nH);
  await applyKeyToChallengeSection(fdFrom, fdTo, null, curve2, "G1", nH, invDelta, curve2.Fr.e(1), "UNCOMPRESSED", "H", logger);
  const nL = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nL);
  await applyKeyToChallengeSection(fdFrom, fdTo, null, curve2, "G1", nL, invDelta, curve2.Fr.e(1), "UNCOMPRESSED", "L", logger);
  const nA = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nA);
  await copy2(nA * sG1);
  const nB1 = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nB1);
  await copy2(nB1 * sG1);
  const nB2 = await fdFrom.readUBE32();
  await fdTo.writeUBE32(nB2);
  await copy2(nB2 * sG2);
  const transcriptHasher = blake2bWasm.exports(64);
  const mpcParams = {};
  mpcParams.csHash = await fdFrom.read(64);
  transcriptHasher.update(mpcParams.csHash);
  const nConttributions = await fdFrom.readUBE32();
  mpcParams.contributions = [];
  for (let i2 = 0; i2 < nConttributions; i2++) {
    const c2 = { delta: {} };
    c2.deltaAfter = await readG12();
    c2.delta.g1_s = await readG12();
    c2.delta.g1_sx = await readG12();
    c2.delta.g2_spx = await readG22();
    c2.transcript = await fdFrom.read(64);
    mpcParams.contributions.push(c2);
    hashPubKey(transcriptHasher, curve2, c2);
  }
  const curContribution = {};
  curContribution.delta = {};
  curContribution.delta.prvKey = delta;
  curContribution.delta.g1_s = curve2.G1.toAffine(curve2.G1.fromRng(rng));
  curContribution.delta.g1_sx = curve2.G1.toAffine(curve2.G1.timesFr(curContribution.delta.g1_s, delta));
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_s);
  hashG1(transcriptHasher, curve2, curContribution.delta.g1_sx);
  curContribution.transcript = transcriptHasher.digest();
  curContribution.delta.g2_sp = hashToG2(curve2, curContribution.transcript);
  curContribution.delta.g2_spx = curve2.G2.toAffine(curve2.G2.timesFr(curContribution.delta.g2_sp, delta));
  curContribution.deltaAfter = delta1;
  curContribution.type = 0;
  mpcParams.contributions.push(curContribution);
  await fdTo.write(mpcParams.csHash);
  await fdTo.writeUBE32(mpcParams.contributions.length);
  for (let i2 = 0; i2 < mpcParams.contributions.length; i2++) {
    const c2 = mpcParams.contributions[i2];
    await writeG12(c2.deltaAfter);
    await writeG12(c2.delta.g1_s);
    await writeG12(c2.delta.g1_sx);
    await writeG22(c2.delta.g2_spx);
    await fdTo.write(c2.transcript);
  }
  const contributionHasher = blake2bWasm.exports(64);
  hashPubKey(contributionHasher, curve2, curContribution);
  const contributionHash = contributionHasher.digest();
  if (logger) logger.info(formatHash(contributionHash, "Contribution Hash: "));
  await fdTo.close();
  await fdFrom.close();
  return contributionHash;
  async function copy2(nBytes) {
    const CHUNK_SIZE = fdFrom.pageSize * 2;
    for (let i2 = 0; i2 < nBytes; i2 += CHUNK_SIZE) {
      const n = Math.min(nBytes - i2, CHUNK_SIZE);
      const buff = await fdFrom.read(n);
      await fdTo.write(buff);
    }
  }
  async function readG12() {
    const buff = await fdFrom.read(curve2.G1.F.n8 * 2);
    return curve2.G1.fromRprUncompressed(buff, 0);
  }
  async function readG22() {
    const buff = await fdFrom.read(curve2.G2.F.n8 * 2);
    return curve2.G2.fromRprUncompressed(buff, 0);
  }
  async function writeG12(P2) {
    const buff = new Uint8Array(sG1);
    curve2.G1.toRprUncompressed(buff, 0, P2);
    await fdTo.write(buff);
  }
  async function writeG22(P2) {
    const buff = new Uint8Array(sG2);
    curve2.G2.toRprUncompressed(buff, 0, P2);
    await fdTo.write(buff);
  }
}
async function zkeyExportVerificationKey(zkeyName, logger) {
  if (logger) logger.info("EXPORT VERIFICATION KEY STARTED");
  const { fd, sections } = await readBinFile(zkeyName, "zkey", 2);
  const zkey2 = await readHeader$1(fd, sections);
  if (logger) logger.info("> Detected protocol: " + zkey2.protocol);
  let res;
  if (zkey2.protocol === "groth16") {
    res = await groth16Vk(zkey2, fd, sections);
  } else if (zkey2.protocol === "plonk") {
    res = await plonkVk(zkey2);
  } else if (zkey2.protocolId && zkey2.protocolId === FFLONK_PROTOCOL_ID) {
    res = await exportFFlonkVk(zkey2);
  } else {
    throw new Error("zkey file protocol unrecognized");
  }
  await fd.close();
  if (logger) logger.info("EXPORT VERIFICATION KEY FINISHED");
  return res;
}
async function groth16Vk(zkey2, fd, sections) {
  const curve2 = await getCurveFromQ(zkey2.q);
  const sG1 = curve2.G1.F.n8 * 2;
  const alphaBeta = await curve2.pairing(zkey2.vk_alpha_1, zkey2.vk_beta_2);
  let vKey = {
    protocol: zkey2.protocol,
    curve: curve2.name,
    nPublic: zkey2.nPublic,
    vk_alpha_1: curve2.G1.toObject(zkey2.vk_alpha_1),
    vk_beta_2: curve2.G2.toObject(zkey2.vk_beta_2),
    vk_gamma_2: curve2.G2.toObject(zkey2.vk_gamma_2),
    vk_delta_2: curve2.G2.toObject(zkey2.vk_delta_2),
    vk_alphabeta_12: curve2.Gt.toObject(alphaBeta)
  };
  await startReadUniqueSection(fd, sections, 3);
  vKey.IC = [];
  for (let i2 = 0; i2 <= zkey2.nPublic; i2++) {
    const buff = await fd.read(sG1);
    const P2 = curve2.G1.toObject(buff);
    vKey.IC.push(P2);
  }
  await endReadSection(fd);
  vKey = stringifyBigInts$3(vKey);
  return vKey;
}
async function plonkVk(zkey2) {
  const curve2 = await getCurveFromQ(zkey2.q);
  let vKey = {
    protocol: zkey2.protocol,
    curve: curve2.name,
    nPublic: zkey2.nPublic,
    power: zkey2.power,
    k1: curve2.Fr.toObject(zkey2.k1),
    k2: curve2.Fr.toObject(zkey2.k2),
    Qm: curve2.G1.toObject(zkey2.Qm),
    Ql: curve2.G1.toObject(zkey2.Ql),
    Qr: curve2.G1.toObject(zkey2.Qr),
    Qo: curve2.G1.toObject(zkey2.Qo),
    Qc: curve2.G1.toObject(zkey2.Qc),
    S1: curve2.G1.toObject(zkey2.S1),
    S2: curve2.G1.toObject(zkey2.S2),
    S3: curve2.G1.toObject(zkey2.S3),
    X_2: curve2.G2.toObject(zkey2.X_2),
    w: curve2.Fr.toObject(curve2.Fr.w[zkey2.power])
  };
  vKey = stringifyBigInts$3(vKey);
  return vKey;
}
async function exportFFlonkVk(zkey2, logger) {
  const curve2 = await getCurveFromQ(zkey2.q);
  let vKey = {
    protocol: zkey2.protocol,
    curve: curve2.name,
    nPublic: zkey2.nPublic,
    power: zkey2.power,
    k1: curve2.Fr.toObject(zkey2.k1),
    k2: curve2.Fr.toObject(zkey2.k2),
    w: curve2.Fr.toObject(curve2.Fr.w[zkey2.power]),
    //wW: curve.Fr.toObject(curve.Fr.w[zkey.power + 1]),
    w3: curve2.Fr.toObject(zkey2.w3),
    w4: curve2.Fr.toObject(zkey2.w4),
    w8: curve2.Fr.toObject(zkey2.w8),
    wr: curve2.Fr.toObject(zkey2.wr),
    X_2: curve2.G2.toObject(zkey2.X_2),
    C0: curve2.G1.toObject(zkey2.C0)
  };
  return stringifyBigInts$3(vKey);
}
async function fflonkExportSolidityVerifier(vk, templates, logger) {
  if (logger) logger.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");
  const curve2 = await getCurveFromName(vk.curve);
  let w3 = fromVkey(vk.w3);
  vk.w3_2 = toVkey(curve2.Fr.square(w3));
  let w4 = fromVkey(vk.w4);
  vk.w4_2 = toVkey(curve2.Fr.square(w4));
  vk.w4_3 = toVkey(curve2.Fr.mul(curve2.Fr.square(w4), w4));
  let w8 = fromVkey(vk.w8);
  let acc = curve2.Fr.one;
  for (let i2 = 1; i2 < 8; i2++) {
    acc = curve2.Fr.mul(acc, w8);
    vk["w8_" + i2] = toVkey(acc);
  }
  let template = templates[vk.protocol];
  if (logger) logger.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED");
  return ejs.render(template, vk);
  function fromVkey(str) {
    const val = unstringifyBigInts$6(str);
    return curve2.Fr.fromObject(val);
  }
  function toVkey(val) {
    const str = curve2.Fr.toObject(val);
    return stringifyBigInts$2(str);
  }
}
async function exportSolidityVerifier(zKeyName, templates, logger) {
  const verificationKey = await zkeyExportVerificationKey(zKeyName, logger);
  if ("fflonk" === verificationKey.protocol) {
    return fflonkExportSolidityVerifier(verificationKey, templates, logger);
  }
  let template = templates[verificationKey.protocol];
  return ejs.render(template, verificationKey);
}
async function plonkSetup(r1csName, ptauName, zkeyName, logger) {
  if (globalThis.gc) {
    globalThis.gc();
  }
  await blake2bWasm.exports.ready();
  const { fd: fdPTau, sections: sectionsPTau } = await readBinFile(ptauName, "ptau", 1);
  const { curve: curve2, power } = await readPTauHeader(fdPTau, sectionsPTau);
  const { fd: fdR1cs, sections: sectionsR1cs } = await readBinFile(r1csName, "r1cs", 1);
  const r1cs2 = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: true, loadCustomGates: true });
  const sG1 = curve2.G1.F.n8 * 2;
  const G1 = curve2.G1;
  const sG2 = curve2.G2.F.n8 * 2;
  const Fr = curve2.Fr;
  const n8r = curve2.Fr.n8;
  if (logger) logger.info("Reading r1cs");
  await readSection(fdR1cs, sectionsR1cs, 2);
  const plonkConstraints = new BigArray$1();
  const plonkAdditions = new BigArray$1();
  let plonkNVars = r1cs2.nVars;
  const nPublic = r1cs2.nOutputs + r1cs2.nPubInputs;
  await processConstraints(curve2.Fr, r1cs2, logger);
  if (globalThis.gc) {
    globalThis.gc();
  }
  const fdZKey = await createBinFile(zkeyName, "zkey", 1, 14, 1 << 22, 1 << 24);
  if (r1cs2.prime != curve2.r) {
    if (logger) logger.error("r1cs curve does not match powers of tau ceremony curve");
    return -1;
  }
  let cirPower = log22(plonkConstraints.length - 1) + 1;
  if (cirPower < 3) cirPower = 3;
  const domainSize = 2 ** cirPower;
  if (logger) logger.info("Plonk constraints: " + plonkConstraints.length);
  if (cirPower > power) {
    if (logger) logger.error(`circuit too big for this power of tau ceremony. ${plonkConstraints.length} > 2**${power}`);
    return -1;
  }
  if (!sectionsPTau[12]) {
    if (logger) logger.error("Powers of tau is not prepared.");
    return -1;
  }
  const LPoints = new BigBuffer(domainSize * sG1);
  const o2 = sectionsPTau[12][0].p + (2 ** cirPower - 1) * sG1;
  await fdPTau.readToBuffer(LPoints, 0, domainSize * sG1, o2);
  const [k1, k2] = getK1K2();
  const vk = {};
  await writeAdditions(3, "Additions");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeWitnessMap(4, 0, "Amap");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeWitnessMap(5, 1, "Bmap");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeWitnessMap(6, 2, "Cmap");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeQMap(7, 3, "Qm");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeQMap(8, 4, "Ql");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeQMap(9, 5, "Qr");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeQMap(10, 6, "Qo");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeQMap(11, 7, "Qc");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeSigma(12, "sigma");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeLs(13, "lagrange polynomials");
  if (globalThis.gc) {
    globalThis.gc();
  }
  await startWriteSection(fdZKey, 14);
  const buffOut = new BigBuffer((domainSize + 6) * sG1);
  await fdPTau.readToBuffer(buffOut, 0, (domainSize + 6) * sG1, sectionsPTau[2][0].p);
  await fdZKey.write(buffOut);
  await endWriteSection(fdZKey);
  if (globalThis.gc) {
    globalThis.gc();
  }
  await writeHeaders();
  await fdZKey.close();
  await fdR1cs.close();
  await fdPTau.close();
  if (logger) logger.info("Setup Finished");
  return;
  async function processConstraints(Fr2, r1cs3, logger2) {
    function normalize2(linearComb) {
      const ss = Object.keys(linearComb);
      for (let i2 = 0; i2 < ss.length; i2++) {
        if (linearComb[ss[i2]] == 0n) delete linearComb[ss[i2]];
      }
    }
    function join(linearComb1, k3, linearComb2) {
      const res = {};
      for (let s2 in linearComb1) {
        if (typeof res[s2] == "undefined") {
          res[s2] = Fr2.mul(k3, linearComb1[s2]);
        } else {
          res[s2] = Fr2.add(res[s2], Fr2.mul(k3, linearComb1[s2]));
        }
      }
      for (let s2 in linearComb2) {
        if (typeof res[s2] == "undefined") {
          res[s2] = linearComb2[s2];
        } else {
          res[s2] = Fr2.add(res[s2], linearComb2[s2]);
        }
      }
      normalize2(res);
      return res;
    }
    function reduceCoefs(linearComb, maxC) {
      const res = {
        k: Fr2.zero,
        s: [],
        coefs: []
      };
      const cs = [];
      for (let s2 in linearComb) {
        if (s2 == 0) {
          res.k = Fr2.add(res.k, linearComb[s2]);
        } else if (linearComb[s2] != 0n) {
          cs.push([Number(s2), linearComb[s2]]);
        }
      }
      while (cs.length > maxC) {
        const c1 = cs.shift();
        const c2 = cs.shift();
        const sl = c1[0];
        const sr = c2[0];
        const so = plonkNVars++;
        const qm = Fr2.zero;
        const ql = Fr2.neg(c1[1]);
        const qr = Fr2.neg(c2[1]);
        const qo = Fr2.one;
        const qc = Fr2.zero;
        plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);
        plonkAdditions.push([sl, sr, c1[1], c2[1]]);
        cs.push([so, Fr2.one]);
      }
      for (let i2 = 0; i2 < cs.length; i2++) {
        res.s[i2] = cs[i2][0];
        res.coefs[i2] = cs[i2][1];
      }
      while (res.coefs.length < maxC) {
        res.s.push(0);
        res.coefs.push(Fr2.zero);
      }
      return res;
    }
    function addConstraintSum(lc) {
      const C2 = reduceCoefs(lc, 3);
      const sl = C2.s[0];
      const sr = C2.s[1];
      const so = C2.s[2];
      const qm = Fr2.zero;
      const ql = C2.coefs[0];
      const qr = C2.coefs[1];
      const qo = C2.coefs[2];
      const qc = C2.k;
      plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);
    }
    function addConstraintMul(lcA, lcB, lcC) {
      const A2 = reduceCoefs(lcA, 1);
      const B2 = reduceCoefs(lcB, 1);
      const C2 = reduceCoefs(lcC, 1);
      const sl = A2.s[0];
      const sr = B2.s[0];
      const so = C2.s[0];
      const qm = Fr2.mul(A2.coefs[0], B2.coefs[0]);
      const ql = Fr2.mul(A2.coefs[0], B2.k);
      const qr = Fr2.mul(A2.k, B2.coefs[0]);
      const qo = Fr2.neg(C2.coefs[0]);
      const qc = Fr2.sub(Fr2.mul(A2.k, B2.k), C2.k);
      plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);
    }
    function getLinearCombinationType(lc) {
      let k3 = Fr2.zero;
      let n = 0;
      const ss = Object.keys(lc);
      for (let i2 = 0; i2 < ss.length; i2++) {
        if (lc[ss[i2]] == 0n) {
          delete lc[ss[i2]];
        } else if (ss[i2] == 0) {
          k3 = Fr2.add(k3, lc[ss[i2]]);
        } else {
          n++;
        }
      }
      if (n > 0) return n.toString();
      if (k3 != Fr2.zero) return "k";
      return "0";
    }
    function process2(lcA, lcB, lcC) {
      const lctA = getLinearCombinationType(lcA);
      const lctB = getLinearCombinationType(lcB);
      if (lctA === "0" || lctB === "0") {
        normalize2(lcC);
        addConstraintSum(lcC);
      } else if (lctA === "k") {
        const lcCC = join(lcB, lcA[0], lcC);
        addConstraintSum(lcCC);
      } else if (lctB === "k") {
        const lcCC = join(lcA, lcB[0], lcC);
        addConstraintSum(lcCC);
      } else {
        addConstraintMul(lcA, lcB, lcC);
      }
    }
    for (let s2 = 1; s2 <= nPublic; s2++) {
      const sl = s2;
      const sr = 0;
      const so = 0;
      const qm = Fr2.zero;
      const ql = Fr2.one;
      const qr = Fr2.zero;
      const qo = Fr2.zero;
      const qc = Fr2.zero;
      plonkConstraints.push([sl, sr, so, qm, ql, qr, qo, qc]);
    }
    for (let c2 = 0; c2 < r1cs3.constraints.length; c2++) {
      if (logger2 && c2 % 1e4 === 0) logger2.debug(`processing constraints: ${c2}/${r1cs3.nConstraints}`);
      process2(...r1cs3.constraints[c2]);
    }
  }
  async function writeWitnessMap(sectionNum, posConstraint, name) {
    await startWriteSection(fdZKey, sectionNum);
    for (let i2 = 0; i2 < plonkConstraints.length; i2++) {
      await fdZKey.writeULE32(plonkConstraints[i2][posConstraint]);
      if (logger && i2 % 1e6 == 0) logger.debug(`writing ${name}: ${i2}/${plonkConstraints.length}`);
    }
    await endWriteSection(fdZKey);
  }
  async function writeQMap(sectionNum, posConstraint, name) {
    let Q2 = new BigBuffer(domainSize * n8r);
    for (let i2 = 0; i2 < plonkConstraints.length; i2++) {
      Q2.set(plonkConstraints[i2][posConstraint], i2 * n8r);
      if (logger && i2 % 1e6 == 0) logger.debug(`writing ${name}: ${i2}/${plonkConstraints.length}`);
    }
    await startWriteSection(fdZKey, sectionNum);
    await writeP4(Q2);
    await endWriteSection(fdZKey);
    Q2 = await Fr.batchFromMontgomery(Q2);
    vk[name] = await curve2.G1.multiExpAffine(LPoints, Q2, logger, "multiexp " + name);
  }
  async function writeP4(buff) {
    const q2 = await Fr.ifft(buff);
    const q4 = new BigBuffer(domainSize * n8r * 4);
    q4.set(q2, 0);
    const Q4 = await Fr.fft(q4);
    await fdZKey.write(q2);
    await fdZKey.write(Q4);
  }
  async function writeAdditions(sectionNum, name) {
    await startWriteSection(fdZKey, sectionNum);
    const buffOut2 = new Uint8Array(2 * 4 + 2 * n8r);
    const buffOutV = new DataView(buffOut2.buffer);
    for (let i2 = 0; i2 < plonkAdditions.length; i2++) {
      const addition = plonkAdditions[i2];
      let o3 = 0;
      buffOutV.setUint32(o3, addition[0], true);
      o3 += 4;
      buffOutV.setUint32(o3, addition[1], true);
      o3 += 4;
      buffOut2.set(addition[2], o3);
      o3 += n8r;
      buffOut2.set(addition[3], o3);
      o3 += n8r;
      await fdZKey.write(buffOut2);
      if (logger && i2 % 1e6 == 0) logger.debug(`writing ${name}: ${i2}/${plonkAdditions.length}`);
    }
    await endWriteSection(fdZKey);
  }
  async function writeSigma(sectionNum, name) {
    const sigma = new BigBuffer(n8r * domainSize * 3);
    const lastAparence = new BigArray$1(plonkNVars);
    const firstPos = new BigArray$1(plonkNVars);
    let w2 = Fr.one;
    for (let i2 = 0; i2 < domainSize; i2++) {
      if (i2 < plonkConstraints.length) {
        buildSigma(plonkConstraints[i2][0], i2);
        buildSigma(plonkConstraints[i2][1], domainSize + i2);
        buildSigma(plonkConstraints[i2][2], domainSize * 2 + i2);
      } else {
        buildSigma(0, i2);
        buildSigma(0, domainSize + i2);
        buildSigma(0, domainSize * 2 + i2);
      }
      w2 = Fr.mul(w2, Fr.w[cirPower]);
      if (logger && i2 % 1e6 == 0) logger.debug(`writing ${name} phase1: ${i2}/${plonkConstraints.length}`);
    }
    for (let s2 = 0; s2 < plonkNVars; s2++) {
      if (typeof firstPos[s2] !== "undefined") {
        sigma.set(lastAparence[s2], firstPos[s2] * n8r);
      } else {
        console.log("Variable not used");
      }
      if (logger && s2 % 1e6 == 0) logger.debug(`writing ${name} phase2: ${s2}/${plonkNVars}`);
    }
    if (globalThis.gc) {
      globalThis.gc();
    }
    await startWriteSection(fdZKey, sectionNum);
    let S1 = sigma.slice(0, domainSize * n8r);
    await writeP4(S1);
    if (globalThis.gc) {
      globalThis.gc();
    }
    let S2 = sigma.slice(domainSize * n8r, domainSize * n8r * 2);
    await writeP4(S2);
    if (globalThis.gc) {
      globalThis.gc();
    }
    let S3 = sigma.slice(domainSize * n8r * 2, domainSize * n8r * 3);
    await writeP4(S3);
    if (globalThis.gc) {
      globalThis.gc();
    }
    await endWriteSection(fdZKey);
    S1 = await Fr.batchFromMontgomery(S1);
    S2 = await Fr.batchFromMontgomery(S2);
    S3 = await Fr.batchFromMontgomery(S3);
    vk.S1 = await curve2.G1.multiExpAffine(LPoints, S1, logger, "multiexp S1");
    if (globalThis.gc) {
      globalThis.gc();
    }
    vk.S2 = await curve2.G1.multiExpAffine(LPoints, S2, logger, "multiexp S2");
    if (globalThis.gc) {
      globalThis.gc();
    }
    vk.S3 = await curve2.G1.multiExpAffine(LPoints, S3, logger, "multiexp S3");
    if (globalThis.gc) {
      globalThis.gc();
    }
    function buildSigma(s2, p2) {
      if (typeof lastAparence[s2] === "undefined") {
        firstPos[s2] = p2;
      } else {
        sigma.set(lastAparence[s2], p2 * n8r);
      }
      let v2;
      if (p2 < domainSize) {
        v2 = w2;
      } else if (p2 < 2 * domainSize) {
        v2 = Fr.mul(w2, k1);
      } else {
        v2 = Fr.mul(w2, k2);
      }
      lastAparence[s2] = v2;
    }
  }
  async function writeLs(sectionNum, name) {
    await startWriteSection(fdZKey, sectionNum);
    const l2 = Math.max(nPublic, 1);
    for (let i2 = 0; i2 < l2; i2++) {
      let buff = new BigBuffer(domainSize * n8r);
      buff.set(Fr.one, i2 * n8r);
      await writeP4(buff);
      if (logger) logger.debug(`writing ${name} ${i2}/${l2}`);
    }
    await endWriteSection(fdZKey);
  }
  async function writeHeaders() {
    await startWriteSection(fdZKey, 1);
    await fdZKey.writeULE32(2);
    await endWriteSection(fdZKey);
    await startWriteSection(fdZKey, 2);
    const primeQ = curve2.q;
    const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;
    const primeR = curve2.r;
    const n8r2 = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;
    await fdZKey.writeULE32(n8q);
    await writeBigInt(fdZKey, primeQ, n8q);
    await fdZKey.writeULE32(n8r2);
    await writeBigInt(fdZKey, primeR, n8r2);
    await fdZKey.writeULE32(plonkNVars);
    await fdZKey.writeULE32(nPublic);
    await fdZKey.writeULE32(domainSize);
    await fdZKey.writeULE32(plonkAdditions.length);
    await fdZKey.writeULE32(plonkConstraints.length);
    await fdZKey.write(k1);
    await fdZKey.write(k2);
    await fdZKey.write(G1.toAffine(vk.Qm));
    await fdZKey.write(G1.toAffine(vk.Ql));
    await fdZKey.write(G1.toAffine(vk.Qr));
    await fdZKey.write(G1.toAffine(vk.Qo));
    await fdZKey.write(G1.toAffine(vk.Qc));
    await fdZKey.write(G1.toAffine(vk.S1));
    await fdZKey.write(G1.toAffine(vk.S2));
    await fdZKey.write(G1.toAffine(vk.S3));
    let bX_2;
    bX_2 = await fdPTau.read(sG2, sectionsPTau[3][0].p + sG2);
    await fdZKey.write(bX_2);
    await endWriteSection(fdZKey);
  }
  function getK1K2() {
    let k12 = Fr.two;
    while (isIncluded(k12, [], cirPower)) Fr.add(k12, Fr.one);
    let k22 = Fr.add(k12, Fr.one);
    while (isIncluded(k22, [k12], cirPower)) Fr.add(k22, Fr.one);
    return [k12, k22];
    function isIncluded(k3, kArr, pow2) {
      const domainSize2 = 2 ** pow2;
      let w2 = Fr.one;
      for (let i2 = 0; i2 < domainSize2; i2++) {
        if (Fr.eq(k3, w2)) return true;
        for (let j2 = 0; j2 < kArr.length; j2++) {
          if (Fr.eq(k3, Fr.mul(kArr[j2], w2))) return true;
        }
        w2 = Fr.mul(w2, Fr.w[pow2]);
      }
      return false;
    }
  }
}
async function plonk16Prove(zkeyFileName, witnessFileName, logger) {
  const { fd: fdWtns, sections: sectionsWtns } = await readBinFile(witnessFileName, "wtns", 2);
  if (logger) logger.debug("> Reading witness file");
  const wtns2 = await readHeader(fdWtns, sectionsWtns);
  if (logger) logger.debug("> Reading zkey file");
  const { fd: fdZKey, sections: zkeySections } = await readBinFile(zkeyFileName, "zkey", 2);
  const zkey2 = await readHeader$1(fdZKey, zkeySections);
  if (zkey2.protocol != "plonk") {
    throw new Error("zkey file is not plonk");
  }
  if (!Scalar.eq(zkey2.r, wtns2.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  if (wtns2.nWitness != zkey2.nVars - zkey2.nAdditions) {
    throw new Error(`Invalid witness length. Circuit: ${zkey2.nVars}, witness: ${wtns2.nWitness}, ${zkey2.nAdditions}`);
  }
  const curve2 = zkey2.curve;
  const Fr = curve2.Fr;
  const n8r = curve2.Fr.n8;
  const sDomain = zkey2.domainSize * n8r;
  if (logger) {
    logger.debug("----------------------------");
    logger.debug("  PLONK PROVE SETTINGS");
    logger.debug(`  Curve:         ${curve2.name}`);
    logger.debug(`  Circuit power: ${zkey2.power}`);
    logger.debug(`  Domain size:   ${zkey2.domainSize}`);
    logger.debug(`  Vars:          ${zkey2.nVars}`);
    logger.debug(`  Public vars:   ${zkey2.nPublic}`);
    logger.debug(`  Constraints:   ${zkey2.nConstraints}`);
    logger.debug(`  Additions:     ${zkey2.nAdditions}`);
    logger.debug("----------------------------");
  }
  if (logger) logger.debug("> Reading witness file data");
  const buffWitness = await readSection(fdWtns, sectionsWtns, 2);
  buffWitness.set(Fr.zero, 0);
  const buffInternalWitness = new BigBuffer(n8r * zkey2.nAdditions);
  let buffers = {};
  let polynomials = {};
  let evaluations = {};
  let challenges = {};
  let proof = new Proof(curve2, logger);
  const transcript = new Keccak256Transcript(curve2);
  if (logger) logger.debug(`> Reading Section ${ZKEY_PL_ADDITIONS_SECTION}. Additions`);
  await calculateAdditions();
  if (logger) logger.debug(`> Reading Section ${ZKEY_PL_SIGMA_SECTION}. Sigma1, Sigma2 & Sigma 3`);
  if (logger) logger.debug(" Reading Sigma polynomials ");
  polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p);
  await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 5 * sDomain);
  await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 10 * sDomain);
  if (logger) logger.debug(" Reading Sigma evaluations");
  evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + sDomain);
  await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 6 * sDomain);
  await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_SIGMA_SECTION][0].p + 11 * sDomain);
  if (logger) logger.debug(`> Reading Section ${ZKEY_PL_PTAU_SECTION}. Powers of Tau`);
  const PTau = await readSection(fdZKey, zkeySections, ZKEY_PL_PTAU_SECTION);
  let publicSignals = [];
  for (let i2 = 1; i2 <= zkey2.nPublic; i2++) {
    const pub = buffWitness.slice(i2 * Fr.n8, i2 * Fr.n8 + Fr.n8);
    publicSignals.push(Scalar.fromRprLE(pub));
  }
  if (logger) logger.debug("");
  if (logger) logger.debug("> ROUND 1");
  await round1();
  if (logger) logger.debug("> ROUND 2");
  await round2();
  if (logger) logger.debug("> ROUND 3");
  await round3();
  if (logger) logger.debug("> ROUND 4");
  await round4();
  if (logger) logger.debug("> ROUND 5");
  await round5();
  await fdZKey.close();
  await fdWtns.close();
  let _proof = proof.toObjectProof(false);
  _proof.protocol = "plonk";
  _proof.curve = curve2.name;
  if (logger) logger.debug("PLONK PROVER FINISHED");
  return {
    proof: stringifyBigInts$1(_proof),
    publicSignals: stringifyBigInts$1(publicSignals)
  };
  async function calculateAdditions() {
    if (logger) logger.debug(" Computing additions");
    const additionsBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_ADDITIONS_SECTION);
    const sSum = 8 + n8r * 2;
    for (let i2 = 0; i2 < zkey2.nAdditions; i2++) {
      if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.debug(`    addition ${i2}/${zkey2.nAdditions}`);
      let offset = i2 * sSum;
      const signalId1 = readUInt32(additionsBuff, offset);
      offset += 4;
      const signalId2 = readUInt32(additionsBuff, offset);
      offset += 4;
      const factor1 = additionsBuff.slice(offset, offset + n8r);
      offset += n8r;
      const factor2 = additionsBuff.slice(offset, offset + n8r);
      const witness1 = getWitness(signalId1);
      const witness2 = getWitness(signalId2);
      const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));
      buffInternalWitness.set(result, n8r * i2);
    }
  }
  function readUInt32(b2, o2) {
    const buff = b2.slice(o2, o2 + 4);
    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
    return buffV.getUint32(0, true);
  }
  function getWitness(idx) {
    if (idx < zkey2.nVars - zkey2.nAdditions) {
      return buffWitness.slice(idx * n8r, idx * n8r + n8r);
    } else if (idx < zkey2.nVars) {
      return buffInternalWitness.slice((idx - (zkey2.nVars - zkey2.nAdditions)) * n8r, (idx - (zkey2.nVars - zkey2.nAdditions)) * n8r + n8r);
    } else {
      return curve2.Fr.zero;
    }
  }
  async function round1() {
    challenges.b = [];
    for (let i2 = 1; i2 <= 11; i2++) {
      challenges.b[i2] = curve2.Fr.random();
    }
    if (logger) logger.debug("> Computing A, B, C wire polynomials");
    await computeWirePolynomials();
    if (logger) logger.debug("> Computing A, B, C MSM");
    let commitA = await polynomials.A.multiExponentiation(PTau, "A");
    let commitB = await polynomials.B.multiExponentiation(PTau, "B");
    let commitC = await polynomials.C.multiExponentiation(PTau, "C");
    proof.addPolynomial("A", commitA);
    proof.addPolynomial("B", commitB);
    proof.addPolynomial("C", commitC);
    return 0;
  }
  async function computeWirePolynomials() {
    if (logger) logger.debug(" Reading data from zkey file");
    buffers.A = new BigBuffer(sDomain);
    buffers.B = new BigBuffer(sDomain);
    buffers.C = new BigBuffer(sDomain);
    const aMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_A_MAP_SECTION);
    const bMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_B_MAP_SECTION);
    const cMapBuff = await readSection(fdZKey, zkeySections, ZKEY_PL_C_MAP_SECTION);
    for (let i2 = 0; i2 < zkey2.nConstraints; i2++) {
      const i_sFr = i2 * n8r;
      const offset = i2 * 4;
      const signalIdA = readUInt32(aMapBuff, offset);
      buffers.A.set(getWitness(signalIdA), i_sFr);
      const signalIdB = readUInt32(bMapBuff, offset);
      buffers.B.set(getWitness(signalIdB), i_sFr);
      const signalIdC = readUInt32(cMapBuff, offset);
      buffers.C.set(getWitness(signalIdC), i_sFr);
    }
    buffers.A = await Fr.batchToMontgomery(buffers.A);
    buffers.B = await Fr.batchToMontgomery(buffers.B);
    buffers.C = await Fr.batchToMontgomery(buffers.C);
    if (logger) logger.debug(" Computing A ifft");
    polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve2, logger);
    if (logger) logger.debug(" Computing B ifft");
    polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve2, logger);
    if (logger) logger.debug(" Computing C ifft");
    polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve2, logger);
    if (logger) logger.debug(" Computing A fft");
    evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve2, logger);
    if (logger) logger.debug(" Computing B fft");
    evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve2, logger);
    if (logger) logger.debug(" Computing C fft");
    evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve2, logger);
    polynomials.A.blindCoefficients([challenges.b[2], challenges.b[1]]);
    polynomials.B.blindCoefficients([challenges.b[4], challenges.b[3]]);
    polynomials.C.blindCoefficients([challenges.b[6], challenges.b[5]]);
    if (polynomials.A.degree() >= zkey2.domainSize + 2) {
      throw new Error("A Polynomial is not well calculated");
    }
    if (polynomials.B.degree() >= zkey2.domainSize + 2) {
      throw new Error("B Polynomial is not well calculated");
    }
    if (polynomials.C.degree() >= zkey2.domainSize + 2) {
      throw new Error("C Polynomial is not well calculated");
    }
  }
  async function round2() {
    if (logger) logger.debug("> Computing challenges beta and gamma");
    transcript.reset();
    transcript.addPolCommitment(zkey2.Qm);
    transcript.addPolCommitment(zkey2.Ql);
    transcript.addPolCommitment(zkey2.Qr);
    transcript.addPolCommitment(zkey2.Qo);
    transcript.addPolCommitment(zkey2.Qc);
    transcript.addPolCommitment(zkey2.S1);
    transcript.addPolCommitment(zkey2.S2);
    transcript.addPolCommitment(zkey2.S3);
    for (let i2 = 0; i2 < zkey2.nPublic; i2++) {
      transcript.addScalar(buffers.A.slice(i2 * n8r, i2 * n8r + n8r));
    }
    transcript.addPolCommitment(proof.getPolynomial("A"));
    transcript.addPolCommitment(proof.getPolynomial("B"));
    transcript.addPolCommitment(proof.getPolynomial("C"));
    challenges.beta = transcript.getChallenge();
    if (logger) logger.debug(" challenges.beta: " + Fr.toString(challenges.beta, 16));
    transcript.reset();
    transcript.addScalar(challenges.beta);
    challenges.gamma = transcript.getChallenge();
    if (logger) logger.debug(" challenges.gamma: " + Fr.toString(challenges.gamma, 16));
    if (logger) logger.debug("> Computing Z polynomial");
    await computeZ();
    if (logger) logger.debug("> Computing Z MSM");
    let commitZ = await polynomials.Z.multiExponentiation(PTau, "Z");
    proof.addPolynomial("Z", commitZ);
  }
  async function computeZ() {
    if (logger) logger.debug(" Computing Z evaluations");
    let numArr = new BigBuffer(sDomain);
    let denArr = new BigBuffer(sDomain);
    numArr.set(Fr.one, 0);
    denArr.set(Fr.one, 0);
    let w2 = Fr.one;
    for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
      const i_n8r = i2 * n8r;
      const a2 = buffers.A.slice(i_n8r, i_n8r + n8r);
      const b2 = buffers.B.slice(i_n8r, i_n8r + n8r);
      const c2 = buffers.C.slice(i_n8r, i_n8r + n8r);
      const betaw = Fr.mul(challenges.beta, w2);
      let n1 = Fr.add(a2, betaw);
      n1 = Fr.add(n1, challenges.gamma);
      let n2 = Fr.add(b2, Fr.mul(zkey2.k1, betaw));
      n2 = Fr.add(n2, challenges.gamma);
      let n3 = Fr.add(c2, Fr.mul(zkey2.k2, betaw));
      n3 = Fr.add(n3, challenges.gamma);
      let num = Fr.mul(n1, Fr.mul(n2, n3));
      let d1 = Fr.add(a2, Fr.mul(evaluations.Sigma1.getEvaluation(i2 * 4), challenges.beta));
      d1 = Fr.add(d1, challenges.gamma);
      let d2 = Fr.add(b2, Fr.mul(evaluations.Sigma2.getEvaluation(i2 * 4), challenges.beta));
      d2 = Fr.add(d2, challenges.gamma);
      let d3 = Fr.add(c2, Fr.mul(evaluations.Sigma3.getEvaluation(i2 * 4), challenges.beta));
      d3 = Fr.add(d3, challenges.gamma);
      let den = Fr.mul(d1, Fr.mul(d2, d3));
      num = Fr.mul(numArr.slice(i_n8r, i_n8r + n8r), num);
      numArr.set(num, (i2 + 1) % zkey2.domainSize * n8r);
      den = Fr.mul(denArr.slice(i_n8r, i_n8r + n8r), den);
      denArr.set(den, (i2 + 1) % zkey2.domainSize * n8r);
      w2 = Fr.mul(w2, Fr.w[zkey2.power]);
    }
    denArr = await Fr.batchInverse(denArr);
    for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
      const i_sFr = i2 * n8r;
      const z2 = Fr.mul(numArr.slice(i_sFr, i_sFr + n8r), denArr.slice(i_sFr, i_sFr + n8r));
      numArr.set(z2, i_sFr);
    }
    buffers.Z = numArr;
    if (!Fr.eq(numArr.slice(0, n8r), Fr.one)) {
      throw new Error("Copy constraints does not match");
    }
    if (logger) logger.debug(" Computing Z ifft");
    polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve2, logger);
    if (logger) logger.debug(" Computing Z fft");
    evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve2, logger);
    polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);
    if (polynomials.Z.degree() >= zkey2.domainSize + 3) {
      throw new Error("Z Polynomial is not well calculated");
    }
    delete buffers.Z;
  }
  async function round3() {
    if (logger) logger.debug("> Computing challenge alpha");
    transcript.reset();
    transcript.addScalar(challenges.beta);
    transcript.addScalar(challenges.gamma);
    transcript.addPolCommitment(proof.getPolynomial("Z"));
    challenges.alpha = transcript.getChallenge();
    challenges.alpha2 = Fr.square(challenges.alpha);
    if (logger) logger.debug(" challenges.alpha: " + Fr.toString(challenges.alpha, 16));
    if (logger) logger.debug("> Computing T polynomial");
    await computeT();
    if (logger) logger.debug("> Computing T MSM");
    let commitT1 = await polynomials.T1.multiExponentiation(PTau, "T1");
    let commitT2 = await polynomials.T2.multiExponentiation(PTau, "T2");
    let commitT3 = await polynomials.T3.multiExponentiation(PTau, "T3");
    proof.addPolynomial("T1", commitT1);
    proof.addPolynomial("T2", commitT2);
    proof.addPolynomial("T3", commitT3);
  }
  async function computeT() {
    if (logger)
      logger.debug(` Reading sections ${ZKEY_PL_QL_SECTION}, ${ZKEY_PL_QR_SECTION}, ${ZKEY_PL_QM_SECTION}, ${ZKEY_PL_QO_SECTION}, ${ZKEY_PL_QC_SECTION}. Q selectors`);
    evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
    evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
    evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
    evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
    evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
    await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QL_SECTION][0].p + sDomain);
    await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QR_SECTION][0].p + sDomain);
    await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QM_SECTION][0].p + sDomain);
    await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QO_SECTION][0].p + sDomain);
    await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_PL_QC_SECTION][0].p + sDomain);
    evaluations.Lagrange = new Evaluations(new BigBuffer(sDomain * 4 * zkey2.nPublic), curve2, logger);
    for (let i2 = 0; i2 < zkey2.nPublic; i2++) {
      await fdZKey.readToBuffer(evaluations.Lagrange.eval, i2 * sDomain * 4, sDomain * 4, zkeySections[ZKEY_PL_LAGRANGE_SECTION][0].p + i2 * 5 * sDomain + sDomain);
    }
    buffers.T = new BigBuffer(sDomain * 4);
    buffers.Tz = new BigBuffer(sDomain * 4);
    if (logger) logger.debug(" Computing T evaluations");
    let w2 = Fr.one;
    for (let i2 = 0; i2 < zkey2.domainSize * 4; i2++) {
      if (logger && 0 !== i2 && i2 % 1e5 === 0)
        logger.debug(`      T evaluation ${i2}/${zkey2.domainSize * 4}`);
      const a2 = evaluations.A.getEvaluation(i2);
      const b2 = evaluations.B.getEvaluation(i2);
      const c2 = evaluations.C.getEvaluation(i2);
      const z2 = evaluations.Z.getEvaluation(i2);
      const zw = evaluations.Z.getEvaluation((zkey2.domainSize * 4 + 4 + i2) % (zkey2.domainSize * 4));
      const qm = evaluations.QM.getEvaluation(i2);
      const ql = evaluations.QL.getEvaluation(i2);
      const qr = evaluations.QR.getEvaluation(i2);
      const qo = evaluations.QO.getEvaluation(i2);
      const qc = evaluations.QC.getEvaluation(i2);
      const s1 = evaluations.Sigma1.getEvaluation(i2);
      const s2 = evaluations.Sigma2.getEvaluation(i2);
      const s3 = evaluations.Sigma3.getEvaluation(i2);
      const ap = Fr.add(challenges.b[2], Fr.mul(challenges.b[1], w2));
      const bp = Fr.add(challenges.b[4], Fr.mul(challenges.b[3], w2));
      const cp = Fr.add(challenges.b[6], Fr.mul(challenges.b[5], w2));
      const w22 = Fr.square(w2);
      const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], w22), Fr.mul(challenges.b[8], w2)), challenges.b[9]);
      const wW = Fr.mul(w2, Fr.w[zkey2.power]);
      const wW2 = Fr.square(wW);
      const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], wW2), Fr.mul(challenges.b[8], wW)), challenges.b[9]);
      let pi = Fr.zero;
      for (let j2 = 0; j2 < zkey2.nPublic; j2++) {
        const offset = j2 * 4 * zkey2.domainSize + i2;
        const lPol = evaluations.Lagrange.getEvaluation(offset);
        const aVal = buffers.A.slice(j2 * n8r, (j2 + 1) * n8r);
        pi = Fr.sub(pi, Fr.mul(lPol, aVal));
      }
      let [e1, e1z] = MulZ.mul2(a2, b2, ap, bp, i2 % 4, Fr);
      e1 = Fr.mul(e1, qm);
      e1z = Fr.mul(e1z, qm);
      e1 = Fr.add(e1, Fr.mul(a2, ql));
      e1z = Fr.add(e1z, Fr.mul(ap, ql));
      e1 = Fr.add(e1, Fr.mul(b2, qr));
      e1z = Fr.add(e1z, Fr.mul(bp, qr));
      e1 = Fr.add(e1, Fr.mul(c2, qo));
      e1z = Fr.add(e1z, Fr.mul(cp, qo));
      e1 = Fr.add(e1, pi);
      e1 = Fr.add(e1, qc);
      const betaw = Fr.mul(challenges.beta, w2);
      let e2a = a2;
      e2a = Fr.add(e2a, betaw);
      e2a = Fr.add(e2a, challenges.gamma);
      let e2b = b2;
      e2b = Fr.add(e2b, Fr.mul(betaw, zkey2.k1));
      e2b = Fr.add(e2b, challenges.gamma);
      let e2c = c2;
      e2c = Fr.add(e2c, Fr.mul(betaw, zkey2.k2));
      e2c = Fr.add(e2c, challenges.gamma);
      let e2d = z2;
      let [e2, e2z] = MulZ.mul4(e2a, e2b, e2c, e2d, ap, bp, cp, zp, i2 % 4, Fr);
      e2 = Fr.mul(e2, challenges.alpha);
      e2z = Fr.mul(e2z, challenges.alpha);
      let e3a = a2;
      e3a = Fr.add(e3a, Fr.mul(challenges.beta, s1));
      e3a = Fr.add(e3a, challenges.gamma);
      let e3b = b2;
      e3b = Fr.add(e3b, Fr.mul(challenges.beta, s2));
      e3b = Fr.add(e3b, challenges.gamma);
      let e3c = c2;
      e3c = Fr.add(e3c, Fr.mul(challenges.beta, s3));
      e3c = Fr.add(e3c, challenges.gamma);
      let e3d = zw;
      let [e3, e3z] = MulZ.mul4(e3a, e3b, e3c, e3d, ap, bp, cp, zWp, i2 % 4, Fr);
      e3 = Fr.mul(e3, challenges.alpha);
      e3z = Fr.mul(e3z, challenges.alpha);
      let e4 = Fr.sub(z2, Fr.one);
      e4 = Fr.mul(e4, evaluations.Lagrange.getEvaluation(i2));
      e4 = Fr.mul(e4, challenges.alpha2);
      let e4z = Fr.mul(zp, evaluations.Lagrange.getEvaluation(i2));
      e4z = Fr.mul(e4z, challenges.alpha2);
      let t = Fr.add(Fr.sub(Fr.add(e1, e2), e3), e4);
      let tz = Fr.add(Fr.sub(Fr.add(e1z, e2z), e3z), e4z);
      buffers.T.set(t, i2 * n8r);
      buffers.Tz.set(tz, i2 * n8r);
      w2 = Fr.mul(w2, Fr.w[zkey2.power + 2]);
    }
    if (logger)
      logger.debug(" Computing T ifft");
    polynomials.T = await Polynomial.fromEvaluations(buffers.T, curve2, logger);
    if (logger)
      logger.debug(" Computing T / ZH");
    polynomials.T.divZh(zkey2.domainSize, 4);
    if (logger)
      logger.debug(" Computing Tz ifft");
    polynomials.Tz = await Polynomial.fromEvaluations(buffers.Tz, curve2, logger);
    polynomials.T.add(polynomials.Tz);
    if (polynomials.T.degree() >= zkey2.domainSize * 3 + 6) {
      throw new Error("T Polynomial is not well calculated");
    }
    if (logger) logger.debug(" Computing T1, T2, T3 polynomials");
    polynomials.T1 = new Polynomial(new BigBuffer((zkey2.domainSize + 1) * n8r), curve2, logger);
    polynomials.T2 = new Polynomial(new BigBuffer((zkey2.domainSize + 1) * n8r), curve2, logger);
    polynomials.T3 = new Polynomial(new BigBuffer((zkey2.domainSize + 6) * n8r), curve2, logger);
    polynomials.T1.coef.set(polynomials.T.coef.slice(0, sDomain), 0);
    polynomials.T2.coef.set(polynomials.T.coef.slice(sDomain, sDomain * 2), 0);
    polynomials.T3.coef.set(polynomials.T.coef.slice(sDomain * 2, sDomain * 3 + 6 * n8r), 0);
    polynomials.T1.setCoef(zkey2.domainSize, challenges.b[10]);
    const lowestMid = Fr.sub(polynomials.T2.getCoef(0), challenges.b[10]);
    polynomials.T2.setCoef(0, lowestMid);
    polynomials.T2.setCoef(zkey2.domainSize, challenges.b[11]);
    const lowestHigh = Fr.sub(polynomials.T3.getCoef(0), challenges.b[11]);
    polynomials.T3.setCoef(0, lowestHigh);
  }
  async function round4() {
    if (logger) logger.debug("> Computing challenge xi");
    transcript.reset();
    transcript.addScalar(challenges.alpha);
    transcript.addPolCommitment(proof.getPolynomial("T1"));
    transcript.addPolCommitment(proof.getPolynomial("T2"));
    transcript.addPolCommitment(proof.getPolynomial("T3"));
    challenges.xi = transcript.getChallenge();
    challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey2.power]);
    if (logger) logger.debug(" challenges.xi: " + Fr.toString(challenges.xi, 16));
    proof.addEvaluation("eval_a", polynomials.A.evaluate(challenges.xi));
    proof.addEvaluation("eval_b", polynomials.B.evaluate(challenges.xi));
    proof.addEvaluation("eval_c", polynomials.C.evaluate(challenges.xi));
    proof.addEvaluation("eval_s1", polynomials.Sigma1.evaluate(challenges.xi));
    proof.addEvaluation("eval_s2", polynomials.Sigma2.evaluate(challenges.xi));
    proof.addEvaluation("eval_zw", polynomials.Z.evaluate(challenges.xiw));
  }
  async function round5() {
    if (logger) logger.debug("> Computing challenge v");
    transcript.reset();
    transcript.addScalar(challenges.xi);
    transcript.addScalar(proof.getEvaluation("eval_a"));
    transcript.addScalar(proof.getEvaluation("eval_b"));
    transcript.addScalar(proof.getEvaluation("eval_c"));
    transcript.addScalar(proof.getEvaluation("eval_s1"));
    transcript.addScalar(proof.getEvaluation("eval_s2"));
    transcript.addScalar(proof.getEvaluation("eval_zw"));
    challenges.v = [];
    challenges.v[1] = transcript.getChallenge();
    if (logger) logger.debug(" challenges.v: " + Fr.toString(challenges.v[1], 16));
    for (let i2 = 2; i2 < 6; i2++) {
      challenges.v[i2] = Fr.mul(challenges.v[i2 - 1], challenges.v[1]);
    }
    if (logger) logger.debug("> Computing linearisation polynomial R(X)");
    await computeR();
    if (logger) logger.debug("> Computing opening proof polynomial Wxi(X) polynomial");
    computeWxi();
    if (logger) logger.debug("> Computing opening proof polynomial Wxiw(X) polynomial");
    computeWxiw();
    if (logger) logger.debug("> Computing Wxi, Wxiw MSM");
    let commitWxi = await polynomials.Wxi.multiExponentiation(PTau, "Wxi");
    let commitWxiw = await polynomials.Wxiw.multiExponentiation(PTau, "Wxiw");
    proof.addPolynomial("Wxi", commitWxi);
    proof.addPolynomial("Wxiw", commitWxiw);
  }
  async function computeR() {
    const Fr2 = curve2.Fr;
    polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_PL_QL_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_PL_QR_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_PL_QM_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_PL_QO_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_PL_QC_SECTION][0].p);
    challenges.xin = challenges.xi;
    for (let i2 = 0; i2 < zkey2.power; i2++) {
      challenges.xin = Fr2.square(challenges.xin);
    }
    challenges.zh = Fr2.sub(challenges.xin, Fr2.one);
    const L2 = [];
    const n = Fr2.e(zkey2.domainSize);
    let w2 = Fr2.one;
    for (let i2 = 1; i2 <= Math.max(1, zkey2.nPublic); i2++) {
      L2[i2] = Fr2.div(Fr2.mul(w2, challenges.zh), Fr2.mul(n, Fr2.sub(challenges.xi, w2)));
      w2 = Fr2.mul(w2, Fr2.w[zkey2.power]);
    }
    const eval_l1 = Fr2.div(
      Fr2.sub(challenges.xin, Fr2.one),
      Fr2.mul(n, Fr2.sub(challenges.xi, Fr2.one))
    );
    if (logger) {
      logger.debug("Lagrange Evaluations: ");
      for (let i2 = 1; i2 < L2.length; i2++) {
        logger.debug(`L${i2}(xi)=` + Fr2.toString(L2[i2], 16));
      }
    }
    let eval_pi = Fr2.zero;
    for (let i2 = 0; i2 < publicSignals.length; i2++) {
      const w3 = Fr2.e(publicSignals[i2]);
      eval_pi = Fr2.sub(eval_pi, Fr2.mul(w3, L2[i2 + 1]));
    }
    if (logger) logger.debug("PI: " + Fr2.toString(eval_pi, 16));
    const coef_ab = Fr2.mul(proof.evaluations.eval_a, proof.evaluations.eval_b);
    let e2a = proof.evaluations.eval_a;
    const betaxi = Fr2.mul(challenges.beta, challenges.xi);
    e2a = Fr2.add(e2a, betaxi);
    e2a = Fr2.add(e2a, challenges.gamma);
    let e2b = proof.evaluations.eval_b;
    e2b = Fr2.add(e2b, Fr2.mul(betaxi, zkey2.k1));
    e2b = Fr2.add(e2b, challenges.gamma);
    let e2c = proof.evaluations.eval_c;
    e2c = Fr2.add(e2c, Fr2.mul(betaxi, zkey2.k2));
    e2c = Fr2.add(e2c, challenges.gamma);
    const e2 = Fr2.mul(Fr2.mul(Fr2.mul(e2a, e2b), e2c), challenges.alpha);
    let e3a = proof.evaluations.eval_a;
    e3a = Fr2.add(e3a, Fr2.mul(challenges.beta, proof.evaluations.eval_s1));
    e3a = Fr2.add(e3a, challenges.gamma);
    let e3b = proof.evaluations.eval_b;
    e3b = Fr2.add(e3b, Fr2.mul(challenges.beta, proof.evaluations.eval_s2));
    e3b = Fr2.add(e3b, challenges.gamma);
    let e3 = Fr2.mul(e3a, e3b);
    e3 = Fr2.mul(e3, proof.evaluations.eval_zw);
    e3 = Fr2.mul(e3, challenges.alpha);
    const e4 = Fr2.mul(eval_l1, challenges.alpha2);
    polynomials.R = new Polynomial(new BigBuffer((zkey2.domainSize + 6) * n8r), curve2, logger);
    polynomials.R.add(polynomials.QM, coef_ab);
    polynomials.R.add(polynomials.QL, proof.evaluations.eval_a);
    polynomials.R.add(polynomials.QR, proof.evaluations.eval_b);
    polynomials.R.add(polynomials.QO, proof.evaluations.eval_c);
    polynomials.R.add(polynomials.QC);
    polynomials.R.add(polynomials.Z, e2);
    polynomials.R.sub(polynomials.Sigma3, Fr2.mul(e3, challenges.beta));
    polynomials.R.add(polynomials.Z, e4);
    let tmp = Polynomial.fromPolynomial(polynomials.T3, curve2, logger);
    tmp.mulScalar(Fr2.square(challenges.xin));
    tmp.add(polynomials.T2, challenges.xin);
    tmp.add(polynomials.T1);
    tmp.mulScalar(challenges.zh);
    polynomials.R.sub(tmp);
    let r0 = Fr2.sub(eval_pi, Fr2.mul(e3, Fr2.add(proof.evaluations.eval_c, challenges.gamma)));
    r0 = Fr2.sub(r0, e4);
    if (logger) logger.debug("r0: " + Fr2.toString(r0, 16));
    polynomials.R.addScalar(r0);
  }
  function computeWxi() {
    polynomials.Wxi = new Polynomial(new BigBuffer(sDomain + 6 * n8r), curve2, logger);
    polynomials.Wxi.add(polynomials.R);
    polynomials.Wxi.add(polynomials.A, challenges.v[1]);
    polynomials.Wxi.add(polynomials.B, challenges.v[2]);
    polynomials.Wxi.add(polynomials.C, challenges.v[3]);
    polynomials.Wxi.add(polynomials.Sigma1, challenges.v[4]);
    polynomials.Wxi.add(polynomials.Sigma2, challenges.v[5]);
    polynomials.Wxi.subScalar(Fr.mul(challenges.v[1], proof.evaluations.eval_a));
    polynomials.Wxi.subScalar(Fr.mul(challenges.v[2], proof.evaluations.eval_b));
    polynomials.Wxi.subScalar(Fr.mul(challenges.v[3], proof.evaluations.eval_c));
    polynomials.Wxi.subScalar(Fr.mul(challenges.v[4], proof.evaluations.eval_s1));
    polynomials.Wxi.subScalar(Fr.mul(challenges.v[5], proof.evaluations.eval_s2));
    polynomials.Wxi.divByZerofier(1, challenges.xi);
  }
  async function computeWxiw() {
    polynomials.Wxiw = Polynomial.fromPolynomial(polynomials.Z, curve2, logger);
    polynomials.Wxiw.subScalar(proof.evaluations.eval_zw);
    polynomials.Wxiw.divByZerofier(1, challenges.xiw);
  }
}
async function plonkFullProve(_input, wasmFile, zkeyFileName, logger) {
  const input = unstringifyBigInts$5(_input);
  const wtns2 = {
    type: "mem"
  };
  await wtnsCalculate(input, wasmFile, wtns2);
  return await plonk16Prove(zkeyFileName, wtns2, logger);
}
async function plonkVerify(_vk_verifier, _publicSignals, _proof, logger) {
  let vk_verifier = unstringifyBigInts$4(_vk_verifier);
  _proof = unstringifyBigInts$4(_proof);
  let publicSignals = unstringifyBigInts$4(_publicSignals);
  const curve2 = await getCurveFromName(vk_verifier.curve);
  const Fr = curve2.Fr;
  const G1 = curve2.G1;
  if (logger) logger.info("PLONK VERIFIER STARTED");
  let proof = fromObjectProof(curve2, _proof);
  vk_verifier = fromObjectVk$1(curve2, vk_verifier);
  if (!isWellConstructed(curve2, proof)) {
    logger.error("Proof is not well constructed");
    return false;
  }
  if (publicSignals.length != vk_verifier.nPublic) {
    logger.error("Invalid number of public inputs");
    return false;
  }
  const challenges = calculatechallenges(curve2, proof, publicSignals, vk_verifier);
  if (logger) {
    logger.debug("beta: " + Fr.toString(challenges.beta, 16));
    logger.debug("gamma: " + Fr.toString(challenges.gamma, 16));
    logger.debug("alpha: " + Fr.toString(challenges.alpha, 16));
    logger.debug("xi: " + Fr.toString(challenges.xi, 16));
    for (let i2 = 1; i2 < 6; i2++) {
      if (logger) logger.debug("v: " + Fr.toString(challenges.v[i2], 16));
    }
    logger.debug("u: " + Fr.toString(challenges.u, 16));
  }
  const L2 = calculateLagrangeEvaluations(curve2, challenges, vk_verifier);
  if (logger) {
    for (let i2 = 1; i2 < L2.length; i2++) {
      logger.debug(`L${i2}(xi)=` + Fr.toString(L2[i2], 16));
    }
  }
  if (publicSignals.length != vk_verifier.nPublic) {
    logger.error("Number of public signals does not match with vk");
    return false;
  }
  const pi = calculatePI$1(curve2, publicSignals, L2);
  if (logger) {
    logger.debug("PI(xi): " + Fr.toString(pi, 16));
  }
  const r0 = calculateR0(curve2, proof, challenges, pi, L2[1]);
  if (logger) {
    logger.debug("r0: " + Fr.toString(r0, 16));
  }
  const D2 = calculateD(curve2, proof, challenges, vk_verifier, L2[1]);
  if (logger) {
    logger.debug("D: " + G1.toString(G1.toAffine(D2), 16));
  }
  const F2 = calculateF(curve2, proof, challenges, vk_verifier, D2);
  if (logger) {
    logger.debug("F: " + G1.toString(G1.toAffine(F2), 16));
  }
  const E2 = calculateE(curve2, proof, challenges, r0);
  if (logger) {
    logger.debug("E: " + G1.toString(G1.toAffine(E2), 16));
  }
  const res = await isValidPairing$1(curve2, proof, challenges, vk_verifier, E2, F2);
  if (logger) {
    if (res) {
      logger.info("OK!");
    } else {
      logger.warn("Invalid Proof");
    }
  }
  return res;
}
function fromObjectProof(curve2, proof) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  const res = {};
  res.A = G1.fromObject(proof.A);
  res.B = G1.fromObject(proof.B);
  res.C = G1.fromObject(proof.C);
  res.Z = G1.fromObject(proof.Z);
  res.T1 = G1.fromObject(proof.T1);
  res.T2 = G1.fromObject(proof.T2);
  res.T3 = G1.fromObject(proof.T3);
  res.eval_a = Fr.fromObject(proof.eval_a);
  res.eval_b = Fr.fromObject(proof.eval_b);
  res.eval_c = Fr.fromObject(proof.eval_c);
  res.eval_zw = Fr.fromObject(proof.eval_zw);
  res.eval_s1 = Fr.fromObject(proof.eval_s1);
  res.eval_s2 = Fr.fromObject(proof.eval_s2);
  res.Wxi = G1.fromObject(proof.Wxi);
  res.Wxiw = G1.fromObject(proof.Wxiw);
  return res;
}
function fromObjectVk$1(curve2, vk) {
  const G1 = curve2.G1;
  const G2 = curve2.G2;
  const Fr = curve2.Fr;
  const res = vk;
  res.Qm = G1.fromObject(vk.Qm);
  res.Ql = G1.fromObject(vk.Ql);
  res.Qr = G1.fromObject(vk.Qr);
  res.Qo = G1.fromObject(vk.Qo);
  res.Qc = G1.fromObject(vk.Qc);
  res.S1 = G1.fromObject(vk.S1);
  res.S2 = G1.fromObject(vk.S2);
  res.S3 = G1.fromObject(vk.S3);
  res.k1 = Fr.fromObject(vk.k1);
  res.k2 = Fr.fromObject(vk.k2);
  res.X_2 = G2.fromObject(vk.X_2);
  return res;
}
function isWellConstructed(curve2, proof) {
  const G1 = curve2.G1;
  if (!G1.isValid(proof.A)) return false;
  if (!G1.isValid(proof.B)) return false;
  if (!G1.isValid(proof.C)) return false;
  if (!G1.isValid(proof.Z)) return false;
  if (!G1.isValid(proof.T1)) return false;
  if (!G1.isValid(proof.T2)) return false;
  if (!G1.isValid(proof.T3)) return false;
  if (!G1.isValid(proof.Wxi)) return false;
  if (!G1.isValid(proof.Wxiw)) return false;
  return true;
}
function calculatechallenges(curve2, proof, publicSignals, vk) {
  const Fr = curve2.Fr;
  const res = {};
  const transcript = new Keccak256Transcript(curve2);
  transcript.addPolCommitment(vk.Qm);
  transcript.addPolCommitment(vk.Ql);
  transcript.addPolCommitment(vk.Qr);
  transcript.addPolCommitment(vk.Qo);
  transcript.addPolCommitment(vk.Qc);
  transcript.addPolCommitment(vk.S1);
  transcript.addPolCommitment(vk.S2);
  transcript.addPolCommitment(vk.S3);
  for (let i2 = 0; i2 < publicSignals.length; i2++) {
    transcript.addScalar(Fr.e(publicSignals[i2]));
  }
  transcript.addPolCommitment(proof.A);
  transcript.addPolCommitment(proof.B);
  transcript.addPolCommitment(proof.C);
  res.beta = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(res.beta);
  res.gamma = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(res.beta);
  transcript.addScalar(res.gamma);
  transcript.addPolCommitment(proof.Z);
  res.alpha = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(res.alpha);
  transcript.addPolCommitment(proof.T1);
  transcript.addPolCommitment(proof.T2);
  transcript.addPolCommitment(proof.T3);
  res.xi = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(res.xi);
  transcript.addScalar(proof.eval_a);
  transcript.addScalar(proof.eval_b);
  transcript.addScalar(proof.eval_c);
  transcript.addScalar(proof.eval_s1);
  transcript.addScalar(proof.eval_s2);
  transcript.addScalar(proof.eval_zw);
  res.v = [];
  res.v[1] = transcript.getChallenge();
  for (let i2 = 2; i2 < 6; i2++) res.v[i2] = Fr.mul(res.v[i2 - 1], res.v[1]);
  transcript.reset();
  transcript.addPolCommitment(proof.Wxi);
  transcript.addPolCommitment(proof.Wxiw);
  res.u = transcript.getChallenge();
  return res;
}
function calculateLagrangeEvaluations(curve2, challenges, vk) {
  const Fr = curve2.Fr;
  let xin = challenges.xi;
  let domainSize = 1;
  for (let i2 = 0; i2 < vk.power; i2++) {
    xin = Fr.square(xin);
    domainSize *= 2;
  }
  challenges.xin = xin;
  challenges.zh = Fr.sub(xin, Fr.one);
  const L2 = [];
  const n = Fr.e(domainSize);
  let w2 = Fr.one;
  for (let i2 = 1; i2 <= Math.max(1, vk.nPublic); i2++) {
    L2[i2] = Fr.div(Fr.mul(w2, challenges.zh), Fr.mul(n, Fr.sub(challenges.xi, w2)));
    w2 = Fr.mul(w2, Fr.w[vk.power]);
  }
  return L2;
}
function calculatePI$1(curve2, publicSignals, L2) {
  const Fr = curve2.Fr;
  let pi = Fr.zero;
  for (let i2 = 0; i2 < publicSignals.length; i2++) {
    const w2 = Fr.e(publicSignals[i2]);
    pi = Fr.sub(pi, Fr.mul(w2, L2[i2 + 1]));
  }
  return pi;
}
function calculateR0(curve2, proof, challenges, pi, l1) {
  const Fr = curve2.Fr;
  const e1 = pi;
  const e2 = Fr.mul(l1, Fr.square(challenges.alpha));
  let e3a = Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1));
  e3a = Fr.add(e3a, challenges.gamma);
  let e3b = Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2));
  e3b = Fr.add(e3b, challenges.gamma);
  let e3c = Fr.add(proof.eval_c, challenges.gamma);
  let e3 = Fr.mul(Fr.mul(e3a, e3b), e3c);
  e3 = Fr.mul(e3, proof.eval_zw);
  e3 = Fr.mul(e3, challenges.alpha);
  const r0 = Fr.sub(Fr.sub(e1, e2), e3);
  return r0;
}
function calculateD(curve2, proof, challenges, vk, l1) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  let d1 = G1.timesFr(vk.Qm, Fr.mul(proof.eval_a, proof.eval_b));
  d1 = G1.add(d1, G1.timesFr(vk.Ql, proof.eval_a));
  d1 = G1.add(d1, G1.timesFr(vk.Qr, proof.eval_b));
  d1 = G1.add(d1, G1.timesFr(vk.Qo, proof.eval_c));
  d1 = G1.add(d1, vk.Qc);
  const betaxi = Fr.mul(challenges.beta, challenges.xi);
  const d2a1 = Fr.add(Fr.add(proof.eval_a, betaxi), challenges.gamma);
  const d2a2 = Fr.add(Fr.add(proof.eval_b, Fr.mul(betaxi, vk.k1)), challenges.gamma);
  const d2a3 = Fr.add(Fr.add(proof.eval_c, Fr.mul(betaxi, vk.k2)), challenges.gamma);
  const d2a = Fr.mul(Fr.mul(Fr.mul(d2a1, d2a2), d2a3), challenges.alpha);
  const d2b = Fr.mul(l1, Fr.square(challenges.alpha));
  const d2 = G1.timesFr(proof.Z, Fr.add(Fr.add(d2a, d2b), challenges.u));
  const d3a = Fr.add(Fr.add(proof.eval_a, Fr.mul(challenges.beta, proof.eval_s1)), challenges.gamma);
  const d3b = Fr.add(Fr.add(proof.eval_b, Fr.mul(challenges.beta, proof.eval_s2)), challenges.gamma);
  const d3c = Fr.mul(Fr.mul(challenges.alpha, challenges.beta), proof.eval_zw);
  const d3 = G1.timesFr(vk.S3, Fr.mul(Fr.mul(d3a, d3b), d3c));
  const d4low = proof.T1;
  const d4mid = G1.timesFr(proof.T2, challenges.xin);
  const d4high = G1.timesFr(proof.T3, Fr.square(challenges.xin));
  let d4 = G1.add(d4low, G1.add(d4mid, d4high));
  d4 = G1.timesFr(d4, challenges.zh);
  const d = G1.sub(G1.sub(G1.add(d1, d2), d3), d4);
  return d;
}
function calculateF(curve2, proof, challenges, vk, D2) {
  const G1 = curve2.G1;
  let res = G1.add(D2, G1.timesFr(proof.A, challenges.v[1]));
  res = G1.add(res, G1.timesFr(proof.B, challenges.v[2]));
  res = G1.add(res, G1.timesFr(proof.C, challenges.v[3]));
  res = G1.add(res, G1.timesFr(vk.S1, challenges.v[4]));
  res = G1.add(res, G1.timesFr(vk.S2, challenges.v[5]));
  return res;
}
function calculateE(curve2, proof, challenges, r0) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  let e2 = Fr.add(Fr.neg(r0), Fr.mul(challenges.v[1], proof.eval_a));
  e2 = Fr.add(e2, Fr.mul(challenges.v[2], proof.eval_b));
  e2 = Fr.add(e2, Fr.mul(challenges.v[3], proof.eval_c));
  e2 = Fr.add(e2, Fr.mul(challenges.v[4], proof.eval_s1));
  e2 = Fr.add(e2, Fr.mul(challenges.v[5], proof.eval_s2));
  e2 = Fr.add(e2, Fr.mul(challenges.u, proof.eval_zw));
  const res = G1.timesFr(G1.one, e2);
  return res;
}
async function isValidPairing$1(curve2, proof, challenges, vk, E2, F2) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  let A1 = proof.Wxi;
  A1 = G1.add(A1, G1.timesFr(proof.Wxiw, challenges.u));
  let B1 = G1.timesFr(proof.Wxi, challenges.xi);
  const s2 = Fr.mul(Fr.mul(challenges.u, challenges.xi), Fr.w[vk.power]);
  B1 = G1.add(B1, G1.timesFr(proof.Wxiw, s2));
  B1 = G1.add(B1, F2);
  B1 = G1.sub(B1, E2);
  const res = await curve2.pairingEq(
    G1.neg(A1),
    vk.X_2,
    B1,
    curve2.G2.one
  );
  return res;
}
function p256$1(n) {
  let nstr = n.toString(16);
  while (nstr.length < 64) nstr = "0" + nstr;
  nstr = `"0x${nstr}"`;
  return nstr;
}
async function plonkExportSolidityCallData(_proof, _pub) {
  const proof = unstringifyBigInts$3(_proof);
  const pub = unstringifyBigInts$3(_pub);
  await getCurveFromName(proof.curve);
  let inputs = "";
  for (let i2 = 0; i2 < pub.length; i2++) {
    if (inputs != "") inputs = inputs + ",";
    inputs = inputs + p256$1(pub[i2]);
  }
  return `[${p256$1(proof.A[0])}, ${p256$1(proof.A[1])},${p256$1(proof.B[0])},${p256$1(proof.B[1])},${p256$1(proof.C[0])},${p256$1(proof.C[1])},${p256$1(proof.Z[0])},${p256$1(proof.Z[1])},${p256$1(proof.T1[0])},${p256$1(proof.T1[1])},${p256$1(proof.T2[0])},${p256$1(proof.T2[1])},${p256$1(proof.T3[0])},${p256$1(proof.T3[1])},${p256$1(proof.Wxi[0])},${p256$1(proof.Wxi[1])},${p256$1(proof.Wxiw[0])},${p256$1(proof.Wxiw[1])},${p256$1(proof.eval_a)},${p256$1(proof.eval_b)},${p256$1(proof.eval_c)},${p256$1(proof.eval_s1)},${p256$1(proof.eval_s2)},${p256$1(proof.eval_zw)}][${inputs}]`;
}
function getFFlonkConstantConstraint(signal1, Fr) {
  return [signal1, 0, 0, Fr.one, Fr.zero, Fr.zero, Fr.zero, Fr.zero];
}
function getFFlonkAdditionConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc) {
  return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];
}
function getFFlonkMultiplicationConstraint(signal1, signal2, signalOut, ql, qr, qm, qo, qc, Fr) {
  return [signal1, signal2, signalOut, ql, qr, qm, qo, qc];
}
async function fflonkSetup(r1csFilename, ptauFilename, zkeyFilename, logger) {
  if (logger) logger.info("FFLONK SETUP STARTED");
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("> Reading PTau file");
  const { fd: fdPTau, sections: pTauSections } = await readBinFile(ptauFilename, "ptau", 1);
  if (!pTauSections[12]) {
    throw new Error("Powers of Tau is not well prepared. Section 12 missing.");
  }
  if (logger) logger.info("> Getting curve from PTau settings");
  const { curve: curve2 } = await readPTauHeader(fdPTau, pTauSections);
  if (logger) logger.info("> Reading r1cs file");
  const { fd: fdR1cs, sections: sectionsR1cs } = await readBinFile(r1csFilename, "r1cs", 1);
  const r1cs2 = await readR1csFd(fdR1cs, sectionsR1cs, { loadConstraints: false, loadCustomGates: true });
  if (r1cs2.prime !== curve2.r) {
    throw new Error("r1cs curve does not match powers of tau ceremony curve");
  }
  const Fr = curve2.Fr;
  const sFr = curve2.Fr.n8;
  const sG1 = curve2.G1.F.n8 * 2;
  const sG2 = curve2.G2.F.n8 * 2;
  let polynomials = {};
  let evaluations = {};
  let PTau;
  let settings = {
    nVars: r1cs2.nVars,
    nPublic: r1cs2.nOutputs + r1cs2.nPubInputs
  };
  const plonkConstraints = new BigArray$1();
  let plonkAdditions = new BigArray$1();
  if (logger) logger.info("> Processing FFlonk constraints");
  await computeFFConstraints(curve2.Fr, r1cs2, logger);
  if (globalThis.gc) globalThis.gc();
  settings.cirPower = Math.max(FF_T_POL_DEG_MIN, log22(plonkConstraints.length + 2 - 1) + 1);
  settings.domainSize = 2 ** settings.cirPower;
  if (pTauSections[2][0].size < (settings.domainSize * 9 + 18) * sG1) {
    throw new Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");
  }
  if (pTauSections[3][0].size < sG2) {
    throw new Error("Powers of Tau is not well prepared. Section 3 too small.");
  }
  if (logger) {
    logger.info("----------------------------");
    logger.info("  FFLONK SETUP SETTINGS");
    logger.info(`  Curve:         ${curve2.name}`);
    logger.info(`  Circuit power: ${settings.cirPower}`);
    logger.info(`  Domain size:   ${settings.domainSize}`);
    logger.info(`  Vars:          ${settings.nVars}`);
    logger.info(`  Public vars:   ${settings.nPublic}`);
    logger.info(`  Constraints:   ${plonkConstraints.length}`);
    logger.info(`  Additions:     ${plonkAdditions.length}`);
    logger.info("----------------------------");
  }
  if (logger) logger.info("> computing k1 and k2");
  const [k1, k2] = computeK1K2();
  if (logger) logger.info("> computing w3");
  const w3 = computeW3();
  if (logger) logger.info("> computing w4");
  const w4 = computeW4();
  if (logger) logger.info("> computing w8");
  const w8 = computeW8();
  if (logger) logger.info("> computing wr");
  const wr = getOmegaCubicRoot(settings.cirPower, curve2.Fr);
  await writeZkeyFile();
  await fdR1cs.close();
  await fdPTau.close();
  if (logger) logger.info("FFLONK SETUP FINISHED");
  return 0;
  async function computeFFConstraints(Fr2, r1cs3, logger2) {
    for (let i2 = 0; i2 < settings.nPublic; i2++) {
      plonkConstraints.push(getFFlonkConstantConstraint(i2 + 1, Fr2));
    }
    const r1csProcessor = new r1csConstraintProcessor(Fr2, getFFlonkConstantConstraint, getFFlonkAdditionConstraint, getFFlonkMultiplicationConstraint, logger2);
    const bR1cs = await readSection(fdR1cs, sectionsR1cs, 2);
    let bR1csPos = 0;
    for (let i2 = 0; i2 < r1cs3.nConstraints; i2++) {
      if (logger2 && i2 !== 0 && i2 % 5e5 === 0) {
        logger2.info(`    processing r1cs constraints ${i2}/${r1cs3.nConstraints}`);
      }
      const [constraints, additions] = r1csProcessor.processR1csConstraint(settings, ...readConstraint());
      plonkConstraints.push(...constraints);
      plonkAdditions.push(...additions);
    }
    function readConstraint() {
      const c2 = [];
      c2[0] = readLC();
      c2[1] = readLC();
      c2[2] = readLC();
      return c2;
    }
    function readLC() {
      const lc = {};
      const buffUL32 = bR1cs.slice(bR1csPos, bR1csPos + 4);
      bR1csPos += 4;
      const buffUL32V = new DataView(buffUL32.buffer);
      const nIdx = buffUL32V.getUint32(0, true);
      const buff = bR1cs.slice(bR1csPos, bR1csPos + (4 + r1cs3.n8) * nIdx);
      bR1csPos += (4 + r1cs3.n8) * nIdx;
      const buffV = new DataView(buff.buffer);
      for (let i2 = 0; i2 < nIdx; i2++) {
        const idx = buffV.getUint32(i2 * (4 + r1cs3.n8), true);
        const val = r1cs3.F.fromRprLE(buff, i2 * (4 + r1cs3.n8) + 4);
        lc[idx] = val;
      }
      return lc;
    }
    return 0;
  }
  async function writeZkeyFile() {
    if (logger) logger.info("> Writing the zkey file");
    const fdZKey = await createBinFile(zkeyFilename, "zkey", 1, ZKEY_FF_NSECTIONS, 1 << 22, 1 << 24);
    if (logger) logger.info(` Writing Section ${HEADER_ZKEY_SECTION}. Zkey Header`);
    await writeZkeyHeader(fdZKey);
    if (logger) logger.info(` Writing Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);
    await writeAdditions(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_A_MAP_SECTION}. A Map`);
    await writeWitnessMap(fdZKey, ZKEY_FF_A_MAP_SECTION, 0, "A map");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_B_MAP_SECTION}. B Map`);
    await writeWitnessMap(fdZKey, ZKEY_FF_B_MAP_SECTION, 1, "B map");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_C_MAP_SECTION}. C Map`);
    await writeWitnessMap(fdZKey, ZKEY_FF_C_MAP_SECTION, 2, "C map");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_QL_SECTION}. QL`);
    await writeQMap(fdZKey, ZKEY_FF_QL_SECTION, 3, "QL");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_QR_SECTION}. QR`);
    await writeQMap(fdZKey, ZKEY_FF_QR_SECTION, 4, "QR");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_QM_SECTION}. QM`);
    await writeQMap(fdZKey, ZKEY_FF_QM_SECTION, 5, "QM");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_QO_SECTION}. QO`);
    await writeQMap(fdZKey, ZKEY_FF_QO_SECTION, 6, "QO");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_QC_SECTION}. QC`);
    await writeQMap(fdZKey, ZKEY_FF_QC_SECTION, 7, "QC");
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);
    await writeSigma(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_LAGRANGE_SECTION}. Lagrange Polynomials`);
    await writeLagrangePolynomials(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);
    await writePtau(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_C0_SECTION}. C0`);
    await writeC0(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info(` Writing Section ${ZKEY_FF_HEADER_SECTION}. FFlonk Header`);
    await writeFFlonkHeader(fdZKey);
    if (globalThis.gc) globalThis.gc();
    if (logger) logger.info("> Writing the zkey file finished");
    await fdZKey.close();
  }
  async function writeZkeyHeader(fdZKey) {
    await startWriteSection(fdZKey, HEADER_ZKEY_SECTION);
    await fdZKey.writeULE32(FFLONK_PROTOCOL_ID);
    await endWriteSection(fdZKey);
  }
  async function writeAdditions(fdZKey) {
    await startWriteSection(fdZKey, ZKEY_FF_ADDITIONS_SECTION);
    const buffOut = new Uint8Array(8 + 2 * sFr);
    const buffOutV = new DataView(buffOut.buffer);
    for (let i2 = 0; i2 < plonkAdditions.length; i2++) {
      if (logger && i2 !== 0 && i2 % 5e5 === 0) logger.info(`      writing Additions: ${i2}/${plonkAdditions.length}`);
      const addition = plonkAdditions[i2];
      buffOutV.setUint32(0, addition[0], true);
      buffOutV.setUint32(4, addition[1], true);
      buffOut.set(addition[2], 8);
      buffOut.set(addition[3], 8 + sFr);
      await fdZKey.write(buffOut);
    }
    await endWriteSection(fdZKey);
  }
  async function writeWitnessMap(fdZKey, sectionNum, posConstraint, name) {
    await startWriteSection(fdZKey, sectionNum);
    for (let i2 = 0; i2 < plonkConstraints.length; i2++) {
      if (logger && i2 !== 0 && i2 % 5e5 === 0) {
        logger.info(`      writing witness ${name}: ${i2}/${plonkConstraints.length}`);
      }
      await fdZKey.writeULE32(plonkConstraints[i2][posConstraint]);
    }
    await endWriteSection(fdZKey);
  }
  async function writeQMap(fdZKey, sectionNum, posConstraint, name) {
    let Q2 = new BigBuffer(settings.domainSize * sFr);
    for (let i2 = 0; i2 < plonkConstraints.length; i2++) {
      Q2.set(plonkConstraints[i2][posConstraint], i2 * sFr);
      if (logger && i2 !== 0 && i2 % 5e5 === 0) {
        logger.info(`      writing ${name}: ${i2}/${plonkConstraints.length}`);
      }
    }
    polynomials[name] = await Polynomial.fromEvaluations(Q2, curve2, logger);
    evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve2, logger);
    await startWriteSection(fdZKey, sectionNum);
    await fdZKey.write(polynomials[name].coef);
    await fdZKey.write(evaluations[name].eval);
    await endWriteSection(fdZKey);
  }
  async function writeSigma(fdZKey) {
    const sigma = new BigBuffer(sFr * settings.domainSize * 3);
    const lastSeen = new BigArray$1(settings.nVars);
    const firstPos = new BigArray$1(settings.nVars);
    let w2 = Fr.one;
    for (let i2 = 0; i2 < settings.domainSize; i2++) {
      if (i2 < plonkConstraints.length) {
        buildSigma(plonkConstraints[i2][0], i2);
        buildSigma(plonkConstraints[i2][1], settings.domainSize + i2);
        buildSigma(plonkConstraints[i2][2], settings.domainSize * 2 + i2);
      } else if (i2 < settings.domainSize - 2) {
        buildSigma(0, i2);
        buildSigma(0, settings.domainSize + i2);
        buildSigma(0, settings.domainSize * 2 + i2);
      } else {
        sigma.set(w2, i2 * sFr);
        sigma.set(Fr.mul(w2, k1), (settings.domainSize + i2) * sFr);
        sigma.set(Fr.mul(w2, k2), (settings.domainSize * 2 + i2) * sFr);
      }
      w2 = Fr.mul(w2, Fr.w[settings.cirPower]);
      if (logger && i2 !== 0 && i2 % 5e5 === 0) {
        logger.info(`      writing sigma phase1: ${i2}/${plonkConstraints.length}`);
      }
    }
    for (let i2 = 0; i2 < settings.nVars; i2++) {
      if (typeof firstPos[i2] !== "undefined") {
        sigma.set(lastSeen[i2], firstPos[i2] * sFr);
      } else {
        console.log("Variable not used");
      }
      if (logger && i2 !== 0 && i2 % 5e5 === 0) logger.info(`      writing sigma phase2: ${i2}/${settings.nVars}`);
    }
    if (globalThis.gc) globalThis.gc();
    for (let i2 = 0; i2 < 3; i2++) {
      const sectionId = 0 === i2 ? ZKEY_FF_SIGMA1_SECTION : 1 === i2 ? ZKEY_FF_SIGMA2_SECTION : ZKEY_FF_SIGMA3_SECTION;
      let name = "S" + (i2 + 1);
      polynomials[name] = await Polynomial.fromEvaluations(sigma.slice(settings.domainSize * sFr * i2, settings.domainSize * sFr * (i2 + 1)), curve2, logger);
      evaluations[name] = await Evaluations.fromPolynomial(polynomials[name], 4, curve2, logger);
      await startWriteSection(fdZKey, sectionId);
      await fdZKey.write(polynomials[name].coef);
      await fdZKey.write(evaluations[name].eval);
      await endWriteSection(fdZKey);
      if (globalThis.gc) globalThis.gc();
    }
    return 0;
    function buildSigma(signalId, idx) {
      if (typeof lastSeen[signalId] === "undefined") {
        firstPos[signalId] = idx;
      } else {
        sigma.set(lastSeen[signalId], idx * sFr);
      }
      let v2;
      if (idx < settings.domainSize) {
        v2 = w2;
      } else if (idx < 2 * settings.domainSize) {
        v2 = Fr.mul(w2, k1);
      } else {
        v2 = Fr.mul(w2, k2);
      }
      lastSeen[signalId] = v2;
    }
  }
  async function writeLagrangePolynomials(fdZKey) {
    await startWriteSection(fdZKey, ZKEY_FF_LAGRANGE_SECTION);
    const l2 = Math.max(settings.nPublic, 1);
    for (let i2 = 0; i2 < l2; i2++) {
      let buff = new BigBuffer(settings.domainSize * sFr);
      buff.set(Fr.one, i2 * sFr);
      await writeP4(fdZKey, buff);
    }
    await endWriteSection(fdZKey);
  }
  async function writePtau(fdZKey) {
    await startWriteSection(fdZKey, ZKEY_FF_PTAU_SECTION);
    PTau = new BigBuffer((settings.domainSize * 9 + 18) * sG1);
    await fdPTau.readToBuffer(PTau, 0, (settings.domainSize * 9 + 18) * sG1, pTauSections[2][0].p);
    await fdZKey.write(PTau);
    await endWriteSection(fdZKey);
  }
  async function writeC0(fdZKey) {
    let C0 = new CPolynomial(8, curve2, logger);
    C0.addPolynomial(0, polynomials.QL);
    C0.addPolynomial(1, polynomials.QR);
    C0.addPolynomial(2, polynomials.QO);
    C0.addPolynomial(3, polynomials.QM);
    C0.addPolynomial(4, polynomials.QC);
    C0.addPolynomial(5, polynomials.S1);
    C0.addPolynomial(6, polynomials.S2);
    C0.addPolynomial(7, polynomials.S3);
    polynomials.C0 = C0.getPolynomial();
    if (polynomials.C0.degree() >= 8 * settings.domainSize) {
      throw new Error("C0 Polynomial is not well calculated");
    }
    await startWriteSection(fdZKey, ZKEY_FF_C0_SECTION);
    await fdZKey.write(polynomials.C0.coef);
    await endWriteSection(fdZKey);
  }
  async function writeFFlonkHeader(fdZKey) {
    await startWriteSection(fdZKey, ZKEY_FF_HEADER_SECTION);
    const primeQ = curve2.q;
    const n8q = (Math.floor((Scalar.bitLength(primeQ) - 1) / 64) + 1) * 8;
    await fdZKey.writeULE32(n8q);
    await writeBigInt(fdZKey, primeQ, n8q);
    const primeR = curve2.r;
    const n8r = (Math.floor((Scalar.bitLength(primeR) - 1) / 64) + 1) * 8;
    await fdZKey.writeULE32(n8r);
    await writeBigInt(fdZKey, primeR, n8r);
    await fdZKey.writeULE32(settings.nVars);
    await fdZKey.writeULE32(settings.nPublic);
    await fdZKey.writeULE32(settings.domainSize);
    await fdZKey.writeULE32(plonkAdditions.length);
    await fdZKey.writeULE32(plonkConstraints.length);
    await fdZKey.write(k1);
    await fdZKey.write(k2);
    await fdZKey.write(w3);
    await fdZKey.write(w4);
    await fdZKey.write(w8);
    await fdZKey.write(wr);
    let bX_2;
    bX_2 = await fdPTau.read(sG2, pTauSections[3][0].p + sG2);
    await fdZKey.write(bX_2);
    let commitC0 = await polynomials.C0.multiExponentiation(PTau, "C0");
    await fdZKey.write(commitC0);
    await endWriteSection(fdZKey);
  }
  async function writeP4(fdZKey, buff) {
    const [coefficients, evaluations4] = await Polynomial.to4T(buff, settings.domainSize, [], Fr);
    await fdZKey.write(coefficients);
    await fdZKey.write(evaluations4);
    return [coefficients, evaluations4];
  }
  function computeK1K2() {
    let k12 = Fr.two;
    while (isIncluded(k12, [], settings.cirPower)) Fr.add(k12, Fr.one);
    let k22 = Fr.add(k12, Fr.one);
    while (isIncluded(k22, [k12], settings.cirPower)) Fr.add(k22, Fr.one);
    return [k12, k22];
    function isIncluded(k3, kArr, pow2) {
      const domainSize = 2 ** pow2;
      let w2 = Fr.one;
      for (let i2 = 0; i2 < domainSize; i2++) {
        if (Fr.eq(k3, w2)) return true;
        for (let j2 = 0; j2 < kArr.length; j2++) {
          if (Fr.eq(k3, Fr.mul(kArr[j2], w2))) return true;
        }
        w2 = Fr.mul(w2, Fr.w[pow2]);
      }
      return false;
    }
  }
  function computeW3() {
    let generator = Fr.e(31624);
    let orderRsub1 = 3648040478639879203707734290876212514758060733402672390616367364429301415936n;
    let exponent = Scalar.div(orderRsub1, Scalar.e(3));
    return Fr.exp(generator, exponent);
  }
  function computeW4() {
    return Fr.w[2];
  }
  function computeW8() {
    return Fr.w[3];
  }
  function getOmegaCubicRoot(power, Fr2) {
    const firstRoot = Fr2.e(467799165886069610036046866799264026481344299079011762026774533774345988080n);
    return Fr2.exp(firstRoot, 2 ** (28 - power));
  }
}
async function fflonkProve(zkeyFileName, witnessFileName, logger) {
  if (logger) logger.info("FFLONK PROVER STARTED");
  if (logger) logger.info("> Reading witness file");
  const {
    fd: fdWtns,
    sections: wtnsSections
  } = await readBinFile(witnessFileName, "wtns", 2);
  const wtns2 = await readHeader(fdWtns, wtnsSections);
  if (logger) logger.info("> Reading zkey file");
  const {
    fd: fdZKey,
    sections: zkeySections
  } = await readBinFile(zkeyFileName, "zkey", 2);
  const zkey2 = await readHeader$1(fdZKey, zkeySections);
  if (zkey2.protocolId !== FFLONK_PROTOCOL_ID) {
    throw new Error("zkey file is not fflonk");
  }
  if (!Scalar.eq(zkey2.r, wtns2.q)) {
    throw new Error("Curve of the witness does not match the curve of the proving key");
  }
  if (wtns2.nWitness !== zkey2.nVars - zkey2.nAdditions) {
    throw new Error(`Invalid witness length. Circuit: ${zkey2.nVars}, witness: ${wtns2.nWitness}, ${zkey2.nAdditions}`);
  }
  const curve2 = zkey2.curve;
  const Fr = curve2.Fr;
  const sFr = curve2.Fr.n8;
  const sG1 = curve2.G1.F.n8 * 2;
  const sDomain = zkey2.domainSize * sFr;
  if (logger) {
    logger.info("----------------------------");
    logger.info("  FFLONK PROVE SETTINGS");
    logger.info(`  Curve:         ${curve2.name}`);
    logger.info(`  Circuit power: ${zkey2.power}`);
    logger.info(`  Domain size:   ${zkey2.domainSize}`);
    logger.info(`  Vars:          ${zkey2.nVars}`);
    logger.info(`  Public vars:   ${zkey2.nPublic}`);
    logger.info(`  Constraints:   ${zkey2.nConstraints}`);
    logger.info(`  Additions:     ${zkey2.nAdditions}`);
    logger.info("----------------------------");
  }
  if (logger) logger.info("> Reading witness file data");
  const buffWitness = await readSection(fdWtns, wtnsSections, 2);
  await fdWtns.close();
  buffWitness.set(Fr.zero, 0);
  const buffInternalWitness = new BigBuffer(zkey2.nAdditions * sFr);
  let buffers = {};
  let polynomials = {};
  let evaluations = {};
  let toInverse = {};
  let challenges = {};
  let roots = {};
  let proof = new Proof(curve2, logger);
  if (logger) logger.info(`> Reading Section ${ZKEY_FF_ADDITIONS_SECTION}. Additions`);
  await calculateAdditions();
  if (logger) logger.info(`> Reading Sections ${ZKEY_FF_SIGMA1_SECTION},${ZKEY_FF_SIGMA2_SECTION},${ZKEY_FF_SIGMA3_SECTION}. Sigma1, Sigma2 & Sigma 3`);
  if (logger) logger.info(" Reading Sigma polynomials ");
  polynomials.Sigma1 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  polynomials.Sigma2 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  polynomials.Sigma3 = new Polynomial(new BigBuffer(sDomain), curve2, logger);
  await fdZKey.readToBuffer(polynomials.Sigma1.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p);
  await fdZKey.readToBuffer(polynomials.Sigma2.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p);
  await fdZKey.readToBuffer(polynomials.Sigma3.coef, 0, sDomain, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p);
  if (logger) logger.info(" Reading Sigma evaluations");
  evaluations.Sigma1 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  evaluations.Sigma2 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  evaluations.Sigma3 = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
  await fdZKey.readToBuffer(evaluations.Sigma1.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA1_SECTION][0].p + sDomain);
  await fdZKey.readToBuffer(evaluations.Sigma2.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA2_SECTION][0].p + sDomain);
  await fdZKey.readToBuffer(evaluations.Sigma3.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_SIGMA3_SECTION][0].p + sDomain);
  if (logger) logger.info(`> Reading Section ${ZKEY_FF_PTAU_SECTION}. Powers of Tau`);
  const PTau = new BigBuffer(zkey2.domainSize * 16 * sG1);
  await fdZKey.readToBuffer(PTau, 0, (zkey2.domainSize * 9 + 18) * sG1, zkeySections[ZKEY_FF_PTAU_SECTION][0].p);
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("");
  if (logger) logger.info("> ROUND 1");
  await round1();
  delete polynomials.T0;
  delete evaluations.QL;
  delete evaluations.QR;
  delete evaluations.QM;
  delete evaluations.QO;
  delete evaluations.QC;
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("> ROUND 2");
  await round2();
  delete buffers.A;
  delete buffers.B;
  delete buffers.C;
  delete evaluations.A;
  delete evaluations.B;
  delete evaluations.C;
  delete evaluations.Sigma1;
  delete evaluations.Sigma2;
  delete evaluations.Sigma3;
  delete evaluations.lagrange1;
  delete evaluations.Z;
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("> ROUND 3");
  await round3();
  delete polynomials.A;
  delete polynomials.B;
  delete polynomials.C;
  delete polynomials.Z;
  delete polynomials.T1;
  delete polynomials.T2;
  delete polynomials.Sigma1;
  delete polynomials.Sigma2;
  delete polynomials.Sigma3;
  delete polynomials.QL;
  delete polynomials.QR;
  delete polynomials.QM;
  delete polynomials.QC;
  delete polynomials.QO;
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("> ROUND 4");
  await round4();
  if (globalThis.gc) globalThis.gc();
  if (logger) logger.info("> ROUND 5");
  await round5();
  delete polynomials.C0;
  delete polynomials.C1;
  delete polynomials.C2;
  delete polynomials.R1;
  delete polynomials.R2;
  delete polynomials.F;
  delete polynomials.L;
  delete polynomials.ZT;
  delete polynomials.ZTS2;
  await fdZKey.close();
  if (globalThis.gc) globalThis.gc();
  proof.addEvaluation("inv", getMontgomeryBatchedInverse());
  let _proof = proof.toObjectProof();
  _proof.protocol = "fflonk";
  _proof.curve = curve2.name;
  let publicSignals = [];
  for (let i2 = 1; i2 <= zkey2.nPublic; i2++) {
    const i_sFr = i2 * sFr;
    const pub = buffWitness.slice(i_sFr, i_sFr + sFr);
    publicSignals.push(Scalar.fromRprLE(pub));
  }
  if (logger) logger.info("FFLONK PROVER FINISHED");
  return {
    proof: stringifyBigInts2(_proof),
    publicSignals: stringifyBigInts2(publicSignals)
  };
  async function calculateAdditions() {
    if (logger) logger.info(" Computing additions");
    const additionsBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_ADDITIONS_SECTION);
    const sSum = 8 + sFr * 2;
    for (let i2 = 0; i2 < zkey2.nAdditions; i2++) {
      if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.info(`    addition ${i2}/${zkey2.nAdditions}`);
      let offset = i2 * sSum;
      const signalId1 = readUInt32(additionsBuff, offset);
      offset += 4;
      const signalId2 = readUInt32(additionsBuff, offset);
      offset += 4;
      const factor1 = additionsBuff.slice(offset, offset + sFr);
      offset += sFr;
      const factor2 = additionsBuff.slice(offset, offset + sFr);
      const witness1 = getWitness(signalId1);
      const witness2 = getWitness(signalId2);
      const result = Fr.add(Fr.mul(factor1, witness1), Fr.mul(factor2, witness2));
      buffInternalWitness.set(result, sFr * i2);
    }
  }
  function readUInt32(b2, o2) {
    const buff = b2.slice(o2, o2 + 4);
    const buffV = new DataView(buff.buffer, buff.byteOffset, buff.byteLength);
    return buffV.getUint32(0, true);
  }
  function getWitness(idx) {
    let diff = zkey2.nVars - zkey2.nAdditions;
    if (idx < diff) {
      return buffWitness.slice(idx * sFr, idx * sFr + sFr);
    } else if (idx < zkey2.nVars) {
      const offset = (idx - diff) * sFr;
      return buffInternalWitness.slice(offset, offset + sFr);
    }
    return Fr.zero;
  }
  async function round1() {
    challenges.b = [];
    for (let i2 = 1; i2 <= 9; i2++) {
      challenges.b[i2] = Fr.random();
    }
    if (logger) logger.info("> Computing A, B, C wire polynomials");
    await computeWirePolynomials();
    if (logger) logger.info("> Computing T0 polynomial");
    await computeT0();
    if (logger) logger.info("> Computing C1 polynomial");
    await computeC1();
    if (logger) logger.info("> Computing C1 multi exponentiation");
    let commitC1 = await polynomials.C1.multiExponentiation(PTau, "C1");
    proof.addPolynomial("C1", commitC1);
    return 0;
    async function computeWirePolynomials() {
      if (logger) logger.info(" Reading data from zkey file");
      buffers.A = new BigBuffer(sDomain);
      buffers.B = new BigBuffer(sDomain);
      buffers.C = new BigBuffer(sDomain);
      const aMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_A_MAP_SECTION);
      const bMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_B_MAP_SECTION);
      const cMapBuff = await readSection(fdZKey, zkeySections, ZKEY_FF_C_MAP_SECTION);
      for (let i2 = 0; i2 < zkey2.nConstraints; i2++) {
        const i_sFr = i2 * sFr;
        const offset = i2 * 4;
        const signalIdA = readUInt32(aMapBuff, offset);
        buffers.A.set(getWitness(signalIdA), i_sFr);
        const signalIdB = readUInt32(bMapBuff, offset);
        buffers.B.set(getWitness(signalIdB), i_sFr);
        const signalIdC = readUInt32(cMapBuff, offset);
        buffers.C.set(getWitness(signalIdC), i_sFr);
      }
      buffers.A.set(challenges.b[1], sDomain - 64);
      buffers.A.set(challenges.b[2], sDomain - 32);
      buffers.B.set(challenges.b[3], sDomain - 64);
      buffers.B.set(challenges.b[4], sDomain - 32);
      buffers.C.set(challenges.b[5], sDomain - 64);
      buffers.C.set(challenges.b[6], sDomain - 32);
      buffers.A = await Fr.batchToMontgomery(buffers.A);
      buffers.B = await Fr.batchToMontgomery(buffers.B);
      buffers.C = await Fr.batchToMontgomery(buffers.C);
      if (logger) logger.info(" Computing A ifft");
      polynomials.A = await Polynomial.fromEvaluations(buffers.A, curve2, logger);
      if (logger) logger.info(" Computing B ifft");
      polynomials.B = await Polynomial.fromEvaluations(buffers.B, curve2, logger);
      if (logger) logger.info(" Computing C ifft");
      polynomials.C = await Polynomial.fromEvaluations(buffers.C, curve2, logger);
      if (logger) logger.info(" Computing A fft");
      evaluations.A = await Evaluations.fromPolynomial(polynomials.A, 4, curve2, logger);
      if (logger) logger.info(" Computing B fft");
      evaluations.B = await Evaluations.fromPolynomial(polynomials.B, 4, curve2, logger);
      if (logger) logger.info(" Computing C fft");
      evaluations.C = await Evaluations.fromPolynomial(polynomials.C, 4, curve2, logger);
      if (polynomials.A.degree() >= zkey2.domainSize) {
        throw new Error("A Polynomial is not well calculated");
      }
      if (polynomials.B.degree() >= zkey2.domainSize) {
        throw new Error("B Polynomial is not well calculated");
      }
      if (polynomials.C.degree() >= zkey2.domainSize) {
        throw new Error("C Polynomial is not well calculated");
      }
    }
    async function computeT0() {
      if (logger) logger.info(` Reading sections ${ZKEY_FF_QL_SECTION}, ${ZKEY_FF_QR_SECTION}, ${ZKEY_FF_QM_SECTION}, ${ZKEY_FF_QO_SECTION}, ${ZKEY_FF_QC_SECTION}. Q selectors`);
      evaluations.QL = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
      evaluations.QR = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
      evaluations.QM = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
      evaluations.QO = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
      evaluations.QC = new Evaluations(new BigBuffer(sDomain * 4), curve2, logger);
      await fdZKey.readToBuffer(evaluations.QL.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QL_SECTION][0].p + sDomain);
      await fdZKey.readToBuffer(evaluations.QR.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QR_SECTION][0].p + sDomain);
      await fdZKey.readToBuffer(evaluations.QM.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QM_SECTION][0].p + sDomain);
      await fdZKey.readToBuffer(evaluations.QO.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QO_SECTION][0].p + sDomain);
      await fdZKey.readToBuffer(evaluations.QC.eval, 0, sDomain * 4, zkeySections[ZKEY_FF_QC_SECTION][0].p + sDomain);
      const lagrangePolynomials = await readSection(fdZKey, zkeySections, ZKEY_FF_LAGRANGE_SECTION);
      evaluations.lagrange1 = new Evaluations(lagrangePolynomials, curve2, logger);
      buffers.T0 = new BigBuffer(sDomain * 4);
      if (logger) logger.info(" Computing T0 evaluations");
      for (let i2 = 0; i2 < zkey2.domainSize * 4; i2++) {
        if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.info(`      T0 evaluation ${i2}/${zkey2.domainSize * 4}`);
        const a2 = evaluations.A.getEvaluation(i2);
        const b2 = evaluations.B.getEvaluation(i2);
        const c2 = evaluations.C.getEvaluation(i2);
        const ql = evaluations.QL.getEvaluation(i2);
        const qr = evaluations.QR.getEvaluation(i2);
        const qm = evaluations.QM.getEvaluation(i2);
        const qo = evaluations.QO.getEvaluation(i2);
        const qc = evaluations.QC.getEvaluation(i2);
        let pi = Fr.zero;
        for (let j2 = 0; j2 < zkey2.nPublic; j2++) {
          const offset = j2 * 5 * zkey2.domainSize + zkey2.domainSize + i2;
          const lPol = evaluations.lagrange1.getEvaluation(offset);
          const aVal = buffers.A.slice(j2 * sFr, (j2 + 1) * sFr);
          pi = Fr.sub(pi, Fr.mul(lPol, aVal));
        }
        const e1 = Fr.mul(a2, ql);
        const e2 = Fr.mul(b2, qr);
        const e3 = Fr.mul(Fr.mul(a2, b2), qm);
        const e4 = Fr.mul(c2, qo);
        const t0 = Fr.add(e1, Fr.add(e2, Fr.add(e3, Fr.add(e4, Fr.add(qc, pi)))));
        buffers.T0.set(t0, i2 * sFr);
      }
      if (logger) logger.info("buffer T0: " + buffers.T0.byteLength / sFr);
      if (logger) logger.info(" Computing T0 ifft");
      polynomials.T0 = await Polynomial.fromEvaluations(buffers.T0, curve2, logger);
      if (logger) logger.info("T0 length: " + polynomials.T0.length());
      if (logger) logger.info("T0 degree: " + polynomials.T0.degree());
      if (logger) logger.info(" Computing T0 / ZH");
      polynomials.T0.divByZerofier(zkey2.domainSize, Fr.one);
      if (polynomials.T0.degree() >= 2 * zkey2.domainSize - 2) {
        throw new Error(`T0 Polynomial is not well calculated (degree is ${polynomials.T0.degree()} and must be less than ${2 * zkey2.domainSize + 2}`);
      }
      delete buffers.T0;
    }
    async function computeC1() {
      let C1 = new CPolynomial(4, curve2, logger);
      C1.addPolynomial(0, polynomials.A);
      C1.addPolynomial(1, polynomials.B);
      C1.addPolynomial(2, polynomials.C);
      C1.addPolynomial(3, polynomials.T0);
      polynomials.C1 = C1.getPolynomial();
      if (polynomials.C1.degree() >= 8 * zkey2.domainSize - 8) {
        throw new Error("C1 Polynomial is not well calculated");
      }
    }
  }
  async function round2() {
    if (logger) logger.info("> Computing challenges beta and gamma");
    const transcript = new Keccak256Transcript(curve2);
    transcript.addPolCommitment(zkey2.C0);
    for (let i2 = 0; i2 < zkey2.nPublic; i2++) {
      transcript.addScalar(buffers.A.slice(i2 * sFr, i2 * sFr + sFr));
    }
    transcript.addPolCommitment(proof.getPolynomial("C1"));
    challenges.beta = transcript.getChallenge();
    if (logger) logger.info(" challenges.beta: " + Fr.toString(challenges.beta));
    transcript.reset();
    transcript.addScalar(challenges.beta);
    challenges.gamma = transcript.getChallenge();
    if (logger) logger.info(" challenges.gamma: " + Fr.toString(challenges.gamma));
    if (logger) logger.info("> Computing Z polynomial");
    await computeZ();
    if (logger) logger.info("> Computing T1 polynomial");
    await computeT1();
    if (logger) logger.info("> Computing T2 polynomial");
    await computeT2();
    if (logger) logger.info("> Computing C2 polynomial");
    await computeC2();
    if (logger) logger.info("> Computing C2 multi exponentiation");
    let commitC2 = await polynomials.C2.multiExponentiation(PTau, "C2");
    proof.addPolynomial("C2", commitC2);
    return 0;
    async function computeZ() {
      if (logger) logger.info(" Computing Z evaluations");
      let numArr = new BigBuffer(sDomain);
      let denArr = new BigBuffer(sDomain);
      numArr.set(Fr.one, 0);
      denArr.set(Fr.one, 0);
      let w2 = Fr.one;
      for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
        if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.info(`    Z evaluation ${i2}/${zkey2.domainSize}`);
        const i_sFr = i2 * sFr;
        const betaw = Fr.mul(challenges.beta, w2);
        let num1 = buffers.A.slice(i_sFr, i_sFr + sFr);
        num1 = Fr.add(num1, betaw);
        num1 = Fr.add(num1, challenges.gamma);
        let num2 = buffers.B.slice(i_sFr, i_sFr + sFr);
        num2 = Fr.add(num2, Fr.mul(zkey2.k1, betaw));
        num2 = Fr.add(num2, challenges.gamma);
        let num3 = buffers.C.slice(i_sFr, i_sFr + sFr);
        num3 = Fr.add(num3, Fr.mul(zkey2.k2, betaw));
        num3 = Fr.add(num3, challenges.gamma);
        let num = Fr.mul(num1, Fr.mul(num2, num3));
        let den1 = buffers.A.slice(i_sFr, i_sFr + sFr);
        den1 = Fr.add(den1, Fr.mul(challenges.beta, evaluations.Sigma1.getEvaluation(i2 * 4)));
        den1 = Fr.add(den1, challenges.gamma);
        let den2 = buffers.B.slice(i_sFr, i_sFr + sFr);
        den2 = Fr.add(den2, Fr.mul(challenges.beta, evaluations.Sigma2.getEvaluation(i2 * 4)));
        den2 = Fr.add(den2, challenges.gamma);
        let den3 = buffers.C.slice(i_sFr, i_sFr + sFr);
        den3 = Fr.add(den3, Fr.mul(challenges.beta, evaluations.Sigma3.getEvaluation(i2 * 4)));
        den3 = Fr.add(den3, challenges.gamma);
        let den = Fr.mul(den1, Fr.mul(den2, den3));
        num = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), num);
        numArr.set(num, (i2 + 1) % zkey2.domainSize * sFr);
        den = Fr.mul(denArr.slice(i_sFr, i_sFr + sFr), den);
        denArr.set(den, (i2 + 1) % zkey2.domainSize * sFr);
        w2 = Fr.mul(w2, Fr.w[zkey2.power]);
      }
      denArr = await Fr.batchInverse(denArr);
      for (let i2 = 0; i2 < zkey2.domainSize; i2++) {
        const i_sFr = i2 * sFr;
        const z2 = Fr.mul(numArr.slice(i_sFr, i_sFr + sFr), denArr.slice(i_sFr, i_sFr + sFr));
        numArr.set(z2, i_sFr);
      }
      buffers.Z = numArr;
      if (!Fr.eq(numArr.slice(0, sFr), Fr.one)) {
        throw new Error("Copy constraints does not match");
      }
      if (logger) logger.info(" Computing Z ifft");
      polynomials.Z = await Polynomial.fromEvaluations(buffers.Z, curve2, logger);
      if (logger) logger.info(" Computing Z fft");
      evaluations.Z = await Evaluations.fromPolynomial(polynomials.Z, 4, curve2, logger);
      polynomials.Z.blindCoefficients([challenges.b[9], challenges.b[8], challenges.b[7]]);
      if (polynomials.Z.degree() >= zkey2.domainSize + 3) {
        throw new Error("Z Polynomial is not well calculated");
      }
      delete buffers.Z;
    }
    async function computeT1() {
      if (logger) logger.info(" Computing T1 evaluations");
      buffers.T1 = new BigBuffer(sDomain * 2);
      buffers.T1z = new BigBuffer(sDomain * 2);
      let omega = Fr.one;
      for (let i2 = 0; i2 < zkey2.domainSize * 2; i2++) {
        if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.info(`    T1 evaluation ${i2}/${zkey2.domainSize * 4}`);
        const omega2 = Fr.square(omega);
        const z2 = evaluations.Z.getEvaluation(i2 * 2);
        const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);
        const lagrange1 = evaluations.lagrange1.getEvaluation(zkey2.domainSize + i2 * 2);
        let t1 = Fr.mul(Fr.sub(z2, Fr.one), lagrange1);
        let t1z = Fr.mul(zp, lagrange1);
        buffers.T1.set(t1, i2 * sFr);
        buffers.T1z.set(t1z, i2 * sFr);
        omega = Fr.mul(omega, Fr.w[zkey2.power + 1]);
      }
      if (logger) logger.info(" Computing T1 ifft");
      polynomials.T1 = await Polynomial.fromEvaluations(buffers.T1, curve2, logger);
      polynomials.T1.divByZerofier(zkey2.domainSize, Fr.one);
      if (logger) logger.info(" Computing T1z ifft");
      polynomials.T1z = await Polynomial.fromEvaluations(buffers.T1z, curve2, logger);
      polynomials.T1.add(polynomials.T1z);
      if (polynomials.T1.degree() >= zkey2.domainSize + 2) {
        throw new Error("T1 Polynomial is not well calculated");
      }
      delete buffers.T1;
      delete buffers.T1z;
      delete polynomials.T1z;
    }
    async function computeT2() {
      if (logger) logger.info(" Computing T2 evaluations");
      buffers.T2 = new BigBuffer(sDomain * 4);
      buffers.T2z = new BigBuffer(sDomain * 4);
      let omega = Fr.one;
      for (let i2 = 0; i2 < zkey2.domainSize * 4; i2++) {
        if (logger && 0 !== i2 && i2 % 1e5 === 0) logger.info(`    T2 evaluation ${i2}/${zkey2.domainSize * 4}`);
        const omega2 = Fr.square(omega);
        const omegaW = Fr.mul(omega, Fr.w[zkey2.power]);
        const omegaW2 = Fr.square(omegaW);
        const a2 = evaluations.A.getEvaluation(i2);
        const b2 = evaluations.B.getEvaluation(i2);
        const c2 = evaluations.C.getEvaluation(i2);
        const z2 = evaluations.Z.getEvaluation(i2);
        const zW = evaluations.Z.getEvaluation((zkey2.domainSize * 4 + 4 + i2) % (zkey2.domainSize * 4));
        const zp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omega2), Fr.mul(challenges.b[8], omega)), challenges.b[9]);
        const zWp = Fr.add(Fr.add(Fr.mul(challenges.b[7], omegaW2), Fr.mul(challenges.b[8], omegaW)), challenges.b[9]);
        const sigma1 = evaluations.Sigma1.getEvaluation(i2);
        const sigma2 = evaluations.Sigma2.getEvaluation(i2);
        const sigma3 = evaluations.Sigma3.getEvaluation(i2);
        const betaX = Fr.mul(challenges.beta, omega);
        let e11 = Fr.add(a2, betaX);
        e11 = Fr.add(e11, challenges.gamma);
        let e12 = Fr.add(b2, Fr.mul(betaX, zkey2.k1));
        e12 = Fr.add(e12, challenges.gamma);
        let e13 = Fr.add(c2, Fr.mul(betaX, zkey2.k2));
        e13 = Fr.add(e13, challenges.gamma);
        let e1 = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), z2);
        let e1z = Fr.mul(Fr.mul(Fr.mul(e11, e12), e13), zp);
        let e21 = Fr.add(a2, Fr.mul(challenges.beta, sigma1));
        e21 = Fr.add(e21, challenges.gamma);
        let e22 = Fr.add(b2, Fr.mul(challenges.beta, sigma2));
        e22 = Fr.add(e22, challenges.gamma);
        let e23 = Fr.add(c2, Fr.mul(challenges.beta, sigma3));
        e23 = Fr.add(e23, challenges.gamma);
        let e2 = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zW);
        let e2z = Fr.mul(Fr.mul(Fr.mul(e21, e22), e23), zWp);
        let t2 = Fr.sub(e1, e2);
        let t2z = Fr.sub(e1z, e2z);
        buffers.T2.set(t2, i2 * sFr);
        buffers.T2z.set(t2z, i2 * sFr);
        omega = Fr.mul(omega, Fr.w[zkey2.power + 2]);
      }
      if (logger) logger.info(" Computing T2 ifft");
      polynomials.T2 = await Polynomial.fromEvaluations(buffers.T2, curve2, logger);
      if (logger) logger.info(" Computing T2 / ZH");
      polynomials.T2.divByZerofier(zkey2.domainSize, Fr.one);
      if (logger) logger.info(" Computing T2z ifft");
      polynomials.T2z = await Polynomial.fromEvaluations(buffers.T2z, curve2, logger);
      polynomials.T2.add(polynomials.T2z);
      if (polynomials.T2.degree() >= 3 * zkey2.domainSize) {
        throw new Error("T2 Polynomial is not well calculated");
      }
      delete buffers.T2;
      delete buffers.T2z;
      delete polynomials.T2z;
    }
    async function computeC2() {
      let C2 = new CPolynomial(3, curve2, logger);
      C2.addPolynomial(0, polynomials.Z);
      C2.addPolynomial(1, polynomials.T1);
      C2.addPolynomial(2, polynomials.T2);
      polynomials.C2 = C2.getPolynomial();
      if (polynomials.C2.degree() >= 9 * zkey2.domainSize) {
        throw new Error("C2 Polynomial is not well calculated");
      }
    }
  }
  async function round3() {
    if (logger) logger.info("> Computing challenge xi");
    const transcript = new Keccak256Transcript(curve2);
    transcript.addScalar(challenges.gamma);
    transcript.addPolCommitment(proof.getPolynomial("C2"));
    challenges.xiSeed = transcript.getChallenge();
    const xiSeed2 = Fr.square(challenges.xiSeed);
    roots.w8 = [];
    roots.w8[0] = Fr.one;
    for (let i2 = 1; i2 < 8; i2++) {
      roots.w8[i2] = Fr.mul(roots.w8[i2 - 1], zkey2.w8);
    }
    roots.w4 = [];
    roots.w4[0] = Fr.one;
    for (let i2 = 1; i2 < 4; i2++) {
      roots.w4[i2] = Fr.mul(roots.w4[i2 - 1], zkey2.w4);
    }
    roots.w3 = [];
    roots.w3[0] = Fr.one;
    roots.w3[1] = zkey2.w3;
    roots.w3[2] = Fr.square(zkey2.w3);
    roots.S0 = {};
    roots.S0.h0w8 = [];
    roots.S0.h0w8[0] = Fr.mul(xiSeed2, challenges.xiSeed);
    for (let i2 = 1; i2 < 8; i2++) {
      roots.S0.h0w8[i2] = Fr.mul(roots.S0.h0w8[0], roots.w8[i2]);
    }
    roots.S1 = {};
    roots.S1.h1w4 = [];
    roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);
    for (let i2 = 1; i2 < 4; i2++) {
      roots.S1.h1w4[i2] = Fr.mul(roots.S1.h1w4[0], roots.w4[i2]);
    }
    roots.S2 = {};
    roots.S2.h2w3 = [];
    roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);
    roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], roots.w3[1]);
    roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], roots.w3[2]);
    roots.S2.h3w3 = [];
    roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], zkey2.wr);
    roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], roots.w3[1]);
    roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], roots.w3[2]);
    challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);
    if (logger) logger.info(" challenges.xi: " + Fr.toString(challenges.xi));
    polynomials.QL = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QR = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QM = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QO = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    polynomials.QC = new Polynomial(new BigBuffer(sDomain), curve2, logger);
    await fdZKey.readToBuffer(polynomials.QL.coef, 0, sDomain, zkeySections[ZKEY_FF_QL_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QR.coef, 0, sDomain, zkeySections[ZKEY_FF_QR_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QM.coef, 0, sDomain, zkeySections[ZKEY_FF_QM_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QO.coef, 0, sDomain, zkeySections[ZKEY_FF_QO_SECTION][0].p);
    await fdZKey.readToBuffer(polynomials.QC.coef, 0, sDomain, zkeySections[ZKEY_FF_QC_SECTION][0].p);
    if (logger) logger.info(" Computing evaluations");
    proof.addEvaluation("ql", polynomials.QL.evaluate(challenges.xi));
    proof.addEvaluation("qr", polynomials.QR.evaluate(challenges.xi));
    proof.addEvaluation("qm", polynomials.QM.evaluate(challenges.xi));
    proof.addEvaluation("qo", polynomials.QO.evaluate(challenges.xi));
    proof.addEvaluation("qc", polynomials.QC.evaluate(challenges.xi));
    proof.addEvaluation("s1", polynomials.Sigma1.evaluate(challenges.xi));
    proof.addEvaluation("s2", polynomials.Sigma2.evaluate(challenges.xi));
    proof.addEvaluation("s3", polynomials.Sigma3.evaluate(challenges.xi));
    proof.addEvaluation("a", polynomials.A.evaluate(challenges.xi));
    proof.addEvaluation("b", polynomials.B.evaluate(challenges.xi));
    proof.addEvaluation("c", polynomials.C.evaluate(challenges.xi));
    proof.addEvaluation("z", polynomials.Z.evaluate(challenges.xi));
    challenges.xiw = Fr.mul(challenges.xi, Fr.w[zkey2.power]);
    proof.addEvaluation("zw", polynomials.Z.evaluate(challenges.xiw));
    proof.addEvaluation("t1w", polynomials.T1.evaluate(challenges.xiw));
    proof.addEvaluation("t2w", polynomials.T2.evaluate(challenges.xiw));
  }
  async function round4() {
    if (logger) logger.info("> Computing challenge alpha");
    const transcript = new Keccak256Transcript(curve2);
    transcript.addScalar(challenges.xiSeed);
    transcript.addScalar(proof.getEvaluation("ql"));
    transcript.addScalar(proof.getEvaluation("qr"));
    transcript.addScalar(proof.getEvaluation("qm"));
    transcript.addScalar(proof.getEvaluation("qo"));
    transcript.addScalar(proof.getEvaluation("qc"));
    transcript.addScalar(proof.getEvaluation("s1"));
    transcript.addScalar(proof.getEvaluation("s2"));
    transcript.addScalar(proof.getEvaluation("s3"));
    transcript.addScalar(proof.getEvaluation("a"));
    transcript.addScalar(proof.getEvaluation("b"));
    transcript.addScalar(proof.getEvaluation("c"));
    transcript.addScalar(proof.getEvaluation("z"));
    transcript.addScalar(proof.getEvaluation("zw"));
    transcript.addScalar(proof.getEvaluation("t1w"));
    transcript.addScalar(proof.getEvaluation("t2w"));
    challenges.alpha = transcript.getChallenge();
    if (logger) logger.info(" challenges.alpha: " + Fr.toString(challenges.alpha));
    if (logger) logger.info("> Reading C0 polynomial");
    polynomials.C0 = new Polynomial(new BigBuffer(sDomain * 8), curve2, logger);
    await fdZKey.readToBuffer(polynomials.C0.coef, 0, sDomain * 8, zkeySections[ZKEY_FF_C0_SECTION][0].p);
    if (logger) logger.info("> Computing R0 polynomial");
    computeR02();
    if (logger) logger.info("> Computing R1 polynomial");
    computeR12();
    if (logger) logger.info("> Computing R2 polynomial");
    computeR22();
    if (logger) logger.info("> Computing F polynomial");
    await computeF2();
    if (logger) logger.info("> Computing W1 multi exponentiation");
    let commitW1 = await polynomials.F.multiExponentiation(PTau, "W1");
    proof.addPolynomial("W1", commitW1);
    return 0;
    function computeR02() {
      polynomials.R0 = Polynomial.lagrangePolynomialInterpolation(
        [
          roots.S0.h0w8[0],
          roots.S0.h0w8[1],
          roots.S0.h0w8[2],
          roots.S0.h0w8[3],
          roots.S0.h0w8[4],
          roots.S0.h0w8[5],
          roots.S0.h0w8[6],
          roots.S0.h0w8[7]
        ],
        [
          polynomials.C0.evaluate(roots.S0.h0w8[0]),
          polynomials.C0.evaluate(roots.S0.h0w8[1]),
          polynomials.C0.evaluate(roots.S0.h0w8[2]),
          polynomials.C0.evaluate(roots.S0.h0w8[3]),
          polynomials.C0.evaluate(roots.S0.h0w8[4]),
          polynomials.C0.evaluate(roots.S0.h0w8[5]),
          polynomials.C0.evaluate(roots.S0.h0w8[6]),
          polynomials.C0.evaluate(roots.S0.h0w8[7])
        ],
        curve2
      );
      if (polynomials.R0.degree() > 7) {
        throw new Error("R0 Polynomial is not well calculated");
      }
    }
    function computeR12() {
      polynomials.R1 = Polynomial.lagrangePolynomialInterpolation(
        [roots.S1.h1w4[0], roots.S1.h1w4[1], roots.S1.h1w4[2], roots.S1.h1w4[3]],
        [
          polynomials.C1.evaluate(roots.S1.h1w4[0]),
          polynomials.C1.evaluate(roots.S1.h1w4[1]),
          polynomials.C1.evaluate(roots.S1.h1w4[2]),
          polynomials.C1.evaluate(roots.S1.h1w4[3])
        ],
        curve2
      );
      if (polynomials.R1.degree() > 3) {
        throw new Error("R1 Polynomial is not well calculated");
      }
    }
    function computeR22() {
      polynomials.R2 = Polynomial.lagrangePolynomialInterpolation(
        [
          roots.S2.h2w3[0],
          roots.S2.h2w3[1],
          roots.S2.h2w3[2],
          roots.S2.h3w3[0],
          roots.S2.h3w3[1],
          roots.S2.h3w3[2]
        ],
        [
          polynomials.C2.evaluate(roots.S2.h2w3[0]),
          polynomials.C2.evaluate(roots.S2.h2w3[1]),
          polynomials.C2.evaluate(roots.S2.h2w3[2]),
          polynomials.C2.evaluate(roots.S2.h3w3[0]),
          polynomials.C2.evaluate(roots.S2.h3w3[1]),
          polynomials.C2.evaluate(roots.S2.h3w3[2])
        ],
        curve2
      );
      if (polynomials.R2.degree() > 5) {
        throw new Error("R2 Polynomial is not well calculated");
      }
    }
    async function computeF2() {
      if (logger) logger.info(" Computing F polynomial");
      polynomials.F = Polynomial.fromPolynomial(polynomials.C0, curve2, logger);
      polynomials.F.sub(polynomials.R0);
      polynomials.F.divByZerofier(8, challenges.xi);
      let f2 = Polynomial.fromPolynomial(polynomials.C1, curve2, logger);
      f2.sub(polynomials.R1);
      f2.mulScalar(challenges.alpha);
      f2.divByZerofier(4, challenges.xi);
      let f3 = Polynomial.fromPolynomial(polynomials.C2, curve2, logger);
      f3.sub(polynomials.R2);
      f3.mulScalar(Fr.square(challenges.alpha));
      f3.divByZerofier(3, challenges.xi);
      f3.divByZerofier(3, challenges.xiw);
      polynomials.F.add(f2);
      polynomials.F.add(f3);
      if (polynomials.F.degree() >= 9 * zkey2.domainSize - 6) {
        throw new Error("F Polynomial is not well calculated");
      }
    }
  }
  async function round5() {
    if (logger) logger.info("> Computing challenge y");
    const transcript = new Keccak256Transcript(curve2);
    transcript.addScalar(challenges.alpha);
    transcript.addPolCommitment(proof.getPolynomial("W1"));
    challenges.y = transcript.getChallenge();
    if (logger) logger.info(" challenges.y: " + Fr.toString(challenges.y));
    if (logger) logger.info("> Computing L polynomial");
    await computeL();
    if (logger) logger.info("> Computing ZTS2 polynomial");
    await computeZTS2();
    let ZTS2Y = polynomials.ZTS2.evaluate(challenges.y);
    ZTS2Y = Fr.inv(ZTS2Y);
    polynomials.L.mulScalar(ZTS2Y);
    const polDividend = Polynomial.fromCoefficientsArray([Fr.neg(challenges.y), Fr.one], curve2);
    if (logger) logger.info("> Computing W' = L / ZTS2 polynomial");
    const polRemainder = polynomials.L.divBy(polDividend);
    if (polRemainder.degree() > 0) {
      throw new Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${polRemainder.degree()} and should be 0`);
    }
    if (polynomials.L.degree() >= 9 * zkey2.domainSize - 1) {
      throw new Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");
    }
    if (logger) logger.info("> Computing W' multi exponentiation");
    let commitW2 = await polynomials.L.multiExponentiation(PTau, "W2");
    proof.addPolynomial("W2", commitW2);
    return 0;
    async function computeL() {
      if (logger) logger.info(" Computing L polynomial");
      const evalR0Y = polynomials.R0.evaluate(challenges.y);
      const evalR1Y = polynomials.R1.evaluate(challenges.y);
      const evalR2Y = polynomials.R2.evaluate(challenges.y);
      let mulL0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);
      for (let i2 = 1; i2 < 8; i2++) {
        mulL0 = Fr.mul(mulL0, Fr.sub(challenges.y, roots.S0.h0w8[i2]));
      }
      let mulL1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);
      for (let i2 = 1; i2 < 4; i2++) {
        mulL1 = Fr.mul(mulL1, Fr.sub(challenges.y, roots.S1.h1w4[i2]));
      }
      let mulL2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);
      for (let i2 = 1; i2 < 3; i2++) {
        mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h2w3[i2]));
      }
      for (let i2 = 0; i2 < 3; i2++) {
        mulL2 = Fr.mul(mulL2, Fr.sub(challenges.y, roots.S2.h3w3[i2]));
      }
      let preL0 = Fr.mul(mulL1, mulL2);
      let preL1 = Fr.mul(challenges.alpha, Fr.mul(mulL0, mulL2));
      let preL2 = Fr.mul(Fr.square(challenges.alpha), Fr.mul(mulL0, mulL1));
      toInverse["denH1"] = mulL1;
      toInverse["denH2"] = mulL2;
      polynomials.L = Polynomial.fromPolynomial(polynomials.C0, curve2, logger);
      polynomials.L.subScalar(evalR0Y);
      polynomials.L.mulScalar(preL0);
      let l2 = Polynomial.fromPolynomial(polynomials.C1, curve2, logger);
      l2.subScalar(evalR1Y);
      l2.mulScalar(preL1);
      let l3 = Polynomial.fromPolynomial(polynomials.C2, curve2, logger);
      l3.subScalar(evalR2Y);
      l3.mulScalar(preL2);
      polynomials.L.add(l2);
      polynomials.L.add(l3);
      if (logger) logger.info("> Computing ZT polynomial");
      await computeZT();
      const evalZTY = polynomials.ZT.evaluate(challenges.y);
      polynomials.F.mulScalar(evalZTY);
      polynomials.L.sub(polynomials.F);
      if (polynomials.L.degree() >= 9 * zkey2.domainSize) {
        throw new Error("L Polynomial is not well calculated");
      }
      delete buffers.L;
    }
    async function computeZT() {
      polynomials.ZT = Polynomial.zerofierPolynomial(
        [
          roots.S0.h0w8[0],
          roots.S0.h0w8[1],
          roots.S0.h0w8[2],
          roots.S0.h0w8[3],
          roots.S0.h0w8[4],
          roots.S0.h0w8[5],
          roots.S0.h0w8[6],
          roots.S0.h0w8[7],
          roots.S1.h1w4[0],
          roots.S1.h1w4[1],
          roots.S1.h1w4[2],
          roots.S1.h1w4[3],
          roots.S2.h2w3[0],
          roots.S2.h2w3[1],
          roots.S2.h2w3[2],
          roots.S2.h3w3[0],
          roots.S2.h3w3[1],
          roots.S2.h3w3[2]
        ],
        curve2
      );
    }
    async function computeZTS2() {
      polynomials.ZTS2 = Polynomial.zerofierPolynomial(
        [
          roots.S1.h1w4[0],
          roots.S1.h1w4[1],
          roots.S1.h1w4[2],
          roots.S1.h1w4[3],
          roots.S2.h2w3[0],
          roots.S2.h2w3[1],
          roots.S2.h2w3[2],
          roots.S2.h3w3[0],
          roots.S2.h3w3[1],
          roots.S2.h3w3[2]
        ],
        curve2
      );
    }
  }
  function getMontgomeryBatchedInverse() {
    let xiN = challenges.xi;
    for (let i2 = 0; i2 < zkey2.power; i2++) {
      xiN = Fr.square(xiN);
    }
    toInverse["zh"] = Fr.sub(xiN, Fr.one);
    computeLiS0(toInverse, roots.S0.h0w8, challenges.y, curve2);
    computeLiS1(toInverse, roots.S1.h1w4, challenges.y, curve2);
    computeLiS2(toInverse, roots.S2.h2w3, roots.S2.h3w3, challenges.y, challenges.xi, challenges.xiw, curve2);
    const size = Math.max(1, zkey2.nPublic);
    let w2 = Fr.one;
    for (let i2 = 0; i2 < size; i2++) {
      toInverse["Li_" + (i2 + 1)] = Fr.mul(Fr.e(zkey2.domainSize), Fr.sub(challenges.xi, w2));
      w2 = Fr.mul(w2, Fr.w[zkey2.power]);
    }
    let mulAccumulator = Fr.one;
    for (const element of Object.values(toInverse)) {
      if (Array.isArray(element)) {
        for (const subElement of element) {
          mulAccumulator = Fr.mul(mulAccumulator, subElement);
        }
      } else {
        mulAccumulator = Fr.mul(mulAccumulator, element);
      }
    }
    return Fr.inv(mulAccumulator);
    function computeLiS0(toInverse2, roots2, x2, curve3) {
      const Fr2 = curve3.Fr;
      const len = roots2.length;
      const den1 = Fr2.mul(Fr2.e(len), Fr2.exp(roots2[0], len - 2));
      const Li = [];
      for (let i2 = 0; i2 < len; i2++) {
        const den2 = roots2[(len - 1) * i2 % len];
        const den3 = Fr2.sub(x2, roots2[i2]);
        toInverse2[["LiS0_" + (i2 + 1)]] = Fr2.mul(Fr2.mul(den1, den2), den3);
      }
      return Li;
    }
    function computeLiS1(toInverse2, roots2, x2, curve3) {
      const Fr2 = curve3.Fr;
      const len = roots2.length;
      const den1 = Fr2.mul(Fr2.e(len), Fr2.exp(roots2[0], len - 2));
      const Li = [];
      for (let i2 = 0; i2 < len; i2++) {
        const den2 = roots2[(len - 1) * i2 % len];
        const den3 = Fr2.sub(x2, roots2[i2]);
        toInverse2[["LiS1_" + (i2 + 1)]] = Fr2.mul(Fr2.mul(den1, den2), den3);
      }
      return Li;
    }
    function computeLiS2(toInverse2, S2, S2p, value, xi, xiw, curve3) {
      const Fr2 = curve3.Fr;
      const Li = [];
      const _3h2 = Fr2.mul(Fr2.e(3), S2[0]);
      const xisubxiw = Fr2.sub(xi, xiw);
      let den1 = Fr2.mul(_3h2, xisubxiw);
      for (let i2 = 0; i2 < 3; i2++) {
        const den2 = S2[2 * i2 % 3];
        const den3 = Fr2.sub(value, S2[i2]);
        toInverse2[["LiS2_" + (i2 + 1)]] = Fr2.mul(den1, Fr2.mul(den2, den3));
      }
      const _3h3 = Fr2.mul(Fr2.e(3), S2p[0]);
      const xiwsubxi = Fr2.sub(xiw, xi);
      den1 = Fr2.mul(_3h3, xiwsubxi);
      for (let i2 = 0; i2 < 3; i2++) {
        const den2 = S2p[2 * i2 % 3];
        const den3 = Fr2.sub(value, S2p[i2]);
        toInverse2[["LiS2_" + (i2 + 1 + 3)]] = Fr2.mul(den1, Fr2.mul(den2, den3));
      }
      return Li;
    }
  }
}
async function fflonkFullProve(_input, wasmFilename, zkeyFilename, logger) {
  const input = unstringifyBigInts$2(_input);
  const wtns2 = { type: "mem" };
  await wtnsCalculate(input, wasmFilename, wtns2);
  return await fflonkProve(zkeyFilename, wtns2, logger);
}
async function fflonkVerify(_vk_verifier, _publicSignals, _proof, logger) {
  if (logger) logger.info("FFLONK VERIFIER STARTED");
  _vk_verifier = unstringifyBigInts$1(_vk_verifier);
  _proof = unstringifyBigInts$1(_proof);
  const curve2 = await getCurveFromName(_vk_verifier.curve);
  const vk = fromObjectVk(curve2, _vk_verifier);
  const proof = new Proof(curve2, logger);
  proof.fromObjectProof(_proof);
  const publicSignals = unstringifyBigInts$1(_publicSignals);
  if (publicSignals.length !== vk.nPublic) {
    logger.error("Number of public signals does not match with vk");
    return false;
  }
  const Fr = curve2.Fr;
  if (logger) {
    logger.info("----------------------------");
    logger.info("  FFLONK VERIFY SETTINGS");
    logger.info(`  Curve:         ${curve2.name}`);
    logger.info(`  Circuit power: ${vk.power}`);
    logger.info(`  Domain size:   ${2 ** vk.power}`);
    logger.info(`  Public vars:   ${vk.nPublic}`);
    logger.info("----------------------------");
  }
  if (logger) logger.info("> Checking commitments belong to G1");
  if (!commitmentsBelongToG1(curve2, proof, vk)) {
    if (logger) logger.error("Proof commitments are not valid");
    return false;
  }
  if (logger) logger.info("> Checking evaluations belong to F");
  if (!evaluationsAreValid(curve2, proof)) {
    if (logger) logger.error("Proof evaluations are not valid.");
    return false;
  }
  if (logger) logger.info("> Checking public inputs belong to F");
  if (!publicInputsAreValid(curve2, publicSignals)) {
    if (logger) logger.error("Public inputs are not valid.");
    return false;
  }
  if (logger) logger.info("> Computing challenges");
  const { challenges, roots } = computeChallenges(curve2, proof, vk, publicSignals, logger);
  if (logger) logger.info("> Computing Zero polynomial evaluation Z_H(xi)");
  challenges.zh = Fr.sub(challenges.xiN, Fr.one);
  challenges.invzh = Fr.inv(challenges.zh);
  if (logger) logger.info("> Computing Lagrange evaluations");
  const lagrangeEvals = await computeLagrangeEvaluations(curve2, challenges, vk);
  if (logger) logger.info("> Computing polynomial identities PI(X)");
  const pi = calculatePI(curve2, publicSignals, lagrangeEvals);
  if (logger) logger.info("> Computing r0(y)");
  const r0 = computeR0(proof, challenges, roots, curve2, logger);
  if (logger) logger.info("> Computing r1(y)");
  const r1 = computeR1(proof, challenges, roots, pi, curve2, logger);
  if (logger) logger.info("> Computing r2(y)");
  const r2 = computeR2(proof, challenges, roots, lagrangeEvals[1], vk, curve2, logger);
  if (logger) logger.info("> Computing F");
  const F2 = computeF(curve2, proof, vk, challenges, roots);
  if (logger) logger.info("> Computing E");
  const E2 = computeE(curve2, proof, challenges, vk, r0, r1, r2);
  if (logger) logger.info("> Computing J");
  const J2 = computeJ(curve2, proof, challenges);
  if (logger) logger.info("> Validate all evaluations with a pairing");
  const res = await isValidPairing(curve2, proof, challenges, vk, F2, E2, J2);
  if (logger) {
    if (res) {
      logger.info("PROOF VERIFIED SUCCESSFULLY");
    } else {
      logger.warn("Invalid Proof");
    }
  }
  if (logger) logger.info("FFLONK VERIFIER FINISHED");
  return res;
}
function fromObjectVk(curve2, vk) {
  const res = vk;
  res.k1 = curve2.Fr.fromObject(vk.k1);
  res.k2 = curve2.Fr.fromObject(vk.k2);
  res.w = curve2.Fr.fromObject(vk.w);
  res.w3 = curve2.Fr.fromObject(vk.w3);
  res.w4 = curve2.Fr.fromObject(vk.w4);
  res.w8 = curve2.Fr.fromObject(vk.w8);
  res.wr = curve2.Fr.fromObject(vk.wr);
  res.X_2 = curve2.G2.fromObject(vk.X_2);
  res.C0 = curve2.G1.fromObject(vk.C0);
  return res;
}
function commitmentsBelongToG1(curve2, proof, vk) {
  const G1 = curve2.G1;
  return G1.isValid(proof.polynomials.C1) && G1.isValid(proof.polynomials.C2) && G1.isValid(proof.polynomials.W1) && G1.isValid(proof.polynomials.W2) && G1.isValid(vk.C0);
}
function checkValueBelongToField(curve2, value) {
  return Scalar.lt(value, curve2.r);
}
function checkEvaluationIsValid(curve2, evaluation) {
  return checkValueBelongToField(curve2, Scalar.fromRprLE(evaluation));
}
function evaluationsAreValid(curve2, proof) {
  return checkEvaluationIsValid(curve2, proof.evaluations.ql) && checkEvaluationIsValid(curve2, proof.evaluations.qr) && checkEvaluationIsValid(curve2, proof.evaluations.qm) && checkEvaluationIsValid(curve2, proof.evaluations.qo) && checkEvaluationIsValid(curve2, proof.evaluations.qc) && checkEvaluationIsValid(curve2, proof.evaluations.s1) && checkEvaluationIsValid(curve2, proof.evaluations.s2) && checkEvaluationIsValid(curve2, proof.evaluations.s3) && checkEvaluationIsValid(curve2, proof.evaluations.a) && checkEvaluationIsValid(curve2, proof.evaluations.b) && checkEvaluationIsValid(curve2, proof.evaluations.c) && checkEvaluationIsValid(curve2, proof.evaluations.z) && checkEvaluationIsValid(curve2, proof.evaluations.zw) && checkEvaluationIsValid(curve2, proof.evaluations.t1w) && checkEvaluationIsValid(curve2, proof.evaluations.t2w);
}
function publicInputsAreValid(curve2, publicInputs) {
  for (let i2 = 0; i2 < publicInputs.length; i2++) {
    if (!checkValueBelongToField(curve2, publicInputs[i2])) {
      return false;
    }
  }
  return true;
}
function computeChallenges(curve2, proof, vk, publicSignals, logger) {
  const Fr = curve2.Fr;
  const challenges = {};
  const roots = {};
  const transcript = new Keccak256Transcript(curve2);
  transcript.addPolCommitment(vk.C0);
  for (let i2 = 0; i2 < publicSignals.length; i2++) {
    transcript.addScalar(Fr.e(publicSignals[i2]));
  }
  transcript.addPolCommitment(proof.polynomials.C1);
  challenges.beta = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(challenges.beta);
  challenges.gamma = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(challenges.gamma);
  transcript.addPolCommitment(proof.polynomials.C2);
  const xiSeed = transcript.getChallenge();
  const xiSeed2 = Fr.square(xiSeed);
  let w8 = [];
  w8[1] = vk.w8;
  w8[2] = Fr.square(vk.w8);
  w8[3] = Fr.mul(w8[2], vk.w8);
  w8[4] = Fr.mul(w8[3], vk.w8);
  w8[5] = Fr.mul(w8[4], vk.w8);
  w8[6] = Fr.mul(w8[5], vk.w8);
  w8[7] = Fr.mul(w8[6], vk.w8);
  let w4 = [];
  w4[1] = vk.w4;
  w4[2] = Fr.square(vk.w4);
  w4[3] = Fr.mul(w4[2], vk.w4);
  let w3 = [];
  w3[1] = vk.w3;
  w3[2] = Fr.square(vk.w3);
  roots.S0 = {};
  roots.S0.h0w8 = [];
  roots.S0.h0w8[0] = Fr.mul(xiSeed2, xiSeed);
  for (let i2 = 1; i2 < 8; i2++) {
    roots.S0.h0w8[i2] = Fr.mul(roots.S0.h0w8[0], w8[i2]);
  }
  roots.S1 = {};
  roots.S1.h1w4 = [];
  roots.S1.h1w4[0] = Fr.square(roots.S0.h0w8[0]);
  for (let i2 = 1; i2 < 4; i2++) {
    roots.S1.h1w4[i2] = Fr.mul(roots.S1.h1w4[0], w4[i2]);
  }
  roots.S2 = {};
  roots.S2.h2w3 = [];
  roots.S2.h2w3[0] = Fr.mul(roots.S1.h1w4[0], xiSeed2);
  roots.S2.h2w3[1] = Fr.mul(roots.S2.h2w3[0], w3[1]);
  roots.S2.h2w3[2] = Fr.mul(roots.S2.h2w3[0], w3[2]);
  roots.S2.h3w3 = [];
  roots.S2.h3w3[0] = Fr.mul(roots.S2.h2w3[0], vk.wr);
  roots.S2.h3w3[1] = Fr.mul(roots.S2.h3w3[0], w3[1]);
  roots.S2.h3w3[2] = Fr.mul(roots.S2.h3w3[0], w3[2]);
  challenges.xi = Fr.mul(Fr.square(roots.S2.h2w3[0]), roots.S2.h2w3[0]);
  challenges.xiw = Fr.mul(challenges.xi, Fr.w[vk.power]);
  challenges.xiN = challenges.xi;
  vk.domainSize = 1;
  for (let i2 = 0; i2 < vk.power; i2++) {
    challenges.xiN = Fr.square(challenges.xiN);
    vk.domainSize *= 2;
  }
  transcript.reset();
  transcript.addScalar(xiSeed);
  transcript.addScalar(proof.evaluations.ql);
  transcript.addScalar(proof.evaluations.qr);
  transcript.addScalar(proof.evaluations.qm);
  transcript.addScalar(proof.evaluations.qo);
  transcript.addScalar(proof.evaluations.qc);
  transcript.addScalar(proof.evaluations.s1);
  transcript.addScalar(proof.evaluations.s2);
  transcript.addScalar(proof.evaluations.s3);
  transcript.addScalar(proof.evaluations.a);
  transcript.addScalar(proof.evaluations.b);
  transcript.addScalar(proof.evaluations.c);
  transcript.addScalar(proof.evaluations.z);
  transcript.addScalar(proof.evaluations.zw);
  transcript.addScalar(proof.evaluations.t1w);
  transcript.addScalar(proof.evaluations.t2w);
  challenges.alpha = transcript.getChallenge();
  transcript.reset();
  transcript.addScalar(challenges.alpha);
  transcript.addPolCommitment(proof.polynomials.W1);
  challenges.y = transcript.getChallenge();
  if (logger) {
    logger.info(" challenges.beta:  " + Fr.toString(challenges.beta));
    logger.info(" challenges.gamma: " + Fr.toString(challenges.gamma));
    logger.info(" challenges.xi:    " + Fr.toString(challenges.xi));
    logger.info(" challenges.alpha: " + Fr.toString(challenges.alpha));
    logger.info(" challenges.y:     " + Fr.toString(challenges.y));
  }
  return { challenges, roots };
}
async function computeLagrangeEvaluations(curve2, challenges, vk) {
  const Fr = curve2.Fr;
  const size = Math.max(1, vk.nPublic);
  const numArr = new BigBuffer(size * Fr.n8);
  let denArr = new BigBuffer(size * Fr.n8);
  let w2 = Fr.one;
  for (let i2 = 0; i2 < size; i2++) {
    const i_sFr = i2 * Fr.n8;
    numArr.set(Fr.mul(w2, challenges.zh), i_sFr);
    denArr.set(Fr.mul(Fr.e(vk.domainSize), Fr.sub(challenges.xi, w2)), i_sFr);
    w2 = Fr.mul(w2, vk.w);
  }
  denArr = await Fr.batchInverse(denArr);
  let L2 = [];
  for (let i2 = 0; i2 < size; i2++) {
    const i_sFr = i2 * Fr.n8;
    L2[i2 + 1] = Fr.mul(numArr.slice(i_sFr, i_sFr + Fr.n8), denArr.slice(i_sFr, i_sFr + Fr.n8));
  }
  return L2;
}
function calculatePI(curve2, publicSignals, lagrangeEvals) {
  const Fr = curve2.Fr;
  let pi = Fr.zero;
  for (let i2 = 0; i2 < publicSignals.length; i2++) {
    const w2 = Fr.e(publicSignals[i2]);
    pi = Fr.sub(pi, Fr.mul(w2, lagrangeEvals[i2 + 1]));
  }
  return pi;
}
function computeR0(proof, challenges, roots, curve2, logger) {
  const Fr = curve2.Fr;
  const Li = computeLagrangeLiSi(roots.S0.h0w8, challenges.y, challenges.xi, curve2);
  if (logger) logger.info(" Computing r0(y)");
  let res = Fr.zero;
  for (let i2 = 0; i2 < 8; i2++) {
    let coefValues = [];
    coefValues[1] = roots.S0.h0w8[i2];
    for (let j2 = 2; j2 < 8; j2++) {
      coefValues[j2] = Fr.mul(coefValues[j2 - 1], roots.S0.h0w8[i2]);
    }
    let c0 = Fr.add(proof.evaluations.ql, Fr.mul(proof.evaluations.qr, coefValues[1]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.qo, coefValues[2]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.qm, coefValues[3]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.qc, coefValues[4]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.s1, coefValues[5]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.s2, coefValues[6]));
    c0 = Fr.add(c0, Fr.mul(proof.evaluations.s3, coefValues[7]));
    res = Fr.add(res, Fr.mul(c0, Li[i2]));
  }
  return res;
}
function computeR1(proof, challenges, roots, pi, curve2, logger) {
  const Fr = curve2.Fr;
  const Li = computeLagrangeLiSi(roots.S1.h1w4, challenges.y, challenges.xi, curve2);
  if (logger) logger.info(" Computing T0(xi)");
  let t0 = Fr.mul(proof.evaluations.ql, proof.evaluations.a);
  t0 = Fr.add(t0, Fr.mul(proof.evaluations.qr, proof.evaluations.b));
  t0 = Fr.add(t0, Fr.mul(proof.evaluations.qm, Fr.mul(proof.evaluations.a, proof.evaluations.b)));
  t0 = Fr.add(t0, Fr.mul(proof.evaluations.qo, proof.evaluations.c));
  t0 = Fr.add(t0, proof.evaluations.qc);
  t0 = Fr.add(t0, pi);
  t0 = Fr.mul(t0, challenges.invzh);
  if (logger) logger.info(" Computing C1(h_1_4^i) values");
  let res = Fr.zero;
  for (let i2 = 0; i2 < 4; i2++) {
    let c1 = proof.evaluations.a;
    c1 = Fr.add(c1, Fr.mul(roots.S1.h1w4[i2], proof.evaluations.b));
    const h1w4Squared = Fr.square(roots.S1.h1w4[i2]);
    c1 = Fr.add(c1, Fr.mul(h1w4Squared, proof.evaluations.c));
    c1 = Fr.add(c1, Fr.mul(Fr.mul(h1w4Squared, roots.S1.h1w4[i2]), t0));
    res = Fr.add(res, Fr.mul(c1, Li[i2]));
  }
  return res;
}
function computeR2(proof, challenges, roots, lagrange1, vk, curve2, logger) {
  const Fr = curve2.Fr;
  const LiS2 = computeLagrangeLiS2([roots.S2.h2w3, roots.S2.h3w3], challenges.y, challenges.xi, challenges.xiw, curve2);
  if (logger) logger.info(" Computing T1(xi)");
  let t1 = Fr.sub(proof.evaluations.z, Fr.one);
  t1 = Fr.mul(t1, lagrange1);
  t1 = Fr.mul(t1, challenges.invzh);
  if (logger) logger.info(" Computing T2(xi)");
  const betaxi = Fr.mul(challenges.beta, challenges.xi);
  const t211 = Fr.add(proof.evaluations.a, Fr.add(betaxi, challenges.gamma));
  const t212 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(betaxi, vk.k1), challenges.gamma));
  const t213 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(betaxi, vk.k2), challenges.gamma));
  const t21 = Fr.mul(t211, Fr.mul(t212, Fr.mul(t213, proof.evaluations.z)));
  const t221 = Fr.add(proof.evaluations.a, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s1), challenges.gamma));
  const t222 = Fr.add(proof.evaluations.b, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s2), challenges.gamma));
  const t223 = Fr.add(proof.evaluations.c, Fr.add(Fr.mul(challenges.beta, proof.evaluations.s3), challenges.gamma));
  const t22 = Fr.mul(t221, Fr.mul(t222, Fr.mul(t223, proof.evaluations.zw)));
  let t2 = Fr.sub(t21, t22);
  t2 = Fr.mul(t2, challenges.invzh);
  if (logger) logger.info(" Computing C2(h_2_3^i) values");
  let res = Fr.zero;
  for (let i2 = 0; i2 < 3; i2++) {
    let c2 = Fr.add(proof.evaluations.z, Fr.mul(roots.S2.h2w3[i2], t1));
    c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h2w3[i2]), t2));
    res = Fr.add(res, Fr.mul(c2, LiS2[i2]));
  }
  if (logger) logger.info(" Computing C2(h_3_3^i) values");
  for (let i2 = 0; i2 < 3; i2++) {
    let c2 = Fr.add(proof.evaluations.zw, Fr.mul(roots.S2.h3w3[i2], proof.evaluations.t1w));
    c2 = Fr.add(c2, Fr.mul(Fr.square(roots.S2.h3w3[i2]), proof.evaluations.t2w));
    res = Fr.add(res, Fr.mul(c2, LiS2[i2 + 3]));
  }
  return res;
}
function computeF(curve2, proof, vk, challenges, roots) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  let mulH0 = Fr.sub(challenges.y, roots.S0.h0w8[0]);
  for (let i2 = 1; i2 < 8; i2++) {
    mulH0 = Fr.mul(mulH0, Fr.sub(challenges.y, roots.S0.h0w8[i2]));
  }
  challenges.temp = mulH0;
  let mulH1 = Fr.sub(challenges.y, roots.S1.h1w4[0]);
  for (let i2 = 1; i2 < 4; i2++) {
    mulH1 = Fr.mul(mulH1, Fr.sub(challenges.y, roots.S1.h1w4[i2]));
  }
  let mulH2 = Fr.sub(challenges.y, roots.S2.h2w3[0]);
  for (let i2 = 1; i2 < 3; i2++) {
    mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h2w3[i2]));
  }
  for (let i2 = 0; i2 < 3; i2++) {
    mulH2 = Fr.mul(mulH2, Fr.sub(challenges.y, roots.S2.h3w3[i2]));
  }
  challenges.quotient1 = Fr.mul(challenges.alpha, Fr.div(mulH0, mulH1));
  challenges.quotient2 = Fr.mul(Fr.square(challenges.alpha), Fr.div(mulH0, mulH2));
  let F2 = G1.timesFr(proof.polynomials.C1, challenges.quotient1);
  let F3 = G1.timesFr(proof.polynomials.C2, challenges.quotient2);
  return G1.add(vk.C0, G1.add(F2, F3));
}
function computeE(curve2, proof, challenges, vk, r0, r1, r2) {
  const G1 = curve2.G1;
  const Fr = curve2.Fr;
  let E2 = Fr.mul(r1, challenges.quotient1);
  let E3 = Fr.mul(r2, challenges.quotient2);
  return G1.timesFr(G1.one, Fr.add(r0, Fr.add(E2, E3)));
}
function computeJ(curve2, proof, challenges) {
  const G1 = curve2.G1;
  return G1.timesFr(proof.polynomials.W1, challenges.temp);
}
async function isValidPairing(curve2, proof, challenges, vk, F2, E2, J2) {
  const G1 = curve2.G1;
  let A1 = G1.timesFr(proof.polynomials.W2, challenges.y);
  A1 = G1.add(G1.sub(G1.sub(F2, E2), J2), A1);
  const A2 = curve2.G2.one;
  const B1 = proof.polynomials.W2;
  const B2 = vk.X_2;
  return await curve2.pairingEq(G1.neg(A1), A2, B1, B2);
}
function computeLagrangeLiSi(roots, x2, xi, curve2) {
  const Fr = curve2.Fr;
  const len = roots.length;
  const num = Fr.sub(Fr.exp(x2, len), xi);
  const den1 = Fr.mul(Fr.e(len), Fr.exp(roots[0], len - 2));
  const Li = [];
  for (let i2 = 0; i2 < len; i2++) {
    const den2 = roots[(len - 1) * i2 % len];
    const den3 = Fr.sub(x2, roots[i2]);
    Li[i2] = Fr.div(num, Fr.mul(Fr.mul(den1, den2), den3));
  }
  return Li;
}
function computeLagrangeLiS2(roots, value, xi0, xi1, curve2) {
  const Fr = curve2.Fr;
  const Li = [];
  const len = roots[0].length;
  const n = len * roots.length;
  const num1 = Fr.exp(value, n);
  const num2 = Fr.mul(Fr.add(xi0, xi1), Fr.exp(value, len));
  const num3 = Fr.mul(xi0, xi1);
  const num = Fr.add(Fr.sub(num1, num2), num3);
  let den1 = Fr.mul(Fr.mul(Fr.e(len), roots[0][0]), Fr.sub(xi0, xi1));
  for (let i2 = 0; i2 < len; i2++) {
    const den2 = roots[0][(len - 1) * i2 % len];
    const den3 = Fr.sub(value, roots[0][i2]);
    const den = Fr.mul(den1, Fr.mul(den2, den3));
    Li[i2] = Fr.div(num, den);
  }
  den1 = Fr.mul(Fr.mul(Fr.e(len), roots[1][0]), Fr.sub(xi1, xi0));
  for (let i2 = 0; i2 < len; i2++) {
    const den2 = roots[1][(len - 1) * i2 % len];
    const den3 = Fr.sub(value, roots[1][i2]);
    const den = Fr.mul(den1, Fr.mul(den2, den3));
    Li[i2 + len] = Fr.div(num, den);
  }
  return Li;
}
function p256(n) {
  let nstr = n.toString(16);
  while (nstr.length < 64) nstr = "0" + nstr;
  nstr = `0x${nstr}`;
  return nstr;
}
async function fflonkExportCallData(_pub, _proof) {
  const proof = unstringifyBigInts2(_proof);
  const pub = unstringifyBigInts2(_pub);
  await getCurveFromName(proof.curve);
  let inputs = "";
  for (let i2 = 0; i2 < pub.length; i2++) {
    if (inputs !== "") inputs = inputs + ",";
    inputs = inputs + p256(pub[i2]);
  }
  return `[${p256(proof.polynomials.C1[0])}, ${p256(proof.polynomials.C1[1])},${p256(proof.polynomials.C2[0])},${p256(proof.polynomials.C2[1])},${p256(proof.polynomials.W1[0])},${p256(proof.polynomials.W1[1])},${p256(proof.polynomials.W2[0])},${p256(proof.polynomials.W2[1])},${p256(proof.evaluations.ql)},${p256(proof.evaluations.qr)},${p256(proof.evaluations.qm)},${p256(proof.evaluations.qo)},${p256(proof.evaluations.qc)},${p256(proof.evaluations.s1)},${p256(proof.evaluations.s2)},${p256(proof.evaluations.s3)},${p256(proof.evaluations.a)},${p256(proof.evaluations.b)},${p256(proof.evaluations.c)},${p256(proof.evaluations.z)},${p256(proof.evaluations.zw)},${p256(proof.evaluations.t1w)},${p256(proof.evaluations.t2w)},${p256(proof.evaluations.inv)}],[${inputs}]`;
}
var import_dist4, import_dist5, import_dist6, fs, FastFile, tmpBuff32$1, tmpBuff32v$1, tmpBuff64$1, tmpBuff64v$1, MemFile, PAGE_SIZE2, tmpBuff32, tmpBuff32v, tmpBuff64, tmpBuff64v, BigMemFile, O_TRUNC, O_CREAT, O_RDWR, O_RDONLY, DEFAULT_CACHE_SIZE, DEFAULT_PAGE_SIZE, bls12381r$1, bn128r$1, bls12381q2, bn128q2, commonjsGlobal, blake2bWasm, nanoassert, AssertionError, browser, ascii, alphabet, codes, base64, hex, toString$1, write$2, utf8, utf16le, blake2b, hasRequiredBlake2b, assert, b4a, wasm, wasmPromise, head, freeList, BYTES_MIN, BYTES_MAX, KEYBYTES_MIN, KEYBYTES_MAX, SALTBYTES, PERSONALBYTES, HEADER_ZKEY_SECTION, GROTH16_PROTOCOL_ID, PLONK_PROTOCOL_ID, FFLONK_PROTOCOL_ID, FF_T_POL_DEG_MIN, ZKEY_FF_NSECTIONS, ZKEY_FF_HEADER_SECTION, ZKEY_FF_ADDITIONS_SECTION, ZKEY_FF_A_MAP_SECTION, ZKEY_FF_B_MAP_SECTION, ZKEY_FF_C_MAP_SECTION, ZKEY_FF_QL_SECTION, ZKEY_FF_QR_SECTION, ZKEY_FF_QM_SECTION, ZKEY_FF_QO_SECTION, ZKEY_FF_QC_SECTION, ZKEY_FF_SIGMA1_SECTION, ZKEY_FF_SIGMA2_SECTION, ZKEY_FF_SIGMA3_SECTION, ZKEY_FF_LAGRANGE_SECTION, ZKEY_FF_PTAU_SECTION, ZKEY_FF_C0_SECTION, stringifyBigInts$4, WitnessCalculatorCircom1, WitnessCalculatorCircom2, unstringifyBigInts$b, unstringifyBigInts$a, unstringifyBigInts$9, unstringifyBigInts$8, groth16, sameRatio$1, powersoftau, SUBARRAY_SIZE$1, BigArrayHandler$1, _BigArray$1, BigArray$2, BigArray$3, R1CS_FILE_CUSTOM_GATES_LIST_SECTION, R1CS_FILE_CUSTOM_GATES_USES_SECTION, bls12381r2, bn128r2, r1cs, unstringifyBigInts$7, wtns, SUBARRAY_SIZE, BigArrayHandler, _BigArray, BigArray, BigArray$1, sameRatio, stringifyBigInts$3, ejs, unstringifyBigInts$6, stringifyBigInts$2, zkey, Proof, sha3, jsSha3, keccak256, POLYNOMIAL, SCALAR, Keccak256Transcript, MulZ, ZKEY_PL_ADDITIONS_SECTION, ZKEY_PL_A_MAP_SECTION, ZKEY_PL_B_MAP_SECTION, ZKEY_PL_C_MAP_SECTION, ZKEY_PL_QM_SECTION, ZKEY_PL_QL_SECTION, ZKEY_PL_QR_SECTION, ZKEY_PL_QO_SECTION, ZKEY_PL_QC_SECTION, ZKEY_PL_SIGMA_SECTION, ZKEY_PL_LAGRANGE_SECTION, ZKEY_PL_PTAU_SECTION, Polynomial, Evaluations, stringifyBigInts$1, unstringifyBigInts$5, unstringifyBigInts$4, unstringifyBigInts$3, plonk, LINEAR_COMBINATION_NULLABLE, LINEAR_COMBINATION_CONSTANT, LINEAR_COMBINATION_VARIABLE, r1csConstraintProcessor, CPolynomial, stringifyBigInts2, unstringifyBigInts$2, unstringifyBigInts$1, unstringifyBigInts2, fflonk;
var init_browser_esm2 = __esm({
  "node_modules/snarkjs/build/browser.esm.js"() {
    import_dist4 = __toESM(require_dist());
    import_dist5 = __toESM(require_dist2());
    import_dist6 = __toESM(require_dist3());
    init_browser_esm();
    fs = {};
    FastFile = class {
      constructor(fd, stats, cacheSize, pageSize, fileName) {
        this.fileName = fileName;
        this.fd = fd;
        this.pos = 0;
        this.pageSize = pageSize || 1 << 8;
        while (this.pageSize < stats.blksize) {
          this.pageSize *= 2;
        }
        this.totalSize = stats.size;
        this.totalPages = Math.floor((stats.size - 1) / this.pageSize) + 1;
        this.maxPagesLoaded = Math.floor(cacheSize / this.pageSize) + 1;
        this.pages = {};
        this.pendingLoads = [];
        this.writing = false;
        this.reading = false;
        this.avBuffs = [];
        this.history = {};
      }
      _loadPage(p2) {
        const self2 = this;
        const P2 = new Promise((resolve, reject) => {
          self2.pendingLoads.push({
            page: p2,
            resolve,
            reject
          });
        });
        self2.__statusPage("After Load request: ", p2);
        return P2;
      }
      __statusPage(s2, p2) {
        const logEntry = [];
        const self2 = this;
        if (!self2.logHistory) return;
        logEntry.push("==" + s2 + " " + p2);
        let S2 = "";
        for (let i2 = 0; i2 < self2.pendingLoads.length; i2++) {
          if (self2.pendingLoads[i2].page == p2) S2 = S2 + " " + i2;
        }
        if (S2) logEntry.push("Pending loads:" + S2);
        if (typeof self2.pages[p2] != "undefined") {
          const page = self2.pages[p2];
          logEntry.push("Loaded");
          logEntry.push("pendingOps: " + page.pendingOps);
          if (page.loading) logEntry.push("loading: " + page.loading);
          if (page.writing) logEntry.push("writing");
          if (page.dirty) logEntry.push("dirty");
        }
        logEntry.push("==");
        if (!self2.history[p2]) self2.history[p2] = [];
        self2.history[p2].push(logEntry);
      }
      __printHistory(p2) {
        const self2 = this;
        if (!self2.history[p2]) console.log("Empty History ", p2);
        console.log("History " + p2);
        for (let i2 = 0; i2 < self2.history[p2].length; i2++) {
          for (let j2 = 0; j2 < self2.history[p2][i2].length; j2++) {
            console.log("-> " + self2.history[p2][i2][j2]);
          }
        }
      }
      _triggerLoad() {
        const self2 = this;
        if (self2.reading) return;
        if (self2.pendingLoads.length == 0) return;
        const pageIdxs = Object.keys(self2.pages);
        const deletablePages = [];
        for (let i2 = 0; i2 < pageIdxs.length; i2++) {
          const page = self2.pages[parseInt(pageIdxs[i2])];
          if (page.dirty == false && page.pendingOps == 0 && !page.writing && !page.loading) deletablePages.push(parseInt(pageIdxs[i2]));
        }
        let freePages = self2.maxPagesLoaded - pageIdxs.length;
        const ops = [];
        while (self2.pendingLoads.length > 0 && (typeof self2.pages[self2.pendingLoads[0].page] != "undefined" || (freePages > 0 || deletablePages.length > 0))) {
          const load = self2.pendingLoads.shift();
          if (typeof self2.pages[load.page] != "undefined") {
            self2.pages[load.page].pendingOps++;
            const idx = deletablePages.indexOf(load.page);
            if (idx >= 0) deletablePages.splice(idx, 1);
            if (self2.pages[load.page].loading) {
              self2.pages[load.page].loading.push(load);
            } else {
              load.resolve();
            }
            self2.__statusPage("After Load (cached): ", load.page);
          } else {
            if (freePages) {
              freePages--;
            } else {
              const fp = deletablePages.shift();
              self2.__statusPage("Before Unload: ", fp);
              self2.avBuffs.unshift(self2.pages[fp]);
              delete self2.pages[fp];
              self2.__statusPage("After Unload: ", fp);
            }
            if (load.page >= self2.totalPages) {
              self2.pages[load.page] = getNewPage();
              load.resolve();
              self2.__statusPage("After Load (new): ", load.page);
            } else {
              self2.reading = true;
              self2.pages[load.page] = getNewPage();
              self2.pages[load.page].loading = [load];
              ops.push(self2.fd.read(self2.pages[load.page].buff, 0, self2.pageSize, load.page * self2.pageSize).then((res) => {
                self2.pages[load.page].size = res.bytesRead;
                const loading = self2.pages[load.page].loading;
                delete self2.pages[load.page].loading;
                for (let i2 = 0; i2 < loading.length; i2++) {
                  loading[i2].resolve();
                }
                self2.__statusPage("After Load (loaded): ", load.page);
                return res;
              }, (err) => {
                load.reject(err);
              }));
              self2.__statusPage("After Load (loading): ", load.page);
            }
          }
        }
        Promise.all(ops).then(() => {
          self2.reading = false;
          if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
          self2._tryClose();
        });
        function getNewPage() {
          if (self2.avBuffs.length > 0) {
            const p2 = self2.avBuffs.shift();
            p2.dirty = false;
            p2.pendingOps = 1;
            p2.size = 0;
            return p2;
          } else {
            return {
              dirty: false,
              buff: new Uint8Array(self2.pageSize),
              pendingOps: 1,
              size: 0
            };
          }
        }
      }
      _triggerWrite() {
        const self2 = this;
        if (self2.writing) return;
        const pageIdxs = Object.keys(self2.pages);
        const ops = [];
        for (let i2 = 0; i2 < pageIdxs.length; i2++) {
          const page = self2.pages[parseInt(pageIdxs[i2])];
          if (page.dirty) {
            page.dirty = false;
            page.writing = true;
            self2.writing = true;
            ops.push(self2.fd.write(page.buff, 0, page.size, parseInt(pageIdxs[i2]) * self2.pageSize).then(() => {
              page.writing = false;
              return;
            }, (err) => {
              console.log("ERROR Writing: " + err);
              self2.error = err;
              self2._tryClose();
            }));
          }
        }
        if (self2.writing) {
          Promise.all(ops).then(() => {
            self2.writing = false;
            setImmediate(self2._triggerWrite.bind(self2));
            self2._tryClose();
            if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
          });
        }
      }
      _getDirtyPage() {
        for (let p2 in this.pages) {
          if (this.pages[p2].dirty) return p2;
        }
        return -1;
      }
      async write(buff, pos) {
        if (buff.byteLength == 0) return;
        const self2 = this;
        if (typeof pos == "undefined") pos = self2.pos;
        self2.pos = pos + buff.byteLength;
        if (self2.totalSize < pos + buff.byteLength) self2.totalSize = pos + buff.byteLength;
        if (self2.pendingClose)
          throw new Error("Writing a closing file");
        const firstPage = Math.floor(pos / self2.pageSize);
        const lastPage = Math.floor((pos + buff.byteLength - 1) / self2.pageSize);
        const pagePromises = [];
        for (let i2 = firstPage; i2 <= lastPage; i2++) pagePromises.push(self2._loadPage(i2));
        self2._triggerLoad();
        let p2 = firstPage;
        let o2 = pos % self2.pageSize;
        let r2 = buff.byteLength;
        while (r2 > 0) {
          await pagePromises[p2 - firstPage];
          const l2 = o2 + r2 > self2.pageSize ? self2.pageSize - o2 : r2;
          const srcView = buff.slice(buff.byteLength - r2, buff.byteLength - r2 + l2);
          const dstView = new Uint8Array(self2.pages[p2].buff.buffer, o2, l2);
          dstView.set(srcView);
          self2.pages[p2].dirty = true;
          self2.pages[p2].pendingOps--;
          self2.pages[p2].size = Math.max(o2 + l2, self2.pages[p2].size);
          if (p2 >= self2.totalPages) {
            self2.totalPages = p2 + 1;
          }
          r2 = r2 - l2;
          p2++;
          o2 = 0;
          if (!self2.writing) setImmediate(self2._triggerWrite.bind(self2));
        }
      }
      async read(len, pos) {
        const self2 = this;
        let buff = new Uint8Array(len);
        await self2.readToBuffer(buff, 0, len, pos);
        return buff;
      }
      async readToBuffer(buffDst, offset, len, pos) {
        if (len == 0) {
          return;
        }
        const self2 = this;
        if (len > self2.pageSize * self2.maxPagesLoaded * 0.8) {
          const cacheSize = Math.floor(len * 1.1);
          this.maxPagesLoaded = Math.floor(cacheSize / self2.pageSize) + 1;
        }
        if (typeof pos == "undefined") pos = self2.pos;
        self2.pos = pos + len;
        if (self2.pendingClose)
          throw new Error("Reading a closing file");
        const firstPage = Math.floor(pos / self2.pageSize);
        const lastPage = Math.floor((pos + len - 1) / self2.pageSize);
        const pagePromises = [];
        for (let i2 = firstPage; i2 <= lastPage; i2++) pagePromises.push(self2._loadPage(i2));
        self2._triggerLoad();
        let p2 = firstPage;
        let o2 = pos % self2.pageSize;
        let r2 = pos + len > self2.totalSize ? len - (pos + len - self2.totalSize) : len;
        while (r2 > 0) {
          await pagePromises[p2 - firstPage];
          self2.__statusPage("After Await (read): ", p2);
          const l2 = o2 + r2 > self2.pageSize ? self2.pageSize - o2 : r2;
          const srcView = new Uint8Array(self2.pages[p2].buff.buffer, self2.pages[p2].buff.byteOffset + o2, l2);
          buffDst.set(srcView, offset + len - r2);
          self2.pages[p2].pendingOps--;
          self2.__statusPage("After Op done: ", p2);
          r2 = r2 - l2;
          p2++;
          o2 = 0;
          if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
        }
        this.pos = pos + len;
      }
      _tryClose() {
        const self2 = this;
        if (!self2.pendingClose) return;
        if (self2.error) {
          self2.pendingCloseReject(self2.error);
        }
        const p2 = self2._getDirtyPage();
        if (p2 >= 0 || self2.writing || self2.reading || self2.pendingLoads.length > 0) return;
        self2.pendingClose();
      }
      close() {
        const self2 = this;
        if (self2.pendingClose)
          throw new Error("Closing the file twice");
        return new Promise((resolve, reject) => {
          self2.pendingClose = resolve;
          self2.pendingCloseReject = reject;
          self2._tryClose();
        }).then(() => {
          self2.fd.close();
        }, (err) => {
          self2.fd.close();
          throw err;
        });
      }
      async discard() {
        const self2 = this;
        await self2.close();
        await fs.promises.unlink(this.fileName);
      }
      async writeULE32(v2, pos) {
        const self2 = this;
        const tmpBuff322 = new Uint8Array(4);
        const tmpBuff32v2 = new DataView(tmpBuff322.buffer);
        tmpBuff32v2.setUint32(0, v2, true);
        await self2.write(tmpBuff322, pos);
      }
      async writeUBE32(v2, pos) {
        const self2 = this;
        const tmpBuff322 = new Uint8Array(4);
        const tmpBuff32v2 = new DataView(tmpBuff322.buffer);
        tmpBuff32v2.setUint32(0, v2, false);
        await self2.write(tmpBuff322, pos);
      }
      async writeULE64(v2, pos) {
        const self2 = this;
        const tmpBuff642 = new Uint8Array(8);
        const tmpBuff64v2 = new DataView(tmpBuff642.buffer);
        tmpBuff64v2.setUint32(0, v2 & 4294967295, true);
        tmpBuff64v2.setUint32(4, Math.floor(v2 / 4294967296), true);
        await self2.write(tmpBuff642, pos);
      }
      async readULE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new Uint32Array(b2.buffer);
        return view[0];
      }
      async readUBE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new DataView(b2.buffer);
        return view.getUint32(0, false);
      }
      async readULE64(pos) {
        const self2 = this;
        const b2 = await self2.read(8, pos);
        const view = new Uint32Array(b2.buffer);
        return view[1] * 4294967296 + view[0];
      }
      async readString(pos) {
        const self2 = this;
        if (self2.pendingClose) {
          throw new Error("Reading a closing file");
        }
        let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
        let currentPage = Math.floor(currentPosition / self2.pageSize);
        let endOfStringFound = false;
        let str = "";
        while (!endOfStringFound) {
          let pagePromise = self2._loadPage(currentPage);
          self2._triggerLoad();
          await pagePromise;
          self2.__statusPage("After Await (read): ", currentPage);
          let offsetOnPage = currentPosition % self2.pageSize;
          const dataArray = new Uint8Array(
            self2.pages[currentPage].buff.buffer,
            self2.pages[currentPage].buff.byteOffset + offsetOnPage,
            self2.pageSize - offsetOnPage
          );
          let indexEndOfString = dataArray.findIndex((element) => element === 0);
          endOfStringFound = indexEndOfString !== -1;
          if (endOfStringFound) {
            str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
            self2.pos = currentPage * this.pageSize + offsetOnPage + indexEndOfString + 1;
          } else {
            str += new TextDecoder().decode(dataArray);
            self2.pos = currentPage * this.pageSize + offsetOnPage + dataArray.length;
          }
          self2.pages[currentPage].pendingOps--;
          self2.__statusPage("After Op done: ", currentPage);
          currentPosition = self2.pos;
          currentPage++;
          if (self2.pendingLoads.length > 0) setImmediate(self2._triggerLoad.bind(self2));
        }
        return str;
      }
    };
    tmpBuff32$1 = new Uint8Array(4);
    tmpBuff32v$1 = new DataView(tmpBuff32$1.buffer);
    tmpBuff64$1 = new Uint8Array(8);
    tmpBuff64v$1 = new DataView(tmpBuff64$1.buffer);
    MemFile = class {
      constructor() {
        this.pageSize = 1 << 14;
      }
      _resizeIfNeeded(newLen) {
        if (newLen > this.allocSize) {
          const newAllocSize = Math.max(
            this.allocSize + (1 << 20),
            Math.floor(this.allocSize * 1.1),
            newLen
          );
          const newData = new Uint8Array(newAllocSize);
          newData.set(this.o.data);
          this.o.data = newData;
          this.allocSize = newAllocSize;
        }
      }
      async write(buff, pos) {
        const self2 = this;
        if (typeof pos == "undefined") pos = self2.pos;
        if (this.readOnly) throw new Error("Writing a read only file");
        this._resizeIfNeeded(pos + buff.byteLength);
        this.o.data.set(buff.slice(), pos);
        if (pos + buff.byteLength > this.totalSize) this.totalSize = pos + buff.byteLength;
        this.pos = pos + buff.byteLength;
      }
      async readToBuffer(buffDest, offset, len, pos) {
        const self2 = this;
        if (typeof pos == "undefined") pos = self2.pos;
        if (this.readOnly) {
          if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos + len);
        const buffSrc = new Uint8Array(this.o.data.buffer, this.o.data.byteOffset + pos, len);
        buffDest.set(buffSrc, offset);
        this.pos = pos + len;
      }
      async read(len, pos) {
        const self2 = this;
        const buff = new Uint8Array(len);
        await self2.readToBuffer(buff, 0, len, pos);
        return buff;
      }
      close() {
        if (this.o.data.byteLength != this.totalSize) {
          this.o.data = this.o.data.slice(0, this.totalSize);
        }
      }
      async discard() {
      }
      async writeULE32(v2, pos) {
        const self2 = this;
        tmpBuff32v$1.setUint32(0, v2, true);
        await self2.write(tmpBuff32$1, pos);
      }
      async writeUBE32(v2, pos) {
        const self2 = this;
        tmpBuff32v$1.setUint32(0, v2, false);
        await self2.write(tmpBuff32$1, pos);
      }
      async writeULE64(v2, pos) {
        const self2 = this;
        tmpBuff64v$1.setUint32(0, v2 & 4294967295, true);
        tmpBuff64v$1.setUint32(4, Math.floor(v2 / 4294967296), true);
        await self2.write(tmpBuff64$1, pos);
      }
      async readULE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new Uint32Array(b2.buffer);
        return view[0];
      }
      async readUBE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new DataView(b2.buffer);
        return view.getUint32(0, false);
      }
      async readULE64(pos) {
        const self2 = this;
        const b2 = await self2.read(8, pos);
        const view = new Uint32Array(b2.buffer);
        return view[1] * 4294967296 + view[0];
      }
      async readString(pos) {
        const self2 = this;
        let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
        if (currentPosition > this.totalSize) {
          if (this.readOnly) {
            throw new Error("Reading out of bounds");
          }
          this._resizeIfNeeded(pos);
        }
        const dataArray = new Uint8Array(
          self2.o.data.buffer,
          currentPosition,
          this.totalSize - currentPosition
        );
        let indexEndOfString = dataArray.findIndex((element) => element === 0);
        let endOfStringFound = indexEndOfString !== -1;
        let str = "";
        if (endOfStringFound) {
          str = new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
          self2.pos = currentPosition + indexEndOfString + 1;
        } else {
          self2.pos = currentPosition;
        }
        return str;
      }
    };
    PAGE_SIZE2 = 1 << 22;
    tmpBuff32 = new Uint8Array(4);
    tmpBuff32v = new DataView(tmpBuff32.buffer);
    tmpBuff64 = new Uint8Array(8);
    tmpBuff64v = new DataView(tmpBuff64.buffer);
    BigMemFile = class {
      constructor() {
        this.pageSize = 1 << 14;
      }
      _resizeIfNeeded(newLen) {
        if (newLen <= this.totalSize) return;
        if (this.readOnly) throw new Error("Reading out of file bounds");
        const nPages = Math.floor((newLen - 1) / PAGE_SIZE2) + 1;
        for (let i2 = Math.max(this.o.data.length - 1, 0); i2 < nPages; i2++) {
          const newSize = i2 < nPages - 1 ? PAGE_SIZE2 : newLen - (nPages - 1) * PAGE_SIZE2;
          const p2 = new Uint8Array(newSize);
          if (i2 == this.o.data.length - 1) p2.set(this.o.data[i2]);
          this.o.data[i2] = p2;
        }
        this.totalSize = newLen;
      }
      async write(buff, pos) {
        const self2 = this;
        if (typeof pos == "undefined") pos = self2.pos;
        if (this.readOnly) throw new Error("Writing a read only file");
        this._resizeIfNeeded(pos + buff.byteLength);
        const firstPage = Math.floor(pos / PAGE_SIZE2);
        let p2 = firstPage;
        let o2 = pos % PAGE_SIZE2;
        let r2 = buff.byteLength;
        while (r2 > 0) {
          const l2 = o2 + r2 > PAGE_SIZE2 ? PAGE_SIZE2 - o2 : r2;
          const srcView = buff.slice(buff.byteLength - r2, buff.byteLength - r2 + l2);
          const dstView = new Uint8Array(self2.o.data[p2].buffer, o2, l2);
          dstView.set(srcView);
          r2 = r2 - l2;
          p2++;
          o2 = 0;
        }
        this.pos = pos + buff.byteLength;
      }
      async readToBuffer(buffDst, offset, len, pos) {
        const self2 = this;
        if (typeof pos == "undefined") pos = self2.pos;
        if (this.readOnly) {
          if (pos + len > this.totalSize) throw new Error("Reading out of bounds");
        }
        this._resizeIfNeeded(pos + len);
        const firstPage = Math.floor(pos / PAGE_SIZE2);
        let p2 = firstPage;
        let o2 = pos % PAGE_SIZE2;
        let r2 = len;
        while (r2 > 0) {
          const l2 = o2 + r2 > PAGE_SIZE2 ? PAGE_SIZE2 - o2 : r2;
          const srcView = new Uint8Array(self2.o.data[p2].buffer, o2, l2);
          buffDst.set(srcView, offset + len - r2);
          r2 = r2 - l2;
          p2++;
          o2 = 0;
        }
        this.pos = pos + len;
      }
      async read(len, pos) {
        const self2 = this;
        const buff = new Uint8Array(len);
        await self2.readToBuffer(buff, 0, len, pos);
        return buff;
      }
      close() {
      }
      async discard() {
      }
      async writeULE32(v2, pos) {
        const self2 = this;
        tmpBuff32v.setUint32(0, v2, true);
        await self2.write(tmpBuff32, pos);
      }
      async writeUBE32(v2, pos) {
        const self2 = this;
        tmpBuff32v.setUint32(0, v2, false);
        await self2.write(tmpBuff32, pos);
      }
      async writeULE64(v2, pos) {
        const self2 = this;
        tmpBuff64v.setUint32(0, v2 & 4294967295, true);
        tmpBuff64v.setUint32(4, Math.floor(v2 / 4294967296), true);
        await self2.write(tmpBuff64, pos);
      }
      async readULE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new Uint32Array(b2.buffer);
        return view[0];
      }
      async readUBE32(pos) {
        const self2 = this;
        const b2 = await self2.read(4, pos);
        const view = new DataView(b2.buffer);
        return view.getUint32(0, false);
      }
      async readULE64(pos) {
        const self2 = this;
        const b2 = await self2.read(8, pos);
        const view = new Uint32Array(b2.buffer);
        return view[1] * 4294967296 + view[0];
      }
      async readString(pos) {
        const self2 = this;
        const fixedSize = 2048;
        let currentPosition = typeof pos == "undefined" ? self2.pos : pos;
        if (currentPosition > this.totalSize) {
          if (this.readOnly) {
            throw new Error("Reading out of bounds");
          }
          this._resizeIfNeeded(pos);
        }
        let endOfStringFound = false;
        let str = "";
        while (!endOfStringFound) {
          let currentPage = Math.floor(currentPosition / PAGE_SIZE2);
          let offsetOnPage = currentPosition % PAGE_SIZE2;
          if (self2.o.data[currentPage] === void 0) {
            throw new Error("ERROR");
          }
          let readLength = Math.min(fixedSize, self2.o.data[currentPage].length - offsetOnPage);
          const dataArray = new Uint8Array(self2.o.data[currentPage].buffer, offsetOnPage, readLength);
          let indexEndOfString = dataArray.findIndex((element) => element === 0);
          endOfStringFound = indexEndOfString !== -1;
          if (endOfStringFound) {
            str += new TextDecoder().decode(dataArray.slice(0, indexEndOfString));
            self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + indexEndOfString + 1;
          } else {
            str += new TextDecoder().decode(dataArray);
            self2.pos = currentPage * PAGE_SIZE2 + offsetOnPage + dataArray.length;
          }
          currentPosition = self2.pos;
        }
        return str;
      }
    };
    O_TRUNC = 1024;
    O_CREAT = 512;
    O_RDWR = 2;
    O_RDONLY = 0;
    DEFAULT_CACHE_SIZE = 1 << 16;
    DEFAULT_PAGE_SIZE = 1 << 13;
    bls12381r$1 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
    bn128r$1 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    bls12381q2 = Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab", 16);
    bn128q2 = Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    blake2bWasm = { exports: {} };
    nanoassert = assert$1;
    AssertionError = class extends Error {
    };
    AssertionError.prototype.name = "AssertionError";
    browser = { exports: {} };
    ascii = {
      byteLength: byteLength$4,
      toString: toString$4,
      write: write$5
    };
    alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    codes = new Uint8Array(256);
    for (let i2 = 0; i2 < alphabet.length; i2++) {
      codes[alphabet.charCodeAt(i2)] = i2;
    }
    codes[
      /* - */
      45
    ] = 62;
    codes[
      /* _ */
      95
    ] = 63;
    base64 = {
      byteLength: byteLength$3,
      toString: toString$3,
      write: write$4
    };
    hex = {
      byteLength: byteLength$2,
      toString: toString$2,
      write: write$3
    };
    if (typeof TextDecoder !== "undefined") {
      const decoder = new TextDecoder();
      toString$1 = function toString3(buffer) {
        return decoder.decode(buffer);
      };
    } else {
      toString$1 = function toString3(buffer) {
        const len = buffer.byteLength;
        let output = "";
        let i2 = 0;
        while (i2 < len) {
          let byte = buffer[i2];
          if (byte <= 127) {
            output += String.fromCharCode(byte);
            i2++;
            continue;
          }
          let bytesNeeded = 0;
          let codePoint = 0;
          if (byte <= 223) {
            bytesNeeded = 1;
            codePoint = byte & 31;
          } else if (byte <= 239) {
            bytesNeeded = 2;
            codePoint = byte & 15;
          } else if (byte <= 244) {
            bytesNeeded = 3;
            codePoint = byte & 7;
          }
          if (len - i2 - bytesNeeded > 0) {
            let k2 = 0;
            while (k2 < bytesNeeded) {
              byte = buffer[i2 + k2 + 1];
              codePoint = codePoint << 6 | byte & 63;
              k2 += 1;
            }
          } else {
            codePoint = 65533;
            bytesNeeded = len - i2;
          }
          output += String.fromCodePoint(codePoint);
          i2 += bytesNeeded + 1;
        }
        return output;
      };
    }
    if (typeof TextEncoder !== "undefined") {
      const encoder = new TextEncoder();
      write$2 = function write2(buffer, string2, offset = 0, length2 = byteLength$1(string2)) {
        const len = Math.min(length2, buffer.byteLength - offset);
        encoder.encodeInto(string2, buffer.subarray(offset, offset + len));
        return len;
      };
    } else {
      write$2 = function write2(buffer, string2, offset = 0, length2 = byteLength$1(string2)) {
        const len = Math.min(length2, buffer.byteLength - offset);
        buffer = buffer.subarray(offset, offset + len);
        let i2 = 0;
        let j2 = 0;
        while (i2 < string2.length) {
          const code = string2.codePointAt(i2);
          if (code <= 127) {
            buffer[j2++] = code;
            i2++;
            continue;
          }
          let count = 0;
          let bits2 = 0;
          if (code <= 2047) {
            count = 6;
            bits2 = 192;
          } else if (code <= 65535) {
            count = 12;
            bits2 = 224;
          } else if (code <= 2097151) {
            count = 18;
            bits2 = 240;
          }
          buffer[j2++] = bits2 | code >> count;
          count -= 6;
          while (count >= 0) {
            buffer[j2++] = 128 | code >> count & 63;
            count -= 6;
          }
          i2 += code >= 65536 ? 2 : 1;
        }
        return len;
      };
    }
    utf8 = {
      byteLength: byteLength$1,
      toString: toString$1,
      write: write$2
    };
    utf16le = {
      byteLength,
      toString: toString2,
      write: write$1
    };
    (function(module, exports) {
      const ascii$1 = ascii;
      const base64$1 = base64;
      const hex$1 = hex;
      const utf8$1 = utf8;
      const utf16le$1 = utf16le;
      const LE = new Uint8Array(Uint16Array.of(255).buffer)[0] === 255;
      function codecFor(encoding) {
        switch (encoding) {
          case "ascii":
            return ascii$1;
          case "base64":
            return base64$1;
          case "hex":
            return hex$1;
          case "utf8":
          case "utf-8":
          case void 0:
            return utf8$1;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16le$1;
          default:
            throw new Error(`Unknown encoding: ${encoding}`);
        }
      }
      function isBuffer(value) {
        return value instanceof Uint8Array;
      }
      function isEncoding(encoding) {
        try {
          codecFor(encoding);
          return true;
        } catch {
          return false;
        }
      }
      function alloc2(size, fill2, encoding) {
        const buffer = new Uint8Array(size);
        if (fill2 !== void 0) exports.fill(buffer, fill2, 0, buffer.byteLength, encoding);
        return buffer;
      }
      function allocUnsafe(size) {
        return new Uint8Array(size);
      }
      function allocUnsafeSlow(size) {
        return new Uint8Array(size);
      }
      function byteLength2(string2, encoding) {
        return codecFor(encoding).byteLength(string2);
      }
      function compare2(a2, b2) {
        if (a2 === b2) return 0;
        const len = Math.min(a2.byteLength, b2.byteLength);
        a2 = new DataView(a2.buffer, a2.byteOffset, a2.byteLength);
        b2 = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        let i2 = 0;
        for (let n = len - len % 4; i2 < n; i2 += 4) {
          const x2 = a2.getUint32(i2, LE);
          const y2 = b2.getUint32(i2, LE);
          if (x2 !== y2) break;
        }
        for (; i2 < len; i2++) {
          const x2 = a2.getUint8(i2);
          const y2 = b2.getUint8(i2);
          if (x2 < y2) return -1;
          if (x2 > y2) return 1;
        }
        return a2.byteLength > b2.byteLength ? 1 : a2.byteLength < b2.byteLength ? -1 : 0;
      }
      function concat(buffers, totalLength) {
        if (totalLength === void 0) {
          totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);
        }
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const buffer of buffers) {
          if (offset + buffer.byteLength > result.byteLength) {
            const sub2 = buffer.subarray(0, result.byteLength - offset);
            result.set(sub2, offset);
            return result;
          }
          result.set(buffer, offset);
          offset += buffer.byteLength;
        }
        return result;
      }
      function copy2(source, target, targetStart = 0, start = 0, end = source.byteLength) {
        if (end > 0 && end < start) return 0;
        if (end === start) return 0;
        if (source.byteLength === 0 || target.byteLength === 0) return 0;
        if (targetStart < 0) throw new RangeError("targetStart is out of range");
        if (start < 0 || start >= source.byteLength) throw new RangeError("sourceStart is out of range");
        if (end < 0) throw new RangeError("sourceEnd is out of range");
        if (targetStart >= target.byteLength) targetStart = target.byteLength;
        if (end > source.byteLength) end = source.byteLength;
        if (target.byteLength - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (source === target) {
          target.copyWithin(targetStart, start, end);
        } else {
          target.set(source.subarray(start, end), targetStart);
        }
        return len;
      }
      function equals(a2, b2) {
        if (a2 === b2) return true;
        if (a2.byteLength !== b2.byteLength) return false;
        const len = a2.byteLength;
        a2 = new DataView(a2.buffer, a2.byteOffset, a2.byteLength);
        b2 = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        let i2 = 0;
        for (let n = len - len % 4; i2 < n; i2 += 4) {
          if (a2.getUint32(i2, LE) !== b2.getUint32(i2, LE)) return false;
        }
        for (; i2 < len; i2++) {
          if (a2.getUint8(i2) !== b2.getUint8(i2)) return false;
        }
        return true;
      }
      function fill(buffer, value, offset, end, encoding) {
        if (typeof value === "string") {
          if (typeof offset === "string") {
            encoding = offset;
            offset = 0;
            end = buffer.byteLength;
          } else if (typeof end === "string") {
            encoding = end;
            end = buffer.byteLength;
          }
        } else if (typeof value === "number") {
          value = value & 255;
        } else if (typeof value === "boolean") {
          value = +value;
        }
        if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {
          throw new RangeError("Out of range index");
        }
        if (offset === void 0) offset = 0;
        if (end === void 0) end = buffer.byteLength;
        if (end <= offset) return buffer;
        if (!value) value = 0;
        if (typeof value === "number") {
          for (let i2 = offset; i2 < end; ++i2) {
            buffer[i2] = value;
          }
        } else {
          value = isBuffer(value) ? value : from2(value, encoding);
          const len = value.byteLength;
          for (let i2 = 0; i2 < end - offset; ++i2) {
            buffer[i2 + offset] = value[i2 % len];
          }
        }
        return buffer;
      }
      function from2(value, encodingOrOffset, length2) {
        if (typeof value === "string") return fromString2(value, encodingOrOffset);
        if (Array.isArray(value)) return fromArray2(value);
        if (ArrayBuffer.isView(value)) return fromBuffer(value);
        return fromArrayBuffer(value, encodingOrOffset, length2);
      }
      function fromString2(string2, encoding) {
        const codec = codecFor(encoding);
        const buffer = new Uint8Array(codec.byteLength(string2));
        codec.write(buffer, string2, 0, buffer.byteLength);
        return buffer;
      }
      function fromArray2(array) {
        const buffer = new Uint8Array(array.length);
        buffer.set(array);
        return buffer;
      }
      function fromBuffer(buffer) {
        const copy3 = new Uint8Array(buffer.byteLength);
        copy3.set(buffer);
        return copy3;
      }
      function fromArrayBuffer(arrayBuffer, byteOffset, length2) {
        return new Uint8Array(arrayBuffer, byteOffset, length2);
      }
      function includes(buffer, value, byteOffset, encoding) {
        return indexOf(buffer, value, byteOffset, encoding) !== -1;
      }
      function bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {
        if (buffer.byteLength === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset === void 0) {
          byteOffset = first ? 0 : buffer.length - 1;
        } else if (byteOffset < 0) {
          byteOffset += buffer.byteLength;
        }
        if (byteOffset >= buffer.byteLength) {
          if (first) return -1;
          else byteOffset = buffer.byteLength - 1;
        } else if (byteOffset < 0) {
          if (first) byteOffset = 0;
          else return -1;
        }
        if (typeof value === "string") {
          value = from2(value, encoding);
        } else if (typeof value === "number") {
          value = value & 255;
          if (first) {
            return buffer.indexOf(value, byteOffset);
          } else {
            return buffer.lastIndexOf(value, byteOffset);
          }
        }
        if (value.byteLength === 0) return -1;
        if (first) {
          let foundIndex = -1;
          for (let i2 = byteOffset; i2 < buffer.byteLength; i2++) {
            if (buffer[i2] === value[foundIndex === -1 ? 0 : i2 - foundIndex]) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === value.byteLength) return foundIndex;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + value.byteLength > buffer.byteLength) {
            byteOffset = buffer.byteLength - value.byteLength;
          }
          for (let i2 = byteOffset; i2 >= 0; i2--) {
            let found = true;
            for (let j2 = 0; j2 < value.byteLength; j2++) {
              if (buffer[i2 + j2] !== value[j2]) {
                found = false;
                break;
              }
            }
            if (found) return i2;
          }
        }
        return -1;
      }
      function indexOf(buffer, value, byteOffset, encoding) {
        return bidirectionalIndexOf(
          buffer,
          value,
          byteOffset,
          encoding,
          true
          /* first */
        );
      }
      function lastIndexOf(buffer, value, byteOffset, encoding) {
        return bidirectionalIndexOf(
          buffer,
          value,
          byteOffset,
          encoding,
          false
          /* last */
        );
      }
      function swap(buffer, n, m2) {
        const i2 = buffer[n];
        buffer[n] = buffer[m2];
        buffer[m2] = i2;
      }
      function swap16(buffer) {
        const len = buffer.byteLength;
        if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let i2 = 0; i2 < len; i2 += 2) swap(buffer, i2, i2 + 1);
        return buffer;
      }
      function swap32(buffer) {
        const len = buffer.byteLength;
        if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let i2 = 0; i2 < len; i2 += 4) {
          swap(buffer, i2, i2 + 3);
          swap(buffer, i2 + 1, i2 + 2);
        }
        return buffer;
      }
      function swap64(buffer) {
        const len = buffer.byteLength;
        if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let i2 = 0; i2 < len; i2 += 8) {
          swap(buffer, i2, i2 + 7);
          swap(buffer, i2 + 1, i2 + 6);
          swap(buffer, i2 + 2, i2 + 5);
          swap(buffer, i2 + 3, i2 + 4);
        }
        return buffer;
      }
      function toBuffer(buffer) {
        return buffer;
      }
      function toString3(buffer, encoding, start = 0, end = buffer.byteLength) {
        const len = buffer.byteLength;
        if (start >= len) return "";
        if (end <= start) return "";
        if (start < 0) start = 0;
        if (end > len) end = len;
        if (start !== 0 || end < len) buffer = buffer.subarray(start, end);
        return codecFor(encoding).toString(buffer);
      }
      function write2(buffer, string2, offset, length2, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
        } else if (length2 === void 0 && typeof offset === "string") {
          encoding = offset;
          offset = void 0;
        } else if (encoding === void 0 && typeof length2 === "string") {
          encoding = length2;
          length2 = void 0;
        }
        return codecFor(encoding).write(buffer, string2, offset, length2);
      }
      function writeDoubleLE(buffer, value, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        view.setFloat64(offset, value, true);
        return offset + 8;
      }
      function writeFloatLE(buffer, value, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        view.setFloat32(offset, value, true);
        return offset + 4;
      }
      function writeUInt32LE(buffer, value, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        view.setUint32(offset, value, true);
        return offset + 4;
      }
      function writeInt32LE(buffer, value, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        view.setInt32(offset, value, true);
        return offset + 4;
      }
      function readDoubleLE(buffer, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        return view.getFloat64(offset, true);
      }
      function readFloatLE(buffer, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        return view.getFloat32(offset, true);
      }
      function readUInt32LE(buffer, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        return view.getUint32(offset, true);
      }
      function readInt32LE(buffer, offset) {
        if (offset === void 0) offset = 0;
        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
        return view.getInt32(offset, true);
      }
      module.exports = exports = {
        isBuffer,
        isEncoding,
        alloc: alloc2,
        allocUnsafe,
        allocUnsafeSlow,
        byteLength: byteLength2,
        compare: compare2,
        concat,
        copy: copy2,
        equals,
        fill,
        from: from2,
        includes,
        indexOf,
        lastIndexOf,
        swap16,
        swap32,
        swap64,
        toBuffer,
        toString: toString3,
        write: write2,
        writeDoubleLE,
        writeFloatLE,
        writeUInt32LE,
        writeInt32LE,
        readDoubleLE,
        readFloatLE,
        readUInt32LE,
        readInt32LE
      };
    })(browser, browser.exports);
    assert = nanoassert;
    b4a = browser.exports;
    wasm = null;
    wasmPromise = typeof WebAssembly !== "undefined" && requireBlake2b()().then((mod2) => {
      wasm = mod2;
    });
    head = 64;
    freeList = [];
    blake2bWasm.exports = Blake2b;
    BYTES_MIN = blake2bWasm.exports.BYTES_MIN = 16;
    BYTES_MAX = blake2bWasm.exports.BYTES_MAX = 64;
    blake2bWasm.exports.BYTES = 32;
    KEYBYTES_MIN = blake2bWasm.exports.KEYBYTES_MIN = 16;
    KEYBYTES_MAX = blake2bWasm.exports.KEYBYTES_MAX = 64;
    blake2bWasm.exports.KEYBYTES = 32;
    SALTBYTES = blake2bWasm.exports.SALTBYTES = 16;
    PERSONALBYTES = blake2bWasm.exports.PERSONALBYTES = 16;
    Blake2b.prototype._realloc = function(size) {
      wasm.memory.grow(Math.max(0, Math.ceil(Math.abs(size - this._memory.length) / 65536)));
      this._memory = new Uint8Array(wasm.memory.buffer);
    };
    Blake2b.prototype.update = function(input) {
      assert(this.finalized === false, "Hash instance finalized");
      assert(input instanceof Uint8Array, "input must be Uint8Array or Buffer");
      if (head + input.length > this._memory.length) this._realloc(head + input.length);
      this._memory.set(input, head);
      wasm.blake2b_update(this.pointer, head, head + input.length);
      return this;
    };
    Blake2b.prototype.digest = function(enc) {
      assert(this.finalized === false, "Hash instance finalized");
      this.finalized = true;
      freeList.push(this.pointer);
      wasm.blake2b_final(this.pointer);
      if (!enc || enc === "binary") {
        return this._memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      if (typeof enc === "string") {
        return b4a.toString(this._memory, enc, this.pointer + 128, this.pointer + 128 + this.digestLength);
      }
      assert(enc instanceof Uint8Array && enc.length >= this.digestLength, "input must be Uint8Array or Buffer");
      for (var i2 = 0; i2 < this.digestLength; i2++) {
        enc[i2] = this._memory[this.pointer + 128 + i2];
      }
      return enc;
    };
    Blake2b.prototype.final = Blake2b.prototype.digest;
    Blake2b.WASM = wasm;
    Blake2b.SUPPORTED = typeof WebAssembly !== "undefined";
    Blake2b.ready = function(cb) {
      if (!cb) cb = noop;
      if (!wasmPromise) return cb(new Error("WebAssembly not supported"));
      return wasmPromise.then(() => cb(), cb);
    };
    Blake2b.prototype.ready = Blake2b.ready;
    Blake2b.prototype.getPartialHash = function() {
      return this._memory.slice(this.pointer, this.pointer + 216);
    };
    Blake2b.prototype.setPartialHash = function(ph) {
      this._memory.set(ph, this.pointer);
    };
    HEADER_ZKEY_SECTION = 1;
    GROTH16_PROTOCOL_ID = 1;
    PLONK_PROTOCOL_ID = 2;
    FFLONK_PROTOCOL_ID = 10;
    FF_T_POL_DEG_MIN = 3;
    ZKEY_FF_NSECTIONS = 17;
    ZKEY_FF_HEADER_SECTION = 2;
    ZKEY_FF_ADDITIONS_SECTION = 3;
    ZKEY_FF_A_MAP_SECTION = 4;
    ZKEY_FF_B_MAP_SECTION = 5;
    ZKEY_FF_C_MAP_SECTION = 6;
    ZKEY_FF_QL_SECTION = 7;
    ZKEY_FF_QR_SECTION = 8;
    ZKEY_FF_QM_SECTION = 9;
    ZKEY_FF_QO_SECTION = 10;
    ZKEY_FF_QC_SECTION = 11;
    ZKEY_FF_SIGMA1_SECTION = 12;
    ZKEY_FF_SIGMA2_SECTION = 13;
    ZKEY_FF_SIGMA3_SECTION = 14;
    ZKEY_FF_LAGRANGE_SECTION = 15;
    ZKEY_FF_PTAU_SECTION = 16;
    ZKEY_FF_C0_SECTION = 17;
    ({ stringifyBigInts: stringifyBigInts$4 } = utils);
    WitnessCalculatorCircom1 = class {
      constructor(memory, instance, sanityCheck) {
        this.memory = memory;
        this.i32 = new Uint32Array(memory.buffer);
        this.instance = instance;
        this.n32 = (this.instance.exports.getFrLen() >> 2) - 2;
        const pRawPrime = this.instance.exports.getPRawPrime();
        const arr = new Array(this.n32);
        for (let i2 = 0; i2 < this.n32; i2++) {
          arr[this.n32 - 1 - i2] = this.i32[(pRawPrime >> 2) + i2];
        }
        this.prime = Scalar.fromArray(arr, 4294967296);
        this.Fr = new ZqField(this.prime);
        this.mask32 = Scalar.fromString("FFFFFFFF", 16);
        this.NVars = this.instance.exports.getNVars();
        this.n64 = Math.floor((this.Fr.bitLength - 1) / 64) + 1;
        this.R = this.Fr.e(Scalar.shiftLeft(1, this.n64 * 64));
        this.RInv = this.Fr.inv(this.R);
        this.sanityCheck = sanityCheck;
      }
      circom_version() {
        return 1;
      }
      async _doCalculateWitness(input, sanityCheck) {
        this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
        const pSigOffset = this.allocInt();
        const pFr = this.allocFr();
        const keys = Object.keys(input);
        keys.forEach((k2) => {
          const h = fnvHash(k2);
          const hMSB = parseInt(h.slice(0, 8), 16);
          const hLSB = parseInt(h.slice(8, 16), 16);
          try {
            this.instance.exports.getSignalOffset32(pSigOffset, 0, hMSB, hLSB);
          } catch (err) {
            throw new Error(`Signal ${k2} is not an input of the circuit.`);
          }
          const sigOffset = this.getInt(pSigOffset);
          const fArr = flatArray(input[k2]);
          for (let i2 = 0; i2 < fArr.length; i2++) {
            this.setFr(pFr, fArr[i2]);
            this.instance.exports.setSignal(0, 0, sigOffset + i2, pFr);
          }
        });
      }
      async calculateWitness(input, sanityCheck) {
        const self2 = this;
        const old0 = self2.i32[0];
        const w2 = [];
        await self2._doCalculateWitness(input, sanityCheck);
        for (let i2 = 0; i2 < self2.NVars; i2++) {
          const pWitness = self2.instance.exports.getPWitness(i2);
          w2.push(self2.getFr(pWitness));
        }
        self2.i32[0] = old0;
        return w2;
      }
      async calculateBinWitness(input, sanityCheck) {
        const self2 = this;
        const old0 = self2.i32[0];
        await self2._doCalculateWitness(input, sanityCheck);
        const pWitnessBuffer = self2.instance.exports.getWitnessBuffer();
        self2.i32[0] = old0;
        const buff = self2.memory.buffer.slice(pWitnessBuffer, pWitnessBuffer + self2.NVars * self2.n64 * 8);
        return new Uint8Array(buff);
      }
      allocInt() {
        const p2 = this.i32[0];
        this.i32[0] = p2 + 8;
        return p2;
      }
      allocFr() {
        const p2 = this.i32[0];
        this.i32[0] = p2 + this.n32 * 4 + 8;
        return p2;
      }
      getInt(p2) {
        return this.i32[p2 >> 2];
      }
      setInt(p2, v2) {
        this.i32[p2 >> 2] = v2;
      }
      getFr(p2) {
        const self2 = this;
        const idx = p2 >> 2;
        if (self2.i32[idx + 1] & 2147483648) {
          const arr = new Array(self2.n32);
          for (let i2 = 0; i2 < self2.n32; i2++) {
            arr[self2.n32 - 1 - i2] = self2.i32[idx + 2 + i2];
          }
          const res = self2.Fr.e(Scalar.fromArray(arr, 4294967296));
          if (self2.i32[idx + 1] & 1073741824) {
            return fromMontgomery(res);
          } else {
            return res;
          }
        } else {
          if (self2.i32[idx] & 2147483648) {
            return self2.Fr.e(self2.i32[idx] - 4294967296);
          } else {
            return self2.Fr.e(self2.i32[idx]);
          }
        }
        function fromMontgomery(n) {
          return self2.Fr.mul(self2.RInv, n);
        }
      }
      setFr(p2, v2) {
        const self2 = this;
        v2 = self2.Fr.e(v2);
        const minShort = self2.Fr.neg(self2.Fr.e("80000000", 16));
        const maxShort = self2.Fr.e("7FFFFFFF", 16);
        if (self2.Fr.geq(v2, minShort) && self2.Fr.leq(v2, maxShort)) {
          let a2;
          if (self2.Fr.geq(v2, self2.Fr.zero)) {
            a2 = Scalar.toNumber(v2);
          } else {
            a2 = Scalar.toNumber(self2.Fr.sub(v2, minShort));
            a2 = a2 - 2147483648;
            a2 = 4294967296 + a2;
          }
          self2.i32[p2 >> 2] = a2;
          self2.i32[(p2 >> 2) + 1] = 0;
          return;
        }
        self2.i32[p2 >> 2] = 0;
        self2.i32[(p2 >> 2) + 1] = 2147483648;
        const arr = Scalar.toArray(v2, 4294967296);
        for (let i2 = 0; i2 < self2.n32; i2++) {
          const idx = arr.length - 1 - i2;
          if (idx >= 0) {
            self2.i32[(p2 >> 2) + 2 + i2] = arr[idx];
          } else {
            self2.i32[(p2 >> 2) + 2 + i2] = 0;
          }
        }
      }
    };
    WitnessCalculatorCircom2 = class {
      constructor(instance, sanityCheck) {
        this.instance = instance;
        this.version = this.instance.exports.getVersion();
        this.n32 = this.instance.exports.getFieldNumLen32();
        this.instance.exports.getRawPrime();
        const arr = new Uint32Array(this.n32);
        for (let i2 = 0; i2 < this.n32; i2++) {
          arr[this.n32 - 1 - i2] = this.instance.exports.readSharedRWMemory(i2);
        }
        this.prime = Scalar.fromArray(arr, 4294967296);
        this.witnessSize = this.instance.exports.getWitnessSize();
        this.sanityCheck = sanityCheck;
      }
      circom_version() {
        return this.instance.exports.getVersion();
      }
      async _doCalculateWitness(input, sanityCheck) {
        this.instance.exports.init(this.sanityCheck || sanityCheck ? 1 : 0);
        const keys = Object.keys(input);
        var input_counter = 0;
        keys.forEach((k2) => {
          const h = fnvHash(k2);
          const hMSB = parseInt(h.slice(0, 8), 16);
          const hLSB = parseInt(h.slice(8, 16), 16);
          const fArr = flatArray(input[k2]);
          if (typeof this.instance.exports.getInputSignalSize === "function") {
            let signalSize = this.instance.exports.getInputSignalSize(hMSB, hLSB);
            if (signalSize < 0) {
              throw new Error(`Signal ${k2} not found
`);
            }
            if (fArr.length < signalSize) {
              throw new Error(`Not enough values for input signal ${k2}
`);
            }
            if (fArr.length > signalSize) {
              throw new Error(`Too many values for input signal ${k2}
`);
            }
          }
          for (let i2 = 0; i2 < fArr.length; i2++) {
            const arrFr = toArray32(normalize(fArr[i2], this.prime), this.n32);
            for (let j2 = 0; j2 < this.n32; j2++) {
              this.instance.exports.writeSharedRWMemory(j2, arrFr[this.n32 - 1 - j2]);
            }
            try {
              this.instance.exports.setInputSignal(hMSB, hLSB, i2);
              input_counter++;
            } catch (err) {
              throw new Error(err);
            }
          }
        });
        if (input_counter < this.instance.exports.getInputSize()) {
          throw new Error(`Not all inputs have been set. Only ${input_counter} out of ${this.instance.exports.getInputSize()}`);
        }
      }
      async calculateWitness(input, sanityCheck) {
        const w2 = [];
        await this._doCalculateWitness(input, sanityCheck);
        for (let i2 = 0; i2 < this.witnessSize; i2++) {
          this.instance.exports.getWitness(i2);
          const arr = new Uint32Array(this.n32);
          for (let j2 = 0; j2 < this.n32; j2++) {
            arr[this.n32 - 1 - j2] = this.instance.exports.readSharedRWMemory(j2);
          }
          w2.push(Scalar.fromArray(arr, 4294967296));
        }
        return w2;
      }
      async calculateWTNSBin(input, sanityCheck) {
        const buff32 = new Uint32Array(this.witnessSize * this.n32 + this.n32 + 11);
        const buff = new Uint8Array(buff32.buffer);
        await this._doCalculateWitness(input, sanityCheck);
        buff[0] = "w".charCodeAt(0);
        buff[1] = "t".charCodeAt(0);
        buff[2] = "n".charCodeAt(0);
        buff[3] = "s".charCodeAt(0);
        buff32[1] = 2;
        buff32[2] = 2;
        buff32[3] = 1;
        const n8 = this.n32 * 4;
        const idSection1length = 8 + n8;
        const idSection1lengthHex = idSection1length.toString(16);
        buff32[4] = parseInt(idSection1lengthHex.slice(0, 8), 16);
        buff32[5] = parseInt(idSection1lengthHex.slice(8, 16), 16);
        buff32[6] = n8;
        this.instance.exports.getRawPrime();
        var pos = 7;
        for (let j2 = 0; j2 < this.n32; j2++) {
          buff32[pos + j2] = this.instance.exports.readSharedRWMemory(j2);
        }
        pos += this.n32;
        buff32[pos] = this.witnessSize;
        pos++;
        buff32[pos] = 2;
        pos++;
        const idSection2length = n8 * this.witnessSize;
        const idSection2lengthHex = idSection2length.toString(16);
        buff32[pos] = parseInt(idSection2lengthHex.slice(0, 8), 16);
        buff32[pos + 1] = parseInt(idSection2lengthHex.slice(8, 16), 16);
        pos += 2;
        for (let i2 = 0; i2 < this.witnessSize; i2++) {
          this.instance.exports.getWitness(i2);
          for (let j2 = 0; j2 < this.n32; j2++) {
            buff32[pos + j2] = this.instance.exports.readSharedRWMemory(j2);
          }
          pos += this.n32;
        }
        return buff;
      }
    };
    ({ unstringifyBigInts: unstringifyBigInts$b } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$a } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$9 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$8 } = utils);
    groth16 = Object.freeze({
      __proto__: null,
      fullProve: groth16FullProve,
      prove: groth16Prove,
      verify: groth16Verify,
      exportSolidityCallData: groth16ExportSolidityCallData
    });
    sameRatio$1 = sameRatio$2;
    powersoftau = Object.freeze({
      __proto__: null,
      newAccumulator,
      exportChallenge,
      importResponse,
      verify,
      challengeContribute,
      beacon: beacon$1,
      contribute,
      preparePhase2,
      truncate,
      convert,
      exportJson
    });
    SUBARRAY_SIZE$1 = 262144;
    BigArrayHandler$1 = {
      get: function(obj, prop) {
        if (!isNaN(prop)) {
          return obj.getElement(prop);
        } else return obj[prop];
      },
      set: function(obj, prop, value) {
        if (!isNaN(prop)) {
          return obj.setElement(prop, value);
        } else {
          obj[prop] = value;
          return true;
        }
      }
    };
    _BigArray$1 = class {
      constructor(initSize) {
        this.length = initSize || 0;
        this.arr = new Array(SUBARRAY_SIZE$1);
        for (let i2 = 0; i2 < initSize; i2 += SUBARRAY_SIZE$1) {
          this.arr[i2 / SUBARRAY_SIZE$1] = new Array(Math.min(SUBARRAY_SIZE$1, initSize - i2));
        }
        return this;
      }
      push() {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.setElement(this.length, arguments[i2]);
        }
      }
      slice(f2, t) {
        const arr = new Array(t - f2);
        for (let i2 = f2; i2 < t; i2++) arr[i2 - f2] = this.getElement(i2);
        return arr;
      }
      getElement(idx) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE$1);
        const idx2 = idx % SUBARRAY_SIZE$1;
        return this.arr[idx1] ? this.arr[idx1][idx2] : void 0;
      }
      setElement(idx, value) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE$1);
        if (!this.arr[idx1]) {
          this.arr[idx1] = new Array(SUBARRAY_SIZE$1);
        }
        const idx2 = idx % SUBARRAY_SIZE$1;
        this.arr[idx1][idx2] = value;
        if (idx >= this.length) this.length = idx + 1;
        return true;
      }
      getKeys() {
        const newA = new BigArray$2();
        for (let i2 = 0; i2 < this.arr.length; i2++) {
          if (this.arr[i2]) {
            for (let j2 = 0; j2 < this.arr[i2].length; j2++) {
              if (typeof this.arr[i2][j2] !== "undefined") {
                newA.push(i2 * SUBARRAY_SIZE$1 + j2);
              }
            }
          }
        }
        return newA;
      }
    };
    BigArray$2 = class {
      constructor(initSize) {
        const obj = new _BigArray$1(initSize);
        const extObj = new Proxy(obj, BigArrayHandler$1);
        return extObj;
      }
    };
    BigArray$3 = BigArray$2;
    R1CS_FILE_CUSTOM_GATES_LIST_SECTION = 4;
    R1CS_FILE_CUSTOM_GATES_USES_SECTION = 5;
    bls12381r2 = Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001", 16);
    bn128r2 = Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");
    r1cs = Object.freeze({
      __proto__: null,
      print: r1csPrint,
      info: r1csInfo,
      exportJson: r1csExportJson
    });
    ({ unstringifyBigInts: unstringifyBigInts$7 } = utils);
    wtns = Object.freeze({
      __proto__: null,
      calculate: wtnsCalculate,
      debug: wtnsDebug,
      exportJson: wtnsExportJson,
      check: wtnsCheck
    });
    SUBARRAY_SIZE = 262144;
    BigArrayHandler = {
      get: function(obj, prop) {
        if (!isNaN(prop)) {
          return obj.getElement(prop);
        } else return obj[prop];
      },
      set: function(obj, prop, value) {
        if (!isNaN(prop)) {
          return obj.setElement(prop, value);
        } else {
          obj[prop] = value;
          return true;
        }
      }
    };
    _BigArray = class {
      constructor(initSize) {
        this.length = initSize || 0;
        this.arr = new Array(SUBARRAY_SIZE);
        for (let i2 = 0; i2 < initSize; i2 += SUBARRAY_SIZE) {
          this.arr[i2 / SUBARRAY_SIZE] = new Array(Math.min(SUBARRAY_SIZE, initSize - i2));
        }
        return this;
      }
      push() {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.setElement(this.length, arguments[i2]);
        }
      }
      slice(f2, t) {
        const arr = new Array(t - f2);
        for (let i2 = f2; i2 < t; i2++) arr[i2 - f2] = this.getElement(i2);
        return arr;
      }
      getElement(idx) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE);
        const idx2 = idx % SUBARRAY_SIZE;
        return this.arr[idx1] ? this.arr[idx1][idx2] : void 0;
      }
      setElement(idx, value) {
        idx = parseInt(idx);
        const idx1 = Math.floor(idx / SUBARRAY_SIZE);
        if (!this.arr[idx1]) {
          this.arr[idx1] = new Array(SUBARRAY_SIZE);
        }
        const idx2 = idx % SUBARRAY_SIZE;
        this.arr[idx1][idx2] = value;
        if (idx >= this.length) this.length = idx + 1;
        return true;
      }
      getKeys() {
        const newA = new BigArray();
        for (let i2 = 0; i2 < this.arr.length; i2++) {
          if (this.arr[i2]) {
            for (let j2 = 0; j2 < this.arr[i2].length; j2++) {
              if (typeof this.arr[i2][j2] !== "undefined") {
                newA.push(i2 * SUBARRAY_SIZE + j2);
              }
            }
          }
        }
        return newA;
      }
    };
    BigArray = class {
      constructor(initSize) {
        const obj = new _BigArray(initSize);
        const extObj = new Proxy(obj, BigArrayHandler);
        return extObj;
      }
    };
    BigArray$1 = BigArray;
    sameRatio = sameRatio$2;
    ({ stringifyBigInts: stringifyBigInts$3 } = utils);
    ejs = {};
    ({ unstringifyBigInts: unstringifyBigInts$6, stringifyBigInts: stringifyBigInts$2 } = utils);
    zkey = Object.freeze({
      __proto__: null,
      newZKey,
      exportBellman: phase2exportMPCParams,
      importBellman: phase2importMPCParams,
      verifyFromR1cs: phase2verifyFromR1cs,
      verifyFromInit: phase2verifyFromInit,
      contribute: phase2contribute,
      beacon,
      exportJson: zkeyExportJson,
      bellmanContribute,
      exportVerificationKey: zkeyExportVerificationKey,
      exportSolidityVerifier
    });
    Proof = class {
      constructor(curve2, logger) {
        this.curve = curve2;
        this.logger = logger;
        this.resetProof();
      }
      resetProof() {
        this.polynomials = {};
        this.evaluations = {};
      }
      addPolynomial(key, polynomial) {
        if (key in this.polynomials) {
          this.logger.warn(`proof: polynomial.${key} already exist in proof`);
        }
        this.polynomials[key] = polynomial;
      }
      getPolynomial(key) {
        if (!(key in this.polynomials)) {
          this.logger.warn(`proof: polynomial ${key} does not exist in proof`);
        }
        return this.polynomials[key];
      }
      addEvaluation(key, evaluation) {
        if (key in this.evaluations) {
          this.logger.warn(`proof: evaluations.${key} already exist in proof`);
        }
        this.evaluations[key] = evaluation;
      }
      getEvaluation(key) {
        if (!(key in this.evaluations)) {
          this.logger.warn(`proof: evaluation ${key} does not exist in proof`);
        }
        return this.evaluations[key];
      }
      toObjectProof(splitFields = true) {
        let res = splitFields ? { polynomials: {}, evaluations: {} } : {};
        Object.keys(this.polynomials).forEach((key) => {
          const value = this.curve.G1.toObject(this.polynomials[key]);
          if (splitFields) {
            res.polynomials[key] = value;
          } else {
            res[key] = value;
          }
        });
        Object.keys(this.evaluations).forEach((key) => {
          const value = this.curve.Fr.toObject(this.evaluations[key]);
          if (splitFields) {
            res.evaluations[key] = value;
          } else {
            res[key] = value;
          }
        });
        return res;
      }
      fromObjectProof(objectProof) {
        this.resetProof();
        Object.keys(objectProof.polynomials).forEach((key) => {
          this.polynomials[key] = this.curve.G1.fromObject(objectProof.polynomials[key]);
        });
        Object.keys(objectProof.evaluations).forEach((key) => {
          this.evaluations[key] = this.curve.Fr.fromObject(objectProof.evaluations[key]);
        });
      }
    };
    sha3 = { exports: {} };
    (function(module) {
      (function() {
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = commonjsGlobal;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
        var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(bits3, padding, outputType) {
          return function(message) {
            return new Keccak(bits3, padding, bits3).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits3, padding, outputType) {
          return function(message, outputBits) {
            return new Keccak(bits3, padding, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits3, padding, outputType) {
          return function(message, outputBits, n, s2) {
            return methods["cshake" + bits3].update(message, outputBits, n, s2)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits3, padding, outputType) {
          return function(key, message, outputBits, s2) {
            return methods["kmac" + bits3].update(key, message, outputBits, s2)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits3, padding) {
          for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
            var type = OUTPUT_TYPES[i3];
            method[type] = createMethod2(bits3, padding, type);
          }
          return method;
        };
        var createMethod = function(bits3, padding) {
          var method = createOutputMethod(bits3, padding, "hex");
          method.create = function() {
            return new Keccak(bits3, padding, bits3);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          return createOutputMethods(method, createOutputMethod, bits3, padding);
        };
        var createShakeMethod = function(bits3, padding) {
          var method = createShakeOutputMethod(bits3, padding, "hex");
          method.create = function(outputBits) {
            return new Keccak(bits3, padding, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits3, padding);
        };
        var createCshakeMethod = function(bits3, padding) {
          var w2 = CSHAKE_BYTEPAD[bits3];
          var method = createCshakeOutputMethod(bits3, padding, "hex");
          method.create = function(outputBits, n, s2) {
            if (!n && !s2) {
              return methods["shake" + bits3].create(outputBits);
            } else {
              return new Keccak(bits3, padding, outputBits).bytepad([n, s2], w2);
            }
          };
          method.update = function(message, outputBits, n, s2) {
            return method.create(outputBits, n, s2).update(message);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits3, padding);
        };
        var createKmacMethod = function(bits3, padding) {
          var w2 = CSHAKE_BYTEPAD[bits3];
          var method = createKmacOutputMethod(bits3, padding, "hex");
          method.create = function(key, outputBits, s2) {
            return new Kmac(bits3, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
          };
          method.update = function(key, message, outputBits, s2) {
            return method.create(key, outputBits, s2).update(message);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits3, padding);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i2 = 0; i2 < algorithms.length; ++i2) {
          var algorithm = algorithms[i2];
          var bits2 = algorithm.bits;
          for (var j2 = 0; j2 < bits2.length; ++j2) {
            var methodName = algorithm.name + "_" + bits2[j2];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits2[j2], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits2[j2];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak(bits3, padding, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits3 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i3 = 0; i3 < 50; ++i3) {
            this.s[i3] = 0;
          }
        }
        Keccak.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code;
          while (index < length2) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i3 = 1; i3 < blockCount + 1; ++i3) {
                blocks[i3] = 0;
              }
            }
            if (notString) {
              for (i3 = this.start; index < length2 && i3 < byteCount; ++index) {
                blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
              }
            } else {
              for (i3 = this.start; index < length2 && i3 < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks[i3 >> 2] |= code << SHIFT[i3++ & 3];
                } else if (code < 2048) {
                  blocks[i3 >> 2] |= (192 | code >> 6) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks[i3 >> 2] |= (224 | code >> 12) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks[i3 >> 2] |= (240 | code >> 18) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                }
              }
            }
            this.lastByteIndex = i3;
            if (i3 >= byteCount) {
              this.start = i3 - byteCount;
              this.block = blocks[blockCount];
              for (i3 = 0; i3 < blockCount; ++i3) {
                s2[i3] ^= blocks[i3];
              }
              f2(s2);
              this.reset = true;
            } else {
              this.start = i3;
            }
          }
          return this;
        };
        Keccak.prototype.encode = function(x2, right) {
          var o2 = x2 & 255, n = 1;
          var bytes = [o2];
          x2 = x2 >> 8;
          o2 = x2 & 255;
          while (o2 > 0) {
            bytes.unshift(o2);
            x2 = x2 >> 8;
            o2 = x2 & 255;
            ++n;
          }
          if (right) {
            bytes.push(n);
          } else {
            bytes.unshift(n);
          }
          this.update(bytes);
          return bytes.length;
        };
        Keccak.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes = 0, length2 = str.length;
          if (notString) {
            bytes = length2;
          } else {
            for (var i3 = 0; i3 < str.length; ++i3) {
              var code = str.charCodeAt(i3);
              if (code < 128) {
                bytes += 1;
              } else if (code < 2048) {
                bytes += 2;
              } else if (code < 55296 || code >= 57344) {
                bytes += 3;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i3) & 1023);
                bytes += 4;
              }
            }
          }
          bytes += this.encode(bytes * 8);
          this.update(str);
          return bytes;
        };
        Keccak.prototype.bytepad = function(strs, w2) {
          var bytes = this.encode(w2);
          for (var i3 = 0; i3 < strs.length; ++i3) {
            bytes += this.encodeString(strs[i3]);
          }
          var paddingBytes = w2 - bytes % w2;
          var zeros = [];
          zeros.length = paddingBytes;
          this.update(zeros);
          return this;
        };
        Keccak.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
          blocks[i3 >> 2] |= this.padding[i3 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f2(s2);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
          var hex2 = "", block;
          while (j3 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
              block = s2[i3];
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j3 % blockCount === 0) {
              f2(s2);
              i3 = 0;
            }
          }
          if (extraBytes) {
            block = s2[i3];
            hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            if (extraBytes > 1) {
              hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex2;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
          var bytes = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes);
          }
          var array = new Uint32Array(buffer);
          while (j3 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
              array[j3] = s2[i3];
            }
            if (j3 % blockCount === 0) {
              f2(s2);
            }
          }
          if (extraBytes) {
            array[i3] = s2[i3];
            buffer = buffer.slice(0, bytes);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
          var array = [], offset, block;
          while (j3 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
              offset = j3 << 2;
              block = s2[i3];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j3 % blockCount === 0) {
              f2(s2);
            }
          }
          if (extraBytes) {
            offset = j3 << 2;
            block = s2[i3];
            array[offset] = block & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits3, padding, outputBits) {
          Keccak.call(this, bits3, padding, outputBits);
        }
        Kmac.prototype = new Keccak();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak.prototype.finalize.call(this);
        };
        var f2 = function(s2) {
          var h, l2, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n = 0; n < 48; n += 2) {
            c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
            c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
            c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
            c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
            c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
            c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
            c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
            c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
            c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
            c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l2 = c9 ^ (c3 << 1 | c2 >>> 31);
            s2[0] ^= h;
            s2[1] ^= l2;
            s2[10] ^= h;
            s2[11] ^= l2;
            s2[20] ^= h;
            s2[21] ^= l2;
            s2[30] ^= h;
            s2[31] ^= l2;
            s2[40] ^= h;
            s2[41] ^= l2;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l2 = c1 ^ (c5 << 1 | c4 >>> 31);
            s2[2] ^= h;
            s2[3] ^= l2;
            s2[12] ^= h;
            s2[13] ^= l2;
            s2[22] ^= h;
            s2[23] ^= l2;
            s2[32] ^= h;
            s2[33] ^= l2;
            s2[42] ^= h;
            s2[43] ^= l2;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l2 = c3 ^ (c7 << 1 | c6 >>> 31);
            s2[4] ^= h;
            s2[5] ^= l2;
            s2[14] ^= h;
            s2[15] ^= l2;
            s2[24] ^= h;
            s2[25] ^= l2;
            s2[34] ^= h;
            s2[35] ^= l2;
            s2[44] ^= h;
            s2[45] ^= l2;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l2 = c5 ^ (c9 << 1 | c8 >>> 31);
            s2[6] ^= h;
            s2[7] ^= l2;
            s2[16] ^= h;
            s2[17] ^= l2;
            s2[26] ^= h;
            s2[27] ^= l2;
            s2[36] ^= h;
            s2[37] ^= l2;
            s2[46] ^= h;
            s2[47] ^= l2;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l2 = c7 ^ (c1 << 1 | c0 >>> 31);
            s2[8] ^= h;
            s2[9] ^= l2;
            s2[18] ^= h;
            s2[19] ^= l2;
            s2[28] ^= h;
            s2[29] ^= l2;
            s2[38] ^= h;
            s2[39] ^= l2;
            s2[48] ^= h;
            s2[49] ^= l2;
            b0 = s2[0];
            b1 = s2[1];
            b32 = s2[11] << 4 | s2[10] >>> 28;
            b33 = s2[10] << 4 | s2[11] >>> 28;
            b14 = s2[20] << 3 | s2[21] >>> 29;
            b15 = s2[21] << 3 | s2[20] >>> 29;
            b46 = s2[31] << 9 | s2[30] >>> 23;
            b47 = s2[30] << 9 | s2[31] >>> 23;
            b28 = s2[40] << 18 | s2[41] >>> 14;
            b29 = s2[41] << 18 | s2[40] >>> 14;
            b20 = s2[2] << 1 | s2[3] >>> 31;
            b21 = s2[3] << 1 | s2[2] >>> 31;
            b2 = s2[13] << 12 | s2[12] >>> 20;
            b3 = s2[12] << 12 | s2[13] >>> 20;
            b34 = s2[22] << 10 | s2[23] >>> 22;
            b35 = s2[23] << 10 | s2[22] >>> 22;
            b16 = s2[33] << 13 | s2[32] >>> 19;
            b17 = s2[32] << 13 | s2[33] >>> 19;
            b48 = s2[42] << 2 | s2[43] >>> 30;
            b49 = s2[43] << 2 | s2[42] >>> 30;
            b40 = s2[5] << 30 | s2[4] >>> 2;
            b41 = s2[4] << 30 | s2[5] >>> 2;
            b22 = s2[14] << 6 | s2[15] >>> 26;
            b23 = s2[15] << 6 | s2[14] >>> 26;
            b4 = s2[25] << 11 | s2[24] >>> 21;
            b5 = s2[24] << 11 | s2[25] >>> 21;
            b36 = s2[34] << 15 | s2[35] >>> 17;
            b37 = s2[35] << 15 | s2[34] >>> 17;
            b18 = s2[45] << 29 | s2[44] >>> 3;
            b19 = s2[44] << 29 | s2[45] >>> 3;
            b10 = s2[6] << 28 | s2[7] >>> 4;
            b11 = s2[7] << 28 | s2[6] >>> 4;
            b42 = s2[17] << 23 | s2[16] >>> 9;
            b43 = s2[16] << 23 | s2[17] >>> 9;
            b24 = s2[26] << 25 | s2[27] >>> 7;
            b25 = s2[27] << 25 | s2[26] >>> 7;
            b6 = s2[36] << 21 | s2[37] >>> 11;
            b7 = s2[37] << 21 | s2[36] >>> 11;
            b38 = s2[47] << 24 | s2[46] >>> 8;
            b39 = s2[46] << 24 | s2[47] >>> 8;
            b30 = s2[8] << 27 | s2[9] >>> 5;
            b31 = s2[9] << 27 | s2[8] >>> 5;
            b12 = s2[18] << 20 | s2[19] >>> 12;
            b13 = s2[19] << 20 | s2[18] >>> 12;
            b44 = s2[29] << 7 | s2[28] >>> 25;
            b45 = s2[28] << 7 | s2[29] >>> 25;
            b26 = s2[38] << 8 | s2[39] >>> 24;
            b27 = s2[39] << 8 | s2[38] >>> 24;
            b8 = s2[48] << 14 | s2[49] >>> 18;
            b9 = s2[49] << 14 | s2[48] >>> 18;
            s2[0] = b0 ^ ~b2 & b4;
            s2[1] = b1 ^ ~b3 & b5;
            s2[10] = b10 ^ ~b12 & b14;
            s2[11] = b11 ^ ~b13 & b15;
            s2[20] = b20 ^ ~b22 & b24;
            s2[21] = b21 ^ ~b23 & b25;
            s2[30] = b30 ^ ~b32 & b34;
            s2[31] = b31 ^ ~b33 & b35;
            s2[40] = b40 ^ ~b42 & b44;
            s2[41] = b41 ^ ~b43 & b45;
            s2[2] = b2 ^ ~b4 & b6;
            s2[3] = b3 ^ ~b5 & b7;
            s2[12] = b12 ^ ~b14 & b16;
            s2[13] = b13 ^ ~b15 & b17;
            s2[22] = b22 ^ ~b24 & b26;
            s2[23] = b23 ^ ~b25 & b27;
            s2[32] = b32 ^ ~b34 & b36;
            s2[33] = b33 ^ ~b35 & b37;
            s2[42] = b42 ^ ~b44 & b46;
            s2[43] = b43 ^ ~b45 & b47;
            s2[4] = b4 ^ ~b6 & b8;
            s2[5] = b5 ^ ~b7 & b9;
            s2[14] = b14 ^ ~b16 & b18;
            s2[15] = b15 ^ ~b17 & b19;
            s2[24] = b24 ^ ~b26 & b28;
            s2[25] = b25 ^ ~b27 & b29;
            s2[34] = b34 ^ ~b36 & b38;
            s2[35] = b35 ^ ~b37 & b39;
            s2[44] = b44 ^ ~b46 & b48;
            s2[45] = b45 ^ ~b47 & b49;
            s2[6] = b6 ^ ~b8 & b0;
            s2[7] = b7 ^ ~b9 & b1;
            s2[16] = b16 ^ ~b18 & b10;
            s2[17] = b17 ^ ~b19 & b11;
            s2[26] = b26 ^ ~b28 & b20;
            s2[27] = b27 ^ ~b29 & b21;
            s2[36] = b36 ^ ~b38 & b30;
            s2[37] = b37 ^ ~b39 & b31;
            s2[46] = b46 ^ ~b48 & b40;
            s2[47] = b47 ^ ~b49 & b41;
            s2[8] = b8 ^ ~b0 & b2;
            s2[9] = b9 ^ ~b1 & b3;
            s2[18] = b18 ^ ~b10 & b12;
            s2[19] = b19 ^ ~b11 & b13;
            s2[28] = b28 ^ ~b20 & b22;
            s2[29] = b29 ^ ~b21 & b23;
            s2[38] = b38 ^ ~b30 & b32;
            s2[39] = b39 ^ ~b31 & b33;
            s2[48] = b48 ^ ~b40 & b42;
            s2[49] = b49 ^ ~b41 & b43;
            s2[0] ^= RC[n];
            s2[1] ^= RC[n + 1];
          }
        };
        if (COMMON_JS) {
          module.exports = methods;
        } else {
          for (i2 = 0; i2 < methodNames.length; ++i2) {
            root[methodNames[i2]] = methods[methodNames[i2]];
          }
        }
      })();
    })(sha3);
    jsSha3 = sha3.exports;
    ({ keccak256 } = jsSha3);
    POLYNOMIAL = 0;
    SCALAR = 1;
    Keccak256Transcript = class {
      constructor(curve2) {
        this.G1 = curve2.G1;
        this.Fr = curve2.Fr;
        this.reset();
      }
      reset() {
        this.data = [];
      }
      addPolCommitment(polynomialCommitment) {
        this.data.push({ type: POLYNOMIAL, data: polynomialCommitment });
      }
      addScalar(scalar) {
        this.data.push({ type: SCALAR, data: scalar });
      }
      getChallenge() {
        if (0 === this.data.length) {
          throw new Error("Keccak256Transcript: No data to generate a transcript");
        }
        let nPolynomials = 0;
        let nScalars = 0;
        this.data.forEach((element) => POLYNOMIAL === element.type ? nPolynomials++ : nScalars++);
        let buffer = new Uint8Array(nScalars * this.Fr.n8 + nPolynomials * this.G1.F.n8 * 2);
        let offset = 0;
        for (let i2 = 0; i2 < this.data.length; i2++) {
          if (POLYNOMIAL === this.data[i2].type) {
            this.G1.toRprUncompressed(buffer, offset, this.data[i2].data);
            offset += this.G1.F.n8 * 2;
          } else {
            this.Fr.toRprBE(buffer, offset, this.data[i2].data);
            offset += this.Fr.n8;
          }
        }
        const value = Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(buffer)));
        return this.Fr.e(value);
      }
    };
    MulZ = class {
      static getZ1(Fr) {
        return [
          Fr.zero,
          Fr.add(Fr.e(-1), Fr.w[2]),
          Fr.e(-2),
          Fr.sub(Fr.e(-1), Fr.w[2])
        ];
      }
      static getZ2(Fr) {
        return [
          Fr.zero,
          Fr.add(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2])),
          Fr.e(4),
          Fr.sub(Fr.zero, Fr.mul(Fr.e(-2), Fr.w[2]))
        ];
      }
      static getZ3(Fr) {
        return [
          Fr.zero,
          Fr.add(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2])),
          Fr.e(-8),
          Fr.sub(Fr.e(2), Fr.mul(Fr.e(2), Fr.w[2]))
        ];
      }
      static mul2(a2, b2, ap, bp, p2, Fr) {
        const Z1 = this.getZ1(Fr);
        let r2, rz;
        const a_b = Fr.mul(a2, b2);
        const a_bp = Fr.mul(a2, bp);
        const ap_b = Fr.mul(ap, b2);
        const ap_bp = Fr.mul(ap, bp);
        r2 = a_b;
        let a0 = Fr.add(a_bp, ap_b);
        let a1 = ap_bp;
        rz = a0;
        if (p2) {
          rz = Fr.add(rz, Fr.mul(Z1[p2], a1));
        }
        return [r2, rz];
      }
      static mul3(a2, b2, c2, ap, bp, cp, p2, Fr) {
        const Z1 = this.getZ1(Fr);
        const Z2 = this.getZ2(Fr);
        let r2, rz;
        const a_b = Fr.mul(a2, b2);
        const a_bp = Fr.mul(a2, bp);
        const ap_b = Fr.mul(ap, b2);
        const ap_bp = Fr.mul(ap, bp);
        r2 = Fr.mul(a_b, c2);
        let a0 = Fr.mul(ap_b, c2);
        a0 = Fr.add(a0, Fr.mul(a_bp, c2));
        a0 = Fr.add(a0, Fr.mul(a_b, cp));
        let a1 = Fr.mul(ap_bp, c2);
        a1 = Fr.add(a1, Fr.mul(a_bp, cp));
        a1 = Fr.add(a1, Fr.mul(ap_b, cp));
        rz = a0;
        if (p2) {
          const a22 = Fr.mul(ap_bp, cp);
          rz = Fr.add(rz, Fr.mul(Z1[p2], a1));
          rz = Fr.add(rz, Fr.mul(Z2[p2], a22));
        }
        return [r2, rz];
      }
      static mul4(a2, b2, c2, d, ap, bp, cp, dp, p2, Fr) {
        const Z1 = this.getZ1(Fr);
        const Z2 = this.getZ2(Fr);
        const Z3 = this.getZ3(Fr);
        let r2, rz;
        const a_b = Fr.mul(a2, b2);
        const a_bp = Fr.mul(a2, bp);
        const ap_b = Fr.mul(ap, b2);
        const ap_bp = Fr.mul(ap, bp);
        const c_d = Fr.mul(c2, d);
        const c_dp = Fr.mul(c2, dp);
        const cp_d = Fr.mul(cp, d);
        const cp_dp = Fr.mul(cp, dp);
        r2 = Fr.mul(a_b, c_d);
        let a0 = Fr.mul(ap_b, c_d);
        a0 = Fr.add(a0, Fr.mul(a_bp, c_d));
        a0 = Fr.add(a0, Fr.mul(a_b, cp_d));
        a0 = Fr.add(a0, Fr.mul(a_b, c_dp));
        let a1 = Fr.mul(ap_bp, c_d);
        a1 = Fr.add(a1, Fr.mul(ap_b, cp_d));
        a1 = Fr.add(a1, Fr.mul(ap_b, c_dp));
        a1 = Fr.add(a1, Fr.mul(a_bp, cp_d));
        a1 = Fr.add(a1, Fr.mul(a_bp, c_dp));
        a1 = Fr.add(a1, Fr.mul(a_b, cp_dp));
        let a22 = Fr.mul(a_bp, cp_dp);
        a22 = Fr.add(a22, Fr.mul(ap_b, cp_dp));
        a22 = Fr.add(a22, Fr.mul(ap_bp, c_dp));
        a22 = Fr.add(a22, Fr.mul(ap_bp, cp_d));
        let a3 = Fr.mul(ap_bp, cp_dp);
        rz = a0;
        if (p2) {
          rz = Fr.add(rz, Fr.mul(Z1[p2], a1));
          rz = Fr.add(rz, Fr.mul(Z2[p2], a22));
          rz = Fr.add(rz, Fr.mul(Z3[p2], a3));
        }
        return [r2, rz];
      }
    };
    ZKEY_PL_ADDITIONS_SECTION = 3;
    ZKEY_PL_A_MAP_SECTION = 4;
    ZKEY_PL_B_MAP_SECTION = 5;
    ZKEY_PL_C_MAP_SECTION = 6;
    ZKEY_PL_QM_SECTION = 7;
    ZKEY_PL_QL_SECTION = 8;
    ZKEY_PL_QR_SECTION = 9;
    ZKEY_PL_QO_SECTION = 10;
    ZKEY_PL_QC_SECTION = 11;
    ZKEY_PL_SIGMA_SECTION = 12;
    ZKEY_PL_LAGRANGE_SECTION = 13;
    ZKEY_PL_PTAU_SECTION = 14;
    Polynomial = class _Polynomial {
      constructor(coefficients, curve2, logger) {
        this.coef = coefficients;
        this.curve = curve2;
        this.Fr = curve2.Fr;
        this.G1 = curve2.G1;
        this.logger = logger;
      }
      static async fromEvaluations(buffer, curve2, logger) {
        let coefficients = await curve2.Fr.ifft(buffer);
        return new _Polynomial(coefficients, curve2, logger);
      }
      static fromCoefficientsArray(array, curve2, logger) {
        const Fr = curve2.Fr;
        let buff = array.length > 2 << 14 ? new BigBuffer(array.length * Fr.n8) : new Uint8Array(array.length * Fr.n8);
        for (let i2 = 0; i2 < array.length; i2++) buff.set(array[i2], i2 * Fr.n8);
        return new _Polynomial(buff, curve2, logger);
      }
      static fromPolynomial(polynomial, curve2, logger) {
        let length2 = polynomial.length();
        let Fr = curve2.Fr;
        let buff = length2 > 2 << 14 ? new BigBuffer(length2 * Fr.n8) : new Uint8Array(length2 * Fr.n8);
        buff.set(polynomial.coef.slice(), 0);
        return new _Polynomial(buff, curve2, logger);
      }
      isEqual(polynomial) {
        const degree = this.degree();
        if (degree !== polynomial.degree()) return false;
        for (let i2 = 0; i2 < degree + 1; i2++) {
          if (!this.Fr.eq(this.getCoef(i2), polynomial.getCoef(i2))) return false;
        }
        return true;
      }
      blindCoefficients(blindingFactors) {
        blindingFactors = blindingFactors || [];
        const blindedCoefficients = this.length() + blindingFactors.length > 2 << 14 ? new BigBuffer((this.length() + blindingFactors.length) * this.Fr.n8) : new Uint8Array((this.length() + blindingFactors.length) * this.Fr.n8);
        blindedCoefficients.set(this.coef, 0);
        for (let i2 = 0; i2 < blindingFactors.length; i2++) {
          blindedCoefficients.set(
            this.Fr.add(
              blindedCoefficients.slice((this.length() + i2) * this.Fr.n8, (this.length() + i2 + 1) * this.Fr.n8),
              blindingFactors[i2]
            ),
            (this.length() + i2) * this.Fr.n8
          );
          blindedCoefficients.set(
            this.Fr.sub(
              blindedCoefficients.slice(i2 * this.Fr.n8, (i2 + 1) * this.Fr.n8),
              blindingFactors[i2]
            ),
            i2 * this.Fr.n8
          );
        }
        this.coef = blindedCoefficients;
      }
      getCoef(index) {
        const i_n8 = index * this.Fr.n8;
        if (i_n8 + this.Fr.n8 > this.coef.byteLength) return this.Fr.zero;
        return this.coef.slice(i_n8, i_n8 + this.Fr.n8);
      }
      setCoef(index, value) {
        if (index > this.length() - 1) {
          throw new Error("Coef index is not available");
        }
        this.coef.set(value, index * this.Fr.n8);
      }
      static async to4T(buffer, domainSize, blindingFactors, Fr) {
        blindingFactors = blindingFactors || [];
        let a2 = await Fr.ifft(buffer);
        const a4 = domainSize * 4 > 2 << 14 ? new BigBuffer(domainSize * 4 * Fr.n8) : new Uint8Array(domainSize * 4 * Fr.n8);
        a4.set(a2, 0);
        const A4 = await Fr.fft(a4);
        if (blindingFactors.length === 0) {
          return [a2, A4];
        }
        const a1 = domainSize + blindingFactors.length > 2 << 14 ? new BigBuffer((domainSize + blindingFactors.length) * Fr.n8) : new Uint8Array((domainSize + blindingFactors.length) * Fr.n8);
        a1.set(a2, 0);
        for (let i2 = 0; i2 < blindingFactors.length; i2++) {
          a1.set(
            Fr.add(
              a1.slice((domainSize + i2) * Fr.n8, (domainSize + i2 + 1) * Fr.n8),
              blindingFactors[i2]
            ),
            (domainSize + i2) * Fr.n8
          );
          a1.set(
            Fr.sub(
              a1.slice(i2 * Fr.n8, (i2 + 1) * Fr.n8),
              blindingFactors[i2]
            ),
            i2 * Fr.n8
          );
        }
        return [a1, A4];
      }
      length() {
        let length2 = this.coef.byteLength / this.Fr.n8;
        if (length2 !== Math.floor(this.coef.byteLength / this.Fr.n8)) {
          throw new Error("Polynomial coefficients buffer has incorrect size");
        }
        if (0 === length2) {
          if (this.logger) {
            this.logger.warn("Polynomial has length zero");
          }
        }
        return length2;
      }
      degree() {
        for (let i2 = this.length() - 1; i2 > 0; i2--) {
          const i_n8 = i2 * this.Fr.n8;
          if (!this.Fr.eq(this.Fr.zero, this.coef.slice(i_n8, i_n8 + this.Fr.n8))) {
            return i2;
          }
        }
        return 0;
      }
      evaluate(point) {
        let res = this.Fr.zero;
        for (let i2 = this.degree() + 1; i2 > 0; i2--) {
          let i_n8 = i2 * this.Fr.n8;
          const currentCoefficient = this.coef.slice(i_n8 - this.Fr.n8, i_n8);
          res = this.Fr.add(currentCoefficient, this.Fr.mul(res, point));
        }
        return res;
      }
      fastEvaluate(point) {
        const Fr = this.Fr;
        let nThreads = 3;
        let nCoefs = this.degree() + 1;
        let coefsThread = parseInt(nCoefs / nThreads);
        let residualCoefs = nCoefs - coefsThread * nThreads;
        let res = [];
        let xN = [];
        xN[0] = Fr.one;
        for (let i2 = 0; i2 < nThreads; i2++) {
          res[i2] = Fr.zero;
          let nCoefs2 = i2 === nThreads - 1 ? coefsThread + residualCoefs : coefsThread;
          for (let j2 = nCoefs2; j2 > 0; j2--) {
            res[i2] = Fr.add(this.getCoef(i2 * coefsThread + j2 - 1), Fr.mul(res[i2], point));
            if (i2 === 0) xN[0] = Fr.mul(xN[0], point);
          }
        }
        for (let i2 = 1; i2 < nThreads; i2++) {
          res[0] = Fr.add(res[0], Fr.mul(xN[i2 - 1], res[i2]));
          xN[i2] = Fr.mul(xN[i2 - 1], xN[0]);
        }
        return res[0];
      }
      add(polynomial, blindingValue) {
        let other = false;
        if (polynomial.length() > this.length()) {
          other = true;
        }
        const thisLength = this.length();
        const polyLength = polynomial.length();
        for (let i2 = 0; i2 < Math.max(thisLength, polyLength); i2++) {
          const i_n8 = i2 * this.Fr.n8;
          const a2 = i2 < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;
          let b2 = i2 < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;
          if (blindingValue !== void 0) {
            b2 = this.Fr.mul(b2, blindingValue);
          }
          if (other) {
            polynomial.coef.set(this.Fr.add(a2, b2), i_n8);
          } else {
            this.coef.set(this.Fr.add(a2, b2), i_n8);
          }
        }
        if (other) {
          delete this.coef;
          this.coef = polynomial.coef;
        }
      }
      sub(polynomial, blindingValue) {
        let other = false;
        if (polynomial.length() > this.length()) {
          other = true;
        }
        const thisLength = this.length();
        const polyLength = polynomial.length();
        for (let i2 = 0; i2 < Math.max(thisLength, polyLength); i2++) {
          const i_n8 = i2 * this.Fr.n8;
          const a2 = i2 < thisLength ? this.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;
          let b2 = i2 < polyLength ? polynomial.coef.slice(i_n8, i_n8 + this.Fr.n8) : this.Fr.zero;
          if (blindingValue !== void 0) {
            b2 = this.Fr.mul(b2, blindingValue);
          }
          if (other) {
            polynomial.coef.set(this.Fr.sub(a2, b2), i_n8);
          } else {
            this.coef.set(this.Fr.sub(a2, b2), i_n8);
          }
        }
        if (other) {
          delete this.coef;
          this.coef = polynomial.coef;
        }
      }
      mulScalar(value) {
        for (let i2 = 0; i2 < this.length(); i2++) {
          const i_n8 = i2 * this.Fr.n8;
          this.coef.set(this.Fr.mul(this.coef.slice(i_n8, i_n8 + this.Fr.n8), value), i_n8);
        }
      }
      addScalar(value) {
        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);
        this.coef.set(this.Fr.add(currentValue, value), 0);
      }
      subScalar(value) {
        const currentValue = 0 === this.length() ? this.Fr.zero : this.coef.slice(0, this.Fr.n8);
        this.coef.set(this.Fr.sub(currentValue, value), 0);
      }
      // Multiply current polynomial by the polynomial (X - value)
      byXSubValue(value) {
        const Fr = this.Fr;
        const resize = !Fr.eq(Fr.zero, this.getCoef(this.length() - 1));
        const length2 = resize ? this.length() + 1 : this.length();
        const buff = length2 > 2 << 14 ? new BigBuffer(length2 * Fr.n8) : new Uint8Array(length2 * Fr.n8);
        let pol = new _Polynomial(buff, this.curve, this.logger);
        pol.coef.set(this.coef.slice(0, (length2 - 1) * Fr.n8), 32);
        this.mulScalar(Fr.neg(value));
        pol.add(this);
        this.coef = pol.coef;
      }
      // Multiply current polynomial by the polynomial (X^n + value)
      byXNSubValue(n, value) {
        const Fr = this.Fr;
        const resize = !(this.length() - n - 1 >= this.degree());
        const length2 = resize ? this.length() + n : this.length();
        const buff = length2 > 2 << 14 ? new BigBuffer(length2 * Fr.n8) : new Uint8Array(length2 * Fr.n8);
        let pol = new _Polynomial(buff, this.curve, this.logger);
        pol.coef.set(this.coef.slice(0, (this.degree() + 1) * 32), n * 32);
        this.mulScalar(value);
        pol.add(this);
        this.coef = pol.coef;
      }
      // Euclidean division
      divBy(polynomial) {
        const Fr = this.Fr;
        const degreeA = this.degree();
        const degreeB = polynomial.degree();
        let polR = new _Polynomial(this.coef, this.curve, this.logger);
        this.coef = this.length() > 2 << 14 ? new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);
        for (let i2 = degreeA - degreeB; i2 >= 0; i2--) {
          this.setCoef(i2, Fr.div(polR.getCoef(i2 + degreeB), polynomial.getCoef(degreeB)));
          for (let j2 = 0; j2 <= degreeB; j2++) {
            polR.setCoef(i2 + j2, Fr.sub(polR.getCoef(i2 + j2), Fr.mul(this.getCoef(i2), polynomial.getCoef(j2))));
          }
        }
        return polR;
      }
      // Division by a Polynomial of the form (x^m - beta)
      divByMonic(m2, beta) {
        const Fr = this.Fr;
        let d = this.degree();
        let buffer = this.length() > 2 << 14 ? new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);
        let quotient = new _Polynomial(buffer, this.curve, this.logger);
        let bArr = [];
        for (let i2 = 0; i2 < m2; i2++) {
          quotient.setCoef(d - i2 - m2, this.getCoef(d - i2));
          bArr[i2] = this.getCoef(d - i2);
        }
        let nThreads = m2;
        for (let k2 = 0; k2 < nThreads; k2++) {
          for (let i2 = d - 2 * m2 - k2; i2 >= 0; i2 = i2 - nThreads) {
            if (i2 < 0) break;
            let idx = k2;
            bArr[idx] = Fr.add(this.getCoef(i2 + m2), Fr.mul(bArr[idx], beta));
            quotient.setCoef(i2, bArr[idx]);
          }
        }
        this.coef = quotient.coef;
      }
      divByVanishing(n, beta) {
        if (this.degree() < n) {
          throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");
        }
        const Fr = this.Fr;
        let polR = new _Polynomial(this.coef, this.curve, this.logger);
        this.coef = this.length() > 2 << 14 ? new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);
        for (let i2 = this.length() - 1; i2 >= n; i2--) {
          let leadingCoef = polR.getCoef(i2);
          if (Fr.eq(Fr.zero, leadingCoef)) continue;
          polR.setCoef(i2, Fr.zero);
          polR.setCoef(i2 - n, Fr.add(polR.getCoef(i2 - n), Fr.mul(beta, leadingCoef)));
          this.setCoef(i2 - n, Fr.add(this.getCoef(i2 - n), leadingCoef));
        }
        return polR;
      }
      divByVanishing2(m2, beta) {
        if (this.degree() < m2) {
          throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");
        }
        const Fr = this.Fr;
        let polR = new _Polynomial(this.coef, this.curve, this.logger);
        this.coef = this.length() > 2 << 14 ? new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8);
        let nThreads = 3;
        let nTotal = this.length() - m2;
        let nElementsChunk = Math.floor(nTotal / nThreads);
        let nElementsLast = nTotal - (nThreads - 1) * nElementsChunk;
        console.log(nTotal);
        console.log(nElementsChunk + "  " + nElementsLast);
        for (let k2 = 0; k2 < nThreads; k2++) {
          console.log("> Thread " + k2);
          for (let i2 = k2 === 0 ? nElementsLast : nElementsChunk; i2 > 0; i2--) {
            let idxDst = i2 - 1;
            if (k2 !== 0) idxDst += (k2 - 1) * nElementsChunk + nElementsLast;
            let idxSrc = idxDst + m2;
            let leadingCoef = polR.getCoef(idxSrc);
            if (Fr.eq(Fr.zero, leadingCoef)) continue;
            polR.setCoef(idxSrc, Fr.zero);
            polR.setCoef(idxDst, Fr.add(polR.getCoef(idxDst), Fr.mul(beta, leadingCoef)));
            this.setCoef(idxDst, Fr.add(this.getCoef(idxDst), leadingCoef));
            console.log(idxDst + " <-- " + idxSrc);
          }
        }
        this.print();
        return polR;
      }
      fastDivByVanishing(data) {
        const Fr = this.Fr;
        for (let i2 = 0; i2 < data.length; i2++) {
          let m2 = data[i2][0];
          let beta = data[i2][1];
          if (this.degree() < m2) {
            throw new Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");
          }
          let nThreads = 5;
          let nElements = this.length() - m2;
          let nElementsBucket = Math.floor(nElements / nThreads / m2);
          let nElementsChunk = nElementsBucket * m2;
          let nElementsLast = nElements - nThreads * nElementsChunk;
          let polTmp = new _Polynomial(this.length() > 2 << 14 ? new BigBuffer(this.length() * Fr.n8) : new Uint8Array(this.length() * Fr.n8), this.curve, this.logger);
          let ptr = this.coef;
          this.coef = polTmp.coef;
          polTmp.coef = ptr;
          for (let k2 = 0; k2 < nThreads; k2++) {
            let idx02 = (k2 + 1) * nElementsChunk + nElementsLast;
            for (let i3 = 0; i3 < m2; i3++) {
              this.setCoef(idx02 + i3 - m2, polTmp.getCoef(idx02 + i3));
            }
            for (let i3 = 0; i3 < nElementsChunk - m2; i3++) {
              let offset = idx02 - i3 - 1;
              let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));
              this.setCoef(offset - m2, val);
            }
          }
          let idx0 = nElementsLast;
          let pending = nElementsLast;
          for (let i3 = 0; i3 < m2 && pending; i3++) {
            this.setCoef(idx0 - i3 - 1, polTmp.getCoef(idx0 + m2 - i3 - 1));
            pending--;
          }
          for (let i3 = 0; i3 < pending; i3++) {
            let offset = idx0 - i3 - 1;
            let val = Fr.add(polTmp.getCoef(offset), Fr.mul(beta, this.getCoef(offset)));
            this.setCoef(offset - m2, val);
          }
          let acc = [];
          let betaPow = Fr.one;
          for (let i3 = 0; i3 < nElementsBucket; i3++) {
            betaPow = Fr.mul(betaPow, beta);
          }
          let currentBeta = Fr.one;
          for (let k2 = nThreads; k2 > 0; k2--) {
            let idThread = k2 - 1;
            let idx02 = idThread * nElementsChunk + nElementsLast;
            acc[idThread] = [];
            for (let i3 = 0; i3 < m2; i3++) {
              acc[idThread][i3] = this.getCoef(idx02 + i3);
              if (k2 !== nThreads) {
                acc[idThread][i3] = Fr.add(acc[idThread][i3], Fr.mul(betaPow, acc[idThread + 1][i3]));
              }
            }
            currentBeta = Fr.mul(currentBeta, betaPow);
          }
          for (let k2 = 0; k2 < nThreads; k2++) {
            let idx02 = k2 * nElementsChunk + nElementsLast;
            let currentBeta2 = beta;
            let currentM = m2 - 1;
            let limit = k2 === 0 ? nElementsLast : nElementsChunk;
            for (let i3 = 0; i3 < limit; i3++) {
              let offset = idx02 - i3 - 1;
              let val = Fr.add(this.getCoef(offset), Fr.mul(currentBeta2, acc[k2][currentM]));
              this.setCoef(offset, val);
              if (currentM === 0) {
                currentM = m2 - 1;
                currentBeta2 = Fr.mul(currentBeta2, beta);
              } else {
                currentM--;
              }
            }
          }
        }
      }
      // Divide polynomial by X - value
      divByXSubValue(value) {
        const coefs = this.length() > 2 << 14 ? new BigBuffer(this.length() * this.Fr.n8) : new Uint8Array(this.length() * this.Fr.n8);
        coefs.set(this.Fr.zero, (this.length() - 1) * this.Fr.n8);
        coefs.set(this.coef.slice((this.length() - 1) * this.Fr.n8, this.length() * this.Fr.n8), (this.length() - 2) * this.Fr.n8);
        for (let i2 = this.length() - 3; i2 >= 0; i2--) {
          let i_n8 = i2 * this.Fr.n8;
          coefs.set(
            this.Fr.add(
              this.coef.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8),
              this.Fr.mul(value, coefs.slice(i_n8 + this.Fr.n8, i_n8 + 2 * this.Fr.n8))
            ),
            i2 * this.Fr.n8
          );
        }
        if (!this.Fr.eq(
          this.coef.slice(0, this.Fr.n8),
          this.Fr.mul(this.Fr.neg(value), coefs.slice(0, this.Fr.n8))
        )) {
          throw new Error("Polynomial does not divide");
        }
        this.coef = coefs;
      }
      divZh(domainSize, extensions = 4) {
        for (let i2 = 0; i2 < domainSize; i2++) {
          const i_n8 = i2 * this.Fr.n8;
          this.coef.set(this.Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8)), i_n8);
        }
        const upperBound = this.coef.byteLength / this.Fr.n8;
        for (let i2 = domainSize; i2 < upperBound; i2++) {
          const i_n8 = i2 * this.Fr.n8;
          const a2 = this.Fr.sub(
            this.coef.slice((i2 - domainSize) * this.Fr.n8, (i2 - domainSize) * this.Fr.n8 + this.Fr.n8),
            this.coef.slice(i_n8, i_n8 + this.Fr.n8)
          );
          this.coef.set(a2, i_n8);
          if (i2 > domainSize * (extensions - 1) - extensions) {
            if (!this.Fr.isZero(a2)) {
              throw new Error("Polynomial is not divisible");
            }
          }
        }
        return this;
      }
      divByZerofier(n, beta) {
        let Fr = this.Fr;
        const invBeta = Fr.inv(beta);
        const invBetaNeg = Fr.neg(invBeta);
        let isOne = Fr.eq(Fr.one, invBetaNeg);
        let isNegOne = Fr.eq(Fr.negone, invBetaNeg);
        if (!isOne) {
          for (let i2 = 0; i2 < n; i2++) {
            const i_n8 = i2 * this.Fr.n8;
            let element;
            if (isNegOne) {
              element = Fr.neg(this.coef.slice(i_n8, i_n8 + this.Fr.n8));
            } else {
              element = Fr.mul(invBetaNeg, this.coef.slice(i_n8, i_n8 + this.Fr.n8));
            }
            this.coef.set(element, i_n8);
          }
        }
        isOne = Fr.eq(Fr.one, invBeta);
        isNegOne = Fr.eq(Fr.negone, invBeta);
        for (let i2 = n; i2 < this.length(); i2++) {
          const i_n8 = i2 * this.Fr.n8;
          const i_prev_n8 = (i2 - n) * this.Fr.n8;
          let element = this.Fr.sub(
            this.coef.slice(i_prev_n8, i_prev_n8 + this.Fr.n8),
            this.coef.slice(i_n8, i_n8 + this.Fr.n8)
          );
          if (!isOne) {
            if (isNegOne) {
              element = Fr.neg(element);
            } else {
              element = Fr.mul(invBeta, element);
            }
          }
          this.coef.set(element, i_n8);
          if (i2 > this.length() - n - 1) {
            if (!this.Fr.isZero(element)) {
              throw new Error("Polynomial is not divisible");
            }
          }
        }
        return this;
      }
      // function divideByVanishing(f, n, p) {
      //     // polynomial division f(X) / (X^n - 1) with remainder
      //     // very cheap, 0 multiplications
      //     // strategy:
      //     // start with q(X) = 0, r(X) = f(X)
      //     // then start changing q, r while preserving the identity:
      //     // f(X) = q(X) * (X^n - 1) + r(X)
      //     // in every step, move highest-degree term of r into the product
      //     // => r eventually has degree < n and we're done
      //     let q = Array(f.length).fill(0n);
      //     let r = [...f];
      //     for (let i = f.length - 1; i >= n; i--) {
      //         let leadingCoeff = r[i];
      //         if (leadingCoeff === 0n) continue;
      //         r[i] = 0n;
      //         r[i - n] = mod(r[i - n] + leadingCoeff, p);
      //         q[i - n] = mod(q[i - n] + leadingCoeff, p);
      //     }
      //     return [q, r];
      // }
      byX() {
        const coefs = this.length() + 1 > 2 << 14 ? new BigBuffer(this.coef.byteLength + this.Fr.n8) : new Uint8Array(this.coef.byteLength + this.Fr.n8);
        coefs.set(this.Fr.zero, 0);
        coefs.set(this.coef, this.Fr.n8);
        this.coef = coefs;
      }
      // Compute a new polynomial f(x^n) from f(x)
      // f(x)   = a_0 + a_1x + a_2x^2 + ... + a_jx^j
      // f(x^n) = a_0 + a_1x^n + a_2x^2n + ... + a_jx^jn
      static async expX(polynomial, n, truncate2 = false) {
        const Fr = polynomial.Fr;
        if (n < 1) {
          throw new Error("Compute a new polynomial to a zero or negative number is not allowed");
        } else if (1 === n) {
          return await _Polynomial.fromEvaluations(polynomial.coef, curve, polynomial.logger);
        }
        const length2 = truncate2 ? polynomial.degree() : polynomial.length() - 1;
        const bufferDst = length2 * n + 1 > 2 << 14 ? new BigBuffer((length2 * n + 1) * Fr.n8) : new Uint8Array((length2 * n + 1) * Fr.n8);
        bufferDst.set(polynomial.getCoef(0), 0);
        for (let i2 = 1; i2 <= length2; i2++) {
          const i_sFr = i2 * Fr.n8;
          const coef = polynomial.getCoef(i2);
          bufferDst.set(coef, i_sFr * n);
        }
        return new _Polynomial(bufferDst, polynomial.curve, polynomial.logger);
      }
      split(numPols, degPols, blindingFactors) {
        if (numPols < 1) {
          throw new Error(`Polynomials can't be split in ${numPols} parts`);
        } else if (1 === numPols) {
          return [this];
        }
        if (0 !== blindingFactors.length && blindingFactors.length < numPols - 1) {
          throw new Error(`Blinding factors length must be ${numPols - 1}`);
        }
        const chunkByteLength = (degPols + 1) * this.Fr.n8;
        let res = [];
        const numRealPols = Math.ceil((this.degree() + 1) * this.Fr.n8 / chunkByteLength);
        if (numRealPols < numPols) {
          for (let i2 = numRealPols; i2 < numPols; i2++) {
            res[i2] = new _Polynomial(new Uint8Array(this.Fr.n8), this.curve, this.logger);
          }
        }
        numPols = Math.min(numPols, numRealPols);
        for (let i2 = 0; i2 < numPols; i2++) {
          const isLast = numPols - 1 === i2;
          const byteLength2 = isLast ? this.coef.byteLength - (numPols - 1) * chunkByteLength : chunkByteLength + this.Fr.n8;
          let buff = byteLength2 / this.Fr.n8 > 2 << 14 ? new BigBuffer(byteLength2) : new Uint8Array(byteLength2);
          res[i2] = new _Polynomial(buff, this.curve, this.logger);
          const fr = i2 * chunkByteLength;
          const to = isLast ? this.coef.byteLength : (i2 + 1) * chunkByteLength;
          res[i2].coef.set(this.coef.slice(fr, to), 0);
          if (!isLast) {
            res[i2].coef.set(blindingFactors[i2], chunkByteLength);
          }
          if (0 !== i2) {
            const lowestDegree = this.Fr.sub(res[i2].coef.slice(0, this.Fr.n8), blindingFactors[i2 - 1]);
            res[i2].coef.set(lowestDegree, 0);
          }
          if (isLast) {
            res[i2].truncate();
          }
        }
        return res;
      }
      // split2(degPols, blindingFactors) {
      //     let currentDegree = this.degree();
      //     const numFilledPols = Math.ceil((currentDegree + 1) / (degPols + 1));
      //
      //     //blinding factors can be void or must have a length of numPols - 1
      //     if (0 !== blindingFactors.length && blindingFactors.length < numFilledPols - 1) {
      //         throw new Error(`Blinding factors length must be ${numFilledPols - 1}`);
      //     }
      //
      //     const chunkByteLength = (degPols + 1) * this.Fr.n8;
      //
      //     // Check polynomial can be split in numChunks parts of chunkSize bytes...
      //     if (this.coef.byteLength / chunkByteLength <= numFilledPols - 1) {
      //         throw new Error(`Polynomial is short to be split in ${numFilledPols} parts of ${degPols} coefficients each.`);
      //     }
      //
      //     let res = [];
      //     for (let i = 0; i < numFilledPols; i++) {
      //         const isLast = (numFilledPols - 1) === i;
      //         const byteLength = isLast ? (currentDegree + 1) * this.Fr.n8 - ((numFilledPols - 1) * chunkByteLength) : chunkByteLength + this.Fr.n8;
      //
      //         res[i] = new Polynomial(new BigBuffer(byteLength), this.Fr, this.logger);
      //         const fr = i * chunkByteLength;
      //         const to = isLast ? (currentDegree + 1) * this.Fr.n8 : (i + 1) * chunkByteLength;
      //         res[i].coef.set(this.coef.slice(fr, to), 0);
      //
      //         // Add a blinding factor as higher degree
      //         if (!isLast) {
      //             res[i].coef.set(blindingFactors[i], chunkByteLength);
      //         }
      //
      //         // Sub blinding factor to the lowest degree
      //         if (0 !== i) {
      //             const lowestDegree = this.Fr.sub(res[i].coef.slice(0, this.Fr.n8), blindingFactors[i - 1]);
      //             res[i].coef.set(lowestDegree, 0);
      //         }
      //     }
      //
      //     return res;
      // }
      // merge(pols, overlap = true) {
      //     let length = 0;
      //     for (let i = 0; i < pols.length; i++) {
      //         length += pols[i].length();
      //     }
      //
      //     if (overlap) {
      //         length -= pols.length - 1;
      //     }
      //
      //     let res = new Polynomial(new BigBuffer(length * this.Fr.n8));
      //     for (let i = 0; i < pols.length; i++) {
      //         const byteLength = pols[i].coef.byteLength;
      //         if (0 === i) {
      //             res.coef.set(pols[i].coef, 0);
      //         } else {
      //
      //         }
      //     }
      //
      //     return res;
      // }
      truncate() {
        const deg = this.degree();
        if (deg + 1 < this.coef.byteLength / this.Fr.n8) {
          const newCoefs = deg + 1 > 2 << 14 ? new BigBuffer((deg + 1) * this.Fr.n8) : new Uint8Array((deg + 1) * this.Fr.n8);
          newCoefs.set(this.coef.slice(0, (deg + 1) * this.Fr.n8), 0);
          this.coef = newCoefs;
        }
      }
      static lagrangePolynomialInterpolation(xArr, yArr, curve2) {
        const Fr = curve2.Fr;
        let polynomial = computeLagrangePolynomial(0);
        for (let i2 = 1; i2 < xArr.length; i2++) {
          polynomial.add(computeLagrangePolynomial(i2));
        }
        return polynomial;
        function computeLagrangePolynomial(i2) {
          let polynomial2;
          for (let j2 = 0; j2 < xArr.length; j2++) {
            if (j2 === i2) continue;
            if (polynomial2 === void 0) {
              let buff = xArr.length > 2 << 14 ? new BigBuffer(xArr.length * Fr.n8) : new Uint8Array(xArr.length * Fr.n8);
              polynomial2 = new _Polynomial(buff, curve2);
              polynomial2.setCoef(0, Fr.neg(xArr[j2]));
              polynomial2.setCoef(1, Fr.one);
            } else {
              polynomial2.byXSubValue(xArr[j2]);
            }
          }
          let denominator = polynomial2.evaluate(xArr[i2]);
          denominator = Fr.inv(denominator);
          const mulFactor = Fr.mul(yArr[i2], denominator);
          polynomial2.mulScalar(mulFactor);
          return polynomial2;
        }
      }
      static zerofierPolynomial(xArr, curve2) {
        const Fr = curve2.Fr;
        let buff = xArr.length + 1 > 2 << 14 ? new BigBuffer((xArr.length + 1) * Fr.n8) : new Uint8Array((xArr.length + 1) * Fr.n8);
        let polynomial = new _Polynomial(buff, curve2);
        polynomial.setCoef(0, Fr.neg(xArr[0]));
        polynomial.setCoef(1, Fr.one);
        for (let i2 = 1; i2 < xArr.length; i2++) {
          polynomial.byXSubValue(xArr[i2]);
        }
        return polynomial;
      }
      print() {
        const Fr = this.Fr;
        let res = "";
        for (let i2 = this.degree(); i2 >= 0; i2--) {
          const coef = this.getCoef(i2);
          if (!Fr.eq(Fr.zero, coef)) {
            if (Fr.isNegative(coef)) {
              res += " - ";
            } else if (i2 !== this.degree()) {
              res += " + ";
            }
            res += Fr.toString(coef);
            if (i2 > 0) {
              res += i2 > 1 ? "x^" + i2 : "x";
            }
          }
        }
        console.log(res);
      }
      async multiExponentiation(PTau, name) {
        const n = this.coef.byteLength / this.Fr.n8;
        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);
        const bm = await this.Fr.batchFromMontgomery(this.coef);
        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);
        res = this.G1.toAffine(res);
        return res;
      }
    };
    Evaluations = class _Evaluations {
      constructor(evaluations, curve2, logger) {
        this.eval = evaluations;
        this.curve = curve2;
        this.Fr = curve2.Fr;
        this.logger = logger;
      }
      static async fromPolynomial(polynomial, extension, curve2, logger) {
        const coefficientsN = new BigBuffer(polynomial.length() * extension * curve2.Fr.n8);
        coefficientsN.set(polynomial.coef, 0);
        const evaluations = await curve2.Fr.fft(coefficientsN);
        return new _Evaluations(evaluations, curve2, logger);
      }
      getEvaluation(index) {
        const i_n8 = index * this.Fr.n8;
        if (i_n8 + this.Fr.n8 > this.eval.byteLength) {
          throw new Error("Evaluations.getEvaluation() out of bounds");
        }
        return this.eval.slice(i_n8, i_n8 + this.Fr.n8);
      }
      length() {
        let length2 = this.eval.byteLength / this.Fr.n8;
        if (length2 !== Math.floor(this.eval.byteLength / this.Fr.n8)) {
          throw new Error("Polynomial evaluations buffer has incorrect size");
        }
        if (0 === length2) {
          this.logger.warn("Polynomial has length zero");
        }
        return length2;
      }
    };
    ({ stringifyBigInts: stringifyBigInts$1 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$5 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$4 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$3 } = utils);
    plonk = Object.freeze({
      __proto__: null,
      setup: plonkSetup,
      fullProve: plonkFullProve,
      prove: plonk16Prove,
      verify: plonkVerify,
      exportSolidityCallData: plonkExportSolidityCallData
    });
    LINEAR_COMBINATION_NULLABLE = 0;
    LINEAR_COMBINATION_CONSTANT = 1;
    LINEAR_COMBINATION_VARIABLE = 2;
    r1csConstraintProcessor = class {
      constructor(Fr, fnGetConstantConstraint, fnGetAdditionConstraint, fnGetMultiplicationConstraint, logger) {
        this.Fr = Fr;
        this.logger = logger;
        this.fnGetAdditionConstraint = fnGetAdditionConstraint;
        this.fnGetMultiplicationConstraint = fnGetMultiplicationConstraint;
      }
      processR1csConstraint(settings, lcA, lcB, lcC) {
        this.normalizeLinearCombination(lcA);
        this.normalizeLinearCombination(lcB);
        this.normalizeLinearCombination(lcC);
        const lctA = this.getLinearCombinationType(lcA);
        const lctB = this.getLinearCombinationType(lcB);
        if (lctA === LINEAR_COMBINATION_NULLABLE || lctB === LINEAR_COMBINATION_NULLABLE) {
          return this.processR1csAdditionConstraint(settings, lcC);
        } else if (lctA === LINEAR_COMBINATION_CONSTANT) {
          const lcCC = this.joinLinearCombinations(lcB, lcC, lcA[0]);
          return this.processR1csAdditionConstraint(settings, lcCC);
        } else if (lctB === LINEAR_COMBINATION_CONSTANT) {
          const lcCC = this.joinLinearCombinations(lcA, lcC, lcB[0]);
          return this.processR1csAdditionConstraint(settings, lcCC);
        } else {
          return this.processR1csMultiplicationConstraint(settings, lcA, lcB, lcC);
        }
      }
      getLinearCombinationType(linCom) {
        let k2 = this.Fr.zero;
        let n = 0;
        const ss = Object.keys(linCom);
        for (let i2 = 0; i2 < ss.length; i2++) {
          if (linCom[ss[i2]] == 0n) {
            delete linCom[ss[i2]];
          } else if (ss[i2] == 0) {
            k2 = this.Fr.add(k2, linCom[ss[i2]]);
          } else {
            n++;
          }
        }
        if (n > 0) return LINEAR_COMBINATION_VARIABLE;
        if (!this.Fr.isZero(k2)) return LINEAR_COMBINATION_CONSTANT;
        return LINEAR_COMBINATION_NULLABLE;
      }
      normalizeLinearCombination(linCom) {
        const signalIds = Object.keys(linCom);
        for (let i2 = 0; i2 < signalIds.length; i2++) {
          if (this.Fr.isZero(linCom[signalIds[i2]])) delete linCom[signalIds[i2]];
        }
        return linCom;
      }
      joinLinearCombinations(linCom1, linCom2, k2) {
        const res = {};
        for (let s2 in linCom1) {
          if (typeof res[s2] == "undefined") {
            res[s2] = this.Fr.mul(k2, linCom1[s2]);
          } else {
            res[s2] = this.Fr.add(res[s2], this.Fr.mul(k2, linCom1[s2]));
          }
        }
        for (let s2 in linCom2) {
          if (typeof res[s2] == "undefined") {
            res[s2] = linCom2[s2];
          } else {
            res[s2] = this.Fr.add(res[s2], linCom2[s2]);
          }
        }
        return this.normalizeLinearCombination(res);
      }
      reduceCoefs(settings, constraintsArr, additionsArr, linCom, maxC) {
        const res = {
          k: this.Fr.zero,
          signals: [],
          coefs: []
        };
        const cs = [];
        for (let signalId in linCom) {
          if (signalId == 0) {
            res.k = this.Fr.add(res.k, linCom[signalId]);
          } else if (linCom[signalId] != 0n) {
            cs.push([Number(signalId), linCom[signalId]]);
          }
        }
        while (cs.length > maxC) {
          const c1 = cs.shift();
          const c2 = cs.shift();
          const so = settings.nVars++;
          const constraints = this.fnGetAdditionConstraint(
            c1[0],
            c2[0],
            so,
            this.Fr.neg(c1[1]),
            this.Fr.neg(c2[1]),
            this.Fr.zero,
            this.Fr.one,
            this.Fr.zero
          );
          constraintsArr.push(constraints);
          additionsArr.push([c1[0], c2[0], c1[1], c2[1]]);
          cs.push([so, this.Fr.one]);
        }
        for (let i2 = 0; i2 < cs.length; i2++) {
          res.signals[i2] = cs[i2][0];
          res.coefs[i2] = cs[i2][1];
        }
        while (res.coefs.length < maxC) {
          res.signals.push(0);
          res.coefs.push(this.Fr.zero);
        }
        return res;
      }
      processR1csAdditionConstraint(settings, linCom) {
        const constraintsArr = [];
        const additionsArr = [];
        const C2 = this.reduceCoefs(settings, constraintsArr, additionsArr, linCom, 3);
        const constraints = this.fnGetAdditionConstraint(
          C2.signals[0],
          C2.signals[1],
          C2.signals[2],
          C2.coefs[0],
          C2.coefs[1],
          this.Fr.zero,
          C2.coefs[2],
          C2.k
        );
        constraintsArr.push(constraints);
        return [constraintsArr, additionsArr];
      }
      processR1csMultiplicationConstraint(settings, lcA, lcB, lcC) {
        const constraintsArr = [];
        const additionsArr = [];
        const A2 = this.reduceCoefs(settings, constraintsArr, additionsArr, lcA, 1);
        const B2 = this.reduceCoefs(settings, constraintsArr, additionsArr, lcB, 1);
        const C2 = this.reduceCoefs(settings, constraintsArr, additionsArr, lcC, 1);
        const constraints = this.fnGetMultiplicationConstraint(
          A2.signals[0],
          B2.signals[0],
          C2.signals[0],
          this.Fr.mul(A2.coefs[0], B2.k),
          this.Fr.mul(A2.k, B2.coefs[0]),
          this.Fr.mul(A2.coefs[0], B2.coefs[0]),
          this.Fr.neg(C2.coefs[0]),
          this.Fr.sub(this.Fr.mul(A2.k, B2.k), C2.k)
        );
        constraintsArr.push(constraints);
        return [constraintsArr, additionsArr];
      }
    };
    CPolynomial = class {
      constructor(n, curve2, logger) {
        this.n = n;
        this.polynomials = Array(n).fill(void 0);
        this.curve = curve2;
        this.Fr = curve2.Fr;
        this.G1 = curve2.G1;
        this.logger = logger;
      }
      addPolynomial(position2, polynomial) {
        if (position2 > this.n - 1) {
          throw new Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");
        }
        this.polynomials[position2] = polynomial;
      }
      degree() {
        let degrees = this.polynomials.map(
          (polynomial, index) => polynomial === void 0 ? 0 : polynomial.degree() * this.n + index
        );
        return Math.max(...degrees);
      }
      getPolynomial() {
        let degrees = this.polynomials.map((polynomial2) => polynomial2 === void 0 ? 0 : polynomial2.degree());
        const maxDegree = this.degree();
        const lengthBuffer = 2 ** (log22(maxDegree - 1) + 1);
        const sFr = this.Fr.n8;
        let polynomial = new Polynomial(new BigBuffer(lengthBuffer * sFr), this.curve, this.logger);
        for (let i2 = 0; i2 < maxDegree; i2++) {
          const i_n8 = i2 * sFr;
          const i_sFr = i_n8 * this.n;
          for (let j2 = 0; j2 < this.n; j2++) {
            if (this.polynomials[j2] !== void 0) {
              if (i2 <= degrees[j2]) polynomial.coef.set(this.polynomials[j2].coef.slice(i_n8, i_n8 + sFr), i_sFr + j2 * sFr);
            }
          }
        }
        return polynomial;
      }
      async multiExponentiation(PTau, name) {
        let polynomial = this.getPolynomial();
        const n = polynomial.coef.byteLength / this.Fr.n8;
        const PTauN = PTau.slice(0, n * this.G1.F.n8 * 2);
        const bm = await this.Fr.batchFromMontgomery(polynomial.coef);
        let res = await this.G1.multiExpAffine(PTauN, bm, this.logger, name);
        res = this.G1.toAffine(res);
        return res;
      }
    };
    ({ stringifyBigInts: stringifyBigInts2 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$2 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts$1 } = utils);
    ({ unstringifyBigInts: unstringifyBigInts2 } = utils);
    fflonk = Object.freeze({
      __proto__: null,
      setup: fflonkSetup,
      prove: fflonkProve,
      fullProve: fflonkFullProve,
      verify: fflonkVerify,
      exportSolidityVerifier: fflonkExportSolidityVerifier,
      exportSolidityCallData: fflonkExportCallData
    });
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div2, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v2, b2) {
          var alphabet2, c2, caseChanged, e2, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
          if (b2 == null) {
            if (v2 && v2._isBigNumber === true) {
              x2.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v2.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v2.e;
                x2.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e2;
                  x2.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v2);
              return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
              x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v2);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet2 = ALPHABET.slice(0, b2);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet2.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v2), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x2.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
              throw Error(tooManyDigits + x2.s * v2);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e2 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e2;
              x2.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 8, p2);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, 0, p2);
                  intCheck(v2[1], 0, MAX, p2);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, -1, p2);
                  intCheck(v2[1], 1, MAX, p2);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v2 = obj[p2];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 9, p2);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v2 = obj[p2];
                if (typeof v2 == "object") FORMAT = v2;
                else throw Error(bignumberError + p2 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v2 = obj[p2];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n, c2 = v2.c, e2 = v2.e, s2 = v2.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n = c2[i2];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v2);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b2, e2, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k2 = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
                for (; i2 < k2; ) {
                  v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b2[0];
                    a2[i2 + 1] = b2[1];
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k2 / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k2 *= 7);
                for (; i2 < k2; ) {
                  v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k2 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k2; ) {
                v2 = random53bitInt();
                if (v2 < 9e15) c2[i2++] = v2 % 1e14;
              }
            }
            k2 = c2[--i2];
            dp %= LOG_BASE;
            if (k2 && dp) {
              v2 = POWS_TEN[LOG_BASE - dp];
              c2[i2] = mathfloor(k2 / v2) * v2;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e2 = 0];
            } else {
              for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c2;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet2) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet2.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet2, d, e2, k2, r2, x2, xc, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k2 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y2 = new BigNumber2(baseIn);
              x2 = y2.pow(str.length - i2);
              POW_PRECISION = k2;
              y2.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y2.e = y2.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet2 = ALPHABET, decimal) : (alphabet2 = decimal, ALPHABET));
            e2 = k2 = xc.length;
            for (; xc[--k2] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet2.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x2.c = xc;
              x2.e = e2;
              x2.s = sign;
              x2 = div2(x2, y2, dp, rm, baseOut);
              xc = x2.c;
              r2 = x2.r;
              e2 = x2.e;
            }
            d = e2 + dp + 1;
            i2 = xc[d];
            k2 = baseOut / 2;
            r2 = r2 || d < 0 || xc[d + 1] != null;
            r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc[d - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r2 ? toFixedPoint(alphabet2.charAt(1), -dp, alphabet2.charAt(0)) : alphabet2.charAt(0);
            } else {
              xc.length = d;
              if (r2) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k2 = xc.length; !xc[--k2]; ) ;
              for (i2 = 0, str = ""; i2 <= k2; str += alphabet2.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet2.charAt(0));
            }
            return str;
          };
        }();
        div2 = /* @__PURE__ */ function() {
          function multiply(x2, k2, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare3(a2, b2, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a2[i2] != b2[i2]) {
                  cmp = a2[i2] > b2[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a2, b2, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i2 * base + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x2, y2, dp, rm, base) {
            var cmp, e2, i2, more, n, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber2(s2);
            qc = q2.c = [];
            e2 = x2.e - y2.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare3(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare3(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare3(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i2++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q2, dp + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        }();
        function format(n, i2, rm, id) {
          var c0, e2, ne2, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne2 = n.e;
          if (i2 == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
          } else {
            n = round(new BigNumber2(n), i2, rm);
            e2 = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne2;
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k2, y2, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y2 = new BigNumber2(args[i2]);
            if (!y2.s || (k2 = compare2(x2, y2)) === n || k2 === 0 && x2.s === n) {
              x2 = y2;
            }
          }
          return x2;
        }
        function normalise(n, c2, e2) {
          var i2 = 1, j2 = c2.length;
          for (; !c2[--j2]; c2.pop()) ;
          for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e2 < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e2;
            n.c = c2;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b2) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m2;
                });
                if (b2) {
                  base = b2;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        }();
        function round(x2, sd, rm, r2) {
          var d, i2, j2, k2, n, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d++) ;
              i2 = sd - d;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j2 = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j2 - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r2) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i2 %= LOG_BASE;
                    j2 = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k2 = xc[ni];
                  for (d = 1; k2 >= 10; k2 /= 10, d++) ;
                  i2 %= LOG_BASE;
                  j2 = i2 - LOG_BASE + d;
                  rd = j2 < 0 ? 0 : mathfloor(n / pows10[d - j2 - 1] % 10);
                }
              }
              r2 = r2 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n : n % pows10[d - j2 - 1]);
              r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n / pows10[d - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r2) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k2 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k2 = pows10[LOG_BASE - i2];
                xc[ni] = j2 > 0 ? mathfloor(n / pows10[d - j2] % pows10[j2]) * k2 : 0;
              }
              if (r2) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++) ;
                    j2 = xc[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
                    if (i2 != k2) {
                      x2.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k2;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n) {
          var str, e2 = n.e;
          if (e2 === null) return n.toString();
          str = coeffToString(n.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P2.comparedTo = function(y2, b2) {
          return compare2(this, new BigNumber2(y2, b2));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c2, n, v2, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c2 = x2.c)) return null;
          n = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P2.dividedBy = P2.div = function(y2, b2) {
          return div2(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
          return div2(this, new BigNumber2(y2, b2), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n, m2) {
          var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n.c || !n.c[0]) {
            y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n.s * (2 - isOdd2(n)) : +valueOf(n)));
            return m2 ? y2.mod(m2) : y2;
          }
          nIsNeg = n.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k2 = x2.s < 0 && isOdd2(n) ? -0 : 0;
            if (x2.e > -1) k2 = 1 / k2;
            return new BigNumber2(nIsNeg ? 1 / k2 : k2);
          } else if (POW_PRECISION) {
            k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd2(n);
          } else {
            i2 = Math.abs(+valueOf(n));
            nIsOdd = i2 % 2;
          }
          y2 = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y2 = y2.times(x2);
              if (!y2.c) break;
              if (k2) {
                if (y2.c.length > k2) y2.c.length = k2;
              } else if (isModExp) {
                y2 = y2.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd2(n);
              } else {
                i2 = +valueOf(n);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k2) {
              if (x2.c && x2.c.length > k2) x2.c.length = k2;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y2;
          if (nIsNeg) y2 = ONE.div(y2);
          return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
        };
        P2.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y2, b2) {
          return compare2(this, new BigNumber2(y2, b2)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y2, b2) {
          return compare2(this, new BigNumber2(y2, b2)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
          return (b2 = compare2(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y2, b2) {
          return compare2(this, new BigNumber2(y2, b2)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
          return (b2 = compare2(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y2, b2) {
          var i2, j2, t, xLTy, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.plus(y2);
          }
          var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe2 || !ye2) {
            if (!xc || !yc) return xc ? (y2.s = -b2, y2) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y2.s = -b2, y2) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe2 = bitFloor(xe2);
          ye2 = bitFloor(ye2);
          xc = xc.slice();
          if (a2 = xe2 - ye2) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t = xc;
            } else {
              ye2 = xe2;
              t = yc;
            }
            t.reverse();
            for (b2 = a2; b2--; t.push(0)) ;
            t.reverse();
          } else {
            j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y2.s = -y2.s;
          }
          b2 = (j2 = yc.length) - (i2 = xc.length);
          if (b2 > 0) for (; b2--; xc[i2++] = 0) ;
          b2 = BASE - 1;
          for (; j2 > a2; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b2) ;
              --xc[i2];
              xc[j2] += BASE;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye2) ;
          if (!xc[0]) {
            y2.s = ROUNDING_MODE == 3 ? -1 : 1;
            y2.c = [y2.e = 0];
            return y2;
          }
          return normalise(y2, xc, ye2);
        };
        P2.modulo = P2.mod = function(y2, b2) {
          var q2, s2, x2 = this;
          y2 = new BigNumber2(y2, b2);
          if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y2.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y2.s;
            y2.s = 1;
            q2 = div2(x2, y2, 0, 3);
            y2.s = s2;
            q2.s *= s2;
          } else {
            q2 = div2(x2, y2, 0, MODULO_MODE);
          }
          y2 = x2.minus(q2.times(y2));
          if (!y2.c[0] && MODULO_MODE == 1) y2.s = x2.s;
          return y2;
        };
        P2.multipliedBy = P2.times = function(y2, b2) {
          var c2, e2, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y2.c = y2.e = y2.s = null;
            } else {
              y2.s *= x2.s;
              if (!xc || !yc) {
                y2.c = y2.e = null;
              } else {
                y2.c = [0];
                y2.e = 0;
              }
            }
            return y2;
          }
          e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
          y2.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
              xlo = xc[--k2] % sqrtBase;
              xhi = xc[k2] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
              c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base;
            }
            zc[j2] = c2;
          }
          if (c2) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y2, zc, e2);
        };
        P2.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P2.plus = function(y2, b2) {
          var t, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.minus(y2);
          }
          var xe2 = x2.e / LOG_BASE, ye2 = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe2 || !ye2) {
            if (!xc || !yc) return new BigNumber2(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a2 * 0);
          }
          xe2 = bitFloor(xe2);
          ye2 = bitFloor(ye2);
          xc = xc.slice();
          if (a2 = xe2 - ye2) {
            if (a2 > 0) {
              ye2 = xe2;
              t = yc;
            } else {
              a2 = -a2;
              t = xc;
            }
            t.reverse();
            for (; a2--; t.push(0)) ;
            t.reverse();
          }
          a2 = xc.length;
          b2 = yc.length;
          if (a2 - b2 < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
            xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye2;
          }
          return normalise(y2, xc, ye2);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c2, n, v2, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), sd, rm);
          }
          if (!(c2 = x2.c)) return null;
          v2 = c2.length - 1;
          n = v2 * LOG_BASE + 1;
          if (v2 = c2[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n--) ;
            for (v2 = c2[0]; v2 >= 10; v2 /= 10, n++) ;
          }
          if (sd && x2.e + 1 > n) n = x2.e + 1;
          return n;
        };
        P2.shiftedBy = function(k2) {
          intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k2);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m2, n, r2, rep, t, x2 = this, c2 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n = coeffToString(c2);
            if ((n.length + e2) % 2 == 0) n += "0";
            s2 = Math.sqrt(+n);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n = "5e" + e2;
            } else {
              n = s2.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e2;
            }
            r2 = new BigNumber2(n);
          } else {
            r2 = new BigNumber2(s2 + "");
          }
          if (r2.c[0]) {
            e2 = r2.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t = r2;
              r2 = half.times(t.plus(div2(x2, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s2) === (n = coeffToString(r2.c)).slice(0, s2)) {
                if (r2.e < e2) --s2;
                n = n.slice(s2 - 3, s2 + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x2)) {
                      r2 = t;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r2, r2.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r2.times(r2).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x2 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d, d0, d1, d2, e2, exp2, n, n0, n1, q2, r2, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s2 = coeffToString(xc);
          e2 = d.e = s2.length - x2.e - 1;
          d.c[0] = POWS_TEN[(exp2 = e2 % LOG_BASE) < 0 ? LOG_BASE + exp2 : exp2];
          md = !md || n.comparedTo(d) > 0 ? e2 > 0 ? d : n1 : n;
          exp2 = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div2(n, d, 0, 1);
            d2 = d0.plus(q2.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q2.times(d2 = n1));
            n0 = d2;
            d = n.minus(q2.times(d2 = d));
            n = d2;
          }
          d2 = div2(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x2.s;
          e2 = e2 * 2;
          r2 = div2(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div2(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp2;
          return r2;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b2) {
          var str, n = this, s2 = n.s, e2 = n.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n.c), e2) : toFixedPoint(coeffToString(n.c), e2, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e2, "0"), 10, b2, s2, true);
            }
            if (s2 < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i2 = n | 0;
        return n > 0 || n === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z2, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
        for (; i2 < j2; ) {
          s2 = a2[i2++] + "";
          z2 = LOG_BASE - s2.length;
          for (; z2--; s2 = "0" + s2) ;
          r2 += s2;
        }
        for (j2 = r2.length; r2.charCodeAt(--j2) === 48; ) ;
        return r2.slice(0, j2 + 1 || 1);
      }
      function compare2(x2, y2) {
        var a2, b2, xc = x2.c, yc = y2.c, i2 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
        if (!i2 || !j2) return null;
        a2 = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
        if (i2 != j2) return i2;
        a2 = i2 < 0;
        b2 = k2 == l2;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
        j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
        for (i2 = 0; i2 < j2; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
        return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd2(n) {
        var k2 = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k2 && n.c[k2] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z2) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z2 + "."; ++e2; zs += z2) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z2, e2 -= len; --e2; zs += z2) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f2(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string2) {
        escapable.lastIndex = 0;
        return escapable.test(string2) ? '"' + string2.replace(escapable, function(a2) {
          var c2 = meta[a2];
          return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string2 + '"';
      }
      function str(key, holder) {
        var i2, k2, v2, length2, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length2 = value.length;
              for (i2 = 0; i2 < length2; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length2 = rep.length;
              for (i2 = 0; i2 < length2; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k2 = rep[i2];
                  v2 = str(k2, value);
                  if (v2) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k3) {
                var v3 = str(k3, value);
                if (v3) {
                  partial.push(quote(k3) + (gap ? ": " : ":") + v3);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at2, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at: at2,
          text
        };
      }, next2 = function(c2) {
        if (c2 && c2 !== ch) {
          error("Expected '" + c2 + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at2);
        at2 += 1;
        return ch;
      }, number = function() {
        var number2, string3 = "";
        if (ch === "-") {
          string3 = "-";
          next2("-");
        }
        while (ch >= "0" && ch <= "9") {
          string3 += ch;
          next2();
        }
        if (ch === ".") {
          string3 += ".";
          while (next2() && ch >= "0" && ch <= "9") {
            string3 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string3 += ch;
          next2();
          if (ch === "-" || ch === "+") {
            string3 += ch;
            next2();
          }
          while (ch >= "0" && ch <= "9") {
            string3 += ch;
            next2();
          }
        }
        number2 = +string3;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string3.length > 15)
            return _options.storeAsString ? string3 : _options.useNativeBigInt ? BigInt(string3) : new BigNumber(string3);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string2 = function() {
        var hex2, i2, string3 = "", uffff;
        if (ch === '"') {
          var startAt = at2;
          while (next2()) {
            if (ch === '"') {
              if (at2 - 1 > startAt) string3 += text.substring(startAt, at2 - 1);
              next2();
              return string3;
            }
            if (ch === "\\") {
              if (at2 - 1 > startAt) string3 += text.substring(startAt, at2 - 1);
              next2();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex2 = parseInt(next2(), 16);
                  if (!isFinite(hex2)) {
                    break;
                  }
                  uffff = uffff * 16 + hex2;
                }
                string3 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string3 += escapee[ch];
              } else {
                break;
              }
              startAt = at2;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next2();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next2("t");
            next2("r");
            next2("u");
            next2("e");
            return true;
          case "f":
            next2("f");
            next2("a");
            next2("l");
            next2("s");
            next2("e");
            return false;
          case "n":
            next2("n");
            next2("u");
            next2("l");
            next2("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next2("[");
          white();
          if (ch === "]") {
            next2("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next2("]");
              return array2;
            }
            next2(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next2("{");
          white();
          if (ch === "}") {
            next2("}");
            return object2;
          }
          while (ch) {
            key = string2();
            white();
            next2(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next2("}");
              return object2;
            }
            next2(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string2();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at2 = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k2, v2, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k3) {
              v2 = walk(value2, k3);
              if (v2 !== void 0) {
                value2[k3] = v2;
              } else {
                delete value2[k3];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var json_stringify = require_stringify2().stringify;
    var json_parse = require_parse2();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// node_modules/localforage/dist/localforage.js
var require_localforage = __commonJS({
  "node_modules/localforage/dist/localforage.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    (function(f2) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f2();
      } else if (typeof define === "function" && define.amd) {
        define([], f2);
      } else {
        var g2;
        if (typeof window !== "undefined") {
          g2 = window;
        } else if (typeof global !== "undefined") {
          g2 = global;
        } else if (typeof self !== "undefined") {
          g2 = self;
        } else {
          g2 = this;
        }
        g2.localforage = f2();
      }
    })(function() {
      var define2, module2, exports2;
      return function e2(t, n, r2) {
        function s2(o3, u2) {
          if (!n[o3]) {
            if (!t[o3]) {
              var a2 = typeof __require == "function" && __require;
              if (!u2 && a2) return a2(o3, true);
              if (i2) return i2(o3, true);
              var f2 = new Error("Cannot find module '" + o3 + "'");
              throw f2.code = "MODULE_NOT_FOUND", f2;
            }
            var l2 = n[o3] = { exports: {} };
            t[o3][0].call(l2.exports, function(e3) {
              var n2 = t[o3][1][e3];
              return s2(n2 ? n2 : e3);
            }, l2, l2.exports, e2, t, n, r2);
          }
          return n[o3].exports;
        }
        var i2 = typeof __require == "function" && __require;
        for (var o2 = 0; o2 < r2.length; o2++) s2(r2[o2]);
        return s2;
      }({ 1: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
          var scheduleDrain;
          {
            if (Mutation) {
              var called = 0;
              var observer = new Mutation(nextTick);
              var element = global2.document.createTextNode("");
              observer.observe(element, {
                characterData: true
              });
              scheduleDrain = function() {
                element.data = called = ++called % 2;
              };
            } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
              var channel = new global2.MessageChannel();
              channel.port1.onmessage = nextTick;
              scheduleDrain = function() {
                channel.port2.postMessage(0);
              };
            } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
              scheduleDrain = function() {
                var scriptEl = global2.document.createElement("script");
                scriptEl.onreadystatechange = function() {
                  nextTick();
                  scriptEl.onreadystatechange = null;
                  scriptEl.parentNode.removeChild(scriptEl);
                  scriptEl = null;
                };
                global2.document.documentElement.appendChild(scriptEl);
              };
            } else {
              scheduleDrain = function() {
                setTimeout(nextTick, 0);
              };
            }
          }
          var draining;
          var queue = [];
          function nextTick() {
            draining = true;
            var i2, oldQueue;
            var len = queue.length;
            while (len) {
              oldQueue = queue;
              queue = [];
              i2 = -1;
              while (++i2 < len) {
                oldQueue[i2]();
              }
              len = queue.length;
            }
            draining = false;
          }
          module3.exports = immediate;
          function immediate(task) {
            if (queue.push(task) === 1 && !draining) {
              scheduleDrain();
            }
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 2: [function(_dereq_, module3, exports3) {
        "use strict";
        var immediate = _dereq_(1);
        function INTERNAL() {
        }
        var handlers = {};
        var REJECTED = ["REJECTED"];
        var FULFILLED = ["FULFILLED"];
        var PENDING = ["PENDING"];
        module3.exports = Promise2;
        function Promise2(resolver) {
          if (typeof resolver !== "function") {
            throw new TypeError("resolver must be a function");
          }
          this.state = PENDING;
          this.queue = [];
          this.outcome = void 0;
          if (resolver !== INTERNAL) {
            safelyResolveThenable(this, resolver);
          }
        }
        Promise2.prototype["catch"] = function(onRejected) {
          return this.then(null, onRejected);
        };
        Promise2.prototype.then = function(onFulfilled, onRejected) {
          if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
            return this;
          }
          var promise = new this.constructor(INTERNAL);
          if (this.state !== PENDING) {
            var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
            unwrap(promise, resolver, this.outcome);
          } else {
            this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
          }
          return promise;
        };
        function QueueItem(promise, onFulfilled, onRejected) {
          this.promise = promise;
          if (typeof onFulfilled === "function") {
            this.onFulfilled = onFulfilled;
            this.callFulfilled = this.otherCallFulfilled;
          }
          if (typeof onRejected === "function") {
            this.onRejected = onRejected;
            this.callRejected = this.otherCallRejected;
          }
        }
        QueueItem.prototype.callFulfilled = function(value) {
          handlers.resolve(this.promise, value);
        };
        QueueItem.prototype.otherCallFulfilled = function(value) {
          unwrap(this.promise, this.onFulfilled, value);
        };
        QueueItem.prototype.callRejected = function(value) {
          handlers.reject(this.promise, value);
        };
        QueueItem.prototype.otherCallRejected = function(value) {
          unwrap(this.promise, this.onRejected, value);
        };
        function unwrap(promise, func, value) {
          immediate(function() {
            var returnValue;
            try {
              returnValue = func(value);
            } catch (e2) {
              return handlers.reject(promise, e2);
            }
            if (returnValue === promise) {
              handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
            } else {
              handlers.resolve(promise, returnValue);
            }
          });
        }
        handlers.resolve = function(self2, value) {
          var result = tryCatch(getThen, value);
          if (result.status === "error") {
            return handlers.reject(self2, result.value);
          }
          var thenable = result.value;
          if (thenable) {
            safelyResolveThenable(self2, thenable);
          } else {
            self2.state = FULFILLED;
            self2.outcome = value;
            var i2 = -1;
            var len = self2.queue.length;
            while (++i2 < len) {
              self2.queue[i2].callFulfilled(value);
            }
          }
          return self2;
        };
        handlers.reject = function(self2, error) {
          self2.state = REJECTED;
          self2.outcome = error;
          var i2 = -1;
          var len = self2.queue.length;
          while (++i2 < len) {
            self2.queue[i2].callRejected(error);
          }
          return self2;
        };
        function getThen(obj) {
          var then = obj && obj.then;
          if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
            return function appyThen() {
              then.apply(obj, arguments);
            };
          }
        }
        function safelyResolveThenable(self2, thenable) {
          var called = false;
          function onError(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.reject(self2, value);
          }
          function onSuccess(value) {
            if (called) {
              return;
            }
            called = true;
            handlers.resolve(self2, value);
          }
          function tryToUnwrap() {
            thenable(onSuccess, onError);
          }
          var result = tryCatch(tryToUnwrap);
          if (result.status === "error") {
            onError(result.value);
          }
        }
        function tryCatch(func, value) {
          var out = {};
          try {
            out.value = func(value);
            out.status = "success";
          } catch (e2) {
            out.status = "error";
            out.value = e2;
          }
          return out;
        }
        Promise2.resolve = resolve;
        function resolve(value) {
          if (value instanceof this) {
            return value;
          }
          return handlers.resolve(new this(INTERNAL), value);
        }
        Promise2.reject = reject;
        function reject(reason) {
          var promise = new this(INTERNAL);
          return handlers.reject(promise, reason);
        }
        Promise2.all = all;
        function all(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var values = new Array(len);
          var resolved = 0;
          var i2 = -1;
          var promise = new this(INTERNAL);
          while (++i2 < len) {
            allResolver(iterable[i2], i2);
          }
          return promise;
          function allResolver(value, i3) {
            self2.resolve(value).then(resolveFromAll, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
            function resolveFromAll(outValue) {
              values[i3] = outValue;
              if (++resolved === len && !called) {
                called = true;
                handlers.resolve(promise, values);
              }
            }
          }
        }
        Promise2.race = race;
        function race(iterable) {
          var self2 = this;
          if (Object.prototype.toString.call(iterable) !== "[object Array]") {
            return this.reject(new TypeError("must be an array"));
          }
          var len = iterable.length;
          var called = false;
          if (!len) {
            return this.resolve([]);
          }
          var i2 = -1;
          var promise = new this(INTERNAL);
          while (++i2 < len) {
            resolver(iterable[i2]);
          }
          return promise;
          function resolver(value) {
            self2.resolve(value).then(function(response) {
              if (!called) {
                called = true;
                handlers.resolve(promise, response);
              }
            }, function(error) {
              if (!called) {
                called = true;
                handlers.reject(promise, error);
              }
            });
          }
        }
      }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
        (function(global2) {
          "use strict";
          if (typeof global2.Promise !== "function") {
            global2.Promise = _dereq_(2);
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
        "use strict";
        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
          return typeof obj;
        } : function(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function getIDB() {
          try {
            if (typeof indexedDB !== "undefined") {
              return indexedDB;
            }
            if (typeof webkitIndexedDB !== "undefined") {
              return webkitIndexedDB;
            }
            if (typeof mozIndexedDB !== "undefined") {
              return mozIndexedDB;
            }
            if (typeof OIndexedDB !== "undefined") {
              return OIndexedDB;
            }
            if (typeof msIndexedDB !== "undefined") {
              return msIndexedDB;
            }
          } catch (e2) {
            return;
          }
        }
        var idb = getIDB();
        function isIndexedDBValid() {
          try {
            if (!idb || !idb.open) {
              return false;
            }
            var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
            var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange !== "undefined";
          } catch (e2) {
            return false;
          }
        }
        function createBlob(parts, properties) {
          parts = parts || [];
          properties = properties || {};
          try {
            return new Blob(parts, properties);
          } catch (e2) {
            if (e2.name !== "TypeError") {
              throw e2;
            }
            var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
            var builder2 = new Builder();
            for (var i2 = 0; i2 < parts.length; i2 += 1) {
              builder2.append(parts[i2]);
            }
            return builder2.getBlob(properties.type);
          }
        }
        if (typeof Promise === "undefined") {
          _dereq_(3);
        }
        var Promise$1 = Promise;
        function executeCallback(promise, callback) {
          if (callback) {
            promise.then(function(result) {
              callback(null, result);
            }, function(error) {
              callback(error);
            });
          }
        }
        function executeTwoCallbacks(promise, callback, errorCallback) {
          if (typeof callback === "function") {
            promise.then(callback);
          }
          if (typeof errorCallback === "function") {
            promise["catch"](errorCallback);
          }
        }
        function normalizeKey(key2) {
          if (typeof key2 !== "string") {
            console.warn(key2 + " used as a key, but it is not a string.");
            key2 = String(key2);
          }
          return key2;
        }
        function getCallback() {
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            return arguments[arguments.length - 1];
          }
        }
        var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
        var supportsBlobs = void 0;
        var dbContexts = {};
        var toString3 = Object.prototype.toString;
        var READ_ONLY = "readonly";
        var READ_WRITE = "readwrite";
        function _binStringToArrayBuffer(bin) {
          var length3 = bin.length;
          var buf = new ArrayBuffer(length3);
          var arr = new Uint8Array(buf);
          for (var i2 = 0; i2 < length3; i2++) {
            arr[i2] = bin.charCodeAt(i2);
          }
          return buf;
        }
        function _checkBlobSupportWithoutCaching(idb2) {
          return new Promise$1(function(resolve) {
            var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
            var blob = createBlob([""]);
            txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
            txn.onabort = function(e2) {
              e2.preventDefault();
              e2.stopPropagation();
              resolve(false);
            };
            txn.oncomplete = function() {
              var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
              var matchedEdge = navigator.userAgent.match(/Edge\//);
              resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
            };
          })["catch"](function() {
            return false;
          });
        }
        function _checkBlobSupport(idb2) {
          if (typeof supportsBlobs === "boolean") {
            return Promise$1.resolve(supportsBlobs);
          }
          return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
            supportsBlobs = value;
            return supportsBlobs;
          });
        }
        function _deferReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = {};
          deferredOperation.promise = new Promise$1(function(resolve, reject) {
            deferredOperation.resolve = resolve;
            deferredOperation.reject = reject;
          });
          dbContext.deferredOperations.push(deferredOperation);
          if (!dbContext.dbReady) {
            dbContext.dbReady = deferredOperation.promise;
          } else {
            dbContext.dbReady = dbContext.dbReady.then(function() {
              return deferredOperation.promise;
            });
          }
        }
        function _advanceReadiness(dbInfo) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.resolve();
            return deferredOperation.promise;
          }
        }
        function _rejectReadiness(dbInfo, err) {
          var dbContext = dbContexts[dbInfo.name];
          var deferredOperation = dbContext.deferredOperations.pop();
          if (deferredOperation) {
            deferredOperation.reject(err);
            return deferredOperation.promise;
          }
        }
        function _getConnection(dbInfo, upgradeNeeded) {
          return new Promise$1(function(resolve, reject) {
            dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
            if (dbInfo.db) {
              if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
              } else {
                return resolve(dbInfo.db);
              }
            }
            var dbArgs = [dbInfo.name];
            if (upgradeNeeded) {
              dbArgs.push(dbInfo.version);
            }
            var openreq = idb.open.apply(idb, dbArgs);
            if (upgradeNeeded) {
              openreq.onupgradeneeded = function(e2) {
                var db = openreq.result;
                try {
                  db.createObjectStore(dbInfo.storeName);
                  if (e2.oldVersion <= 1) {
                    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                  }
                } catch (ex) {
                  if (ex.name === "ConstraintError") {
                    console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e2.oldVersion + " to version " + e2.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                  } else {
                    throw ex;
                  }
                }
              };
            }
            openreq.onerror = function(e2) {
              e2.preventDefault();
              reject(openreq.error);
            };
            openreq.onsuccess = function() {
              var db = openreq.result;
              db.onversionchange = function(e2) {
                e2.target.close();
              };
              resolve(db);
              _advanceReadiness(dbInfo);
            };
          });
        }
        function _getOriginalConnection(dbInfo) {
          return _getConnection(dbInfo, false);
        }
        function _getUpgradedConnection(dbInfo) {
          return _getConnection(dbInfo, true);
        }
        function _isUpgradeNeeded(dbInfo, defaultVersion) {
          if (!dbInfo.db) {
            return true;
          }
          var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
          var isDowngrade = dbInfo.version < dbInfo.db.version;
          var isUpgrade = dbInfo.version > dbInfo.db.version;
          if (isDowngrade) {
            if (dbInfo.version !== defaultVersion) {
              console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
            }
            dbInfo.version = dbInfo.db.version;
          }
          if (isUpgrade || isNewStore) {
            if (isNewStore) {
              var incVersion = dbInfo.db.version + 1;
              if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
              }
            }
            return true;
          }
          return false;
        }
        function _encodeBlob(blob) {
          return new Promise$1(function(resolve, reject) {
            var reader = new FileReader();
            reader.onerror = reject;
            reader.onloadend = function(e2) {
              var base642 = btoa(e2.target.result || "");
              resolve({
                __local_forage_encoded_blob: true,
                data: base642,
                type: blob.type
              });
            };
            reader.readAsBinaryString(blob);
          });
        }
        function _decodeBlob(encodedBlob) {
          var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
          return createBlob([arrayBuff], { type: encodedBlob.type });
        }
        function _isEncodedBlob(value) {
          return value && value.__local_forage_encoded_blob;
        }
        function _fullyReady(callback) {
          var self2 = this;
          var promise = self2._initReady().then(function() {
            var dbContext = dbContexts[self2._dbInfo.name];
            if (dbContext && dbContext.dbReady) {
              return dbContext.dbReady;
            }
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        }
        function _tryReconnect(dbInfo) {
          _deferReadiness(dbInfo);
          var dbContext = dbContexts[dbInfo.name];
          var forages = dbContext.forages;
          for (var i2 = 0; i2 < forages.length; i2++) {
            var forage = forages[i2];
            if (forage._dbInfo.db) {
              forage._dbInfo.db.close();
              forage._dbInfo.db = null;
            }
          }
          dbInfo.db = null;
          return _getOriginalConnection(dbInfo).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            for (var i3 = 0; i3 < forages.length; i3++) {
              forages[i3]._dbInfo.db = db;
            }
          })["catch"](function(err) {
            _rejectReadiness(dbInfo, err);
            throw err;
          });
        }
        function createTransaction(dbInfo, mode, callback, retries) {
          if (retries === void 0) {
            retries = 1;
          }
          try {
            var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
            callback(null, tx);
          } catch (err) {
            if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
              return Promise$1.resolve().then(function() {
                if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                  if (dbInfo.db) {
                    dbInfo.version = dbInfo.db.version + 1;
                  }
                  return _getUpgradedConnection(dbInfo);
                }
              }).then(function() {
                return _tryReconnect(dbInfo).then(function() {
                  createTransaction(dbInfo, mode, callback, retries - 1);
                });
              })["catch"](callback);
            }
            callback(err);
          }
        }
        function createDbContext() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function _initStorage(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = options[i2];
            }
          }
          var dbContext = dbContexts[dbInfo.name];
          if (!dbContext) {
            dbContext = createDbContext();
            dbContexts[dbInfo.name] = dbContext;
          }
          dbContext.forages.push(self2);
          if (!self2._initReady) {
            self2._initReady = self2.ready;
            self2.ready = _fullyReady;
          }
          var initPromises = [];
          function ignoreErrors() {
            return Promise$1.resolve();
          }
          for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
            var forage = dbContext.forages[j2];
            if (forage !== self2) {
              initPromises.push(forage._initReady()["catch"](ignoreErrors));
            }
          }
          var forages = dbContext.forages.slice(0);
          return Promise$1.all(initPromises).then(function() {
            dbInfo.db = dbContext.db;
            return _getOriginalConnection(dbInfo);
          }).then(function(db) {
            dbInfo.db = db;
            if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
              return _getUpgradedConnection(dbInfo);
            }
            return db;
          }).then(function(db) {
            dbInfo.db = dbContext.db = db;
            self2._dbInfo = dbInfo;
            for (var k2 = 0; k2 < forages.length; k2++) {
              var forage2 = forages[k2];
              if (forage2 !== self2) {
                forage2._dbInfo.db = dbInfo.db;
                forage2._dbInfo.version = dbInfo.version;
              }
            }
          });
        }
        function getItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.get(key2);
                  req.onsuccess = function() {
                    var value = req.result;
                    if (value === void 0) {
                      value = null;
                    }
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    resolve(value);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openCursor();
                  var iterationNumber = 1;
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (cursor) {
                      var value = cursor.value;
                      if (_isEncodedBlob(value)) {
                        value = _decodeBlob(value);
                      }
                      var result = iterator(value, cursor.key, iterationNumber++);
                      if (result !== void 0) {
                        resolve(result);
                      } else {
                        cursor["continue"]();
                      }
                    } else {
                      resolve();
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            var dbInfo;
            self2.ready().then(function() {
              dbInfo = self2._dbInfo;
              if (toString3.call(value) === "[object Blob]") {
                return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                  if (blobSupport) {
                    return value;
                  }
                  return _encodeBlob(value);
                });
              }
              return value;
            }).then(function(value2) {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  if (value2 === null) {
                    value2 = void 0;
                  }
                  var req = store.put(value2, key2);
                  transaction.oncomplete = function() {
                    if (value2 === void 0) {
                      value2 = null;
                    }
                    resolve(value2);
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store["delete"](key2);
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onerror = function() {
                    reject(req.error);
                  };
                  transaction.onabort = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.clear();
                  transaction.oncomplete = function() {
                    resolve();
                  };
                  transaction.onabort = transaction.onerror = function() {
                    var err2 = req.error ? req.error : req.transaction.error;
                    reject(err2);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length2(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.count();
                  req.onsuccess = function() {
                    resolve(req.result);
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            if (n < 0) {
              resolve(null);
              return;
            }
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var advanced = false;
                  var req = store.openKeyCursor();
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(null);
                      return;
                    }
                    if (n === 0) {
                      resolve(cursor.key);
                    } else {
                      if (!advanced) {
                        advanced = true;
                        cursor.advance(n);
                      } else {
                        resolve(cursor.key);
                      }
                    }
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
                if (err) {
                  return reject(err);
                }
                try {
                  var store = transaction.objectStore(self2._dbInfo.storeName);
                  var req = store.openKeyCursor();
                  var keys2 = [];
                  req.onsuccess = function() {
                    var cursor = req.result;
                    if (!cursor) {
                      resolve(keys2);
                      return;
                    }
                    keys2.push(cursor.key);
                    cursor["continue"]();
                  };
                  req.onerror = function() {
                    reject(req.error);
                  };
                } catch (e2) {
                  reject(e2);
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
            var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              dbContext.db = db;
              for (var i2 = 0; i2 < forages.length; i2++) {
                forages[i2]._dbInfo.db = db;
              }
              return db;
            });
            if (!options.storeName) {
              promise = dbPromise.then(function(db) {
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var forage = forages[i2];
                  forage._dbInfo.db = null;
                }
                var dropDBPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.deleteDatabase(options.name);
                  req.onerror = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    reject(req.error);
                  };
                  req.onblocked = function() {
                    console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    if (db2) {
                      db2.close();
                    }
                    resolve(db2);
                  };
                });
                return dropDBPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var i3 = 0; i3 < forages.length; i3++) {
                    var _forage = forages[i3];
                    _advanceReadiness(_forage._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            } else {
              promise = dbPromise.then(function(db) {
                if (!db.objectStoreNames.contains(options.storeName)) {
                  return;
                }
                var newVersion = db.version + 1;
                _deferReadiness(options);
                var dbContext = dbContexts[options.name];
                var forages = dbContext.forages;
                db.close();
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var forage = forages[i2];
                  forage._dbInfo.db = null;
                  forage._dbInfo.version = newVersion;
                }
                var dropObjectPromise = new Promise$1(function(resolve, reject) {
                  var req = idb.open(options.name, newVersion);
                  req.onerror = function(err) {
                    var db2 = req.result;
                    db2.close();
                    reject(err);
                  };
                  req.onupgradeneeded = function() {
                    var db2 = req.result;
                    db2.deleteObjectStore(options.storeName);
                  };
                  req.onsuccess = function() {
                    var db2 = req.result;
                    db2.close();
                    resolve(db2);
                  };
                });
                return dropObjectPromise.then(function(db2) {
                  dbContext.db = db2;
                  for (var j2 = 0; j2 < forages.length; j2++) {
                    var _forage2 = forages[j2];
                    _forage2._dbInfo.db = db2;
                    _advanceReadiness(_forage2._dbInfo);
                  }
                })["catch"](function(err) {
                  (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                  });
                  throw err;
                });
              });
            }
          }
          executeCallback(promise, callback);
          return promise;
        }
        var asyncStorage = {
          _driver: "asyncStorage",
          _initStorage,
          _support: isIndexedDBValid(),
          iterate,
          getItem,
          setItem,
          removeItem,
          clear,
          length: length2,
          key,
          keys,
          dropInstance
        };
        function isWebSQLValid() {
          return typeof openDatabase === "function";
        }
        var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var BLOB_TYPE_PREFIX = "~~local_forage_type~";
        var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
        var SERIALIZED_MARKER = "__lfsc__:";
        var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
        var TYPE_ARRAYBUFFER = "arbf";
        var TYPE_BLOB = "blob";
        var TYPE_INT8ARRAY = "si08";
        var TYPE_UINT8ARRAY = "ui08";
        var TYPE_UINT8CLAMPEDARRAY = "uic8";
        var TYPE_INT16ARRAY = "si16";
        var TYPE_INT32ARRAY = "si32";
        var TYPE_UINT16ARRAY = "ur16";
        var TYPE_UINT32ARRAY = "ui32";
        var TYPE_FLOAT32ARRAY = "fl32";
        var TYPE_FLOAT64ARRAY = "fl64";
        var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
        var toString$12 = Object.prototype.toString;
        function stringToBuffer(serializedString) {
          var bufferLength = serializedString.length * 0.75;
          var len = serializedString.length;
          var i2;
          var p2 = 0;
          var encoded1, encoded2, encoded3, encoded4;
          if (serializedString[serializedString.length - 1] === "=") {
            bufferLength--;
            if (serializedString[serializedString.length - 2] === "=") {
              bufferLength--;
            }
          }
          var buffer = new ArrayBuffer(bufferLength);
          var bytes = new Uint8Array(buffer);
          for (i2 = 0; i2 < len; i2 += 4) {
            encoded1 = BASE_CHARS.indexOf(serializedString[i2]);
            encoded2 = BASE_CHARS.indexOf(serializedString[i2 + 1]);
            encoded3 = BASE_CHARS.indexOf(serializedString[i2 + 2]);
            encoded4 = BASE_CHARS.indexOf(serializedString[i2 + 3]);
            bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return buffer;
        }
        function bufferToString(buffer) {
          var bytes = new Uint8Array(buffer);
          var base64String = "";
          var i2;
          for (i2 = 0; i2 < bytes.length; i2 += 3) {
            base64String += BASE_CHARS[bytes[i2] >> 2];
            base64String += BASE_CHARS[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];
            base64String += BASE_CHARS[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];
            base64String += BASE_CHARS[bytes[i2 + 2] & 63];
          }
          if (bytes.length % 3 === 2) {
            base64String = base64String.substring(0, base64String.length - 1) + "=";
          } else if (bytes.length % 3 === 1) {
            base64String = base64String.substring(0, base64String.length - 2) + "==";
          }
          return base64String;
        }
        function serialize2(value, callback) {
          var valueType = "";
          if (value) {
            valueType = toString$12.call(value);
          }
          if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$12.call(value.buffer) === "[object ArrayBuffer]")) {
            var buffer;
            var marker = SERIALIZED_MARKER;
            if (value instanceof ArrayBuffer) {
              buffer = value;
              marker += TYPE_ARRAYBUFFER;
            } else {
              buffer = value.buffer;
              if (valueType === "[object Int8Array]") {
                marker += TYPE_INT8ARRAY;
              } else if (valueType === "[object Uint8Array]") {
                marker += TYPE_UINT8ARRAY;
              } else if (valueType === "[object Uint8ClampedArray]") {
                marker += TYPE_UINT8CLAMPEDARRAY;
              } else if (valueType === "[object Int16Array]") {
                marker += TYPE_INT16ARRAY;
              } else if (valueType === "[object Uint16Array]") {
                marker += TYPE_UINT16ARRAY;
              } else if (valueType === "[object Int32Array]") {
                marker += TYPE_INT32ARRAY;
              } else if (valueType === "[object Uint32Array]") {
                marker += TYPE_UINT32ARRAY;
              } else if (valueType === "[object Float32Array]") {
                marker += TYPE_FLOAT32ARRAY;
              } else if (valueType === "[object Float64Array]") {
                marker += TYPE_FLOAT64ARRAY;
              } else {
                callback(new Error("Failed to get type for BinaryArray"));
              }
            }
            callback(marker + bufferToString(buffer));
          } else if (valueType === "[object Blob]") {
            var fileReader = new FileReader();
            fileReader.onload = function() {
              var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
              callback(SERIALIZED_MARKER + TYPE_BLOB + str);
            };
            fileReader.readAsArrayBuffer(value);
          } else {
            try {
              callback(JSON.stringify(value));
            } catch (e2) {
              console.error("Couldn't convert value into a JSON string: ", value);
              callback(null, e2);
            }
          }
        }
        function deserialize(value) {
          if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
            return JSON.parse(value);
          }
          var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
          var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
          var blobType;
          if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
            var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
            blobType = matcher[1];
            serializedString = serializedString.substring(matcher[0].length);
          }
          var buffer = stringToBuffer(serializedString);
          switch (type) {
            case TYPE_ARRAYBUFFER:
              return buffer;
            case TYPE_BLOB:
              return createBlob([buffer], { type: blobType });
            case TYPE_INT8ARRAY:
              return new Int8Array(buffer);
            case TYPE_UINT8ARRAY:
              return new Uint8Array(buffer);
            case TYPE_UINT8CLAMPEDARRAY:
              return new Uint8ClampedArray(buffer);
            case TYPE_INT16ARRAY:
              return new Int16Array(buffer);
            case TYPE_UINT16ARRAY:
              return new Uint16Array(buffer);
            case TYPE_INT32ARRAY:
              return new Int32Array(buffer);
            case TYPE_UINT32ARRAY:
              return new Uint32Array(buffer);
            case TYPE_FLOAT32ARRAY:
              return new Float32Array(buffer);
            case TYPE_FLOAT64ARRAY:
              return new Float64Array(buffer);
            default:
              throw new Error("Unkown type: " + type);
          }
        }
        var localforageSerializer = {
          serialize: serialize2,
          deserialize,
          stringToBuffer,
          bufferToString
        };
        function createDbTable(t, dbInfo, callback, errorCallback) {
          t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
        }
        function _initStorage$1(options) {
          var self2 = this;
          var dbInfo = {
            db: null
          };
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = typeof options[i2] !== "string" ? options[i2].toString() : options[i2];
            }
          }
          var dbInfoPromise = new Promise$1(function(resolve, reject) {
            try {
              dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
            } catch (e2) {
              return reject(e2);
            }
            dbInfo.db.transaction(function(t) {
              createDbTable(t, dbInfo, function() {
                self2._dbInfo = dbInfo;
                resolve();
              }, function(t2, error) {
                reject(error);
              });
            }, reject);
          });
          dbInfo.serializer = localforageSerializer;
          return dbInfoPromise;
        }
        function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
          t.executeSql(sqlStatement, args, callback, function(t2, error) {
            if (error.code === error.SYNTAX_ERR) {
              t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
                if (!results.rows.length) {
                  createDbTable(t3, dbInfo, function() {
                    t3.executeSql(sqlStatement, args, callback, errorCallback);
                  }, errorCallback);
                } else {
                  errorCallback(t3, error);
                }
              }, errorCallback);
            } else {
              errorCallback(t2, error);
            }
          }, errorCallback);
        }
        function getItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).value : null;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$1(iterator, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                  var rows = results.rows;
                  var length3 = rows.length;
                  for (var i2 = 0; i2 < length3; i2++) {
                    var item = rows.item(i2);
                    var result = item.value;
                    if (result) {
                      result = dbInfo.serializer.deserialize(result);
                    }
                    result = iterator(result, item.key, i2 + 1);
                    if (result !== void 0) {
                      resolve(result);
                      return;
                    }
                  }
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function _setItem(key2, value, callback, retriesLeft) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              if (value === void 0) {
                value = null;
              }
              var originalValue = value;
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  dbInfo.db.transaction(function(t) {
                    tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                      resolve(originalValue);
                    }, function(t2, error2) {
                      reject(error2);
                    });
                  }, function(sqlError) {
                    if (sqlError.code === sqlError.QUOTA_ERR) {
                      if (retriesLeft > 0) {
                        resolve(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                        return;
                      }
                      reject(sqlError);
                    }
                  });
                }
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$1(key2, value, callback) {
          return _setItem.apply(this, [key2, value, callback, 1]);
        }
        function removeItem$1(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function clear$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                  resolve();
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                  var result = results.rows.item(0).c;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$1(n, callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                  var result = results.rows.length ? results.rows.item(0).key : null;
                  resolve(result);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$1(callback) {
          var self2 = this;
          var promise = new Promise$1(function(resolve, reject) {
            self2.ready().then(function() {
              var dbInfo = self2._dbInfo;
              dbInfo.db.transaction(function(t) {
                tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                  var keys2 = [];
                  for (var i2 = 0; i2 < results.rows.length; i2++) {
                    keys2.push(results.rows.item(i2).key);
                  }
                  resolve(keys2);
                }, function(t2, error) {
                  reject(error);
                });
              });
            })["catch"](reject);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getAllStoreNames(db) {
          return new Promise$1(function(resolve, reject) {
            db.transaction(function(t) {
              t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
                var storeNames = [];
                for (var i2 = 0; i2 < results.rows.length; i2++) {
                  storeNames.push(results.rows.item(i2).name);
                }
                resolve({
                  db,
                  storeNames
                });
              }, function(t2, error) {
                reject(error);
              });
            }, function(sqlError) {
              reject(sqlError);
            });
          });
        }
        function dropInstance$1(options, callback) {
          callback = getCallback.apply(this, arguments);
          var currentConfig = this.config();
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              var db;
              if (options.name === currentConfig.name) {
                db = self2._dbInfo.db;
              } else {
                db = openDatabase(options.name, "", "", 0);
              }
              if (!options.storeName) {
                resolve(getAllStoreNames(db));
              } else {
                resolve({
                  db,
                  storeNames: [options.storeName]
                });
              }
            }).then(function(operationInfo) {
              return new Promise$1(function(resolve, reject) {
                operationInfo.db.transaction(function(t) {
                  function dropTable(storeName) {
                    return new Promise$1(function(resolve2, reject2) {
                      t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                        resolve2();
                      }, function(t2, error) {
                        reject2(error);
                      });
                    });
                  }
                  var operations = [];
                  for (var i2 = 0, len = operationInfo.storeNames.length; i2 < len; i2++) {
                    operations.push(dropTable(operationInfo.storeNames[i2]));
                  }
                  Promise$1.all(operations).then(function() {
                    resolve();
                  })["catch"](function(e2) {
                    reject(e2);
                  });
                }, function(sqlError) {
                  reject(sqlError);
                });
              });
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var webSQLStorage = {
          _driver: "webSQLStorage",
          _initStorage: _initStorage$1,
          _support: isWebSQLValid(),
          iterate: iterate$1,
          getItem: getItem$1,
          setItem: setItem$1,
          removeItem: removeItem$1,
          clear: clear$1,
          length: length$1,
          key: key$1,
          keys: keys$1,
          dropInstance: dropInstance$1
        };
        function isLocalStorageValid() {
          try {
            return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch (e2) {
            return false;
          }
        }
        function _getKeyPrefix(options, defaultConfig) {
          var keyPrefix = options.name + "/";
          if (options.storeName !== defaultConfig.storeName) {
            keyPrefix += options.storeName + "/";
          }
          return keyPrefix;
        }
        function checkIfLocalStorageThrows() {
          var localStorageTestKey = "_localforage_support_test";
          try {
            localStorage.setItem(localStorageTestKey, true);
            localStorage.removeItem(localStorageTestKey);
            return false;
          } catch (e2) {
            return true;
          }
        }
        function _isLocalStorageUsable() {
          return !checkIfLocalStorageThrows() || localStorage.length > 0;
        }
        function _initStorage$2(options) {
          var self2 = this;
          var dbInfo = {};
          if (options) {
            for (var i2 in options) {
              dbInfo[i2] = options[i2];
            }
          }
          dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
          if (!_isLocalStorageUsable()) {
            return Promise$1.reject();
          }
          self2._dbInfo = dbInfo;
          dbInfo.serializer = localforageSerializer;
          return Promise$1.resolve();
        }
        function clear$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var keyPrefix = self2._dbInfo.keyPrefix;
            for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function getItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result = localStorage.getItem(dbInfo.keyPrefix + key2);
            if (result) {
              result = dbInfo.serializer.deserialize(result);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function iterate$2(iterator, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var keyPrefix = dbInfo.keyPrefix;
            var keyPrefixLength = keyPrefix.length;
            var length3 = localStorage.length;
            var iterationNumber = 1;
            for (var i2 = 0; i2 < length3; i2++) {
              var key2 = localStorage.key(i2);
              if (key2.indexOf(keyPrefix) !== 0) {
                continue;
              }
              var value = localStorage.getItem(key2);
              if (value) {
                value = dbInfo.serializer.deserialize(value);
              }
              value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
              if (value !== void 0) {
                return value;
              }
            }
          });
          executeCallback(promise, callback);
          return promise;
        }
        function key$2(n, callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var result;
            try {
              result = localStorage.key(n);
            } catch (error) {
              result = null;
            }
            if (result) {
              result = result.substring(dbInfo.keyPrefix.length);
            }
            return result;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function keys$2(callback) {
          var self2 = this;
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            var length3 = localStorage.length;
            var keys2 = [];
            for (var i2 = 0; i2 < length3; i2++) {
              var itemKey = localStorage.key(i2);
              if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
                keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
              }
            }
            return keys2;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function length$2(callback) {
          var self2 = this;
          var promise = self2.keys().then(function(keys2) {
            return keys2.length;
          });
          executeCallback(promise, callback);
          return promise;
        }
        function removeItem$2(key2, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            localStorage.removeItem(dbInfo.keyPrefix + key2);
          });
          executeCallback(promise, callback);
          return promise;
        }
        function setItem$2(key2, value, callback) {
          var self2 = this;
          key2 = normalizeKey(key2);
          var promise = self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            return new Promise$1(function(resolve, reject) {
              var dbInfo = self2._dbInfo;
              dbInfo.serializer.serialize(value, function(value2, error) {
                if (error) {
                  reject(error);
                } else {
                  try {
                    localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                    resolve(originalValue);
                  } catch (e2) {
                    if (e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                      reject(e2);
                    }
                    reject(e2);
                  }
                }
              });
            });
          });
          executeCallback(promise, callback);
          return promise;
        }
        function dropInstance$2(options, callback) {
          callback = getCallback.apply(this, arguments);
          options = typeof options !== "function" && options || {};
          if (!options.name) {
            var currentConfig = this.config();
            options.name = options.name || currentConfig.name;
            options.storeName = options.storeName || currentConfig.storeName;
          }
          var self2 = this;
          var promise;
          if (!options.name) {
            promise = Promise$1.reject("Invalid arguments");
          } else {
            promise = new Promise$1(function(resolve) {
              if (!options.storeName) {
                resolve(options.name + "/");
              } else {
                resolve(_getKeyPrefix(options, self2._defaultConfig));
              }
            }).then(function(keyPrefix) {
              for (var i2 = localStorage.length - 1; i2 >= 0; i2--) {
                var key2 = localStorage.key(i2);
                if (key2.indexOf(keyPrefix) === 0) {
                  localStorage.removeItem(key2);
                }
              }
            });
          }
          executeCallback(promise, callback);
          return promise;
        }
        var localStorageWrapper = {
          _driver: "localStorageWrapper",
          _initStorage: _initStorage$2,
          _support: isLocalStorageValid(),
          iterate: iterate$2,
          getItem: getItem$2,
          setItem: setItem$2,
          removeItem: removeItem$2,
          clear: clear$2,
          length: length$2,
          key: key$2,
          keys: keys$2,
          dropInstance: dropInstance$2
        };
        var sameValue = function sameValue2(x2, y2) {
          return x2 === y2 || typeof x2 === "number" && typeof y2 === "number" && isNaN(x2) && isNaN(y2);
        };
        var includes = function includes2(array, searchElement) {
          var len = array.length;
          var i2 = 0;
          while (i2 < len) {
            if (sameValue(array[i2], searchElement)) {
              return true;
            }
            i2++;
          }
          return false;
        };
        var isArray = Array.isArray || function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        var DefinedDrivers = {};
        var DriverSupport = {};
        var DefaultDrivers = {
          INDEXEDDB: asyncStorage,
          WEBSQL: webSQLStorage,
          LOCALSTORAGE: localStorageWrapper
        };
        var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
        var OptionalDriverMethods = ["dropInstance"];
        var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
        var DefaultConfig = {
          description: "",
          driver: DefaultDriverOrder.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function callWhenReady(localForageInstance, libraryMethod) {
          localForageInstance[libraryMethod] = function() {
            var _args = arguments;
            return localForageInstance.ready().then(function() {
              return localForageInstance[libraryMethod].apply(localForageInstance, _args);
            });
          };
        }
        function extend() {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var arg = arguments[i2];
            if (arg) {
              for (var _key in arg) {
                if (arg.hasOwnProperty(_key)) {
                  if (isArray(arg[_key])) {
                    arguments[0][_key] = arg[_key].slice();
                  } else {
                    arguments[0][_key] = arg[_key];
                  }
                }
              }
            }
          }
          return arguments[0];
        }
        var LocalForage = function() {
          function LocalForage2(options) {
            _classCallCheck(this, LocalForage2);
            for (var driverTypeKey in DefaultDrivers) {
              if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
                var driver = DefaultDrivers[driverTypeKey];
                var driverName = driver._driver;
                this[driverTypeKey] = driverName;
                if (!DefinedDrivers[driverName]) {
                  this.defineDriver(driver);
                }
              }
            }
            this._defaultConfig = extend({}, DefaultConfig);
            this._config = extend({}, this._defaultConfig, options);
            this._driverSet = null;
            this._initDriver = null;
            this._ready = false;
            this._dbInfo = null;
            this._wrapLibraryMethodsWithReady();
            this.setDriver(this._config.driver)["catch"](function() {
            });
          }
          LocalForage2.prototype.config = function config(options) {
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
              if (this._ready) {
                return new Error("Can't call config() after localforage has been used.");
              }
              for (var i2 in options) {
                if (i2 === "storeName") {
                  options[i2] = options[i2].replace(/\W/g, "_");
                }
                if (i2 === "version" && typeof options[i2] !== "number") {
                  return new Error("Database version must be a number.");
                }
                this._config[i2] = options[i2];
              }
              if ("driver" in options && options.driver) {
                return this.setDriver(this._config.driver);
              }
              return true;
            } else if (typeof options === "string") {
              return this._config[options];
            } else {
              return this._config;
            }
          };
          LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
            var promise = new Promise$1(function(resolve, reject) {
              try {
                var driverName = driverObject._driver;
                var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!driverObject._driver) {
                  reject(complianceError);
                  return;
                }
                var driverMethods = LibraryMethods.concat("_initStorage");
                for (var i2 = 0, len = driverMethods.length; i2 < len; i2++) {
                  var driverMethodName = driverMethods[i2];
                  var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                  if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                    reject(complianceError);
                    return;
                  }
                }
                var configureMissingMethods = function configureMissingMethods2() {
                  var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                    return function() {
                      var error = new Error("Method " + methodName + " is not implemented by the current driver");
                      var promise2 = Promise$1.reject(error);
                      executeCallback(promise2, arguments[arguments.length - 1]);
                      return promise2;
                    };
                  };
                  for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                    var optionalDriverMethod = OptionalDriverMethods[_i];
                    if (!driverObject[optionalDriverMethod]) {
                      driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                    }
                  }
                };
                configureMissingMethods();
                var setDriverSupport = function setDriverSupport2(support) {
                  if (DefinedDrivers[driverName]) {
                    console.info("Redefining LocalForage driver: " + driverName);
                  }
                  DefinedDrivers[driverName] = driverObject;
                  DriverSupport[driverName] = support;
                  resolve();
                };
                if ("_support" in driverObject) {
                  if (driverObject._support && typeof driverObject._support === "function") {
                    driverObject._support().then(setDriverSupport, reject);
                  } else {
                    setDriverSupport(!!driverObject._support);
                  }
                } else {
                  setDriverSupport(true);
                }
              } catch (e2) {
                reject(e2);
              }
            });
            executeTwoCallbacks(promise, callback, errorCallback);
            return promise;
          };
          LocalForage2.prototype.driver = function driver() {
            return this._driver || null;
          };
          LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
            var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
            executeTwoCallbacks(getDriverPromise, callback, errorCallback);
            return getDriverPromise;
          };
          LocalForage2.prototype.getSerializer = function getSerializer(callback) {
            var serializerPromise = Promise$1.resolve(localforageSerializer);
            executeTwoCallbacks(serializerPromise, callback);
            return serializerPromise;
          };
          LocalForage2.prototype.ready = function ready(callback) {
            var self2 = this;
            var promise = self2._driverSet.then(function() {
              if (self2._ready === null) {
                self2._ready = self2._initDriver();
              }
              return self2._ready;
            });
            executeTwoCallbacks(promise, callback, callback);
            return promise;
          };
          LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
            var self2 = this;
            if (!isArray(drivers)) {
              drivers = [drivers];
            }
            var supportedDrivers = this._getSupportedDrivers(drivers);
            function setDriverToConfig() {
              self2._config.driver = self2.driver();
            }
            function extendSelfWithDriver(driver) {
              self2._extend(driver);
              setDriverToConfig();
              self2._ready = self2._initStorage(self2._config);
              return self2._ready;
            }
            function initDriver(supportedDrivers2) {
              return function() {
                var currentDriverIndex = 0;
                function driverPromiseLoop() {
                  while (currentDriverIndex < supportedDrivers2.length) {
                    var driverName = supportedDrivers2[currentDriverIndex];
                    currentDriverIndex++;
                    self2._dbInfo = null;
                    self2._ready = null;
                    return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                  }
                  setDriverToConfig();
                  var error = new Error("No available storage method found.");
                  self2._driverSet = Promise$1.reject(error);
                  return self2._driverSet;
                }
                return driverPromiseLoop();
              };
            }
            var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
              return Promise$1.resolve();
            }) : Promise$1.resolve();
            this._driverSet = oldDriverSetDone.then(function() {
              var driverName = supportedDrivers[0];
              self2._dbInfo = null;
              self2._ready = null;
              return self2.getDriver(driverName).then(function(driver) {
                self2._driver = driver._driver;
                setDriverToConfig();
                self2._wrapLibraryMethodsWithReady();
                self2._initDriver = initDriver(supportedDrivers);
              });
            })["catch"](function() {
              setDriverToConfig();
              var error = new Error("No available storage method found.");
              self2._driverSet = Promise$1.reject(error);
              return self2._driverSet;
            });
            executeTwoCallbacks(this._driverSet, callback, errorCallback);
            return this._driverSet;
          };
          LocalForage2.prototype.supports = function supports(driverName) {
            return !!DriverSupport[driverName];
          };
          LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
            extend(this, libraryMethodsAndProperties);
          };
          LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
            var supportedDrivers = [];
            for (var i2 = 0, len = drivers.length; i2 < len; i2++) {
              var driverName = drivers[i2];
              if (this.supports(driverName)) {
                supportedDrivers.push(driverName);
              }
            }
            return supportedDrivers;
          };
          LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
            for (var i2 = 0, len = LibraryMethods.length; i2 < len; i2++) {
              callWhenReady(this, LibraryMethods[i2]);
            }
          };
          LocalForage2.prototype.createInstance = function createInstance(options) {
            return new LocalForage2(options);
          };
          return LocalForage2;
        }();
        var localforage_js = new LocalForage();
        module3.exports = localforage_js;
      }, { "3": 3 }] }, {}, [4])(4);
    });
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero2(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
    );
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero2(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero2(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero2(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero2(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero2(base_length);
    var base_dist = new Array(D_CODES);
    zero2(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s2, w2) => {
      s2.pending_buf[s2.pending++] = w2 & 255;
      s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
    };
    var send_bits = (s2, value, length2) => {
      if (s2.bi_valid > Buf_size - length2) {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        put_short(s2, s2.bi_buf);
        s2.bi_buf = value >> Buf_size - s2.bi_valid;
        s2.bi_valid += length2 - Buf_size;
      } else {
        s2.bi_buf |= value << s2.bi_valid & 65535;
        s2.bi_valid += length2;
      }
    };
    var send_code = (s2, c2, tree) => {
      send_bits(
        s2,
        tree[c2 * 2],
        tree[c2 * 2 + 1]
        /*.Len*/
      );
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s2) => {
      if (s2.bi_valid === 16) {
        put_short(s2, s2.bi_buf);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      } else if (s2.bi_valid >= 8) {
        s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
        s2.bi_buf >>= 8;
        s2.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s2, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m2;
      let bits2;
      let xbits;
      let f2;
      let overflow = 0;
      for (bits2 = 0; bits2 <= MAX_BITS; bits2++) {
        s2.bl_count[bits2] = 0;
      }
      tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
      for (h = s2.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s2.heap[h];
        bits2 = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits2 > max_length) {
          bits2 = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits2;
        if (n > max_code) {
          continue;
        }
        s2.bl_count[bits2]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f2 = tree[n * 2];
        s2.opt_len += f2 * (bits2 + xbits);
        if (has_stree) {
          s2.static_len += f2 * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits2 = max_length - 1;
        while (s2.bl_count[bits2] === 0) {
          bits2--;
        }
        s2.bl_count[bits2]--;
        s2.bl_count[bits2 + 1] += 2;
        s2.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits2 = max_length; bits2 !== 0; bits2--) {
        n = s2.bl_count[bits2];
        while (n !== 0) {
          m2 = s2.heap[--h];
          if (m2 > max_code) {
            continue;
          }
          if (tree[m2 * 2 + 1] !== bits2) {
            s2.opt_len += (bits2 - tree[m2 * 2 + 1]) * tree[m2 * 2];
            tree[m2 * 2 + 1] = bits2;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits2;
      let n;
      for (bits2 = 1; bits2 <= MAX_BITS; bits2++) {
        code = code + bl_count[bits2 - 1] << 1;
        next_code[bits2] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits2;
      let length2;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length2 = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length2;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length2++] = code;
        }
      }
      _length_code[length2 - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits2 = 0; bits2 <= MAX_BITS; bits2++) {
        bl_count[bits2] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s2) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s2.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s2.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s2.bl_tree[n * 2] = 0;
      }
      s2.dyn_ltree[END_BLOCK * 2] = 1;
      s2.opt_len = s2.static_len = 0;
      s2.sym_next = s2.matches = 0;
    };
    var bi_windup = (s2) => {
      if (s2.bi_valid > 8) {
        put_short(s2, s2.bi_buf);
      } else if (s2.bi_valid > 0) {
        s2.pending_buf[s2.pending++] = s2.bi_buf;
      }
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    };
    var smaller = (tree, n, m2, depth) => {
      const _n2 = n * 2;
      const _m2 = m2 * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m2];
    };
    var pqdownheap = (s2, tree, k2) => {
      const v2 = s2.heap[k2];
      let j2 = k2 << 1;
      while (j2 <= s2.heap_len) {
        if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
          j2++;
        }
        if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
          break;
        }
        s2.heap[k2] = s2.heap[j2];
        k2 = j2;
        j2 <<= 1;
      }
      s2.heap[k2] = v2;
    };
    var compress_block = (s2, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s2.sym_next !== 0) {
        do {
          dist = s2.pending_buf[s2.sym_buf + sx++] & 255;
          dist += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
          lc = s2.pending_buf[s2.sym_buf + sx++];
          if (dist === 0) {
            send_code(s2, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s2, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s2, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s2, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s2, dist, extra);
            }
          }
        } while (sx < s2.sym_next);
      }
      send_code(s2, END_BLOCK, ltree);
    };
    var build_tree = (s2, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m2;
      let max_code = -1;
      let node2;
      s2.heap_len = 0;
      s2.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s2.heap[++s2.heap_len] = max_code = n;
          s2.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s2.heap_len < 2) {
        node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node2 * 2] = 1;
        s2.depth[node2] = 0;
        s2.opt_len--;
        if (has_stree) {
          s2.static_len -= stree[node2 * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s2.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s2, tree, n);
      }
      node2 = elems;
      do {
        n = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[
          1
          /*SMALLEST*/
        ] = s2.heap[s2.heap_len--];
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
        m2 = s2.heap[
          1
          /*SMALLEST*/
        ];
        s2.heap[--s2.heap_max] = n;
        s2.heap[--s2.heap_max] = m2;
        tree[node2 * 2] = tree[n * 2] + tree[m2 * 2];
        s2.depth[node2] = (s2.depth[n] >= s2.depth[m2] ? s2.depth[n] : s2.depth[m2]) + 1;
        tree[n * 2 + 1] = tree[m2 * 2 + 1] = node2;
        s2.heap[
          1
          /*SMALLEST*/
        ] = node2++;
        pqdownheap(
          s2,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s2.heap_len >= 2);
      s2.heap[--s2.heap_max] = s2.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s2, desc);
      gen_codes(tree, max_code, s2.bl_count);
    };
    var scan_tree = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s2.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s2.bl_tree[curlen * 2]++;
          }
          s2.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s2.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s2.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s2, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s2, curlen, s2.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s2, curlen, s2.bl_tree);
            count--;
          }
          send_code(s2, REP_3_6, s2.bl_tree);
          send_bits(s2, count - 3, 2);
        } else if (count <= 10) {
          send_code(s2, REPZ_3_10, s2.bl_tree);
          send_bits(s2, count - 3, 3);
        } else {
          send_code(s2, REPZ_11_138, s2.bl_tree);
          send_bits(s2, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s2) => {
      let max_blindex;
      scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
      scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
      build_tree(s2, s2.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s2, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s2, lcodes - 257, 5);
      send_bits(s2, dcodes - 1, 5);
      send_bits(s2, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s2, s2.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s2, s2.dyn_ltree, lcodes - 1);
      send_tree(s2, s2.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s2) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s2.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s2) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
      s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
      s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
      init_block(s2);
    };
    var _tr_stored_block = (s2, buf, stored_len, last) => {
      send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s2);
      put_short(s2, stored_len);
      put_short(s2, ~stored_len);
      if (stored_len) {
        s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
      }
      s2.pending += stored_len;
    };
    var _tr_align = (s2) => {
      send_bits(s2, STATIC_TREES << 1, 3);
      send_code(s2, END_BLOCK, static_ltree);
      bi_flush(s2);
    };
    var _tr_flush_block = (s2, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s2.level > 0) {
        if (s2.strm.data_type === Z_UNKNOWN) {
          s2.strm.data_type = detect_data_type(s2);
        }
        build_tree(s2, s2.l_desc);
        build_tree(s2, s2.d_desc);
        max_blindex = build_bl_tree(s2);
        opt_lenb = s2.opt_len + 3 + 7 >>> 3;
        static_lenb = s2.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s2, buf, stored_len, last);
      } else if (s2.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s2, static_ltree, static_dtree);
      } else {
        send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
      }
      init_block(s2);
      if (last) {
        bi_windup(s2);
      }
    };
    var _tr_tally = (s2, dist, lc) => {
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
      s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
      if (dist === 0) {
        s2.dyn_ltree[lc * 2]++;
      } else {
        s2.matches++;
        dist--;
        s2.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s2.dyn_dtree[d_code(dist) * 2]++;
      }
      return s2.sym_next === s2.sym_end;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var makeTable = () => {
      let c2, table = [];
      for (var n = 0; n < 256; n++) {
        c2 = n;
        for (var k2 = 0; k2 < 8; k2++) {
          c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
        }
        table[n] = c2;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i2 = pos; i2 < end; i2++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f2) => {
      return f2 * 2 - (f2 > 4 ? 9 : 0);
    };
    var zero2 = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s2) => {
      let n, m2;
      let p2;
      let wsize = s2.w_size;
      n = s2.hash_size;
      p2 = n;
      do {
        m2 = s2.head[--p2];
        s2.head[p2] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n);
      n = wsize;
      p2 = n;
      do {
        m2 = s2.prev[--p2];
        s2.prev[p2] = m2 >= wsize ? m2 - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s2, prev3, data) => (prev3 << s2.hash_shift ^ data) & s2.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s2 = strm.state;
      let len = s2.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
      strm.next_out += len;
      s2.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s2.pending -= len;
      if (s2.pending === 0) {
        s2.pending_out = 0;
      }
    };
    var flush_block_only = (s2, last) => {
      _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
      s2.block_start = s2.strstart;
      flush_pending(s2.strm);
    };
    var put_byte = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2;
    };
    var putShortMSB = (s2, b2) => {
      s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
      s2.pending_buf[s2.pending++] = b2 & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s2, cur_match) => {
      let chain_length = s2.max_chain_length;
      let scan = s2.strstart;
      let match2;
      let len;
      let best_len = s2.prev_length;
      let nice_match = s2.nice_match;
      const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s2.window;
      const wmask = s2.w_mask;
      const prev3 = s2.prev;
      const strend = s2.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s2.prev_length >= s2.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s2.lookahead) {
        nice_match = s2.lookahead;
      }
      do {
        match2 = cur_match;
        if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match2++;
        do {
        } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s2.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev3[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s2.lookahead) {
        return best_len;
      }
      return s2.lookahead;
    };
    var fill_window = (s2) => {
      const _w_size = s2.w_size;
      let n, more, str;
      do {
        more = s2.window_size - s2.lookahead - s2.strstart;
        if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s2.match_start -= _w_size;
          s2.strstart -= _w_size;
          s2.block_start -= _w_size;
          if (s2.insert > s2.strstart) {
            s2.insert = s2.strstart;
          }
          slide_hash(s2);
          more += _w_size;
        }
        if (s2.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
        s2.lookahead += n;
        if (s2.lookahead + s2.insert >= MIN_MATCH) {
          str = s2.strstart - s2.insert;
          s2.ins_h = s2.window[str];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
          while (s2.insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
            s2.insert--;
            if (s2.lookahead + s2.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
    };
    var deflate_stored = (s2, flush) => {
      let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s2.strm.avail_in;
      do {
        len = 65535;
        have = s2.bi_valid + 42 >> 3;
        if (s2.strm.avail_out < have) {
          break;
        }
        have = s2.strm.avail_out - have;
        left = s2.strstart - s2.block_start;
        if (len > left + s2.strm.avail_in) {
          len = left + s2.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s2.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s2.strm.avail_in ? 1 : 0;
        _tr_stored_block(s2, 0, 0, last);
        s2.pending_buf[s2.pending - 4] = len;
        s2.pending_buf[s2.pending - 3] = len >> 8;
        s2.pending_buf[s2.pending - 2] = ~len;
        s2.pending_buf[s2.pending - 1] = ~len >> 8;
        flush_pending(s2.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
          s2.strm.next_out += left;
          s2.strm.avail_out -= left;
          s2.strm.total_out += left;
          s2.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len);
          s2.strm.next_out += len;
          s2.strm.avail_out -= len;
          s2.strm.total_out += len;
        }
      } while (last === 0);
      used -= s2.strm.avail_in;
      if (used) {
        if (used >= s2.w_size) {
          s2.matches = 2;
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
          s2.strstart = s2.w_size;
          s2.insert = s2.strstart;
        } else {
          if (s2.window_size - s2.strstart <= used) {
            s2.strstart -= s2.w_size;
            s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
            if (s2.matches < 2) {
              s2.matches++;
            }
            if (s2.insert > s2.strstart) {
              s2.insert = s2.strstart;
            }
          }
          s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
          s2.strstart += used;
          s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
        }
        s2.block_start = s2.strstart;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s2.window_size - s2.strstart;
      if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
        s2.block_start -= s2.w_size;
        s2.strstart -= s2.w_size;
        s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
        if (s2.matches < 2) {
          s2.matches++;
        }
        have += s2.w_size;
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
      }
      if (have > s2.strm.avail_in) {
        have = s2.strm.avail_in;
      }
      if (have) {
        read_buf(s2.strm, s2.window, s2.strstart, have);
        s2.strstart += have;
        s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
      }
      if (s2.high_water < s2.strstart) {
        s2.high_water = s2.strstart;
      }
      have = s2.bi_valid + 42 >> 3;
      have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
      min_block = have > s2.w_size ? s2.w_size : have;
      left = s2.strstart - s2.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s2.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s2.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s2, s2.block_start, len, last);
        s2.block_start += len;
        flush_pending(s2.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s2, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
            s2.match_length--;
            do {
              s2.strstart++;
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            } while (--s2.match_length !== 0);
            s2.strstart++;
          } else {
            s2.strstart += s2.match_length;
            s2.match_length = 0;
            s2.ins_h = s2.window[s2.strstart];
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s2, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s2.lookahead < MIN_LOOKAHEAD) {
          fill_window(s2);
          if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s2.lookahead >= MIN_MATCH) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
          hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = s2.strstart;
        }
        s2.prev_length = s2.match_length;
        s2.prev_match = s2.match_start;
        s2.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
          s2.match_length = longest_match(s2, hash_head);
          if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
            s2.match_length = MIN_MATCH - 1;
          }
        }
        if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
          max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
          bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
          s2.lookahead -= s2.prev_length - 1;
          s2.prev_length -= 2;
          do {
            if (++s2.strstart <= max_insert) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
          } while (--s2.prev_length !== 0);
          s2.match_available = 0;
          s2.match_length = MIN_MATCH - 1;
          s2.strstart++;
          if (bflush) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s2.match_available) {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
          if (bflush) {
            flush_block_only(s2, false);
          }
          s2.strstart++;
          s2.lookahead--;
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s2.match_available = 1;
          s2.strstart++;
          s2.lookahead--;
        }
      }
      if (s2.match_available) {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        s2.match_available = 0;
      }
      s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s2, flush) => {
      let bflush;
      let prev3;
      let scan, strend;
      const _win = s2.window;
      for (; ; ) {
        if (s2.lookahead <= MAX_MATCH) {
          fill_window(s2);
          if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s2.lookahead === 0) {
            break;
          }
        }
        s2.match_length = 0;
        if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
          scan = s2.strstart - 1;
          prev3 = _win[scan];
          if (prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan]) {
            strend = s2.strstart + MAX_MATCH;
            do {
            } while (prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && prev3 === _win[++scan] && scan < strend);
            s2.match_length = MAX_MATCH - (strend - scan);
            if (s2.match_length > s2.lookahead) {
              s2.match_length = s2.lookahead;
            }
          }
        }
        if (s2.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
          s2.lookahead -= s2.match_length;
          s2.strstart += s2.match_length;
          s2.match_length = 0;
        } else {
          bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
        }
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s2, flush) => {
      let bflush;
      for (; ; ) {
        if (s2.lookahead === 0) {
          fill_window(s2);
          if (s2.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s2.match_length = 0;
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s2.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s2, true);
        if (s2.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s2.sym_next) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    var lm_init = (s2) => {
      s2.window_size = 2 * s2.w_size;
      zero2(s2.head);
      s2.max_lazy_match = configuration_table[s2.level].max_lazy;
      s2.good_match = configuration_table[s2.level].good_length;
      s2.nice_match = configuration_table[s2.level].nice_length;
      s2.max_chain_length = configuration_table[s2.level].max_chain;
      s2.strstart = 0;
      s2.block_start = 0;
      s2.lookahead = 0;
      s2.insert = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      s2.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero2(this.dyn_ltree);
      zero2(this.dyn_dtree);
      zero2(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero2(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero2(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s2 = strm.state;
      if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
      s2.status !== GZIP_STATE && //#endif
      s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s2 = strm.state;
      s2.pending = 0;
      s2.pending_out = 0;
      if (s2.wrap < 0) {
        s2.wrap = -s2.wrap;
      }
      s2.status = //#ifdef GZIP
      s2.wrap === 2 ? GZIP_STATE : (
        //#endif
        s2.wrap ? INIT_STATE : BUSY_STATE
      );
      strm.adler = s2.wrap === 2 ? 0 : 1;
      s2.last_flush = -2;
      _tr_init(s2);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head2) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head2;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s2 = new DeflateState();
      strm.state = s2;
      s2.strm = strm;
      s2.status = INIT_STATE;
      s2.wrap = wrap;
      s2.gzhead = null;
      s2.w_bits = windowBits;
      s2.w_size = 1 << s2.w_bits;
      s2.w_mask = s2.w_size - 1;
      s2.hash_bits = memLevel + 7;
      s2.hash_size = 1 << s2.hash_bits;
      s2.hash_mask = s2.hash_size - 1;
      s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s2.window = new Uint8Array(s2.w_size * 2);
      s2.head = new Uint16Array(s2.hash_size);
      s2.prev = new Uint16Array(s2.w_size);
      s2.lit_bufsize = 1 << memLevel + 6;
      s2.pending_buf_size = s2.lit_bufsize * 4;
      s2.pending_buf = new Uint8Array(s2.pending_buf_size);
      s2.sym_buf = s2.lit_bufsize;
      s2.sym_end = (s2.lit_bufsize - 1) * 3;
      s2.level = level;
      s2.strategy = strategy;
      s2.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s2 = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s2.last_flush;
      s2.last_flush = flush;
      if (s2.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s2.status === INIT_STATE && s2.wrap === 0) {
        s2.status = BUSY_STATE;
      }
      if (s2.status === INIT_STATE) {
        let header = Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
          level_flags = 0;
        } else if (s2.level < 6) {
          level_flags = 1;
        } else if (s2.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s2.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s2, header);
        if (s2.strstart !== 0) {
          putShortMSB(s2, strm.adler >>> 16);
          putShortMSB(s2, strm.adler & 65535);
        }
        strm.adler = 1;
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      }
      if (s2.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s2, 31);
        put_byte(s2, 139);
        put_byte(s2, 8);
        if (!s2.gzhead) {
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, 0);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, OS_CODE);
          s2.status = BUSY_STATE;
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s2,
            (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
          );
          put_byte(s2, s2.gzhead.time & 255);
          put_byte(s2, s2.gzhead.time >> 8 & 255);
          put_byte(s2, s2.gzhead.time >> 16 & 255);
          put_byte(s2, s2.gzhead.time >> 24 & 255);
          put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
          put_byte(s2, s2.gzhead.os & 255);
          if (s2.gzhead.extra && s2.gzhead.extra.length) {
            put_byte(s2, s2.gzhead.extra.length & 255);
            put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
          }
          if (s2.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending, 0);
          }
          s2.gzindex = 0;
          s2.status = EXTRA_STATE;
        }
      }
      if (s2.status === EXTRA_STATE) {
        if (s2.gzhead.extra) {
          let beg = s2.pending;
          let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
          while (s2.pending + left > s2.pending_buf_size) {
            let copy2 = s2.pending_buf_size - s2.pending;
            s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy2), s2.pending);
            s2.pending = s2.pending_buf_size;
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            s2.gzindex += copy2;
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy2;
          }
          let gzhead_extra = new Uint8Array(s2.gzhead.extra);
          s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
          s2.pending += left;
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = NAME_STATE;
      }
      if (s2.status === NAME_STATE) {
        if (s2.gzhead.name) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.name.length) {
              val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex = 0;
        }
        s2.status = COMMENT_STATE;
      }
      if (s2.status === COMMENT_STATE) {
        if (s2.gzhead.comment) {
          let beg = s2.pending;
          let val;
          do {
            if (s2.pending === s2.pending_buf_size) {
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              flush_pending(strm);
              if (s2.pending !== 0) {
                s2.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s2.gzindex < s2.gzhead.comment.length) {
              val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s2, val);
          } while (val !== 0);
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
        }
        s2.status = HCRC_STATE;
      }
      if (s2.status === HCRC_STATE) {
        if (s2.gzhead.hcrc) {
          if (s2.pending + 2 > s2.pending_buf_size) {
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s2, strm.adler & 255);
          put_byte(s2, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH && s2.status !== FINISH_STATE) {
        let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s2.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s2);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s2, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero2(s2.head);
              if (s2.lookahead === 0) {
                s2.strstart = 0;
                s2.block_start = 0;
                s2.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s2.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s2.wrap === 2) {
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        put_byte(s2, strm.adler >> 16 & 255);
        put_byte(s2, strm.adler >> 24 & 255);
        put_byte(s2, strm.total_in & 255);
        put_byte(s2, strm.total_in >> 8 & 255);
        put_byte(s2, strm.total_in >> 16 & 255);
        put_byte(s2, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s2.wrap > 0) {
        s2.wrap = -s2.wrap;
      }
      return s2.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s2 = strm.state;
      const wrap = s2.wrap;
      if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s2.wrap = 0;
      if (dictLength >= s2.w_size) {
        if (wrap === 0) {
          zero2(s2.head);
          s2.strstart = 0;
          s2.block_start = 0;
          s2.insert = 0;
        }
        let tmpDict = new Uint8Array(s2.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s2.w_size;
      }
      const avail = strm.avail_in;
      const next2 = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s2);
      while (s2.lookahead >= MIN_MATCH) {
        let str = s2.strstart;
        let n = s2.lookahead - (MIN_MATCH - 1);
        do {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
        } while (--n);
        s2.strstart = str;
        s2.lookahead = MIN_MATCH - 1;
        fill_window(s2);
      }
      s2.strstart += s2.lookahead;
      s2.block_start = s2.strstart;
      s2.insert = s2.lookahead;
      s2.lookahead = 0;
      s2.match_length = s2.prev_length = MIN_MATCH - 1;
      s2.match_available = 0;
      strm.next_in = next2;
      strm.input = input;
      strm.avail_in = avail;
      s2.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p2 in source) {
          if (_has(source, p2)) {
            obj[p2] = source[p2];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
        len += chunks[i2].length;
      }
      const result = new Uint8Array(len);
      for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
        let chunk = chunks[i2];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q2 = 0; q2 < 256; q2++) {
      _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c2 = str.charCodeAt(m_pos);
        if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
          c22 = str.charCodeAt(m_pos + 1);
          if ((c22 & 64512) === 56320) {
            c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
            m_pos++;
          }
        }
        if (c2 < 128) {
          buf[i2++] = c2;
        } else if (c2 < 2048) {
          buf[i2++] = 192 | c2 >>> 6;
          buf[i2++] = 128 | c2 & 63;
        } else if (c2 < 65536) {
          buf[i2++] = 224 | c2 >>> 12;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        } else {
          buf[i2++] = 240 | c2 >>> 18;
          buf[i2++] = 128 | c2 >>> 12 & 63;
          buf[i2++] = 128 | c2 >>> 6 & 63;
          buf[i2++] = 128 | c2 & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i2 = 0; i2 < len; i2++) {
        result += String.fromCharCode(buf[i2]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i2, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        let c2 = buf[i2++];
        if (c2 < 128) {
          utf16buf[out++] = c2;
          continue;
        }
        let c_len = _utf8len[c2];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c2 = c2 << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c2 < 65536) {
          utf16buf[out++] = c2;
        } else {
          c2 -= 65536;
          utf16buf[out++] = 55296 | c2 >> 10 & 1023;
          utf16buf[out++] = 56320 | c2 & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var zlib_deflate = require_deflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString3 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants();
    function Deflate(options) {
      this.options = utils2.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString3.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils2.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var BAD = 16209;
    var TYPE = 16191;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits2;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from2;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits2 = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits2 < 15) {
            hold += input[_in++] << bits2;
            bits2 += 8;
            hold += input[_in++] << bits2;
            bits2 += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits2 -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits2 < op) {
                    hold += input[_in++] << bits2;
                    bits2 += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits2 -= op;
                }
                if (bits2 < 15) {
                  hold += input[_in++] << bits2;
                  bits2 += 8;
                  hold += input[_in++] << bits2;
                  bits2 += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits2 -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits2 < op) {
                        hold += input[_in++] << bits2;
                        bits2 += 8;
                        if (bits2 < op) {
                          hold += input[_in++] << bits2;
                          bits2 += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits2 -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from2 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from2 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from2 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from2++];
                              } while (--op);
                              from2 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from2 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from2++];
                          output[_out++] = from_source[from2++];
                          output[_out++] = from_source[from2++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from2++];
                          if (len > 1) {
                            output[_out++] = from_source[from2++];
                          }
                        }
                      } else {
                        from2 = _out - dist;
                        do {
                          output[_out++] = output[from2++];
                          output[_out++] = output[from2++];
                          output[_out++] = output[from2++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from2++];
                          if (len > 1) {
                            output[_out++] = output[from2++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits2 >> 3;
      _in -= len;
      bits2 -= len << 3;
      hold &= (1 << bits2) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits2;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes2, table, table_index, work, opts) => {
      const bits2 = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next2;
      let base = null;
      let match2;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes2; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits2;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes2; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match2 = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match2 = 257;
      } else {
        base = dbase;
        extra = dext;
        match2 = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next2 = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match2) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match2) {
          here_op = extra[work[sym] - match2];
          here_val = base[work[sym] - match2];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next2 += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next2 - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next2 + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT2 = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q2) => {
      return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy2) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy2 >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy2) {
          dist = copy2;
        }
        state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
        copy2 -= dist;
        if (copy2) {
          state.window.set(src.subarray(end - copy2, end), 0);
          state.wnext = copy2;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next2;
      let put;
      let have, left;
      let hold;
      let bits2;
      let _in, _out;
      let copy2;
      let from2;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = (
        /* permutation of code lengths */
        new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
      );
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next2 = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits2 = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits2 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits2 = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits2 -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits2 = 0;
              break;
            case FLAGS:
              while (bits2 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits2 = 0;
              state.mode = TIME;
            case TIME:
              while (bits2 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits2 = 0;
              state.mode = OS;
            case OS:
              while (bits2 < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits2 = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits2 < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits2 = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy2 = state.length;
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next2,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        next2 + copy2
                      ),
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy2, next2);
                  }
                  have -= copy2;
                  next2 += copy2;
                  state.length -= copy2;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next2 + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy2, next2);
                }
                have -= copy2;
                next2 += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT2;
            case COMMENT2:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy2 = 0;
                do {
                  len = input[next2 + copy2++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy2 < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy2, next2);
                }
                have -= copy2;
                next2 += copy2;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits2 < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits2 = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits2 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits2 = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits2;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits2 & 7;
                bits2 -= bits2 & 7;
                state.mode = CHECK;
                break;
              }
              while (bits2 < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits2 -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits2 -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits2 -= 2;
              break;
            case STORED:
              hold >>>= bits2 & 7;
              bits2 -= bits2 & 7;
              while (bits2 < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits2 = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy2 = state.length;
              if (copy2) {
                if (copy2 > have) {
                  copy2 = have;
                }
                if (copy2 > left) {
                  copy2 = left;
                }
                if (copy2 === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next2, next2 + copy2), put);
                have -= copy2;
                next2 += copy2;
                left -= copy2;
                put += copy2;
                state.length -= copy2;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits2 < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits2 -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits2 -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits2 -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits2 < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits2 -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits2) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits2 -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits2 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits2;
                      bits2 += 8;
                    }
                    hold >>>= here_bits;
                    bits2 -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy2 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits2 -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits2 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits2;
                      bits2 += 8;
                    }
                    hold >>>= here_bits;
                    bits2 -= here_bits;
                    len = 0;
                    copy2 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits2 -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits2 < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits2;
                      bits2 += 8;
                    }
                    hold >>>= here_bits;
                    bits2 -= here_bits;
                    len = 0;
                    copy2 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits2 -= 7;
                  }
                  if (state.have + copy2 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy2--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits2;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next2 = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits2 = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits2) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits2) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                hold >>>= last_bits;
                bits2 -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits2 -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits2) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits2;
                bits2 += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits2) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                hold >>>= last_bits;
                bits2 -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits2 -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits2 < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits2 -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy2 = _out - left;
              if (state.offset > copy2) {
                copy2 = state.offset - copy2;
                if (copy2 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy2 > state.wnext) {
                  copy2 -= state.wnext;
                  from2 = state.wsize - copy2;
                } else {
                  from2 = state.wnext - copy2;
                }
                if (copy2 > state.length) {
                  copy2 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from2 = put - state.offset;
                copy2 = state.length;
              }
              if (copy2 > left) {
                copy2 = left;
              }
              left -= copy2;
              state.length -= copy2;
              do {
                output[put++] = from_source[from2++];
              } while (--copy2);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits2 < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next2++] << bits2;
                  bits2 += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits2 = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits2 < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits2;
                  bits2 += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits2 = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next2;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits2;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head2) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head2;
      head2.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var zlib_inflate = require_inflate();
    var utils2 = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString3 = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants();
    function Inflate(options) {
      this.options = utils2.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended) return false;
      if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
      else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString3.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0) continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0) break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils2.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err) throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/@zk-email/helpers/dist/constants.js
var require_constants2 = __commonJS({
  "node_modules/@zk-email/helpers/dist/constants.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CIRCOM_LEVELS = exports.CIRCOM_BIGINT_K = exports.CIRCOM_BIGINT_N = exports.MAX_BODY_PADDED_BYTES = exports.MAX_HEADER_PADDED_BYTES = exports.CIRCOM_FIELD_MODULUS = void 0;
    exports.CIRCOM_FIELD_MODULUS = 21888242871839275222246405745257275088548364400416034343698204186575808495617n;
    exports.MAX_HEADER_PADDED_BYTES = 1024;
    exports.MAX_BODY_PADDED_BYTES = 1536;
    exports.CIRCOM_BIGINT_N = 121;
    exports.CIRCOM_BIGINT_K = 17;
    exports.CIRCOM_LEVELS = 30;
  }
});

// node_modules/@zk-email/helpers/dist/binary-format.js
var require_binary_format = __commonJS({
  "node_modules/@zk-email/helpers/dist/binary-format.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.packBytesIntoNBytes = exports.packedNBytesToString = exports.assert = exports.mergeUInt8Arrays = exports.uint8ToBits = exports.bitsToUint8 = exports.int8toBytes = exports.int64toBytes = exports.fromHex = exports.toHex = exports.toCircomBigIntBytes = exports.bigIntToChunkedBytes = exports.bytesToBigInt = exports.bufferToString = exports.Uint8ArrayToHex = exports.Uint8ArrayToString = exports.Uint8ArrayToCharArray = exports.bufferToHex = exports.bufferToUint8Array = exports.stringToBytes = exports.bytesToString = void 0;
    var constants_1 = require_constants2();
    function bytesToString(bytes) {
      return new TextDecoder().decode(bytes);
    }
    exports.bytesToString = bytesToString;
    function stringToBytes(str) {
      const toReturn = Uint8Array.from(str, (x2) => x2.charCodeAt(0));
      return toReturn;
    }
    exports.stringToBytes = stringToBytes;
    function bufferToUint8Array(buf) {
      const ab = new ArrayBuffer(buf.length);
      const view = new Uint8Array(ab);
      for (let i2 = 0; i2 < buf.length; ++i2) {
        view[i2] = buf[i2];
      }
      return Uint8Array.from(view);
    }
    exports.bufferToUint8Array = bufferToUint8Array;
    function bufferToHex(buf) {
      return buf.toString("hex");
    }
    exports.bufferToHex = bufferToHex;
    function Uint8ArrayToCharArray(a2) {
      return Array.from(a2).map((x2) => x2.toString());
    }
    exports.Uint8ArrayToCharArray = Uint8ArrayToCharArray;
    async function Uint8ArrayToString(a2) {
      return Array.from(a2).map((x2) => x2.toString()).join(";");
    }
    exports.Uint8ArrayToString = Uint8ArrayToString;
    async function Uint8ArrayToHex(a2) {
      return Buffer.from(a2).toString("hex");
    }
    exports.Uint8ArrayToHex = Uint8ArrayToHex;
    function bufferToString(buf) {
      const intermediate = bufferToUint8Array(buf);
      return bytesToString(intermediate);
    }
    exports.bufferToString = bufferToString;
    function bytesToBigInt(bytes) {
      let res = 0n;
      for (let i2 = 0; i2 < bytes.length; ++i2) {
        res = (res << 8n) + BigInt(bytes[i2]);
      }
      return res;
    }
    exports.bytesToBigInt = bytesToBigInt;
    function bigIntToChunkedBytes(num, bytesPerChunk, numChunks) {
      const res = [];
      const bigintNum = typeof num === "bigint" ? num : num.valueOf();
      const msk = (1n << BigInt(bytesPerChunk)) - 1n;
      for (let i2 = 0; i2 < numChunks; ++i2) {
        res.push((bigintNum >> BigInt(i2 * bytesPerChunk) & msk).toString());
      }
      return res;
    }
    exports.bigIntToChunkedBytes = bigIntToChunkedBytes;
    function toCircomBigIntBytes(num) {
      return bigIntToChunkedBytes(num, constants_1.CIRCOM_BIGINT_N, constants_1.CIRCOM_BIGINT_K);
    }
    exports.toCircomBigIntBytes = toCircomBigIntBytes;
    var HEX_STRINGS = "0123456789abcdef";
    var MAP_HEX = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15
    };
    function toHex(bytes) {
      return Array.from(bytes || []).map((b2) => HEX_STRINGS[b2 >> 4] + HEX_STRINGS[b2 & 15]).join("");
    }
    exports.toHex = toHex;
    function fromHex(hexString) {
      let hexStringTrimmed = hexString;
      if (hexString[0] === "0" && hexString[1] === "x") {
        hexStringTrimmed = hexString.slice(2);
      }
      const bytes = new Uint8Array(Math.floor((hexStringTrimmed || "").length / 2));
      let i2;
      for (i2 = 0; i2 < bytes.length; i2++) {
        const a2 = MAP_HEX[hexStringTrimmed[i2 * 2]];
        const b2 = MAP_HEX[hexStringTrimmed[i2 * 2 + 1]];
        if (a2 === void 0 || b2 === void 0) {
          break;
        }
        bytes[i2] = a2 << 4 | b2;
      }
      return i2 === bytes.length ? bytes : bytes.slice(0, i2);
    }
    exports.fromHex = fromHex;
    function int64toBytes(num) {
      const arr = new ArrayBuffer(8);
      const view = new DataView(arr);
      view.setInt32(4, num, false);
      return new Uint8Array(arr);
    }
    exports.int64toBytes = int64toBytes;
    function int8toBytes(num) {
      const arr = new ArrayBuffer(1);
      const view = new DataView(arr);
      view.setUint8(0, num);
      return new Uint8Array(arr);
    }
    exports.int8toBytes = int8toBytes;
    function bitsToUint8(bits2) {
      const bytes = new Uint8Array(bits2.length);
      for (let i2 = 0; i2 < bits2.length; i2 += 1) {
        bytes[i2] = parseInt(bits2[i2], 2);
      }
      return bytes;
    }
    exports.bitsToUint8 = bitsToUint8;
    function uint8ToBits(uint8) {
      return uint8.reduce((acc, byte) => acc + byte.toString(2).padStart(8, "0"), "");
    }
    exports.uint8ToBits = uint8ToBits;
    function mergeUInt8Arrays(a1, a2) {
      const mergedArray = new Uint8Array(a1.length + a2.length);
      mergedArray.set(a1);
      mergedArray.set(a2, a1.length);
      return mergedArray;
    }
    exports.mergeUInt8Arrays = mergeUInt8Arrays;
    function assert2(cond, errorMessage) {
      if (!cond) {
        throw new Error(errorMessage);
      }
    }
    exports.assert = assert2;
    function packedNBytesToString(packedBytes, n = 31) {
      const chars = [];
      for (let i2 = 0; i2 < packedBytes.length; i2++) {
        for (let k2 = 0n; k2 < n; k2++) {
          chars.push(Number((packedBytes[i2] >> k2 * 8n) % 256n));
        }
      }
      return bytesToString(Uint8Array.from(chars));
    }
    exports.packedNBytesToString = packedNBytesToString;
    function packBytesIntoNBytes(messagePaddedRaw, n = 7) {
      const messagePadded = typeof messagePaddedRaw === "string" ? stringToBytes(messagePaddedRaw) : messagePaddedRaw;
      const output = [];
      for (let i2 = 0; i2 < messagePadded.length; i2++) {
        if (i2 % n === 0) {
          output.push(0n);
        }
        const j2 = i2 / n | 0;
        console.assert(j2 === output.length - 1, "Not editing the index of the last element -- packing loop invariants bug!");
        output[j2] += BigInt(messagePadded[i2]) << BigInt(i2 % n * 8);
      }
      return output;
    }
    exports.packBytesIntoNBytes = packBytesIntoNBytes;
  }
});

// node_modules/@zk-email/helpers/dist/lib/fast-sha256.js
var require_fast_sha256 = __commonJS({
  "node_modules/@zk-email/helpers/dist/lib/fast-sha256.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = exports.hkdf = exports.hmac = exports.hash = exports.HMAC = exports.Hash = exports.blockSize = exports.digestLength = void 0;
    exports.digestLength = 32;
    exports.blockSize = 64;
    var K2 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w2, v2, p2, pos, len) {
      let a2, b2, c2, d, e2, f2, g2, h, u2, i2, j2, t1, t2;
      while (len >= 64) {
        a2 = v2[0];
        b2 = v2[1];
        c2 = v2[2];
        d = v2[3];
        e2 = v2[4];
        f2 = v2[5];
        g2 = v2[6];
        h = v2[7];
        for (i2 = 0; i2 < 16; i2++) {
          j2 = pos + i2 * 4;
          w2[i2] = (p2[j2] & 255) << 24 | (p2[j2 + 1] & 255) << 16 | (p2[j2 + 2] & 255) << 8 | p2[j2 + 3] & 255;
        }
        for (i2 = 16; i2 < 64; i2++) {
          u2 = w2[i2 - 2];
          t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
          u2 = w2[i2 - 15];
          t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
          w2[i2] = (t1 + w2[i2 - 7] | 0) + (t2 + w2[i2 - 16] | 0);
        }
        for (i2 = 0; i2 < 64; i2++) {
          t1 = (((e2 >>> 6 | e2 << 32 - 6) ^ (e2 >>> 11 | e2 << 32 - 11) ^ (e2 >>> 25 | e2 << 32 - 25)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h + (K2[i2] + w2[i2] | 0) | 0) | 0;
          t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
          h = g2;
          g2 = f2;
          f2 = e2;
          e2 = d + t1 | 0;
          d = c2;
          c2 = b2;
          b2 = a2;
          a2 = t1 + t2 | 0;
        }
        v2[0] += a2;
        v2[1] += b2;
        v2[2] += c2;
        v2[3] += d;
        v2[4] += e2;
        v2[5] += f2;
        v2[6] += g2;
        v2[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    var Hash = class {
      constructor() {
        this.digestLength = exports.digestLength;
        this.blockSize = exports.blockSize;
        this.state = new Int32Array(8);
        this.temp = new Int32Array(64);
        this.buffer = new Uint8Array(128);
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        this.reset();
      }
      // Resets hash state making it possible
      // to re-use this instance to hash other data.
      reset() {
        this.state[0] = 1779033703;
        this.state[1] = 3144134277;
        this.state[2] = 1013904242;
        this.state[3] = 2773480762;
        this.state[4] = 1359893119;
        this.state[5] = 2600822924;
        this.state[6] = 528734635;
        this.state[7] = 1541459225;
        this.bufferLength = 0;
        this.bytesHashed = 0;
        this.finished = false;
        return this;
      }
      // Cleans internal buffers and re-initializes hash state.
      clean() {
        for (let i2 = 0; i2 < this.buffer.length; i2++) {
          this.buffer[i2] = 0;
        }
        for (let i2 = 0; i2 < this.temp.length; i2++) {
          this.temp[i2] = 0;
        }
        this.reset();
      }
      // Updates hash state with the given data.
      //
      // Optionally, length of the data can be specified to hash
      // fewer bytes than data.length.
      //
      // Throws error when trying to update already finalized hash:
      // instance must be reset to use it again.
      update(data, dataLength = data.length) {
        if (this.finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        let dataPos = 0;
        this.bytesHashed += dataLength;
        if (this.bufferLength > 0) {
          while (this.bufferLength < 64 && dataLength > 0) {
            this.buffer[this.bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this.bufferLength === 64) {
            hashBlocks(this.temp, this.state, this.buffer, 0, 64);
            this.bufferLength = 0;
          }
        }
        if (dataLength >= 64) {
          dataPos = hashBlocks(this.temp, this.state, data, dataPos, dataLength);
          dataLength %= 64;
        }
        while (dataLength > 0) {
          this.buffer[this.bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      }
      // Finalizes hash state and puts hash into out.
      //
      // If hash was already finalized, puts the same value.
      finish(out) {
        if (!this.finished) {
          const bytesHashed = this.bytesHashed;
          const left = this.bufferLength;
          const bitLenHi = bytesHashed / 536870912 | 0;
          const bitLenLo = bytesHashed << 3;
          const padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this.buffer[left] = 128;
          for (let i2 = left + 1; i2 < padLength - 8; i2++) {
            this.buffer[i2] = 0;
          }
          this.buffer[padLength - 8] = bitLenHi >>> 24 & 255;
          this.buffer[padLength - 7] = bitLenHi >>> 16 & 255;
          this.buffer[padLength - 6] = bitLenHi >>> 8 & 255;
          this.buffer[padLength - 5] = bitLenHi >>> 0 & 255;
          this.buffer[padLength - 4] = bitLenLo >>> 24 & 255;
          this.buffer[padLength - 3] = bitLenLo >>> 16 & 255;
          this.buffer[padLength - 2] = bitLenLo >>> 8 & 255;
          this.buffer[padLength - 1] = bitLenLo >>> 0 & 255;
          hashBlocks(this.temp, this.state, this.buffer, 0, padLength);
          this.finished = true;
        }
        for (let i2 = 0; i2 < 8; i2++) {
          out[i2 * 4 + 0] = this.state[i2] >>> 24 & 255;
          out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
          out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
          out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
        }
        return this;
      }
      // Returns the final hash digest.
      digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      }
      // Returns the current hash state.
      cacheState() {
        const out32 = new Uint32Array(this.state.length);
        this._saveState(out32);
        const out = new Uint8Array(this.state.length * 4);
        for (let i2 = 0; i2 < 8; i2++) {
          out[i2 * 4 + 0] = this.state[i2] >>> 24 & 255;
          out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
          out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
          out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
        }
        return out;
      }
      // Internal function for use in HMAC for optimization.
      _saveState(out) {
        for (let i2 = 0; i2 < this.state.length; i2++) {
          out[i2] = this.state[i2];
        }
      }
      // Internal function for use in HMAC for optimization.
      _restoreState(from2, bytesHashed) {
        for (let i2 = 0; i2 < this.state.length; i2++) {
          this.state[i2] = from2[i2];
        }
        this.bytesHashed = bytesHashed;
        this.finished = false;
        this.bufferLength = 0;
      }
    };
    exports.Hash = Hash;
    var HMAC = class {
      constructor(key) {
        this.inner = new Hash();
        this.outer = new Hash();
        this.blockSize = this.inner.blockSize;
        this.digestLength = this.inner.digestLength;
        const pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          new Hash().update(key).finish(pad).clean();
        } else {
          for (let i2 = 0; i2 < key.length; i2++) {
            pad[i2] = key[i2];
          }
        }
        for (let i2 = 0; i2 < pad.length; i2++) {
          pad[i2] ^= 54;
        }
        this.inner.update(pad);
        for (let i2 = 0; i2 < pad.length; i2++) {
          pad[i2] ^= 54 ^ 92;
        }
        this.outer.update(pad);
        this.istate = new Uint32Array(8);
        this.ostate = new Uint32Array(8);
        this.inner._saveState(this.istate);
        this.outer._saveState(this.ostate);
        for (let i2 = 0; i2 < pad.length; i2++) {
          pad[i2] = 0;
        }
      }
      // Returns HMAC state to the state initialized with key
      // to make it possible to run HMAC over the other data with the same
      // key without creating a new instance.
      reset() {
        this.inner._restoreState(this.istate, this.inner.blockSize);
        this.outer._restoreState(this.ostate, this.outer.blockSize);
        return this;
      }
      // Cleans HMAC state.
      clean() {
        for (let i2 = 0; i2 < this.istate.length; i2++) {
          this.ostate[i2] = this.istate[i2] = 0;
        }
        this.inner.clean();
        this.outer.clean();
      }
      // Updates state with provided data.
      update(data) {
        this.inner.update(data);
        return this;
      }
      // Finalizes HMAC and puts the result in out.
      finish(out) {
        if (this.outer.finished) {
          this.outer.finish(out);
        } else {
          this.inner.finish(out);
          this.outer.update(out, this.digestLength).finish(out);
        }
        return this;
      }
      // Returns message authentication code.
      digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      }
    };
    exports.HMAC = HMAC;
    function hash2(data) {
      const h = new Hash().update(data);
      const digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hash = hash2;
    exports.default = hash2;
    function hmac(key, data) {
      const h = new HMAC(key).update(data);
      const digest = h.digest();
      h.clean();
      return digest;
    }
    exports.hmac = hmac;
    function fillBuffer(buffer, hmac2, info, counter) {
      const num = counter[0];
      if (num === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      hmac2.reset();
      if (num > 1) {
        hmac2.update(buffer);
      }
      if (info) {
        hmac2.update(info);
      }
      hmac2.update(counter);
      hmac2.finish(buffer);
      counter[0]++;
    }
    var hkdfSalt = new Uint8Array(exports.digestLength);
    function hkdf(key, salt = hkdfSalt, info, length2 = 32) {
      const counter = new Uint8Array([1]);
      const okm = hmac(salt, key);
      const hmac_ = new HMAC(okm);
      const buffer = new Uint8Array(hmac_.digestLength);
      let bufpos = buffer.length;
      const out = new Uint8Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        if (bufpos === buffer.length) {
          fillBuffer(buffer, hmac_, info, counter);
          bufpos = 0;
        }
        out[i2] = buffer[bufpos++];
      }
      hmac_.clean();
      buffer.fill(0);
      counter.fill(0);
      return out;
    }
    exports.hkdf = hkdf;
    function pbkdf2(password, salt, iterations, dkLen) {
      const prf = new HMAC(password);
      const len = prf.digestLength;
      const ctr = new Uint8Array(4);
      const t = new Uint8Array(len);
      const u2 = new Uint8Array(len);
      const dk = new Uint8Array(dkLen);
      for (let i2 = 0; i2 * len < dkLen; i2++) {
        let c2 = i2 + 1;
        ctr[0] = c2 >>> 24 & 255;
        ctr[1] = c2 >>> 16 & 255;
        ctr[2] = c2 >>> 8 & 255;
        ctr[3] = c2 >>> 0 & 255;
        prf.reset();
        prf.update(salt);
        prf.update(ctr);
        prf.finish(u2);
        for (let j2 = 0; j2 < len; j2++) {
          t[j2] = u2[j2];
        }
        for (let j2 = 2; j2 <= iterations; j2++) {
          prf.reset();
          prf.update(u2).finish(u2);
          for (let k2 = 0; k2 < len; k2++) {
            t[k2] ^= u2[k2];
          }
        }
        for (let j2 = 0; j2 < len && i2 * len + j2 < dkLen; j2++) {
          dk[i2 * len + j2] = t[j2];
        }
      }
      for (let i2 = 0; i2 < len; i2++) {
        t[i2] = u2[i2] = 0;
      }
      for (let i2 = 0; i2 < 4; i2++) {
        ctr[i2] = 0;
      }
      prf.clean();
      return dk;
    }
    exports.pbkdf2 = pbkdf2;
  }
});

// node_modules/@zk-email/helpers/dist/sha-utils.js
var require_sha_utils = __commonJS({
  "node_modules/@zk-email/helpers/dist/sha-utils.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k2 in mod2) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k2)) __createBinding(result, mod2, k2);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha256Pad = exports.partialSha = exports.shaHash = exports.generatePartialSHA = exports.padUint8ArrayWithZeros = exports.findIndexInUint8Array = void 0;
    var CryptoJS = __importStar(require_crypto_browserify());
    var binary_format_1 = require_binary_format();
    var fast_sha256_1 = require_fast_sha256();
    function findIndexInUint8Array(array, selector) {
      let i2 = 0;
      let j2 = 0;
      while (i2 < array.length) {
        if (array[i2] === selector[j2]) {
          j2++;
          if (j2 === selector.length) {
            return i2 - j2 + 1;
          }
        } else {
          j2 = 0;
        }
        i2++;
      }
      return -1;
    }
    exports.findIndexInUint8Array = findIndexInUint8Array;
    function padUint8ArrayWithZeros(array, length2) {
      while (array.length < length2) {
        array = (0, binary_format_1.mergeUInt8Arrays)(array, (0, binary_format_1.int8toBytes)(0));
      }
      return array;
    }
    exports.padUint8ArrayWithZeros = padUint8ArrayWithZeros;
    function generatePartialSHA({
      body,
      bodyLength,
      selectorString,
      // String to split the body
      maxRemainingBodyLength
      // Maximum allowed length of the body after the selector
    }) {
      let selectorIndex = 0;
      if (selectorString) {
        const selector = new TextEncoder().encode(selectorString);
        selectorIndex = findIndexInUint8Array(body, selector);
        if (selectorIndex === -1) {
          throw new Error(`SHA precompute selector "${selectorString}" not found in the body`);
        }
      }
      const shaCutoffIndex = Math.floor(selectorIndex / 64) * 64;
      const precomputeText = body.slice(0, shaCutoffIndex);
      let bodyRemaining = body.slice(shaCutoffIndex);
      const bodyRemainingLength = bodyLength - precomputeText.length;
      if (bodyRemainingLength > maxRemainingBodyLength) {
        throw new Error(`Remaining body ${bodyRemainingLength} after the selector is longer than max (${maxRemainingBodyLength})`);
      }
      if (bodyRemaining.length % 64 !== 0) {
        throw new Error("Remaining body was not padded correctly with int64s");
      }
      bodyRemaining = padUint8ArrayWithZeros(bodyRemaining, maxRemainingBodyLength);
      const precomputedSha = partialSha(precomputeText, shaCutoffIndex);
      return {
        precomputedSha,
        bodyRemaining,
        bodyRemainingLength
      };
    }
    exports.generatePartialSHA = generatePartialSHA;
    function shaHash(str) {
      return CryptoJS.createHash("sha256").update(str).digest();
    }
    exports.shaHash = shaHash;
    function partialSha(msg, msgLen) {
      const shaGadget = new fast_sha256_1.Hash();
      return shaGadget.update(msg, msgLen).cacheState();
    }
    exports.partialSha = partialSha;
    function sha256Pad(message, maxShaBytes) {
      const msgLen = message.length * 8;
      const msgLenBytes = (0, binary_format_1.int64toBytes)(msgLen);
      let res = (0, binary_format_1.mergeUInt8Arrays)(message, (0, binary_format_1.int8toBytes)(2 ** 7));
      while ((res.length * 8 + msgLenBytes.length * 8) % 512 !== 0) {
        res = (0, binary_format_1.mergeUInt8Arrays)(res, (0, binary_format_1.int8toBytes)(0));
      }
      res = (0, binary_format_1.mergeUInt8Arrays)(res, msgLenBytes);
      (0, binary_format_1.assert)(res.length * 8 % 512 === 0, "Padding did not complete properly!");
      const messageLen = res.length;
      while (res.length < maxShaBytes) {
        res = (0, binary_format_1.mergeUInt8Arrays)(res, (0, binary_format_1.int64toBytes)(0));
      }
      (0, binary_format_1.assert)(res.length === maxShaBytes, `Padding to max length did not complete properly! Your padded message is ${res.length} long but max is ${maxShaBytes}!`);
      return [res, messageLen];
    }
    exports.sha256Pad = sha256Pad;
  }
});

// node_modules/@pcd/pcd-types/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/@pcd/pcd-types/dist/index.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var src_exports = {};
    __export2(src_exports, {
      ArgumentTypeName: () => ArgumentTypeName,
      isBigIntArgument: () => isBigIntArgument,
      isBooleanArgument: () => isBooleanArgument,
      isNumberArgument: () => isNumberArgument,
      isObjectArgument: () => isObjectArgument,
      isPCDArgument: () => isPCDArgument,
      isRevealListArgument: () => isRevealListArgument,
      isStringArgument: () => isStringArgument,
      isStringArrayArgument: () => isStringArrayArgument,
      isToggleListArgument: () => isToggleListArgument
    });
    module.exports = __toCommonJS2(src_exports);
    var ArgumentTypeName = ((ArgumentTypeName2) => {
      ArgumentTypeName2["String"] = "String";
      ArgumentTypeName2["Number"] = "Number";
      ArgumentTypeName2["BigInt"] = "BigInt";
      ArgumentTypeName2["Boolean"] = "Boolean";
      ArgumentTypeName2["Object"] = "Object";
      ArgumentTypeName2["StringArray"] = "StringArray";
      ArgumentTypeName2["PCD"] = "PCD";
      ArgumentTypeName2["ToggleList"] = "ToggleList";
      ArgumentTypeName2["Unknown"] = "Unknown";
      return ArgumentTypeName2;
    })(ArgumentTypeName || {});
    function isStringArgument(arg) {
      return arg.argumentType === "String";
    }
    function isNumberArgument(arg) {
      return arg.argumentType === "Number";
    }
    function isBigIntArgument(arg) {
      return arg.argumentType === "BigInt";
    }
    function isBooleanArgument(arg) {
      return arg.argumentType === "Boolean";
    }
    function isObjectArgument(arg) {
      return arg.argumentType === "Object";
    }
    function isStringArrayArgument(arg) {
      return arg.argumentType === "StringArray";
    }
    function isPCDArgument(arg) {
      return arg.argumentType === "PCD";
    }
    function isToggleListArgument(arg) {
      return arg.argumentType === "ToggleList" && arg.value !== void 0 && arg.value !== null && typeof arg.value === "object" && Object.values(arg.value).every((v2) => typeof v2 === "boolean");
    }
    function isRevealListArgument(arg) {
      return arg.value !== void 0 && Object.keys(arg.value).every((k2) => k2.startsWith("reveal"));
    }
  }
});

// node_modules/@anon-aadhaar/core/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/@anon-aadhaar/core/dist/index.js"(exports, module) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __commonJS2 = (cb, mod2) => function __require2() {
      return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
    };
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var require_forge2 = __commonJS2({
      "../../node_modules/node-forge/lib/forge.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          // default options
          options: {
            usePureJavaScript: false
          }
        };
      }
    });
    var require_baseN2 = __commonJS2({
      "../../node_modules/node-forge/lib/baseN.js"(exports2, module2) {
        "use strict";
        var api = {};
        module2.exports = api;
        var _reverseAlphabets = {};
        api.encode = function(input, alphabet2, maxline) {
          if (typeof alphabet2 !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          if (maxline !== void 0 && typeof maxline !== "number") {
            throw new TypeError('"maxline" must be a number.');
          }
          var output = "";
          if (!(input instanceof Uint8Array)) {
            output = _encodeWithByteBuffer(input, alphabet2);
          } else {
            var i2 = 0;
            var base = alphabet2.length;
            var first = alphabet2.charAt(0);
            var digits = [0];
            for (i2 = 0; i2 < input.length; ++i2) {
              for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
                carry += digits[j2] << 8;
                digits[j2] = carry % base;
                carry = carry / base | 0;
              }
              while (carry > 0) {
                digits.push(carry % base);
                carry = carry / base | 0;
              }
            }
            for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
              output += first;
            }
            for (i2 = digits.length - 1; i2 >= 0; --i2) {
              output += alphabet2[digits[i2]];
            }
          }
          if (maxline) {
            var regex = new RegExp(".{1," + maxline + "}", "g");
            output = output.match(regex).join("\r\n");
          }
          return output;
        };
        api.decode = function(input, alphabet2) {
          if (typeof input !== "string") {
            throw new TypeError('"input" must be a string.');
          }
          if (typeof alphabet2 !== "string") {
            throw new TypeError('"alphabet" must be a string.');
          }
          var table = _reverseAlphabets[alphabet2];
          if (!table) {
            table = _reverseAlphabets[alphabet2] = [];
            for (var i2 = 0; i2 < alphabet2.length; ++i2) {
              table[alphabet2.charCodeAt(i2)] = i2;
            }
          }
          input = input.replace(/\s/g, "");
          var base = alphabet2.length;
          var first = alphabet2.charAt(0);
          var bytes = [0];
          for (var i2 = 0; i2 < input.length; i2++) {
            var value = table[input.charCodeAt(i2)];
            if (value === void 0) {
              return;
            }
            for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
              carry += bytes[j2] * base;
              bytes[j2] = carry & 255;
              carry >>= 8;
            }
            while (carry > 0) {
              bytes.push(carry & 255);
              carry >>= 8;
            }
          }
          for (var k2 = 0; input[k2] === first && k2 < input.length - 1; ++k2) {
            bytes.push(0);
          }
          if (typeof Buffer !== "undefined") {
            return Buffer.from(bytes.reverse());
          }
          return new Uint8Array(bytes.reverse());
        };
        function _encodeWithByteBuffer(input, alphabet2) {
          var i2 = 0;
          var base = alphabet2.length;
          var first = alphabet2.charAt(0);
          var digits = [0];
          for (i2 = 0; i2 < input.length(); ++i2) {
            for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
              carry += digits[j2] << 8;
              digits[j2] = carry % base;
              carry = carry / base | 0;
            }
            while (carry > 0) {
              digits.push(carry % base);
              carry = carry / base | 0;
            }
          }
          var output = "";
          for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
            output += first;
          }
          for (i2 = digits.length - 1; i2 >= 0; --i2) {
            output += alphabet2[digits[i2]];
          }
          return output;
        }
      }
    });
    var require_util2 = __commonJS2({
      "../../node_modules/node-forge/lib/util.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        var baseN = require_baseN2();
        var util = module2.exports = forge.util = forge.util || {};
        (function() {
          if (typeof process !== "undefined" && process.nextTick && !process.browser) {
            util.nextTick = process.nextTick;
            if (typeof setImmediate === "function") {
              util.setImmediate = setImmediate;
            } else {
              util.setImmediate = util.nextTick;
            }
            return;
          }
          if (typeof setImmediate === "function") {
            util.setImmediate = function() {
              return setImmediate.apply(void 0, arguments);
            };
            util.nextTick = function(callback) {
              return setImmediate(callback);
            };
            return;
          }
          util.setImmediate = function(callback) {
            setTimeout(callback, 0);
          };
          if (typeof window !== "undefined" && typeof window.postMessage === "function") {
            let handler2 = function(event) {
              if (event.source === window && event.data === msg) {
                event.stopPropagation();
                var copy2 = callbacks.slice();
                callbacks.length = 0;
                copy2.forEach(function(callback) {
                  callback();
                });
              }
            };
            var handler = handler2;
            var msg = "forge.setImmediate";
            var callbacks = [];
            util.setImmediate = function(callback) {
              callbacks.push(callback);
              if (callbacks.length === 1) {
                window.postMessage(msg, "*");
              }
            };
            window.addEventListener("message", handler2, true);
          }
          if (typeof MutationObserver !== "undefined") {
            var now = Date.now();
            var attr = true;
            var div2 = document.createElement("div");
            var callbacks = [];
            new MutationObserver(function() {
              var copy2 = callbacks.slice();
              callbacks.length = 0;
              copy2.forEach(function(callback) {
                callback();
              });
            }).observe(div2, { attributes: true });
            var oldSetImmediate = util.setImmediate;
            util.setImmediate = function(callback) {
              if (Date.now() - now > 15) {
                now = Date.now();
                oldSetImmediate(callback);
              } else {
                callbacks.push(callback);
                if (callbacks.length === 1) {
                  div2.setAttribute("a", attr = !attr);
                }
              }
            };
          }
          util.nextTick = util.setImmediate;
        })();
        util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
        util.globalScope = function() {
          if (util.isNodejs) {
            return global;
          }
          return typeof self === "undefined" ? window : self;
        }();
        util.isArray = Array.isArray || function(x2) {
          return Object.prototype.toString.call(x2) === "[object Array]";
        };
        util.isArrayBuffer = function(x2) {
          return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
        };
        util.isArrayBufferView = function(x2) {
          return x2 && util.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
        };
        function _checkBitsParam(n) {
          if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
            throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
          }
        }
        util.ByteBuffer = ByteStringBuffer;
        function ByteStringBuffer(b2) {
          this.data = "";
          this.read = 0;
          if (typeof b2 === "string") {
            this.data = b2;
          } else if (util.isArrayBuffer(b2) || util.isArrayBufferView(b2)) {
            if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
              this.data = b2.toString("binary");
            } else {
              var arr = new Uint8Array(b2);
              try {
                this.data = String.fromCharCode.apply(null, arr);
              } catch (e2) {
                for (var i2 = 0; i2 < arr.length; ++i2) {
                  this.putByte(arr[i2]);
                }
              }
            }
          } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
            this.data = b2.data;
            this.read = b2.read;
          }
          this._constructedStringLength = 0;
        }
        util.ByteStringBuffer = ByteStringBuffer;
        var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
        util.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
          this._constructedStringLength += x2;
          if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
            this.data.substr(0, 1);
            this._constructedStringLength = 0;
          }
        };
        util.ByteStringBuffer.prototype.length = function() {
          return this.data.length - this.read;
        };
        util.ByteStringBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util.ByteStringBuffer.prototype.putByte = function(b2) {
          return this.putBytes(String.fromCharCode(b2));
        };
        util.ByteStringBuffer.prototype.fillWithByte = function(b2, n) {
          b2 = String.fromCharCode(b2);
          var d = this.data;
          while (n > 0) {
            if (n & 1) {
              d += b2;
            }
            n >>>= 1;
            if (n > 0) {
              b2 += b2;
            }
          }
          this.data = d;
          this._optimizeConstructedString(n);
          return this;
        };
        util.ByteStringBuffer.prototype.putBytes = function(bytes) {
          this.data += bytes;
          this._optimizeConstructedString(bytes.length);
          return this;
        };
        util.ByteStringBuffer.prototype.putString = function(str) {
          return this.putBytes(util.encodeUtf8(str));
        };
        util.ByteStringBuffer.prototype.putInt16 = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt24 = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt32 = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt16Le = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt24Le = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt32Le = function(i2) {
          return this.putBytes(
            String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
          );
        };
        util.ByteStringBuffer.prototype.putInt = function(i2, n) {
          _checkBitsParam(n);
          var bytes = "";
          do {
            n -= 8;
            bytes += String.fromCharCode(i2 >> n & 255);
          } while (n > 0);
          return this.putBytes(bytes);
        };
        util.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
          if (i2 < 0) {
            i2 += 2 << n - 1;
          }
          return this.putInt(i2, n);
        };
        util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
          return this.putBytes(buffer.getBytes());
        };
        util.ByteStringBuffer.prototype.getByte = function() {
          return this.data.charCodeAt(this.read++);
        };
        util.ByteStringBuffer.prototype.getInt16 = function() {
          var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
          this.read += 2;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt24 = function() {
          var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
          this.read += 3;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt32 = function() {
          var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
          this.read += 4;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt16Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
          this.read += 2;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt24Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
          this.read += 3;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt32Le = function() {
          var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
          this.read += 4;
          return rval;
        };
        util.ByteStringBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.charCodeAt(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util.ByteStringBuffer.prototype.getSignedInt = function(n) {
          var x2 = this.getInt(n);
          var max = 2 << n - 2;
          if (x2 >= max) {
            x2 -= max << 1;
          }
          return x2;
        };
        util.ByteStringBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util.ByteStringBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util.ByteStringBuffer.prototype.at = function(i2) {
          return this.data.charCodeAt(this.read + i2);
        };
        util.ByteStringBuffer.prototype.setAt = function(i2, b2) {
          this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
          return this;
        };
        util.ByteStringBuffer.prototype.last = function() {
          return this.data.charCodeAt(this.data.length - 1);
        };
        util.ByteStringBuffer.prototype.copy = function() {
          var c2 = util.createBuffer(this.data);
          c2.read = this.read;
          return c2;
        };
        util.ByteStringBuffer.prototype.compact = function() {
          if (this.read > 0) {
            this.data = this.data.slice(this.read);
            this.read = 0;
          }
          return this;
        };
        util.ByteStringBuffer.prototype.clear = function() {
          this.data = "";
          this.read = 0;
          return this;
        };
        util.ByteStringBuffer.prototype.truncate = function(count) {
          var len = Math.max(0, this.length() - count);
          this.data = this.data.substr(this.read, len);
          this.read = 0;
          return this;
        };
        util.ByteStringBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i2 = this.read; i2 < this.data.length; ++i2) {
            var b2 = this.data.charCodeAt(i2);
            if (b2 < 16) {
              rval += "0";
            }
            rval += b2.toString(16);
          }
          return rval;
        };
        util.ByteStringBuffer.prototype.toString = function() {
          return util.decodeUtf8(this.bytes());
        };
        function DataBuffer(b2, options) {
          options = options || {};
          this.read = options.readOffset || 0;
          this.growSize = options.growSize || 1024;
          var isArrayBuffer = util.isArrayBuffer(b2);
          var isArrayBufferView = util.isArrayBufferView(b2);
          if (isArrayBuffer || isArrayBufferView) {
            if (isArrayBuffer) {
              this.data = new DataView(b2);
            } else {
              this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
            }
            this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
            return;
          }
          this.data = new DataView(new ArrayBuffer(0));
          this.write = 0;
          if (b2 !== null && b2 !== void 0) {
            this.putBytes(b2);
          }
          if ("writeOffset" in options) {
            this.write = options.writeOffset;
          }
        }
        util.DataBuffer = DataBuffer;
        util.DataBuffer.prototype.length = function() {
          return this.write - this.read;
        };
        util.DataBuffer.prototype.isEmpty = function() {
          return this.length() <= 0;
        };
        util.DataBuffer.prototype.accommodate = function(amount, growSize) {
          if (this.length() >= amount) {
            return this;
          }
          growSize = Math.max(growSize || this.growSize, amount);
          var src = new Uint8Array(
            this.data.buffer,
            this.data.byteOffset,
            this.data.byteLength
          );
          var dst = new Uint8Array(this.length() + growSize);
          dst.set(src);
          this.data = new DataView(dst.buffer);
          return this;
        };
        util.DataBuffer.prototype.putByte = function(b2) {
          this.accommodate(1);
          this.data.setUint8(this.write++, b2);
          return this;
        };
        util.DataBuffer.prototype.fillWithByte = function(b2, n) {
          this.accommodate(n);
          for (var i2 = 0; i2 < n; ++i2) {
            this.data.setUint8(b2);
          }
          return this;
        };
        util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
          if (util.isArrayBufferView(bytes)) {
            var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
            var len = src.byteLength - src.byteOffset;
            this.accommodate(len);
            var dst = new Uint8Array(this.data.buffer, this.write);
            dst.set(src);
            this.write += len;
            return this;
          }
          if (util.isArrayBuffer(bytes)) {
            var src = new Uint8Array(bytes);
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(this.data.buffer);
            dst.set(src, this.write);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
            var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
            this.accommodate(src.byteLength);
            var dst = new Uint8Array(bytes.data.byteLength, this.write);
            dst.set(src);
            this.write += src.byteLength;
            return this;
          }
          if (bytes instanceof util.ByteStringBuffer) {
            bytes = bytes.data;
            encoding = "binary";
          }
          encoding = encoding || "binary";
          if (typeof bytes === "string") {
            var view;
            if (encoding === "hex") {
              this.accommodate(Math.ceil(bytes.length / 2));
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util.binary.hex.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "base64") {
              this.accommodate(Math.ceil(bytes.length / 4) * 3);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util.binary.base64.decode(bytes, view, this.write);
              return this;
            }
            if (encoding === "utf8") {
              bytes = util.encodeUtf8(bytes);
              encoding = "binary";
            }
            if (encoding === "binary" || encoding === "raw") {
              this.accommodate(bytes.length);
              view = new Uint8Array(this.data.buffer, this.write);
              this.write += util.binary.raw.decode(view);
              return this;
            }
            if (encoding === "utf16") {
              this.accommodate(bytes.length * 2);
              view = new Uint16Array(this.data.buffer, this.write);
              this.write += util.text.utf16.encode(view);
              return this;
            }
            throw new Error("Invalid encoding: " + encoding);
          }
          throw Error("Invalid parameter: " + bytes);
        };
        util.DataBuffer.prototype.putBuffer = function(buffer) {
          this.putBytes(buffer);
          buffer.clear();
          return this;
        };
        util.DataBuffer.prototype.putString = function(str) {
          return this.putBytes(str, "utf16");
        };
        util.DataBuffer.prototype.putInt16 = function(i2) {
          this.accommodate(2);
          this.data.setInt16(this.write, i2);
          this.write += 2;
          return this;
        };
        util.DataBuffer.prototype.putInt24 = function(i2) {
          this.accommodate(3);
          this.data.setInt16(this.write, i2 >> 8 & 65535);
          this.data.setInt8(this.write, i2 >> 16 & 255);
          this.write += 3;
          return this;
        };
        util.DataBuffer.prototype.putInt32 = function(i2) {
          this.accommodate(4);
          this.data.setInt32(this.write, i2);
          this.write += 4;
          return this;
        };
        util.DataBuffer.prototype.putInt16Le = function(i2) {
          this.accommodate(2);
          this.data.setInt16(this.write, i2, true);
          this.write += 2;
          return this;
        };
        util.DataBuffer.prototype.putInt24Le = function(i2) {
          this.accommodate(3);
          this.data.setInt8(this.write, i2 >> 16 & 255);
          this.data.setInt16(this.write, i2 >> 8 & 65535, true);
          this.write += 3;
          return this;
        };
        util.DataBuffer.prototype.putInt32Le = function(i2) {
          this.accommodate(4);
          this.data.setInt32(this.write, i2, true);
          this.write += 4;
          return this;
        };
        util.DataBuffer.prototype.putInt = function(i2, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          do {
            n -= 8;
            this.data.setInt8(this.write++, i2 >> n & 255);
          } while (n > 0);
          return this;
        };
        util.DataBuffer.prototype.putSignedInt = function(i2, n) {
          _checkBitsParam(n);
          this.accommodate(n / 8);
          if (i2 < 0) {
            i2 += 2 << n - 1;
          }
          return this.putInt(i2, n);
        };
        util.DataBuffer.prototype.getByte = function() {
          return this.data.getInt8(this.read++);
        };
        util.DataBuffer.prototype.getInt16 = function() {
          var rval = this.data.getInt16(this.read);
          this.read += 2;
          return rval;
        };
        util.DataBuffer.prototype.getInt24 = function() {
          var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
          this.read += 3;
          return rval;
        };
        util.DataBuffer.prototype.getInt32 = function() {
          var rval = this.data.getInt32(this.read);
          this.read += 4;
          return rval;
        };
        util.DataBuffer.prototype.getInt16Le = function() {
          var rval = this.data.getInt16(this.read, true);
          this.read += 2;
          return rval;
        };
        util.DataBuffer.prototype.getInt24Le = function() {
          var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
          this.read += 3;
          return rval;
        };
        util.DataBuffer.prototype.getInt32Le = function() {
          var rval = this.data.getInt32(this.read, true);
          this.read += 4;
          return rval;
        };
        util.DataBuffer.prototype.getInt = function(n) {
          _checkBitsParam(n);
          var rval = 0;
          do {
            rval = (rval << 8) + this.data.getInt8(this.read++);
            n -= 8;
          } while (n > 0);
          return rval;
        };
        util.DataBuffer.prototype.getSignedInt = function(n) {
          var x2 = this.getInt(n);
          var max = 2 << n - 2;
          if (x2 >= max) {
            x2 -= max << 1;
          }
          return x2;
        };
        util.DataBuffer.prototype.getBytes = function(count) {
          var rval;
          if (count) {
            count = Math.min(this.length(), count);
            rval = this.data.slice(this.read, this.read + count);
            this.read += count;
          } else if (count === 0) {
            rval = "";
          } else {
            rval = this.read === 0 ? this.data : this.data.slice(this.read);
            this.clear();
          }
          return rval;
        };
        util.DataBuffer.prototype.bytes = function(count) {
          return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
        };
        util.DataBuffer.prototype.at = function(i2) {
          return this.data.getUint8(this.read + i2);
        };
        util.DataBuffer.prototype.setAt = function(i2, b2) {
          this.data.setUint8(i2, b2);
          return this;
        };
        util.DataBuffer.prototype.last = function() {
          return this.data.getUint8(this.write - 1);
        };
        util.DataBuffer.prototype.copy = function() {
          return new util.DataBuffer(this);
        };
        util.DataBuffer.prototype.compact = function() {
          if (this.read > 0) {
            var src = new Uint8Array(this.data.buffer, this.read);
            var dst = new Uint8Array(src.byteLength);
            dst.set(src);
            this.data = new DataView(dst);
            this.write -= this.read;
            this.read = 0;
          }
          return this;
        };
        util.DataBuffer.prototype.clear = function() {
          this.data = new DataView(new ArrayBuffer(0));
          this.read = this.write = 0;
          return this;
        };
        util.DataBuffer.prototype.truncate = function(count) {
          this.write = Math.max(0, this.length() - count);
          this.read = Math.min(this.read, this.write);
          return this;
        };
        util.DataBuffer.prototype.toHex = function() {
          var rval = "";
          for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
            var b2 = this.data.getUint8(i2);
            if (b2 < 16) {
              rval += "0";
            }
            rval += b2.toString(16);
          }
          return rval;
        };
        util.DataBuffer.prototype.toString = function(encoding) {
          var view = new Uint8Array(this.data, this.read, this.length());
          encoding = encoding || "utf8";
          if (encoding === "binary" || encoding === "raw") {
            return util.binary.raw.encode(view);
          }
          if (encoding === "hex") {
            return util.binary.hex.encode(view);
          }
          if (encoding === "base64") {
            return util.binary.base64.encode(view);
          }
          if (encoding === "utf8") {
            return util.text.utf8.decode(view);
          }
          if (encoding === "utf16") {
            return util.text.utf16.decode(view);
          }
          throw new Error("Invalid encoding: " + encoding);
        };
        util.createBuffer = function(input, encoding) {
          encoding = encoding || "raw";
          if (input !== void 0 && encoding === "utf8") {
            input = util.encodeUtf8(input);
          }
          return new util.ByteBuffer(input);
        };
        util.fillString = function(c2, n) {
          var s2 = "";
          while (n > 0) {
            if (n & 1) {
              s2 += c2;
            }
            n >>>= 1;
            if (n > 0) {
              c2 += c2;
            }
          }
          return s2;
        };
        util.xorBytes = function(s1, s2, n) {
          var s3 = "";
          var b2 = "";
          var t = "";
          var i2 = 0;
          var c2 = 0;
          for (; n > 0; --n, ++i2) {
            b2 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
            if (c2 >= 10) {
              s3 += t;
              t = "";
              c2 = 0;
            }
            t += String.fromCharCode(b2);
            ++c2;
          }
          s3 += t;
          return s3;
        };
        util.hexToBytes = function(hex2) {
          var rval = "";
          var i2 = 0;
          if (hex2.length & true) {
            i2 = 1;
            rval += String.fromCharCode(parseInt(hex2[0], 16));
          }
          for (; i2 < hex2.length; i2 += 2) {
            rval += String.fromCharCode(parseInt(hex2.substr(i2, 2), 16));
          }
          return rval;
        };
        util.bytesToHex = function(bytes) {
          return util.createBuffer(bytes).toHex();
        };
        util.int32ToBytes = function(i2) {
          return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
        };
        var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var _base64Idx = [
          /*43 -43 = 0*/
          /*'+',  1,  2,  3,'/' */
          62,
          -1,
          -1,
          -1,
          63,
          /*'0','1','2','3','4','5','6','7','8','9' */
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          /*15, 16, 17,'=', 19, 20, 21 */
          -1,
          -1,
          -1,
          64,
          -1,
          -1,
          -1,
          /*65 - 43 = 22*/
          /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          /*91 - 43 = 48 */
          /*48, 49, 50, 51, 52, 53 */
          -1,
          -1,
          -1,
          -1,
          -1,
          -1,
          /*97 - 43 = 54*/
          /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51
        ];
        var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        util.encode64 = function(input, maxline) {
          var line2 = "";
          var output = "";
          var chr1, chr2, chr3;
          var i2 = 0;
          while (i2 < input.length) {
            chr1 = input.charCodeAt(i2++);
            chr2 = input.charCodeAt(i2++);
            chr3 = input.charCodeAt(i2++);
            line2 += _base64.charAt(chr1 >> 2);
            line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line2 += "==";
            } else {
              line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line2.length > maxline) {
              output += line2.substr(0, maxline) + "\r\n";
              line2 = line2.substr(maxline);
            }
          }
          output += line2;
          return output;
        };
        util.decode64 = function(input) {
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          var output = "";
          var enc1, enc2, enc3, enc4;
          var i2 = 0;
          while (i2 < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
            output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
            if (enc3 !== 64) {
              output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
              if (enc4 !== 64) {
                output += String.fromCharCode((enc3 & 3) << 6 | enc4);
              }
            }
          }
          return output;
        };
        util.encodeUtf8 = function(str) {
          return unescape(encodeURIComponent(str));
        };
        util.decodeUtf8 = function(str) {
          return decodeURIComponent(escape(str));
        };
        util.binary = {
          raw: {},
          hex: {},
          base64: {},
          base58: {},
          baseN: {
            encode: baseN.encode,
            decode: baseN.decode
          }
        };
        util.binary.raw.encode = function(bytes) {
          return String.fromCharCode.apply(null, bytes);
        };
        util.binary.raw.decode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j2 = offset;
          for (var i2 = 0; i2 < str.length; ++i2) {
            out[j2++] = str.charCodeAt(i2);
          }
          return output ? j2 - offset : out;
        };
        util.binary.hex.encode = util.bytesToHex;
        util.binary.hex.decode = function(hex2, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(hex2.length / 2));
          }
          offset = offset || 0;
          var i2 = 0, j2 = offset;
          if (hex2.length & 1) {
            i2 = 1;
            out[j2++] = parseInt(hex2[0], 16);
          }
          for (; i2 < hex2.length; i2 += 2) {
            out[j2++] = parseInt(hex2.substr(i2, 2), 16);
          }
          return output ? j2 - offset : out;
        };
        util.binary.base64.encode = function(input, maxline) {
          var line2 = "";
          var output = "";
          var chr1, chr2, chr3;
          var i2 = 0;
          while (i2 < input.byteLength) {
            chr1 = input[i2++];
            chr2 = input[i2++];
            chr3 = input[i2++];
            line2 += _base64.charAt(chr1 >> 2);
            line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
            if (isNaN(chr2)) {
              line2 += "==";
            } else {
              line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
              line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
            }
            if (maxline && line2.length > maxline) {
              output += line2.substr(0, maxline) + "\r\n";
              line2 = line2.substr(maxline);
            }
          }
          output += line2;
          return output;
        };
        util.binary.base64.decode = function(input, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(Math.ceil(input.length / 4) * 3);
          }
          input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
          offset = offset || 0;
          var enc1, enc2, enc3, enc4;
          var i2 = 0, j2 = offset;
          while (i2 < input.length) {
            enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
            enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
            out[j2++] = enc1 << 2 | enc2 >> 4;
            if (enc3 !== 64) {
              out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
              if (enc4 !== 64) {
                out[j2++] = (enc3 & 3) << 6 | enc4;
              }
            }
          }
          return output ? j2 - offset : out.subarray(0, j2);
        };
        util.binary.base58.encode = function(input, maxline) {
          return util.binary.baseN.encode(input, _base58, maxline);
        };
        util.binary.base58.decode = function(input, maxline) {
          return util.binary.baseN.decode(input, _base58, maxline);
        };
        util.text = {
          utf8: {},
          utf16: {}
        };
        util.text.utf8.encode = function(str, output, offset) {
          str = util.encodeUtf8(str);
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length);
          }
          offset = offset || 0;
          var j2 = offset;
          for (var i2 = 0; i2 < str.length; ++i2) {
            out[j2++] = str.charCodeAt(i2);
          }
          return output ? j2 - offset : out;
        };
        util.text.utf8.decode = function(bytes) {
          return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
        };
        util.text.utf16.encode = function(str, output, offset) {
          var out = output;
          if (!out) {
            out = new Uint8Array(str.length * 2);
          }
          var view = new Uint16Array(out.buffer);
          offset = offset || 0;
          var j2 = offset;
          var k2 = offset;
          for (var i2 = 0; i2 < str.length; ++i2) {
            view[k2++] = str.charCodeAt(i2);
            j2 += 2;
          }
          return output ? j2 - offset : out;
        };
        util.text.utf16.decode = function(bytes) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        };
        util.deflate = function(api, bytes, raw) {
          bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
          if (raw) {
            var start = 2;
            var flg = bytes.charCodeAt(1);
            if (flg & 32) {
              start = 6;
            }
            bytes = bytes.substring(start, bytes.length - 4);
          }
          return bytes;
        };
        util.inflate = function(api, bytes, raw) {
          var rval = api.inflate(util.encode64(bytes)).rval;
          return rval === null ? null : util.decode64(rval);
        };
        var _setStorageObject = function(api, id, obj) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval;
          if (obj === null) {
            rval = api.removeItem(id);
          } else {
            obj = util.encode64(JSON.stringify(obj));
            rval = api.setItem(id, obj);
          }
          if (typeof rval !== "undefined" && rval.rval !== true) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
        };
        var _getStorageObject = function(api, id) {
          if (!api) {
            throw new Error("WebStorage not available.");
          }
          var rval = api.getItem(id);
          if (api.init) {
            if (rval.rval === null) {
              if (rval.error) {
                var error = new Error(rval.error.message);
                error.id = rval.error.id;
                error.name = rval.error.name;
                throw error;
              }
              rval = null;
            } else {
              rval = rval.rval;
            }
          }
          if (rval !== null) {
            rval = JSON.parse(util.decode64(rval));
          }
          return rval;
        };
        var _setItem = function(api, id, key, data) {
          var obj = _getStorageObject(api, id);
          if (obj === null) {
            obj = {};
          }
          obj[key] = data;
          _setStorageObject(api, id, obj);
        };
        var _getItem = function(api, id, key) {
          var rval = _getStorageObject(api, id);
          if (rval !== null) {
            rval = key in rval ? rval[key] : null;
          }
          return rval;
        };
        var _removeItem = function(api, id, key) {
          var obj = _getStorageObject(api, id);
          if (obj !== null && key in obj) {
            delete obj[key];
            var empty = true;
            for (var prop in obj) {
              empty = false;
              break;
            }
            if (empty) {
              obj = null;
            }
            _setStorageObject(api, id, obj);
          }
        };
        var _clearItems = function(api, id) {
          _setStorageObject(api, id, null);
        };
        var _callStorageFunction = function(func, args, location) {
          var rval = null;
          if (typeof location === "undefined") {
            location = ["web", "flash"];
          }
          var type;
          var done = false;
          var exception = null;
          for (var idx in location) {
            type = location[idx];
            try {
              if (type === "flash" || type === "both") {
                if (args[0] === null) {
                  throw new Error("Flash local storage not available.");
                }
                rval = func.apply(this, args);
                done = type === "flash";
              }
              if (type === "web" || type === "both") {
                args[0] = localStorage;
                rval = func.apply(this, args);
                done = true;
              }
            } catch (ex) {
              exception = ex;
            }
            if (done) {
              break;
            }
          }
          if (!done) {
            throw exception;
          }
          return rval;
        };
        util.setItem = function(api, id, key, data, location) {
          _callStorageFunction(_setItem, arguments, location);
        };
        util.getItem = function(api, id, key, location) {
          return _callStorageFunction(_getItem, arguments, location);
        };
        util.removeItem = function(api, id, key, location) {
          _callStorageFunction(_removeItem, arguments, location);
        };
        util.clearItems = function(api, id, location) {
          _callStorageFunction(_clearItems, arguments, location);
        };
        util.isEmpty = function(obj) {
          for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
              return false;
            }
          }
          return true;
        };
        util.format = function(format) {
          var re2 = /%./g;
          var match2;
          var part;
          var argi = 0;
          var parts = [];
          var last = 0;
          while (match2 = re2.exec(format)) {
            part = format.substring(last, re2.lastIndex - 2);
            if (part.length > 0) {
              parts.push(part);
            }
            last = re2.lastIndex;
            var code = match2[0][1];
            switch (code) {
              case "s":
              case "o":
                if (argi < arguments.length) {
                  parts.push(arguments[argi++ + 1]);
                } else {
                  parts.push("<?>");
                }
                break;
              case "%":
                parts.push("%");
                break;
              default:
                parts.push("<%" + code + "?>");
            }
          }
          parts.push(format.substring(last));
          return parts.join("");
        };
        util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
          var n = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
          var d = dec_point === void 0 ? "," : dec_point;
          var t = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
          var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c2), 10) + "";
          var j2 = i2.length > 3 ? i2.length % 3 : 0;
          return s2 + (j2 ? i2.substr(0, j2) + t : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c2 ? d + Math.abs(n - i2).toFixed(c2).slice(2) : "");
        };
        util.formatSize = function(size) {
          if (size >= 1073741824) {
            size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
          } else if (size >= 1048576) {
            size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
          } else if (size >= 1024) {
            size = util.formatNumber(size / 1024, 0) + " KiB";
          } else {
            size = util.formatNumber(size, 0) + " bytes";
          }
          return size;
        };
        util.bytesFromIP = function(ip) {
          if (ip.indexOf(".") !== -1) {
            return util.bytesFromIPv4(ip);
          }
          if (ip.indexOf(":") !== -1) {
            return util.bytesFromIPv6(ip);
          }
          return null;
        };
        util.bytesFromIPv4 = function(ip) {
          ip = ip.split(".");
          if (ip.length !== 4) {
            return null;
          }
          var b2 = util.createBuffer();
          for (var i2 = 0; i2 < ip.length; ++i2) {
            var num = parseInt(ip[i2], 10);
            if (isNaN(num)) {
              return null;
            }
            b2.putByte(num);
          }
          return b2.getBytes();
        };
        util.bytesFromIPv6 = function(ip) {
          var blanks = 0;
          ip = ip.split(":").filter(function(e2) {
            if (e2.length === 0)
              ++blanks;
            return true;
          });
          var zeros = (8 - ip.length + blanks) * 2;
          var b2 = util.createBuffer();
          for (var i2 = 0; i2 < 8; ++i2) {
            if (!ip[i2] || ip[i2].length === 0) {
              b2.fillWithByte(0, zeros);
              zeros = 0;
              continue;
            }
            var bytes = util.hexToBytes(ip[i2]);
            if (bytes.length < 2) {
              b2.putByte(0);
            }
            b2.putBytes(bytes);
          }
          return b2.getBytes();
        };
        util.bytesToIP = function(bytes) {
          if (bytes.length === 4) {
            return util.bytesToIPv4(bytes);
          }
          if (bytes.length === 16) {
            return util.bytesToIPv6(bytes);
          }
          return null;
        };
        util.bytesToIPv4 = function(bytes) {
          if (bytes.length !== 4) {
            return null;
          }
          var ip = [];
          for (var i2 = 0; i2 < bytes.length; ++i2) {
            ip.push(bytes.charCodeAt(i2));
          }
          return ip.join(".");
        };
        util.bytesToIPv6 = function(bytes) {
          if (bytes.length !== 16) {
            return null;
          }
          var ip = [];
          var zeroGroups = [];
          var zeroMaxGroup = 0;
          for (var i2 = 0; i2 < bytes.length; i2 += 2) {
            var hex2 = util.bytesToHex(bytes[i2] + bytes[i2 + 1]);
            while (hex2[0] === "0" && hex2 !== "0") {
              hex2 = hex2.substr(1);
            }
            if (hex2 === "0") {
              var last = zeroGroups[zeroGroups.length - 1];
              var idx = ip.length;
              if (!last || idx !== last.end + 1) {
                zeroGroups.push({ start: idx, end: idx });
              } else {
                last.end = idx;
                if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
                  zeroMaxGroup = zeroGroups.length - 1;
                }
              }
            }
            ip.push(hex2);
          }
          if (zeroGroups.length > 0) {
            var group = zeroGroups[zeroMaxGroup];
            if (group.end - group.start > 0) {
              ip.splice(group.start, group.end - group.start + 1, "");
              if (group.start === 0) {
                ip.unshift("");
              }
              if (group.end === 7) {
                ip.push("");
              }
            }
          }
          return ip.join(":");
        };
        util.estimateCores = function(options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          if ("cores" in util && !options.update) {
            return callback(null, util.cores);
          }
          if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
            util.cores = navigator.hardwareConcurrency;
            return callback(null, util.cores);
          }
          if (typeof Worker === "undefined") {
            util.cores = 1;
            return callback(null, util.cores);
          }
          if (typeof Blob === "undefined") {
            util.cores = 2;
            return callback(null, util.cores);
          }
          var blobUrl = URL.createObjectURL(new Blob([
            "(",
            function() {
              self.addEventListener("message", function(e2) {
                var st2 = Date.now();
                var et2 = st2 + 4;
                while (Date.now() < et2)
                  ;
                self.postMessage({ st: st2, et: et2 });
              });
            }.toString(),
            ")()"
          ], { type: "application/javascript" }));
          sample([], 5, 16);
          function sample(max, samples, numWorkers) {
            if (samples === 0) {
              var avg = Math.floor(max.reduce(function(avg2, x2) {
                return avg2 + x2;
              }, 0) / max.length);
              util.cores = Math.max(1, avg);
              URL.revokeObjectURL(blobUrl);
              return callback(null, util.cores);
            }
            map(numWorkers, function(err, results) {
              max.push(reduce(numWorkers, results));
              sample(max, samples - 1, numWorkers);
            });
          }
          function map(numWorkers, callback2) {
            var workers = [];
            var results = [];
            for (var i2 = 0; i2 < numWorkers; ++i2) {
              var worker = new Worker(blobUrl);
              worker.addEventListener("message", function(e2) {
                results.push(e2.data);
                if (results.length === numWorkers) {
                  for (var i22 = 0; i22 < numWorkers; ++i22) {
                    workers[i22].terminate();
                  }
                  callback2(null, results);
                }
              });
              workers.push(worker);
            }
            for (var i2 = 0; i2 < numWorkers; ++i2) {
              workers[i2].postMessage(i2);
            }
          }
          function reduce(numWorkers, results) {
            var overlaps = [];
            for (var n = 0; n < numWorkers; ++n) {
              var r1 = results[n];
              var overlap = overlaps[n] = [];
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                if (n === i2) {
                  continue;
                }
                var r2 = results[i2];
                if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
                  overlap.push(i2);
                }
              }
            }
            return overlaps.reduce(function(max, overlap2) {
              return Math.max(max, overlap2.length);
            }, 0);
          }
        };
      }
    });
    var require_cipher2 = __commonJS2({
      "../../node_modules/node-forge/lib/cipher.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        module2.exports = forge.cipher = forge.cipher || {};
        forge.cipher.algorithms = forge.cipher.algorithms || {};
        forge.cipher.createCipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: false
          });
        };
        forge.cipher.createDecipher = function(algorithm, key) {
          var api = algorithm;
          if (typeof api === "string") {
            api = forge.cipher.getAlgorithm(api);
            if (api) {
              api = api();
            }
          }
          if (!api) {
            throw new Error("Unsupported algorithm: " + algorithm);
          }
          return new forge.cipher.BlockCipher({
            algorithm: api,
            key,
            decrypt: true
          });
        };
        forge.cipher.registerAlgorithm = function(name, algorithm) {
          name = name.toUpperCase();
          forge.cipher.algorithms[name] = algorithm;
        };
        forge.cipher.getAlgorithm = function(name) {
          name = name.toUpperCase();
          if (name in forge.cipher.algorithms) {
            return forge.cipher.algorithms[name];
          }
          return null;
        };
        var BlockCipher = forge.cipher.BlockCipher = function(options) {
          this.algorithm = options.algorithm;
          this.mode = this.algorithm.mode;
          this.blockSize = this.mode.blockSize;
          this._finish = false;
          this._input = null;
          this.output = null;
          this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
          this._decrypt = options.decrypt;
          this.algorithm.initialize(options);
        };
        BlockCipher.prototype.start = function(options) {
          options = options || {};
          var opts = {};
          for (var key in options) {
            opts[key] = options[key];
          }
          opts.decrypt = this._decrypt;
          this._finish = false;
          this._input = forge.util.createBuffer();
          this.output = options.output || forge.util.createBuffer();
          this.mode.start(opts);
        };
        BlockCipher.prototype.update = function(input) {
          if (input) {
            this._input.putBuffer(input);
          }
          while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
          }
          this._input.compact();
        };
        BlockCipher.prototype.finish = function(pad) {
          if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
            this.mode.pad = function(input) {
              return pad(this.blockSize, input, false);
            };
            this.mode.unpad = function(output) {
              return pad(this.blockSize, output, true);
            };
          }
          var options = {};
          options.decrypt = this._decrypt;
          options.overflow = this._input.length() % this.blockSize;
          if (!this._decrypt && this.mode.pad) {
            if (!this.mode.pad(this._input, options)) {
              return false;
            }
          }
          this._finish = true;
          this.update();
          if (this._decrypt && this.mode.unpad) {
            if (!this.mode.unpad(this.output, options)) {
              return false;
            }
          }
          if (this.mode.afterFinish) {
            if (!this.mode.afterFinish(this.output, options)) {
              return false;
            }
          }
          return true;
        };
      }
    });
    var require_cipherModes2 = __commonJS2({
      "../../node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        forge.cipher = forge.cipher || {};
        var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
        modes.ecb = function(options) {
          options = options || {};
          this.name = "ECB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.ecb.prototype.start = function(options) {
        };
        modes.ecb.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._inBlock[i2] = input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            output.putInt32(this._outBlock[i2]);
          }
        };
        modes.ecb.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._inBlock[i2] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            output.putInt32(this._outBlock[i2]);
          }
        };
        modes.ecb.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.ecb.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cbc = function(options) {
          options = options || {};
          this.name = "CBC";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
        };
        modes.cbc.prototype.start = function(options) {
          if (options.iv === null) {
            if (!this._prev) {
              throw new Error("Invalid IV parameter.");
            }
            this._iv = this._prev.slice(0);
          } else if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          } else {
            this._iv = transformIV(options.iv, this.blockSize);
            this._prev = this._iv.slice(0);
          }
        };
        modes.cbc.prototype.encrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            output.putInt32(this._outBlock[i2]);
          }
          this._prev = this._outBlock;
        };
        modes.cbc.prototype.decrypt = function(input, output, finish) {
          if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
            return true;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._inBlock[i2] = input.getInt32();
          }
          this.cipher.decrypt(this._inBlock, this._outBlock);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
          }
          this._prev = this._inBlock.slice(0);
        };
        modes.cbc.prototype.pad = function(input, options) {
          var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
          input.fillWithByte(padding, padding);
          return true;
        };
        modes.cbc.prototype.unpad = function(output, options) {
          if (options.overflow > 0) {
            return false;
          }
          var len = output.length();
          var count = output.at(len - 1);
          if (count > this.blockSize << 2) {
            return false;
          }
          output.truncate(count);
          return true;
        };
        modes.cfb = function(options) {
          options = options || {};
          this.name = "CFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialBlock = new Array(this._ints);
          this._partialOutput = forge.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.cfb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.cfb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
              output.putInt32(this._inBlock[i2]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
            this._partialOutput.putInt32(this._partialBlock[i2]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._inBlock[i2] = this._partialBlock[i2];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.cfb.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._inBlock[i2] = input.getInt32();
              output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._partialBlock[i2] = input.getInt32();
            this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._inBlock[i2] = this._partialBlock[i2];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb = function(options) {
          options = options || {};
          this.name = "OFB";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ofb.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ofb.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (input.length() === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              output.putInt32(input.getInt32() ^ this._outBlock[i2]);
              this._inBlock[i2] = this._outBlock[i2];
            }
            return;
          }
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          } else {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._inBlock[i2] = this._outBlock[i2];
            }
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(
              partialBytes - this._partialBytes
            ));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(
            inputLength - this._partialBytes
          ));
          this._partialBytes = 0;
        };
        modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
        modes.ctr = function(options) {
          options = options || {};
          this.name = "CTR";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = null;
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge.util.createBuffer();
          this._partialBytes = 0;
        };
        modes.ctr.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = transformIV(options.iv, this.blockSize);
          this._inBlock = this._iv.slice(0);
          this._partialBytes = 0;
        };
        modes.ctr.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              output.putInt32(input.getInt32() ^ this._outBlock[i2]);
            }
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
            }
            if (partialBytes > 0) {
              input.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          inc32(this._inBlock);
        };
        modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
        modes.gcm = function(options) {
          options = options || {};
          this.name = "GCM";
          this.cipher = options.cipher;
          this.blockSize = options.blockSize || 16;
          this._ints = this.blockSize / 4;
          this._inBlock = new Array(this._ints);
          this._outBlock = new Array(this._ints);
          this._partialOutput = forge.util.createBuffer();
          this._partialBytes = 0;
          this._R = 3774873600;
        };
        modes.gcm.prototype.start = function(options) {
          if (!("iv" in options)) {
            throw new Error("Invalid IV parameter.");
          }
          var iv = forge.util.createBuffer(options.iv);
          this._cipherLength = 0;
          var additionalData;
          if ("additionalData" in options) {
            additionalData = forge.util.createBuffer(options.additionalData);
          } else {
            additionalData = forge.util.createBuffer();
          }
          if ("tagLength" in options) {
            this._tagLength = options.tagLength;
          } else {
            this._tagLength = 128;
          }
          this._tag = null;
          if (options.decrypt) {
            this._tag = forge.util.createBuffer(options.tag).getBytes();
            if (this._tag.length !== this._tagLength / 8) {
              throw new Error("Authentication tag does not match tag length.");
            }
          }
          this._hashBlock = new Array(this._ints);
          this.tag = null;
          this._hashSubkey = new Array(this._ints);
          this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
          this.componentBits = 4;
          this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
          var ivLength = iv.length();
          if (ivLength === 12) {
            this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
          } else {
            this._j0 = [0, 0, 0, 0];
            while (iv.length() > 0) {
              this._j0 = this.ghash(
                this._hashSubkey,
                this._j0,
                [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
              );
            }
            this._j0 = this.ghash(
              this._hashSubkey,
              this._j0,
              [0, 0].concat(from64To32(ivLength * 8))
            );
          }
          this._inBlock = this._j0.slice(0);
          inc32(this._inBlock);
          this._partialBytes = 0;
          additionalData = forge.util.createBuffer(additionalData);
          this._aDataLength = from64To32(additionalData.length() * 8);
          var overflow = additionalData.length() % this.blockSize;
          if (overflow) {
            additionalData.fillWithByte(0, this.blockSize - overflow);
          }
          this._s = [0, 0, 0, 0];
          while (additionalData.length() > 0) {
            this._s = this.ghash(this._hashSubkey, this._s, [
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32(),
              additionalData.getInt32()
            ]);
          }
        };
        modes.gcm.prototype.encrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength === 0) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          if (this._partialBytes === 0 && inputLength >= this.blockSize) {
            for (var i2 = 0; i2 < this._ints; ++i2) {
              output.putInt32(this._outBlock[i2] ^= input.getInt32());
            }
            this._cipherLength += this.blockSize;
          } else {
            var partialBytes = (this.blockSize - inputLength) % this.blockSize;
            if (partialBytes > 0) {
              partialBytes = this.blockSize - partialBytes;
            }
            this._partialOutput.clear();
            for (var i2 = 0; i2 < this._ints; ++i2) {
              this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
            }
            if (partialBytes <= 0 || finish) {
              if (finish) {
                var overflow = inputLength % this.blockSize;
                this._cipherLength += overflow;
                this._partialOutput.truncate(this.blockSize - overflow);
              } else {
                this._cipherLength += this.blockSize;
              }
              for (var i2 = 0; i2 < this._ints; ++i2) {
                this._outBlock[i2] = this._partialOutput.getInt32();
              }
              this._partialOutput.read -= this.blockSize;
            }
            if (this._partialBytes > 0) {
              this._partialOutput.getBytes(this._partialBytes);
            }
            if (partialBytes > 0 && !finish) {
              input.read -= this.blockSize;
              output.putBytes(this._partialOutput.getBytes(
                partialBytes - this._partialBytes
              ));
              this._partialBytes = partialBytes;
              return true;
            }
            output.putBytes(this._partialOutput.getBytes(
              inputLength - this._partialBytes
            ));
            this._partialBytes = 0;
          }
          this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
          inc32(this._inBlock);
        };
        modes.gcm.prototype.decrypt = function(input, output, finish) {
          var inputLength = input.length();
          if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
            return true;
          }
          this.cipher.encrypt(this._inBlock, this._outBlock);
          inc32(this._inBlock);
          this._hashBlock[0] = input.getInt32();
          this._hashBlock[1] = input.getInt32();
          this._hashBlock[2] = input.getInt32();
          this._hashBlock[3] = input.getInt32();
          this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
          }
          if (inputLength < this.blockSize) {
            this._cipherLength += inputLength % this.blockSize;
          } else {
            this._cipherLength += this.blockSize;
          }
        };
        modes.gcm.prototype.afterFinish = function(output, options) {
          var rval = true;
          if (options.decrypt && options.overflow) {
            output.truncate(this.blockSize - options.overflow);
          }
          this.tag = forge.util.createBuffer();
          var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
          this._s = this.ghash(this._hashSubkey, this._s, lengths);
          var tag = [];
          this.cipher.encrypt(this._j0, tag);
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this.tag.putInt32(this._s[i2] ^ tag[i2]);
          }
          this.tag.truncate(this.tag.length() % (this._tagLength / 8));
          if (options.decrypt && this.tag.bytes() !== this._tag) {
            rval = false;
          }
          return rval;
        };
        modes.gcm.prototype.multiply = function(x2, y2) {
          var z_i = [0, 0, 0, 0];
          var v_i = y2.slice(0);
          for (var i2 = 0; i2 < 128; ++i2) {
            var x_i = x2[i2 / 32 | 0] & 1 << 31 - i2 % 32;
            if (x_i) {
              z_i[0] ^= v_i[0];
              z_i[1] ^= v_i[1];
              z_i[2] ^= v_i[2];
              z_i[3] ^= v_i[3];
            }
            this.pow(v_i, v_i);
          }
          return z_i;
        };
        modes.gcm.prototype.pow = function(x2, out) {
          var lsb = x2[3] & 1;
          for (var i2 = 3; i2 > 0; --i2) {
            out[i2] = x2[i2] >>> 1 | (x2[i2 - 1] & 1) << 31;
          }
          out[0] = x2[0] >>> 1;
          if (lsb) {
            out[0] ^= this._R;
          }
        };
        modes.gcm.prototype.tableMultiply = function(x2) {
          var z2 = [0, 0, 0, 0];
          for (var i2 = 0; i2 < 32; ++i2) {
            var idx = i2 / 8 | 0;
            var x_i = x2[idx] >>> (7 - i2 % 8) * 4 & 15;
            var ah = this._m[i2][x_i];
            z2[0] ^= ah[0];
            z2[1] ^= ah[1];
            z2[2] ^= ah[2];
            z2[3] ^= ah[3];
          }
          return z2;
        };
        modes.gcm.prototype.ghash = function(h, y2, x2) {
          y2[0] ^= x2[0];
          y2[1] ^= x2[1];
          y2[2] ^= x2[2];
          y2[3] ^= x2[3];
          return this.tableMultiply(y2);
        };
        modes.gcm.prototype.generateHashTable = function(h, bits2) {
          var multiplier = 8 / bits2;
          var perInt = 4 * multiplier;
          var size = 16 * multiplier;
          var m2 = new Array(size);
          for (var i2 = 0; i2 < size; ++i2) {
            var tmp = [0, 0, 0, 0];
            var idx = i2 / perInt | 0;
            var shft = (perInt - 1 - i2 % perInt) * bits2;
            tmp[idx] = 1 << bits2 - 1 << shft;
            m2[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
          }
          return m2;
        };
        modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
          var size = 1 << bits2;
          var half = size >>> 1;
          var m2 = new Array(size);
          m2[half] = mid.slice(0);
          var i2 = half >>> 1;
          while (i2 > 0) {
            this.pow(m2[2 * i2], m2[i2] = []);
            i2 >>= 1;
          }
          i2 = 2;
          while (i2 < half) {
            for (var j2 = 1; j2 < i2; ++j2) {
              var m_i = m2[i2];
              var m_j = m2[j2];
              m2[i2 + j2] = [
                m_i[0] ^ m_j[0],
                m_i[1] ^ m_j[1],
                m_i[2] ^ m_j[2],
                m_i[3] ^ m_j[3]
              ];
            }
            i2 *= 2;
          }
          m2[0] = [0, 0, 0, 0];
          for (i2 = half + 1; i2 < size; ++i2) {
            var c2 = m2[i2 ^ half];
            m2[i2] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
          }
          return m2;
        };
        function transformIV(iv, blockSize) {
          if (typeof iv === "string") {
            iv = forge.util.createBuffer(iv);
          }
          if (forge.util.isArray(iv) && iv.length > 4) {
            var tmp = iv;
            iv = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              iv.putByte(tmp[i2]);
            }
          }
          if (iv.length() < blockSize) {
            throw new Error(
              "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
            );
          }
          if (!forge.util.isArray(iv)) {
            var ints = [];
            var blocks = blockSize / 4;
            for (var i2 = 0; i2 < blocks; ++i2) {
              ints.push(iv.getInt32());
            }
            iv = ints;
          }
          return iv;
        }
        function inc32(block) {
          block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
        }
        function from64To32(num) {
          return [num / 4294967296 | 0, num & 4294967295];
        }
      }
    });
    var require_aes2 = __commonJS2({
      "../../node_modules/node-forge/lib/aes.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_cipher2();
        require_cipherModes2();
        require_util2();
        module2.exports = forge.aes = forge.aes || {};
        forge.aes.startEncrypting = function(key, iv, output, mode) {
          var cipher = _createCipher({
            key,
            output,
            decrypt: false,
            mode
          });
          cipher.start(iv);
          return cipher;
        };
        forge.aes.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge.aes.startDecrypting = function(key, iv, output, mode) {
          var cipher = _createCipher({
            key,
            output,
            decrypt: true,
            mode
          });
          cipher.start(iv);
          return cipher;
        };
        forge.aes.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge.aes.Algorithm = function(name, mode) {
          if (!init2) {
            initialize();
          }
          var self2 = this;
          self2.name = name;
          self2.mode = new mode({
            blockSize: 16,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._w, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge.aes.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = options.key;
          var tmp;
          if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
            tmp = key;
            key = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          if (!forge.util.isArray(key)) {
            tmp = key;
            key = [];
            var len = tmp.length();
            if (len === 16 || len === 24 || len === 32) {
              len = len >>> 2;
              for (var i2 = 0; i2 < len; ++i2) {
                key.push(tmp.getInt32());
              }
            }
          }
          if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
            throw new Error("Invalid key parameter.");
          }
          var mode = this.mode.name;
          var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
          this._w = _expandKey(key, options.decrypt && !encryptOp);
          this._init = true;
        };
        forge.aes._expandKey = function(key, decrypt) {
          if (!init2) {
            initialize();
          }
          return _expandKey(key, decrypt);
        };
        forge.aes._updateBlock = _updateBlock;
        registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
        registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
        registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
        registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
        registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
        registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
        function registerAlgorithm(name, mode) {
          var factory = function() {
            return new forge.aes.Algorithm(name, mode);
          };
          forge.cipher.registerAlgorithm(name, factory);
        }
        var init2 = false;
        var Nb = 4;
        var sbox;
        var isbox;
        var rcon;
        var mix;
        var imix;
        function initialize() {
          init2 = true;
          rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          var xtime = new Array(256);
          for (var i2 = 0; i2 < 128; ++i2) {
            xtime[i2] = i2 << 1;
            xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
          }
          sbox = new Array(256);
          isbox = new Array(256);
          mix = new Array(4);
          imix = new Array(4);
          for (var i2 = 0; i2 < 4; ++i2) {
            mix[i2] = new Array(256);
            imix[i2] = new Array(256);
          }
          var e2 = 0, ei = 0, e22, e4, e8, sx, sx2, me2, ime;
          for (var i2 = 0; i2 < 256; ++i2) {
            sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
            sx = sx >> 8 ^ sx & 255 ^ 99;
            sbox[e2] = sx;
            isbox[sx] = e2;
            sx2 = xtime[sx];
            e22 = xtime[e2];
            e4 = xtime[e22];
            e8 = xtime[e4];
            me2 = sx2 << 24 ^ // 2
            sx << 16 ^ // 1
            sx << 8 ^ // 1
            (sx ^ sx2);
            ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
            (e2 ^ e8) << 16 ^ // 9
            (e2 ^ e4 ^ e8) << 8 ^ // D (13)
            (e2 ^ e22 ^ e8);
            for (var n = 0; n < 4; ++n) {
              mix[n][e2] = me2;
              imix[n][sx] = ime;
              me2 = me2 << 24 | me2 >>> 8;
              ime = ime << 24 | ime >>> 8;
            }
            if (e2 === 0) {
              e2 = ei = 1;
            } else {
              e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
              ei ^= xtime[xtime[ei]];
            }
          }
        }
        function _expandKey(key, decrypt) {
          var w2 = key.slice(0);
          var temp, iNk = 1;
          var Nk = w2.length;
          var Nr1 = Nk + 6 + 1;
          var end = Nb * Nr1;
          for (var i2 = Nk; i2 < end; ++i2) {
            temp = w2[i2 - 1];
            if (i2 % Nk === 0) {
              temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
              iNk++;
            } else if (Nk > 6 && i2 % Nk === 4) {
              temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
            }
            w2[i2] = w2[i2 - Nk] ^ temp;
          }
          if (decrypt) {
            var tmp;
            var m0 = imix[0];
            var m1 = imix[1];
            var m2 = imix[2];
            var m3 = imix[3];
            var wnew = w2.slice(0);
            end = w2.length;
            for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
              if (i2 === 0 || i2 === end - Nb) {
                wnew[i2] = w2[wi];
                wnew[i2 + 1] = w2[wi + 3];
                wnew[i2 + 2] = w2[wi + 2];
                wnew[i2 + 3] = w2[wi + 1];
              } else {
                for (var n = 0; n < Nb; ++n) {
                  tmp = w2[wi + n];
                  wnew[i2 + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
                }
              }
            }
            w2 = wnew;
          }
          return w2;
        }
        function _updateBlock(w2, input, output, decrypt) {
          var Nr = w2.length / 4 - 1;
          var m0, m1, m2, m3, sub2;
          if (decrypt) {
            m0 = imix[0];
            m1 = imix[1];
            m2 = imix[2];
            m3 = imix[3];
            sub2 = isbox;
          } else {
            m0 = mix[0];
            m1 = mix[1];
            m2 = mix[2];
            m3 = mix[3];
            sub2 = sbox;
          }
          var a2, b2, c2, d, a22, b22, c22;
          a2 = input[0] ^ w2[0];
          b2 = input[decrypt ? 3 : 1] ^ w2[1];
          c2 = input[2] ^ w2[2];
          d = input[decrypt ? 1 : 3] ^ w2[3];
          var i2 = 3;
          for (var round = 1; round < Nr; ++round) {
            a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m2[c2 >>> 8 & 255] ^ m3[d & 255] ^ w2[++i2];
            b22 = m0[b2 >>> 24] ^ m1[c2 >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a2 & 255] ^ w2[++i2];
            c22 = m0[c2 >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w2[++i2];
            d = m0[d >>> 24] ^ m1[a2 >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w2[++i2];
            a2 = a22;
            b2 = b22;
            c2 = c22;
          }
          output[0] = sub2[a2 >>> 24] << 24 ^ sub2[b2 >>> 16 & 255] << 16 ^ sub2[c2 >>> 8 & 255] << 8 ^ sub2[d & 255] ^ w2[++i2];
          output[decrypt ? 3 : 1] = sub2[b2 >>> 24] << 24 ^ sub2[c2 >>> 16 & 255] << 16 ^ sub2[d >>> 8 & 255] << 8 ^ sub2[a2 & 255] ^ w2[++i2];
          output[2] = sub2[c2 >>> 24] << 24 ^ sub2[d >>> 16 & 255] << 16 ^ sub2[a2 >>> 8 & 255] << 8 ^ sub2[b2 & 255] ^ w2[++i2];
          output[decrypt ? 1 : 3] = sub2[d >>> 24] << 24 ^ sub2[a2 >>> 16 & 255] << 16 ^ sub2[b2 >>> 8 & 255] << 8 ^ sub2[c2 & 255] ^ w2[++i2];
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "AES-" + mode;
          var cipher;
          if (options.decrypt) {
            cipher = forge.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher = forge.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher.start;
          cipher.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher, options2);
          };
          return cipher;
        }
      }
    });
    var require_oids2 = __commonJS2({
      "../../node_modules/node-forge/lib/oids.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        forge.pki = forge.pki || {};
        var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
        function _IN(id, name) {
          oids[id] = name;
          oids[name] = id;
        }
        function _I_(id, name) {
          oids[id] = name;
        }
        _IN("1.2.840.113549.1.1.1", "rsaEncryption");
        _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
        _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
        _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
        _IN("1.2.840.113549.1.1.8", "mgf1");
        _IN("1.2.840.113549.1.1.9", "pSpecified");
        _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
        _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
        _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
        _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
        _IN("1.3.101.112", "EdDSA25519");
        _IN("1.2.840.10040.4.3", "dsa-with-sha1");
        _IN("1.3.14.3.2.7", "desCBC");
        _IN("1.3.14.3.2.26", "sha1");
        _IN("1.3.14.3.2.29", "sha1WithRSASignature");
        _IN("2.16.840.1.101.3.4.2.1", "sha256");
        _IN("2.16.840.1.101.3.4.2.2", "sha384");
        _IN("2.16.840.1.101.3.4.2.3", "sha512");
        _IN("2.16.840.1.101.3.4.2.4", "sha224");
        _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
        _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
        _IN("1.2.840.113549.2.2", "md2");
        _IN("1.2.840.113549.2.5", "md5");
        _IN("1.2.840.113549.1.7.1", "data");
        _IN("1.2.840.113549.1.7.2", "signedData");
        _IN("1.2.840.113549.1.7.3", "envelopedData");
        _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
        _IN("1.2.840.113549.1.7.5", "digestedData");
        _IN("1.2.840.113549.1.7.6", "encryptedData");
        _IN("1.2.840.113549.1.9.1", "emailAddress");
        _IN("1.2.840.113549.1.9.2", "unstructuredName");
        _IN("1.2.840.113549.1.9.3", "contentType");
        _IN("1.2.840.113549.1.9.4", "messageDigest");
        _IN("1.2.840.113549.1.9.5", "signingTime");
        _IN("1.2.840.113549.1.9.6", "counterSignature");
        _IN("1.2.840.113549.1.9.7", "challengePassword");
        _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
        _IN("1.2.840.113549.1.9.14", "extensionRequest");
        _IN("1.2.840.113549.1.9.20", "friendlyName");
        _IN("1.2.840.113549.1.9.21", "localKeyId");
        _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
        _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
        _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
        _IN("1.2.840.113549.1.12.10.1.3", "certBag");
        _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
        _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
        _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
        _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
        _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
        _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
        _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
        _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
        _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
        _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
        _IN("1.2.840.113549.2.7", "hmacWithSHA1");
        _IN("1.2.840.113549.2.8", "hmacWithSHA224");
        _IN("1.2.840.113549.2.9", "hmacWithSHA256");
        _IN("1.2.840.113549.2.10", "hmacWithSHA384");
        _IN("1.2.840.113549.2.11", "hmacWithSHA512");
        _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
        _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
        _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
        _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
        _IN("2.5.4.3", "commonName");
        _IN("2.5.4.4", "surname");
        _IN("2.5.4.5", "serialNumber");
        _IN("2.5.4.6", "countryName");
        _IN("2.5.4.7", "localityName");
        _IN("2.5.4.8", "stateOrProvinceName");
        _IN("2.5.4.9", "streetAddress");
        _IN("2.5.4.10", "organizationName");
        _IN("2.5.4.11", "organizationalUnitName");
        _IN("2.5.4.12", "title");
        _IN("2.5.4.13", "description");
        _IN("2.5.4.15", "businessCategory");
        _IN("2.5.4.17", "postalCode");
        _IN("2.5.4.42", "givenName");
        _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
        _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
        _IN("2.16.840.1.113730.1.1", "nsCertType");
        _IN("2.16.840.1.113730.1.13", "nsComment");
        _I_("2.5.29.1", "authorityKeyIdentifier");
        _I_("2.5.29.2", "keyAttributes");
        _I_("2.5.29.3", "certificatePolicies");
        _I_("2.5.29.4", "keyUsageRestriction");
        _I_("2.5.29.5", "policyMapping");
        _I_("2.5.29.6", "subtreesConstraint");
        _I_("2.5.29.7", "subjectAltName");
        _I_("2.5.29.8", "issuerAltName");
        _I_("2.5.29.9", "subjectDirectoryAttributes");
        _I_("2.5.29.10", "basicConstraints");
        _I_("2.5.29.11", "nameConstraints");
        _I_("2.5.29.12", "policyConstraints");
        _I_("2.5.29.13", "basicConstraints");
        _IN("2.5.29.14", "subjectKeyIdentifier");
        _IN("2.5.29.15", "keyUsage");
        _I_("2.5.29.16", "privateKeyUsagePeriod");
        _IN("2.5.29.17", "subjectAltName");
        _IN("2.5.29.18", "issuerAltName");
        _IN("2.5.29.19", "basicConstraints");
        _I_("2.5.29.20", "cRLNumber");
        _I_("2.5.29.21", "cRLReason");
        _I_("2.5.29.22", "expirationDate");
        _I_("2.5.29.23", "instructionCode");
        _I_("2.5.29.24", "invalidityDate");
        _I_("2.5.29.25", "cRLDistributionPoints");
        _I_("2.5.29.26", "issuingDistributionPoint");
        _I_("2.5.29.27", "deltaCRLIndicator");
        _I_("2.5.29.28", "issuingDistributionPoint");
        _I_("2.5.29.29", "certificateIssuer");
        _I_("2.5.29.30", "nameConstraints");
        _IN("2.5.29.31", "cRLDistributionPoints");
        _IN("2.5.29.32", "certificatePolicies");
        _I_("2.5.29.33", "policyMappings");
        _I_("2.5.29.34", "policyConstraints");
        _IN("2.5.29.35", "authorityKeyIdentifier");
        _I_("2.5.29.36", "policyConstraints");
        _IN("2.5.29.37", "extKeyUsage");
        _I_("2.5.29.46", "freshestCRL");
        _I_("2.5.29.54", "inhibitAnyPolicy");
        _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
        _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
        _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
        _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
        _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
        _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
        _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
      }
    });
    var require_asn12 = __commonJS2({
      "../../node_modules/node-forge/lib/asn1.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        require_oids2();
        var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
        asn1.Class = {
          UNIVERSAL: 0,
          APPLICATION: 64,
          CONTEXT_SPECIFIC: 128,
          PRIVATE: 192
        };
        asn1.Type = {
          NONE: 0,
          BOOLEAN: 1,
          INTEGER: 2,
          BITSTRING: 3,
          OCTETSTRING: 4,
          NULL: 5,
          OID: 6,
          ODESC: 7,
          EXTERNAL: 8,
          REAL: 9,
          ENUMERATED: 10,
          EMBEDDED: 11,
          UTF8: 12,
          ROID: 13,
          SEQUENCE: 16,
          SET: 17,
          PRINTABLESTRING: 19,
          IA5STRING: 22,
          UTCTIME: 23,
          GENERALIZEDTIME: 24,
          BMPSTRING: 30
        };
        asn1.create = function(tagClass, type, constructed, value, options) {
          if (forge.util.isArray(value)) {
            var tmp = [];
            for (var i2 = 0; i2 < value.length; ++i2) {
              if (value[i2] !== void 0) {
                tmp.push(value[i2]);
              }
            }
            value = tmp;
          }
          var obj = {
            tagClass,
            type,
            constructed,
            composed: constructed || forge.util.isArray(value),
            value
          };
          if (options && "bitStringContents" in options) {
            obj.bitStringContents = options.bitStringContents;
            obj.original = asn1.copy(obj);
          }
          return obj;
        };
        asn1.copy = function(obj, options) {
          var copy2;
          if (forge.util.isArray(obj)) {
            copy2 = [];
            for (var i2 = 0; i2 < obj.length; ++i2) {
              copy2.push(asn1.copy(obj[i2], options));
            }
            return copy2;
          }
          if (typeof obj === "string") {
            return obj;
          }
          copy2 = {
            tagClass: obj.tagClass,
            type: obj.type,
            constructed: obj.constructed,
            composed: obj.composed,
            value: asn1.copy(obj.value, options)
          };
          if (options && !options.excludeBitStringContents) {
            copy2.bitStringContents = obj.bitStringContents;
          }
          return copy2;
        };
        asn1.equals = function(obj1, obj2, options) {
          if (forge.util.isArray(obj1)) {
            if (!forge.util.isArray(obj2)) {
              return false;
            }
            if (obj1.length !== obj2.length) {
              return false;
            }
            for (var i2 = 0; i2 < obj1.length; ++i2) {
              if (!asn1.equals(obj1[i2], obj2[i2])) {
                return false;
              }
            }
            return true;
          }
          if (typeof obj1 !== typeof obj2) {
            return false;
          }
          if (typeof obj1 === "string") {
            return obj1 === obj2;
          }
          var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
          if (options && options.includeBitStringContents) {
            equal = equal && obj1.bitStringContents === obj2.bitStringContents;
          }
          return equal;
        };
        asn1.getBerValueLength = function(b2) {
          var b22 = b2.getByte();
          if (b22 === 128) {
            return void 0;
          }
          var length2;
          var longForm = b22 & 128;
          if (!longForm) {
            length2 = b22;
          } else {
            length2 = b2.getInt((b22 & 127) << 3);
          }
          return length2;
        };
        function _checkBufferLength(bytes, remaining, n) {
          if (n > remaining) {
            var error = new Error("Too few bytes to parse DER.");
            error.available = bytes.length();
            error.remaining = remaining;
            error.requested = n;
            throw error;
          }
        }
        var _getValueLength = function(bytes, remaining) {
          var b2 = bytes.getByte();
          remaining--;
          if (b2 === 128) {
            return void 0;
          }
          var length2;
          var longForm = b2 & 128;
          if (!longForm) {
            length2 = b2;
          } else {
            var longFormBytes = b2 & 127;
            _checkBufferLength(bytes, remaining, longFormBytes);
            length2 = bytes.getInt(longFormBytes << 3);
          }
          if (length2 < 0) {
            throw new Error("Negative length: " + length2);
          }
          return length2;
        };
        asn1.fromDer = function(bytes, options) {
          if (options === void 0) {
            options = {
              strict: true,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (typeof options === "boolean") {
            options = {
              strict: options,
              parseAllBytes: true,
              decodeBitStrings: true
            };
          }
          if (!("strict" in options)) {
            options.strict = true;
          }
          if (!("parseAllBytes" in options)) {
            options.parseAllBytes = true;
          }
          if (!("decodeBitStrings" in options)) {
            options.decodeBitStrings = true;
          }
          if (typeof bytes === "string") {
            bytes = forge.util.createBuffer(bytes);
          }
          var byteCount = bytes.length();
          var value = _fromDer(bytes, bytes.length(), 0, options);
          if (options.parseAllBytes && bytes.length() !== 0) {
            var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
            error.byteCount = byteCount;
            error.remaining = bytes.length();
            throw error;
          }
          return value;
        };
        function _fromDer(bytes, remaining, depth, options) {
          var start;
          _checkBufferLength(bytes, remaining, 2);
          var b1 = bytes.getByte();
          remaining--;
          var tagClass = b1 & 192;
          var type = b1 & 31;
          start = bytes.length();
          var length2 = _getValueLength(bytes, remaining);
          remaining -= start - bytes.length();
          if (length2 !== void 0 && length2 > remaining) {
            if (options.strict) {
              var error = new Error("Too few bytes to read ASN.1 value.");
              error.available = bytes.length();
              error.remaining = remaining;
              error.requested = length2;
              throw error;
            }
            length2 = remaining;
          }
          var value;
          var bitStringContents;
          var constructed = (b1 & 32) === 32;
          if (constructed) {
            value = [];
            if (length2 === void 0) {
              for (; ; ) {
                _checkBufferLength(bytes, remaining, 2);
                if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                  bytes.getBytes(2);
                  remaining -= 2;
                  break;
                }
                start = bytes.length();
                value.push(_fromDer(bytes, remaining, depth + 1, options));
                remaining -= start - bytes.length();
              }
            } else {
              while (length2 > 0) {
                start = bytes.length();
                value.push(_fromDer(bytes, length2, depth + 1, options));
                remaining -= start - bytes.length();
                length2 -= start - bytes.length();
              }
            }
          }
          if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
            bitStringContents = bytes.bytes(length2);
          }
          if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
          // .. other parts of forge expect to decode OCTET STRINGs manually
          type === asn1.Type.BITSTRING && length2 > 1) {
            var savedRead = bytes.read;
            var savedRemaining = remaining;
            var unused = 0;
            if (type === asn1.Type.BITSTRING) {
              _checkBufferLength(bytes, remaining, 1);
              unused = bytes.getByte();
              remaining--;
            }
            if (unused === 0) {
              try {
                start = bytes.length();
                var subOptions = {
                  // enforce strict mode to avoid parsing ASN.1 from plain data
                  strict: true,
                  decodeBitStrings: true
                };
                var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
                var used = start - bytes.length();
                remaining -= used;
                if (type == asn1.Type.BITSTRING) {
                  used++;
                }
                var tc = composed.tagClass;
                if (used === length2 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
                  value = [composed];
                }
              } catch (ex) {
              }
            }
            if (value === void 0) {
              bytes.read = savedRead;
              remaining = savedRemaining;
            }
          }
          if (value === void 0) {
            if (length2 === void 0) {
              if (options.strict) {
                throw new Error("Non-constructed ASN.1 object of indefinite length.");
              }
              length2 = remaining;
            }
            if (type === asn1.Type.BMPSTRING) {
              value = "";
              for (; length2 > 0; length2 -= 2) {
                _checkBufferLength(bytes, remaining, 2);
                value += String.fromCharCode(bytes.getInt16());
                remaining -= 2;
              }
            } else {
              value = bytes.getBytes(length2);
              remaining -= length2;
            }
          }
          var asn1Options = bitStringContents === void 0 ? null : {
            bitStringContents
          };
          return asn1.create(tagClass, type, constructed, value, asn1Options);
        }
        asn1.toDer = function(obj) {
          var bytes = forge.util.createBuffer();
          var b1 = obj.tagClass | obj.type;
          var value = forge.util.createBuffer();
          var useBitStringContents = false;
          if ("bitStringContents" in obj) {
            useBitStringContents = true;
            if (obj.original) {
              useBitStringContents = asn1.equals(obj, obj.original);
            }
          }
          if (useBitStringContents) {
            value.putBytes(obj.bitStringContents);
          } else if (obj.composed) {
            if (obj.constructed) {
              b1 |= 32;
            } else {
              value.putByte(0);
            }
            for (var i2 = 0; i2 < obj.value.length; ++i2) {
              if (obj.value[i2] !== void 0) {
                value.putBuffer(asn1.toDer(obj.value[i2]));
              }
            }
          } else {
            if (obj.type === asn1.Type.BMPSTRING) {
              for (var i2 = 0; i2 < obj.value.length; ++i2) {
                value.putInt16(obj.value.charCodeAt(i2));
              }
            } else {
              if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
              (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
              obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
                value.putBytes(obj.value.substr(1));
              } else {
                value.putBytes(obj.value);
              }
            }
          }
          bytes.putByte(b1);
          if (value.length() <= 127) {
            bytes.putByte(value.length() & 127);
          } else {
            var len = value.length();
            var lenBytes = "";
            do {
              lenBytes += String.fromCharCode(len & 255);
              len = len >>> 8;
            } while (len > 0);
            bytes.putByte(lenBytes.length | 128);
            for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
              bytes.putByte(lenBytes.charCodeAt(i2));
            }
          }
          bytes.putBuffer(value);
          return bytes;
        };
        asn1.oidToDer = function(oid) {
          var values = oid.split(".");
          var bytes = forge.util.createBuffer();
          bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
          var last, valueBytes, value, b2;
          for (var i2 = 2; i2 < values.length; ++i2) {
            last = true;
            valueBytes = [];
            value = parseInt(values[i2], 10);
            do {
              b2 = value & 127;
              value = value >>> 7;
              if (!last) {
                b2 |= 128;
              }
              valueBytes.push(b2);
              last = false;
            } while (value > 0);
            for (var n = valueBytes.length - 1; n >= 0; --n) {
              bytes.putByte(valueBytes[n]);
            }
          }
          return bytes;
        };
        asn1.derToOid = function(bytes) {
          var oid;
          if (typeof bytes === "string") {
            bytes = forge.util.createBuffer(bytes);
          }
          var b2 = bytes.getByte();
          oid = Math.floor(b2 / 40) + "." + b2 % 40;
          var value = 0;
          while (bytes.length() > 0) {
            b2 = bytes.getByte();
            value = value << 7;
            if (b2 & 128) {
              value += b2 & 127;
            } else {
              oid += "." + (value + b2);
              value = 0;
            }
          }
          return oid;
        };
        asn1.utcTimeToDate = function(utc) {
          var date = /* @__PURE__ */ new Date();
          var year = parseInt(utc.substr(0, 2), 10);
          year = year >= 50 ? 1900 + year : 2e3 + year;
          var MM = parseInt(utc.substr(2, 2), 10) - 1;
          var DD = parseInt(utc.substr(4, 2), 10);
          var hh = parseInt(utc.substr(6, 2), 10);
          var mm = parseInt(utc.substr(8, 2), 10);
          var ss = 0;
          if (utc.length > 11) {
            var c2 = utc.charAt(10);
            var end = 10;
            if (c2 !== "+" && c2 !== "-") {
              ss = parseInt(utc.substr(10, 2), 10);
              end += 2;
            }
          }
          date.setUTCFullYear(year, MM, DD);
          date.setUTCHours(hh, mm, ss, 0);
          if (end) {
            c2 = utc.charAt(end);
            if (c2 === "+" || c2 === "-") {
              var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
              var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
              var offset = hhoffset * 60 + mmoffset;
              offset *= 6e4;
              if (c2 === "+") {
                date.setTime(+date - offset);
              } else {
                date.setTime(+date + offset);
              }
            }
          }
          return date;
        };
        asn1.generalizedTimeToDate = function(gentime) {
          var date = /* @__PURE__ */ new Date();
          var YYYY = parseInt(gentime.substr(0, 4), 10);
          var MM = parseInt(gentime.substr(4, 2), 10) - 1;
          var DD = parseInt(gentime.substr(6, 2), 10);
          var hh = parseInt(gentime.substr(8, 2), 10);
          var mm = parseInt(gentime.substr(10, 2), 10);
          var ss = parseInt(gentime.substr(12, 2), 10);
          var fff = 0;
          var offset = 0;
          var isUTC = false;
          if (gentime.charAt(gentime.length - 1) === "Z") {
            isUTC = true;
          }
          var end = gentime.length - 5, c2 = gentime.charAt(end);
          if (c2 === "+" || c2 === "-") {
            var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
            var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
            offset = hhoffset * 60 + mmoffset;
            offset *= 6e4;
            if (c2 === "+") {
              offset *= -1;
            }
            isUTC = true;
          }
          if (gentime.charAt(14) === ".") {
            fff = parseFloat(gentime.substr(14), 10) * 1e3;
          }
          if (isUTC) {
            date.setUTCFullYear(YYYY, MM, DD);
            date.setUTCHours(hh, mm, ss, fff);
            date.setTime(+date + offset);
          } else {
            date.setFullYear(YYYY, MM, DD);
            date.setHours(hh, mm, ss, fff);
          }
          return date;
        };
        asn1.dateToUtcTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push(("" + date.getUTCFullYear()).substr(2));
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i2 = 0; i2 < format.length; ++i2) {
            if (format[i2].length < 2) {
              rval += "0";
            }
            rval += format[i2];
          }
          rval += "Z";
          return rval;
        };
        asn1.dateToGeneralizedTime = function(date) {
          if (typeof date === "string") {
            return date;
          }
          var rval = "";
          var format = [];
          format.push("" + date.getUTCFullYear());
          format.push("" + (date.getUTCMonth() + 1));
          format.push("" + date.getUTCDate());
          format.push("" + date.getUTCHours());
          format.push("" + date.getUTCMinutes());
          format.push("" + date.getUTCSeconds());
          for (var i2 = 0; i2 < format.length; ++i2) {
            if (format[i2].length < 2) {
              rval += "0";
            }
            rval += format[i2];
          }
          rval += "Z";
          return rval;
        };
        asn1.integerToDer = function(x2) {
          var rval = forge.util.createBuffer();
          if (x2 >= -128 && x2 < 128) {
            return rval.putSignedInt(x2, 8);
          }
          if (x2 >= -32768 && x2 < 32768) {
            return rval.putSignedInt(x2, 16);
          }
          if (x2 >= -8388608 && x2 < 8388608) {
            return rval.putSignedInt(x2, 24);
          }
          if (x2 >= -2147483648 && x2 < 2147483648) {
            return rval.putSignedInt(x2, 32);
          }
          var error = new Error("Integer too large; max is 32-bits.");
          error.integer = x2;
          throw error;
        };
        asn1.derToInteger = function(bytes) {
          if (typeof bytes === "string") {
            bytes = forge.util.createBuffer(bytes);
          }
          var n = bytes.length() * 8;
          if (n > 32) {
            throw new Error("Integer too large; max is 32-bits.");
          }
          return bytes.getSignedInt(n);
        };
        asn1.validate = function(obj, v2, capture, errors) {
          var rval = false;
          if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
            if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
              rval = true;
              if (v2.value && forge.util.isArray(v2.value)) {
                var j2 = 0;
                for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
                  rval = v2.value[i2].optional || false;
                  if (obj.value[j2]) {
                    rval = asn1.validate(obj.value[j2], v2.value[i2], capture, errors);
                    if (rval) {
                      ++j2;
                    } else if (v2.value[i2].optional) {
                      rval = true;
                    }
                  }
                  if (!rval && errors) {
                    errors.push(
                      "[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"'
                    );
                  }
                }
              }
              if (rval && capture) {
                if (v2.capture) {
                  capture[v2.capture] = obj.value;
                }
                if (v2.captureAsn1) {
                  capture[v2.captureAsn1] = obj;
                }
                if (v2.captureBitStringContents && "bitStringContents" in obj) {
                  capture[v2.captureBitStringContents] = obj.bitStringContents;
                }
                if (v2.captureBitStringValue && "bitStringContents" in obj) {
                  var value;
                  if (obj.bitStringContents.length < 2) {
                    capture[v2.captureBitStringValue] = "";
                  } else {
                    var unused = obj.bitStringContents.charCodeAt(0);
                    if (unused !== 0) {
                      throw new Error(
                        "captureBitStringValue only supported for zero unused bits"
                      );
                    }
                    capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
                  }
                }
              }
            } else if (errors) {
              errors.push(
                "[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"'
              );
            }
          } else if (errors) {
            if (obj.tagClass !== v2.tagClass) {
              errors.push(
                "[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"'
              );
            }
            if (obj.type !== v2.type) {
              errors.push(
                "[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"'
              );
            }
          }
          return rval;
        };
        var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
        asn1.prettyPrint = function(obj, level, indentation) {
          var rval = "";
          level = level || 0;
          indentation = indentation || 2;
          if (level > 0) {
            rval += "\n";
          }
          var indent = "";
          for (var i2 = 0; i2 < level * indentation; ++i2) {
            indent += " ";
          }
          rval += indent + "Tag: ";
          switch (obj.tagClass) {
            case asn1.Class.UNIVERSAL:
              rval += "Universal:";
              break;
            case asn1.Class.APPLICATION:
              rval += "Application:";
              break;
            case asn1.Class.CONTEXT_SPECIFIC:
              rval += "Context-Specific:";
              break;
            case asn1.Class.PRIVATE:
              rval += "Private:";
              break;
          }
          if (obj.tagClass === asn1.Class.UNIVERSAL) {
            rval += obj.type;
            switch (obj.type) {
              case asn1.Type.NONE:
                rval += " (None)";
                break;
              case asn1.Type.BOOLEAN:
                rval += " (Boolean)";
                break;
              case asn1.Type.INTEGER:
                rval += " (Integer)";
                break;
              case asn1.Type.BITSTRING:
                rval += " (Bit string)";
                break;
              case asn1.Type.OCTETSTRING:
                rval += " (Octet string)";
                break;
              case asn1.Type.NULL:
                rval += " (Null)";
                break;
              case asn1.Type.OID:
                rval += " (Object Identifier)";
                break;
              case asn1.Type.ODESC:
                rval += " (Object Descriptor)";
                break;
              case asn1.Type.EXTERNAL:
                rval += " (External or Instance of)";
                break;
              case asn1.Type.REAL:
                rval += " (Real)";
                break;
              case asn1.Type.ENUMERATED:
                rval += " (Enumerated)";
                break;
              case asn1.Type.EMBEDDED:
                rval += " (Embedded PDV)";
                break;
              case asn1.Type.UTF8:
                rval += " (UTF8)";
                break;
              case asn1.Type.ROID:
                rval += " (Relative Object Identifier)";
                break;
              case asn1.Type.SEQUENCE:
                rval += " (Sequence)";
                break;
              case asn1.Type.SET:
                rval += " (Set)";
                break;
              case asn1.Type.PRINTABLESTRING:
                rval += " (Printable String)";
                break;
              case asn1.Type.IA5String:
                rval += " (IA5String (ASCII))";
                break;
              case asn1.Type.UTCTIME:
                rval += " (UTC time)";
                break;
              case asn1.Type.GENERALIZEDTIME:
                rval += " (Generalized time)";
                break;
              case asn1.Type.BMPSTRING:
                rval += " (BMP String)";
                break;
            }
          } else {
            rval += obj.type;
          }
          rval += "\n";
          rval += indent + "Constructed: " + obj.constructed + "\n";
          if (obj.composed) {
            var subvalues = 0;
            var sub2 = "";
            for (var i2 = 0; i2 < obj.value.length; ++i2) {
              if (obj.value[i2] !== void 0) {
                subvalues += 1;
                sub2 += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
                if (i2 + 1 < obj.value.length) {
                  sub2 += ",";
                }
              }
            }
            rval += indent + "Sub values: " + subvalues + sub2;
          } else {
            rval += indent + "Value: ";
            if (obj.type === asn1.Type.OID) {
              var oid = asn1.derToOid(obj.value);
              rval += oid;
              if (forge.pki && forge.pki.oids) {
                if (oid in forge.pki.oids) {
                  rval += " (" + forge.pki.oids[oid] + ") ";
                }
              }
            }
            if (obj.type === asn1.Type.INTEGER) {
              try {
                rval += asn1.derToInteger(obj.value);
              } catch (ex) {
                rval += "0x" + forge.util.bytesToHex(obj.value);
              }
            } else if (obj.type === asn1.Type.BITSTRING) {
              if (obj.value.length > 1) {
                rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
              } else {
                rval += "(none)";
              }
              if (obj.value.length > 0) {
                var unused = obj.value.charCodeAt(0);
                if (unused == 1) {
                  rval += " (1 unused bit shown)";
                } else if (unused > 1) {
                  rval += " (" + unused + " unused bits shown)";
                }
              }
            } else if (obj.type === asn1.Type.OCTETSTRING) {
              if (!_nonLatinRegex.test(obj.value)) {
                rval += "(" + obj.value + ") ";
              }
              rval += "0x" + forge.util.bytesToHex(obj.value);
            } else if (obj.type === asn1.Type.UTF8) {
              try {
                rval += forge.util.decodeUtf8(obj.value);
              } catch (e2) {
                if (e2.message === "URI malformed") {
                  rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
                } else {
                  throw e2;
                }
              }
            } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
              rval += obj.value;
            } else if (_nonLatinRegex.test(obj.value)) {
              rval += "0x" + forge.util.bytesToHex(obj.value);
            } else if (obj.value.length === 0) {
              rval += "[null]";
            } else {
              rval += obj.value;
            }
          }
          return rval;
        };
      }
    });
    var require_md2 = __commonJS2({
      "../../node_modules/node-forge/lib/md.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        module2.exports = forge.md = forge.md || {};
        forge.md.algorithms = forge.md.algorithms || {};
      }
    });
    var require_hmac2 = __commonJS2({
      "../../node_modules/node-forge/lib/hmac.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_md2();
        require_util2();
        var hmac = module2.exports = forge.hmac = forge.hmac || {};
        hmac.create = function() {
          var _key = null;
          var _md = null;
          var _ipadding = null;
          var _opadding = null;
          var ctx = {};
          ctx.start = function(md, key) {
            if (md !== null) {
              if (typeof md === "string") {
                md = md.toLowerCase();
                if (md in forge.md.algorithms) {
                  _md = forge.md.algorithms[md].create();
                } else {
                  throw new Error('Unknown hash algorithm "' + md + '"');
                }
              } else {
                _md = md;
              }
            }
            if (key === null) {
              key = _key;
            } else {
              if (typeof key === "string") {
                key = forge.util.createBuffer(key);
              } else if (forge.util.isArray(key)) {
                var tmp = key;
                key = forge.util.createBuffer();
                for (var i2 = 0; i2 < tmp.length; ++i2) {
                  key.putByte(tmp[i2]);
                }
              }
              var keylen = key.length();
              if (keylen > _md.blockLength) {
                _md.start();
                _md.update(key.bytes());
                key = _md.digest();
              }
              _ipadding = forge.util.createBuffer();
              _opadding = forge.util.createBuffer();
              keylen = key.length();
              for (var i2 = 0; i2 < keylen; ++i2) {
                var tmp = key.at(i2);
                _ipadding.putByte(54 ^ tmp);
                _opadding.putByte(92 ^ tmp);
              }
              if (keylen < _md.blockLength) {
                var tmp = _md.blockLength - keylen;
                for (var i2 = 0; i2 < tmp; ++i2) {
                  _ipadding.putByte(54);
                  _opadding.putByte(92);
                }
              }
              _key = key;
              _ipadding = _ipadding.bytes();
              _opadding = _opadding.bytes();
            }
            _md.start();
            _md.update(_ipadding);
          };
          ctx.update = function(bytes) {
            _md.update(bytes);
          };
          ctx.getMac = function() {
            var inner = _md.digest().bytes();
            _md.start();
            _md.update(_opadding);
            _md.update(inner);
            return _md.digest();
          };
          ctx.digest = ctx.getMac;
          return ctx;
        };
      }
    });
    var require_md53 = __commonJS2({
      "../../node_modules/node-forge/lib/md5.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_md2();
        require_util2();
        var md5 = module2.exports = forge.md5 = forge.md5 || {};
        forge.md.md5 = forge.md.algorithms.md5 = md5;
        md5.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge.util.createBuffer();
          var _w = new Array(16);
          var md = {
            algorithm: "md5",
            blockLength: 64,
            digestLength: 16,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md.start = function() {
            md.messageLength = 0;
            md.fullMessageLength = md.messageLength64 = [];
            var int32s = md.messageLengthSize / 4;
            for (var i2 = 0; i2 < int32s; ++i2) {
              md.fullMessageLength.push(0);
            }
            _input = forge.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878
            };
            return md;
          };
          md.start();
          md.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
              md.fullMessageLength[i2] += len[1];
              len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
              md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md;
          };
          md.digest = function() {
            var finalBlock = forge.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
            var overflow = remaining & md.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
            var bits2, carry = 0;
            for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
              bits2 = md.fullMessageLength[i2] * 8 + carry;
              carry = bits2 / 4294967296 >>> 0;
              finalBlock.putInt32Le(bits2 >>> 0);
            }
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3
            };
            _update(s2, _w, finalBlock);
            var rval = forge.util.createBuffer();
            rval.putInt32Le(s2.h0);
            rval.putInt32Le(s2.h1);
            rval.putInt32Le(s2.h2);
            rval.putInt32Le(s2.h3);
            return rval;
          };
          return md;
        };
        var _padding = null;
        var _g = null;
        var _r = null;
        var _k = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge.util.fillString(String.fromCharCode(0), 64);
          _g = [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            1,
            6,
            11,
            0,
            5,
            10,
            15,
            4,
            9,
            14,
            3,
            8,
            13,
            2,
            7,
            12,
            5,
            8,
            11,
            14,
            1,
            4,
            7,
            10,
            13,
            0,
            3,
            6,
            9,
            12,
            15,
            2,
            0,
            7,
            14,
            5,
            12,
            3,
            10,
            1,
            8,
            15,
            6,
            13,
            4,
            11,
            2,
            9
          ];
          _r = [
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            7,
            12,
            17,
            22,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            5,
            9,
            14,
            20,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            4,
            11,
            16,
            23,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21,
            6,
            10,
            15,
            21
          ];
          _k = new Array(64);
          for (var i2 = 0; i2 < 64; ++i2) {
            _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
          }
          _initialized = true;
        }
        function _update(s2, w2, bytes) {
          var t, a2, b2, c2, d, f2, r2, i2;
          var len = bytes.length();
          while (len >= 64) {
            a2 = s2.h0;
            b2 = s2.h1;
            c2 = s2.h2;
            d = s2.h3;
            for (i2 = 0; i2 < 16; ++i2) {
              w2[i2] = bytes.getInt32Le();
              f2 = d ^ b2 & (c2 ^ d);
              t = a2 + f2 + _k[i2] + w2[i2];
              r2 = _r[i2];
              a2 = d;
              d = c2;
              c2 = b2;
              b2 += t << r2 | t >>> 32 - r2;
            }
            for (; i2 < 32; ++i2) {
              f2 = c2 ^ d & (b2 ^ c2);
              t = a2 + f2 + _k[i2] + w2[_g[i2]];
              r2 = _r[i2];
              a2 = d;
              d = c2;
              c2 = b2;
              b2 += t << r2 | t >>> 32 - r2;
            }
            for (; i2 < 48; ++i2) {
              f2 = b2 ^ c2 ^ d;
              t = a2 + f2 + _k[i2] + w2[_g[i2]];
              r2 = _r[i2];
              a2 = d;
              d = c2;
              c2 = b2;
              b2 += t << r2 | t >>> 32 - r2;
            }
            for (; i2 < 64; ++i2) {
              f2 = c2 ^ (b2 | ~d);
              t = a2 + f2 + _k[i2] + w2[_g[i2]];
              r2 = _r[i2];
              a2 = d;
              d = c2;
              c2 = b2;
              b2 += t << r2 | t >>> 32 - r2;
            }
            s2.h0 = s2.h0 + a2 | 0;
            s2.h1 = s2.h1 + b2 | 0;
            s2.h2 = s2.h2 + c2 | 0;
            s2.h3 = s2.h3 + d | 0;
            len -= 64;
          }
        }
      }
    });
    var require_pem2 = __commonJS2({
      "../../node_modules/node-forge/lib/pem.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        var pem = module2.exports = forge.pem = forge.pem || {};
        pem.encode = function(msg, options) {
          options = options || {};
          var rval = "-----BEGIN " + msg.type + "-----\r\n";
          var header;
          if (msg.procType) {
            header = {
              name: "Proc-Type",
              values: [String(msg.procType.version), msg.procType.type]
            };
            rval += foldHeader(header);
          }
          if (msg.contentDomain) {
            header = { name: "Content-Domain", values: [msg.contentDomain] };
            rval += foldHeader(header);
          }
          if (msg.dekInfo) {
            header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
            if (msg.dekInfo.parameters) {
              header.values.push(msg.dekInfo.parameters);
            }
            rval += foldHeader(header);
          }
          if (msg.headers) {
            for (var i2 = 0; i2 < msg.headers.length; ++i2) {
              rval += foldHeader(msg.headers[i2]);
            }
          }
          if (msg.procType) {
            rval += "\r\n";
          }
          rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
          rval += "-----END " + msg.type + "-----\r\n";
          return rval;
        };
        pem.decode = function(str) {
          var rval = [];
          var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
          var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
          var rCRLF = /\r?\n/;
          var match2;
          while (true) {
            match2 = rMessage.exec(str);
            if (!match2) {
              break;
            }
            var type = match2[1];
            if (type === "NEW CERTIFICATE REQUEST") {
              type = "CERTIFICATE REQUEST";
            }
            var msg = {
              type,
              procType: null,
              contentDomain: null,
              dekInfo: null,
              headers: [],
              body: forge.util.decode64(match2[3])
            };
            rval.push(msg);
            if (!match2[2]) {
              continue;
            }
            var lines = match2[2].split(rCRLF);
            var li = 0;
            while (match2 && li < lines.length) {
              var line2 = lines[li].replace(/\s+$/, "");
              for (var nl = li + 1; nl < lines.length; ++nl) {
                var next2 = lines[nl];
                if (!/\s/.test(next2[0])) {
                  break;
                }
                line2 += next2;
                li = nl;
              }
              match2 = line2.match(rHeader);
              if (match2) {
                var header = { name: match2[1], values: [] };
                var values = match2[2].split(",");
                for (var vi = 0; vi < values.length; ++vi) {
                  header.values.push(ltrim(values[vi]));
                }
                if (!msg.procType) {
                  if (header.name !== "Proc-Type") {
                    throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                  } else if (header.values.length !== 2) {
                    throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                  }
                  msg.procType = { version: values[0], type: values[1] };
                } else if (!msg.contentDomain && header.name === "Content-Domain") {
                  msg.contentDomain = values[0] || "";
                } else if (!msg.dekInfo && header.name === "DEK-Info") {
                  if (header.values.length === 0) {
                    throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                  }
                  msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
                } else {
                  msg.headers.push(header);
                }
              }
              ++li;
            }
            if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
            }
          }
          if (rval.length === 0) {
            throw new Error("Invalid PEM formatted message.");
          }
          return rval;
        };
        function foldHeader(header) {
          var rval = header.name + ": ";
          var values = [];
          var insertSpace = function(match2, $1) {
            return " " + $1;
          };
          for (var i2 = 0; i2 < header.values.length; ++i2) {
            values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
          }
          rval += values.join(",") + "\r\n";
          var length2 = 0;
          var candidate = -1;
          for (var i2 = 0; i2 < rval.length; ++i2, ++length2) {
            if (length2 > 65 && candidate !== -1) {
              var insert = rval[candidate];
              if (insert === ",") {
                ++candidate;
                rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
              } else {
                rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
              }
              length2 = i2 - candidate - 1;
              candidate = -1;
              ++i2;
            } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
              candidate = i2;
            }
          }
          return rval;
        }
        function ltrim(str) {
          return str.replace(/^\s+/, "");
        }
      }
    });
    var require_des2 = __commonJS2({
      "../../node_modules/node-forge/lib/des.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_cipher2();
        require_cipherModes2();
        require_util2();
        module2.exports = forge.des = forge.des || {};
        forge.des.startEncrypting = function(key, iv, output, mode) {
          var cipher = _createCipher({
            key,
            output,
            decrypt: false,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher.start(iv);
          return cipher;
        };
        forge.des.createEncryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: false,
            mode
          });
        };
        forge.des.startDecrypting = function(key, iv, output, mode) {
          var cipher = _createCipher({
            key,
            output,
            decrypt: true,
            mode: mode || (iv === null ? "ECB" : "CBC")
          });
          cipher.start(iv);
          return cipher;
        };
        forge.des.createDecryptionCipher = function(key, mode) {
          return _createCipher({
            key,
            output: null,
            decrypt: true,
            mode
          });
        };
        forge.des.Algorithm = function(name, mode) {
          var self2 = this;
          self2.name = name;
          self2.mode = new mode({
            blockSize: 8,
            cipher: {
              encrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, false);
              },
              decrypt: function(inBlock, outBlock) {
                return _updateBlock(self2._keys, inBlock, outBlock, true);
              }
            }
          });
          self2._init = false;
        };
        forge.des.Algorithm.prototype.initialize = function(options) {
          if (this._init) {
            return;
          }
          var key = forge.util.createBuffer(options.key);
          if (this.name.indexOf("3DES") === 0) {
            if (key.length() !== 24) {
              throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
            }
          }
          this._keys = _createKeys(key);
          this._init = true;
        };
        registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
        registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
        registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
        registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
        registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
        registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
        registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
        registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
        registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
        registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
        function registerAlgorithm(name, mode) {
          var factory = function() {
            return new forge.des.Algorithm(name, mode);
          };
          forge.cipher.registerAlgorithm(name, factory);
        }
        var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
        var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
        var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
        var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
        var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
        var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
        var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
        var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
        function _createKeys(key) {
          var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
          var iterations = key.length() > 8 ? 3 : 1;
          var keys = [];
          var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
          var n = 0, tmp;
          for (var j2 = 0; j2 < iterations; j2++) {
            var left = key.getInt32();
            var right = key.getInt32();
            tmp = (left >>> 4 ^ right) & 252645135;
            right ^= tmp;
            left ^= tmp << 4;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 2 ^ right) & 858993459;
            right ^= tmp;
            left ^= tmp << 2;
            tmp = (right >>> -16 ^ left) & 65535;
            left ^= tmp;
            right ^= tmp << -16;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = (right >>> 8 ^ left) & 16711935;
            left ^= tmp;
            right ^= tmp << 8;
            tmp = (left >>> 1 ^ right) & 1431655765;
            right ^= tmp;
            left ^= tmp << 1;
            tmp = left << 8 | right >>> 20 & 240;
            left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
            right = tmp;
            for (var i2 = 0; i2 < shifts.length; ++i2) {
              if (shifts[i2]) {
                left = left << 2 | left >>> 26;
                right = right << 2 | right >>> 26;
              } else {
                left = left << 1 | left >>> 27;
                right = right << 1 | right >>> 27;
              }
              left &= -15;
              right &= -15;
              var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
              var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
              tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
              keys[n++] = lefttmp ^ tmp;
              keys[n++] = righttmp ^ tmp << 16;
            }
          }
          return keys;
        }
        function _updateBlock(keys, input, output, decrypt) {
          var iterations = keys.length === 32 ? 3 : 9;
          var looping;
          if (iterations === 3) {
            looping = decrypt ? [30, -2, -2] : [0, 32, 2];
          } else {
            looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
          }
          var tmp;
          var left = input[0];
          var right = input[1];
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          left = left << 1 | left >>> 31;
          right = right << 1 | right >>> 31;
          for (var j2 = 0; j2 < iterations; j2 += 3) {
            var endloop = looping[j2 + 1];
            var loopinc = looping[j2 + 2];
            for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
              var right1 = right ^ keys[i2];
              var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
              tmp = left;
              left = right;
              right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
            }
            tmp = left;
            left = right;
            right = tmp;
          }
          left = left >>> 1 | left << 31;
          right = right >>> 1 | right << 31;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (right >>> 2 ^ left) & 858993459;
          left ^= tmp;
          right ^= tmp << 2;
          tmp = (left >>> 16 ^ right) & 65535;
          right ^= tmp;
          left ^= tmp << 16;
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          output[0] = left;
          output[1] = right;
        }
        function _createCipher(options) {
          options = options || {};
          var mode = (options.mode || "CBC").toUpperCase();
          var algorithm = "DES-" + mode;
          var cipher;
          if (options.decrypt) {
            cipher = forge.cipher.createDecipher(algorithm, options.key);
          } else {
            cipher = forge.cipher.createCipher(algorithm, options.key);
          }
          var start = cipher.start;
          cipher.start = function(iv, options2) {
            var output = null;
            if (options2 instanceof forge.util.ByteBuffer) {
              output = options2;
              options2 = {};
            }
            options2 = options2 || {};
            options2.output = output;
            options2.iv = iv;
            start.call(cipher, options2);
          };
          return cipher;
        }
      }
    });
    var require_pbkdf22 = __commonJS2({
      "../../node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_hmac2();
        require_md2();
        require_util2();
        var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
        var crypto2;
        if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
          crypto2 = require_crypto_browserify();
        }
        module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s2, c2, dkLen, md, callback) {
          if (typeof md === "function") {
            callback = md;
            md = null;
          }
          if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
            if (typeof md !== "string") {
              md = "sha1";
            }
            p2 = Buffer.from(p2, "binary");
            s2 = Buffer.from(s2, "binary");
            if (!callback) {
              if (crypto2.pbkdf2Sync.length === 4) {
                return crypto2.pbkdf2Sync(p2, s2, c2, dkLen).toString("binary");
              }
              return crypto2.pbkdf2Sync(p2, s2, c2, dkLen, md).toString("binary");
            }
            if (crypto2.pbkdf2Sync.length === 4) {
              return crypto2.pbkdf2(p2, s2, c2, dkLen, function(err2, key) {
                if (err2) {
                  return callback(err2);
                }
                callback(null, key.toString("binary"));
              });
            }
            return crypto2.pbkdf2(p2, s2, c2, dkLen, md, function(err2, key) {
              if (err2) {
                return callback(err2);
              }
              callback(null, key.toString("binary"));
            });
          }
          if (typeof md === "undefined" || md === null) {
            md = "sha1";
          }
          if (typeof md === "string") {
            if (!(md in forge.md.algorithms)) {
              throw new Error("Unknown hash algorithm: " + md);
            }
            md = forge.md[md].create();
          }
          var hLen = md.digestLength;
          if (dkLen > 4294967295 * hLen) {
            var err = new Error("Derived key is too long.");
            if (callback) {
              return callback(err);
            }
            throw err;
          }
          var len = Math.ceil(dkLen / hLen);
          var r2 = dkLen - (len - 1) * hLen;
          var prf = forge.hmac.create();
          prf.start(md, p2);
          var dk = "";
          var xor, u_c, u_c1;
          if (!callback) {
            for (var i2 = 1; i2 <= len; ++i2) {
              prf.start(null, null);
              prf.update(s2);
              prf.update(forge.util.int32ToBytes(i2));
              xor = u_c1 = prf.digest().getBytes();
              for (var j2 = 2; j2 <= c2; ++j2) {
                prf.start(null, null);
                prf.update(u_c1);
                u_c = prf.digest().getBytes();
                xor = forge.util.xorBytes(xor, u_c, hLen);
                u_c1 = u_c;
              }
              dk += i2 < len ? xor : xor.substr(0, r2);
            }
            return dk;
          }
          var i2 = 1, j2;
          function outer() {
            if (i2 > len) {
              return callback(null, dk);
            }
            prf.start(null, null);
            prf.update(s2);
            prf.update(forge.util.int32ToBytes(i2));
            xor = u_c1 = prf.digest().getBytes();
            j2 = 2;
            inner();
          }
          function inner() {
            if (j2 <= c2) {
              prf.start(null, null);
              prf.update(u_c1);
              u_c = prf.digest().getBytes();
              xor = forge.util.xorBytes(xor, u_c, hLen);
              u_c1 = u_c;
              ++j2;
              return forge.util.setImmediate(inner);
            }
            dk += i2 < len ? xor : xor.substr(0, r2);
            ++i2;
            outer();
          }
          outer();
        };
      }
    });
    var require_sha2562 = __commonJS2({
      "../../node_modules/node-forge/lib/sha256.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_md2();
        require_util2();
        var sha256 = module2.exports = forge.sha256 = forge.sha256 || {};
        forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
        sha256.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge.util.createBuffer();
          var _w = new Array(64);
          var md = {
            algorithm: "sha256",
            blockLength: 64,
            digestLength: 32,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md.start = function() {
            md.messageLength = 0;
            md.fullMessageLength = md.messageLength64 = [];
            var int32s = md.messageLengthSize / 4;
            for (var i2 = 0; i2 < int32s; ++i2) {
              md.fullMessageLength.push(0);
            }
            _input = forge.util.createBuffer();
            _state = {
              h0: 1779033703,
              h1: 3144134277,
              h2: 1013904242,
              h3: 2773480762,
              h4: 1359893119,
              h5: 2600822924,
              h6: 528734635,
              h7: 1541459225
            };
            return md;
          };
          md.start();
          md.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
              md.fullMessageLength[i2] += len[1];
              len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
              md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md;
          };
          md.digest = function() {
            var finalBlock = forge.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
            var overflow = remaining & md.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
            var next2, carry;
            var bits2 = md.fullMessageLength[0] * 8;
            for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
              next2 = md.fullMessageLength[i2 + 1] * 8;
              carry = next2 / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next2 >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4,
              h5: _state.h5,
              h6: _state.h6,
              h7: _state.h7
            };
            _update(s2, _w, finalBlock);
            var rval = forge.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            rval.putInt32(s2.h5);
            rval.putInt32(s2.h6);
            rval.putInt32(s2.h7);
            return rval;
          };
          return md;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge.util.fillString(String.fromCharCode(0), 64);
          _k = [
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ];
          _initialized = true;
        }
        function _update(s2, w2, bytes) {
          var t1, t2, s0, s1, ch, maj, i2, a2, b2, c2, d, e2, f2, g2, h;
          var len = bytes.length();
          while (len >= 64) {
            for (i2 = 0; i2 < 16; ++i2) {
              w2[i2] = bytes.getInt32();
            }
            for (; i2 < 64; ++i2) {
              t1 = w2[i2 - 2];
              t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
              t2 = w2[i2 - 15];
              t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
              w2[i2] = t1 + w2[i2 - 7] + t2 + w2[i2 - 16] | 0;
            }
            a2 = s2.h0;
            b2 = s2.h1;
            c2 = s2.h2;
            d = s2.h3;
            e2 = s2.h4;
            f2 = s2.h5;
            g2 = s2.h6;
            h = s2.h7;
            for (i2 = 0; i2 < 64; ++i2) {
              s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
              ch = g2 ^ e2 & (f2 ^ g2);
              s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
              maj = a2 & b2 | c2 & (a2 ^ b2);
              t1 = h + s1 + ch + _k[i2] + w2[i2];
              t2 = s0 + maj;
              h = g2;
              g2 = f2;
              f2 = e2;
              e2 = d + t1 >>> 0;
              d = c2;
              c2 = b2;
              b2 = a2;
              a2 = t1 + t2 >>> 0;
            }
            s2.h0 = s2.h0 + a2 | 0;
            s2.h1 = s2.h1 + b2 | 0;
            s2.h2 = s2.h2 + c2 | 0;
            s2.h3 = s2.h3 + d | 0;
            s2.h4 = s2.h4 + e2 | 0;
            s2.h5 = s2.h5 + f2 | 0;
            s2.h6 = s2.h6 + g2 | 0;
            s2.h7 = s2.h7 + h | 0;
            len -= 64;
          }
        }
      }
    });
    var require_prng2 = __commonJS2({
      "../../node_modules/node-forge/lib/prng.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        var _crypto = null;
        if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
          _crypto = require_crypto_browserify();
        }
        var prng = module2.exports = forge.prng = forge.prng || {};
        prng.create = function(plugin) {
          var ctx = {
            plugin,
            key: null,
            seed: null,
            time: null,
            // number of reseeds so far
            reseeds: 0,
            // amount of data generated so far
            generated: 0,
            // no initial key bytes
            keyBytes: ""
          };
          var md = plugin.md;
          var pools = new Array(32);
          for (var i2 = 0; i2 < 32; ++i2) {
            pools[i2] = md.create();
          }
          ctx.pools = pools;
          ctx.pool = 0;
          ctx.generate = function(count, callback) {
            if (!callback) {
              return ctx.generateSync(count);
            }
            var cipher = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            var b2 = forge.util.createBuffer();
            ctx.key = null;
            generate();
            function generate(err) {
              if (err) {
                return callback(err);
              }
              if (b2.length() >= count) {
                return callback(null, b2.getBytes(count));
              }
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                return forge.util.nextTick(function() {
                  _reseed(generate);
                });
              }
              var bytes = cipher(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b2.putBytes(bytes);
              ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
              forge.util.setImmediate(generate);
            }
          };
          ctx.generateSync = function(count) {
            var cipher = ctx.plugin.cipher;
            var increment = ctx.plugin.increment;
            var formatKey = ctx.plugin.formatKey;
            var formatSeed = ctx.plugin.formatSeed;
            ctx.key = null;
            var b2 = forge.util.createBuffer();
            while (b2.length() < count) {
              if (ctx.generated > 1048575) {
                ctx.key = null;
              }
              if (ctx.key === null) {
                _reseedSync();
              }
              var bytes = cipher(ctx.key, ctx.seed);
              ctx.generated += bytes.length;
              b2.putBytes(bytes);
              ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
              ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
            }
            return b2.getBytes(count);
          };
          function _reseed(callback) {
            if (ctx.pools[0].messageLength >= 32) {
              _seed();
              return callback();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.seedFile(needed, function(err, bytes) {
              if (err) {
                return callback(err);
              }
              ctx.collect(bytes);
              _seed();
              callback();
            });
          }
          function _reseedSync() {
            if (ctx.pools[0].messageLength >= 32) {
              return _seed();
            }
            var needed = 32 - ctx.pools[0].messageLength << 5;
            ctx.collect(ctx.seedFileSync(needed));
            _seed();
          }
          function _seed() {
            ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
            var md2 = ctx.plugin.md.create();
            md2.update(ctx.keyBytes);
            var _2powK = 1;
            for (var k2 = 0; k2 < 32; ++k2) {
              if (ctx.reseeds % _2powK === 0) {
                md2.update(ctx.pools[k2].digest().getBytes());
                ctx.pools[k2].start();
              }
              _2powK = _2powK << 1;
            }
            ctx.keyBytes = md2.digest().getBytes();
            md2.start();
            md2.update(ctx.keyBytes);
            var seedBytes = md2.digest().getBytes();
            ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
            ctx.seed = ctx.plugin.formatSeed(seedBytes);
            ctx.generated = 0;
          }
          function defaultSeedFile(needed) {
            var getRandomValues = null;
            var globalScope = forge.util.globalScope;
            var _crypto2 = globalScope.crypto || globalScope.msCrypto;
            if (_crypto2 && _crypto2.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto2.getRandomValues(arr);
              };
            }
            var b2 = forge.util.createBuffer();
            if (getRandomValues) {
              while (b2.length() < needed) {
                var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
                var entropy = new Uint32Array(Math.floor(count));
                try {
                  getRandomValues(entropy);
                  for (var i22 = 0; i22 < entropy.length; ++i22) {
                    b2.putInt32(entropy[i22]);
                  }
                } catch (e2) {
                  if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                    throw e2;
                  }
                }
              }
            }
            if (b2.length() < needed) {
              var hi, lo, next2;
              var seed = Math.floor(Math.random() * 65536);
              while (b2.length() < needed) {
                lo = 16807 * (seed & 65535);
                hi = 16807 * (seed >> 16);
                lo += (hi & 32767) << 16;
                lo += hi >> 15;
                lo = (lo & 2147483647) + (lo >> 31);
                seed = lo & 4294967295;
                for (var i22 = 0; i22 < 3; ++i22) {
                  next2 = seed >>> (i22 << 3);
                  next2 ^= Math.floor(Math.random() * 256);
                  b2.putByte(next2 & 255);
                }
              }
            }
            return b2.getBytes(needed);
          }
          if (_crypto) {
            ctx.seedFile = function(needed, callback) {
              _crypto.randomBytes(needed, function(err, bytes) {
                if (err) {
                  return callback(err);
                }
                callback(null, bytes.toString());
              });
            };
            ctx.seedFileSync = function(needed) {
              return _crypto.randomBytes(needed).toString();
            };
          } else {
            ctx.seedFile = function(needed, callback) {
              try {
                callback(null, defaultSeedFile(needed));
              } catch (e2) {
                callback(e2);
              }
            };
            ctx.seedFileSync = defaultSeedFile;
          }
          ctx.collect = function(bytes) {
            var count = bytes.length;
            for (var i22 = 0; i22 < count; ++i22) {
              ctx.pools[ctx.pool].update(bytes.substr(i22, 1));
              ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
            }
          };
          ctx.collectInt = function(i22, n) {
            var bytes = "";
            for (var x2 = 0; x2 < n; x2 += 8) {
              bytes += String.fromCharCode(i22 >> x2 & 255);
            }
            ctx.collect(bytes);
          };
          ctx.registerWorker = function(worker) {
            if (worker === self) {
              ctx.seedFile = function(needed, callback) {
                function listener2(e2) {
                  var data = e2.data;
                  if (data.forge && data.forge.prng) {
                    self.removeEventListener("message", listener2);
                    callback(data.forge.prng.err, data.forge.prng.bytes);
                  }
                }
                self.addEventListener("message", listener2);
                self.postMessage({ forge: { prng: { needed } } });
              };
            } else {
              var listener = function(e2) {
                var data = e2.data;
                if (data.forge && data.forge.prng) {
                  ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                    worker.postMessage({ forge: { prng: { err, bytes } } });
                  });
                }
              };
              worker.addEventListener("message", listener);
            }
          };
          return ctx;
        };
      }
    });
    var require_random2 = __commonJS2({
      "../../node_modules/node-forge/lib/random.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_sha2562();
        require_prng2();
        require_util2();
        (function() {
          if (forge.random && forge.random.getBytes) {
            module2.exports = forge.random;
            return;
          }
          (function(jQuery2) {
            var prng_aes = {};
            var _prng_aes_output = new Array(4);
            var _prng_aes_buffer = forge.util.createBuffer();
            prng_aes.formatKey = function(key2) {
              var tmp = forge.util.createBuffer(key2);
              key2 = new Array(4);
              key2[0] = tmp.getInt32();
              key2[1] = tmp.getInt32();
              key2[2] = tmp.getInt32();
              key2[3] = tmp.getInt32();
              return forge.aes._expandKey(key2, false);
            };
            prng_aes.formatSeed = function(seed) {
              var tmp = forge.util.createBuffer(seed);
              seed = new Array(4);
              seed[0] = tmp.getInt32();
              seed[1] = tmp.getInt32();
              seed[2] = tmp.getInt32();
              seed[3] = tmp.getInt32();
              return seed;
            };
            prng_aes.cipher = function(key2, seed) {
              forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
              _prng_aes_buffer.putInt32(_prng_aes_output[0]);
              _prng_aes_buffer.putInt32(_prng_aes_output[1]);
              _prng_aes_buffer.putInt32(_prng_aes_output[2]);
              _prng_aes_buffer.putInt32(_prng_aes_output[3]);
              return _prng_aes_buffer.getBytes();
            };
            prng_aes.increment = function(seed) {
              ++seed[3];
              return seed;
            };
            prng_aes.md = forge.md.sha256;
            function spawnPrng() {
              var ctx = forge.prng.create(prng_aes);
              ctx.getBytes = function(count, callback) {
                return ctx.generate(count, callback);
              };
              ctx.getBytesSync = function(count) {
                return ctx.generate(count);
              };
              return ctx;
            }
            var _ctx = spawnPrng();
            var getRandomValues = null;
            var globalScope = forge.util.globalScope;
            var _crypto = globalScope.crypto || globalScope.msCrypto;
            if (_crypto && _crypto.getRandomValues) {
              getRandomValues = function(arr) {
                return _crypto.getRandomValues(arr);
              };
            }
            if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
              if (typeof window === "undefined" || window.document === void 0) {
              }
              _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
              if (typeof navigator !== "undefined") {
                var _navBytes = "";
                for (var key in navigator) {
                  try {
                    if (typeof navigator[key] == "string") {
                      _navBytes += navigator[key];
                    }
                  } catch (e2) {
                  }
                }
                _ctx.collect(_navBytes);
                _navBytes = null;
              }
              if (jQuery2) {
                jQuery2().mousemove(function(e2) {
                  _ctx.collectInt(e2.clientX, 16);
                  _ctx.collectInt(e2.clientY, 16);
                });
                jQuery2().keypress(function(e2) {
                  _ctx.collectInt(e2.charCode, 8);
                });
              }
            }
            if (!forge.random) {
              forge.random = _ctx;
            } else {
              for (var key in _ctx) {
                forge.random[key] = _ctx[key];
              }
            }
            forge.random.createInstance = spawnPrng;
            module2.exports = forge.random;
          })(typeof jQuery !== "undefined" ? jQuery : null);
        })();
      }
    });
    var require_rc22 = __commonJS2({
      "../../node_modules/node-forge/lib/rc2.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        var piTable = [
          217,
          120,
          249,
          196,
          25,
          221,
          181,
          237,
          40,
          233,
          253,
          121,
          74,
          160,
          216,
          157,
          198,
          126,
          55,
          131,
          43,
          118,
          83,
          142,
          98,
          76,
          100,
          136,
          68,
          139,
          251,
          162,
          23,
          154,
          89,
          245,
          135,
          179,
          79,
          19,
          97,
          69,
          109,
          141,
          9,
          129,
          125,
          50,
          189,
          143,
          64,
          235,
          134,
          183,
          123,
          11,
          240,
          149,
          33,
          34,
          92,
          107,
          78,
          130,
          84,
          214,
          101,
          147,
          206,
          96,
          178,
          28,
          115,
          86,
          192,
          20,
          167,
          140,
          241,
          220,
          18,
          117,
          202,
          31,
          59,
          190,
          228,
          209,
          66,
          61,
          212,
          48,
          163,
          60,
          182,
          38,
          111,
          191,
          14,
          218,
          70,
          105,
          7,
          87,
          39,
          242,
          29,
          155,
          188,
          148,
          67,
          3,
          248,
          17,
          199,
          246,
          144,
          239,
          62,
          231,
          6,
          195,
          213,
          47,
          200,
          102,
          30,
          215,
          8,
          232,
          234,
          222,
          128,
          82,
          238,
          247,
          132,
          170,
          114,
          172,
          53,
          77,
          106,
          42,
          150,
          26,
          210,
          113,
          90,
          21,
          73,
          116,
          75,
          159,
          208,
          94,
          4,
          24,
          164,
          236,
          194,
          224,
          65,
          110,
          15,
          81,
          203,
          204,
          36,
          145,
          175,
          80,
          161,
          244,
          112,
          57,
          153,
          124,
          58,
          133,
          35,
          184,
          180,
          122,
          252,
          2,
          54,
          91,
          37,
          85,
          151,
          49,
          45,
          93,
          250,
          152,
          227,
          138,
          146,
          174,
          5,
          223,
          41,
          16,
          103,
          108,
          186,
          201,
          211,
          0,
          230,
          207,
          225,
          158,
          168,
          44,
          99,
          22,
          1,
          63,
          88,
          226,
          137,
          169,
          13,
          56,
          52,
          27,
          171,
          51,
          255,
          176,
          187,
          72,
          12,
          95,
          185,
          177,
          205,
          46,
          197,
          243,
          219,
          71,
          229,
          165,
          156,
          119,
          10,
          166,
          32,
          104,
          254,
          127,
          193,
          173
        ];
        var s2 = [1, 2, 3, 5];
        var rol = function(word, bits2) {
          return word << bits2 & 65535 | (word & 65535) >> 16 - bits2;
        };
        var ror = function(word, bits2) {
          return (word & 65535) >> bits2 | word << 16 - bits2 & 65535;
        };
        module2.exports = forge.rc2 = forge.rc2 || {};
        forge.rc2.expandKey = function(key, effKeyBits) {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          }
          effKeyBits = effKeyBits || 128;
          var L2 = key;
          var T2 = key.length();
          var T1 = effKeyBits;
          var T8 = Math.ceil(T1 / 8);
          var TM = 255 >> (T1 & 7);
          var i2;
          for (i2 = T2; i2 < 128; i2++) {
            L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T2) & 255]);
          }
          L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
          for (i2 = 127 - T8; i2 >= 0; i2--) {
            L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
          }
          return L2;
        };
        var createCipher = function(key, bits2, encrypt) {
          var _finish = false, _input = null, _output = null, _iv = null;
          var mixRound, mashRound;
          var i2, j2, K2 = [];
          key = forge.rc2.expandKey(key, bits2);
          for (i2 = 0; i2 < 64; i2++) {
            K2.push(key.getInt16Le());
          }
          if (encrypt) {
            mixRound = function(R2) {
              for (i2 = 0; i2 < 4; i2++) {
                R2[i2] += K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
                R2[i2] = rol(R2[i2], s2[i2]);
                j2++;
              }
            };
            mashRound = function(R2) {
              for (i2 = 0; i2 < 4; i2++) {
                R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
              }
            };
          } else {
            mixRound = function(R2) {
              for (i2 = 3; i2 >= 0; i2--) {
                R2[i2] = ror(R2[i2], s2[i2]);
                R2[i2] -= K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
                j2--;
              }
            };
            mashRound = function(R2) {
              for (i2 = 3; i2 >= 0; i2--) {
                R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
              }
            };
          }
          var runPlan = function(plan) {
            var R2 = [];
            for (i2 = 0; i2 < 4; i2++) {
              var val = _input.getInt16Le();
              if (_iv !== null) {
                if (encrypt) {
                  val ^= _iv.getInt16Le();
                } else {
                  _iv.putInt16Le(val);
                }
              }
              R2.push(val & 65535);
            }
            j2 = encrypt ? 0 : 63;
            for (var ptr = 0; ptr < plan.length; ptr++) {
              for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
                plan[ptr][1](R2);
              }
            }
            for (i2 = 0; i2 < 4; i2++) {
              if (_iv !== null) {
                if (encrypt) {
                  _iv.putInt16Le(R2[i2]);
                } else {
                  R2[i2] ^= _iv.getInt16Le();
                }
              }
              _output.putInt16Le(R2[i2]);
            }
          };
          var cipher = null;
          cipher = {
            /**
             * Starts or restarts the encryption or decryption process, whichever
             * was previously configured.
             *
             * To use the cipher in CBC mode, iv may be given either as a string
             * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
             *
             * @param iv the initialization vector to use, null for ECB mode.
             * @param output the output the buffer to write to, null to create one.
             */
            start: function(iv, output) {
              if (iv) {
                if (typeof iv === "string") {
                  iv = forge.util.createBuffer(iv);
                }
              }
              _finish = false;
              _input = forge.util.createBuffer();
              _output = output || new forge.util.createBuffer();
              _iv = iv;
              cipher.output = _output;
            },
            /**
             * Updates the next block.
             *
             * @param input the buffer to read from.
             */
            update: function(input) {
              if (!_finish) {
                _input.putBuffer(input);
              }
              while (_input.length() >= 8) {
                runPlan([
                  [5, mixRound],
                  [1, mashRound],
                  [6, mixRound],
                  [1, mashRound],
                  [5, mixRound]
                ]);
              }
            },
            /**
             * Finishes encrypting or decrypting.
             *
             * @param pad a padding function to use, null for PKCS#7 padding,
             *           signature(blockSize, buffer, decrypt).
             *
             * @return true if successful, false on error.
             */
            finish: function(pad) {
              var rval = true;
              if (encrypt) {
                if (pad) {
                  rval = pad(8, _input, !encrypt);
                } else {
                  var padding = _input.length() === 8 ? 8 : 8 - _input.length();
                  _input.fillWithByte(padding, padding);
                }
              }
              if (rval) {
                _finish = true;
                cipher.update();
              }
              if (!encrypt) {
                rval = _input.length() === 0;
                if (rval) {
                  if (pad) {
                    rval = pad(8, _output, !encrypt);
                  } else {
                    var len = _output.length();
                    var count = _output.at(len - 1);
                    if (count > len) {
                      rval = false;
                    } else {
                      _output.truncate(count);
                    }
                  }
                }
              }
              return rval;
            }
          };
          return cipher;
        };
        forge.rc2.startEncrypting = function(key, iv, output) {
          var cipher = forge.rc2.createEncryptionCipher(key, 128);
          cipher.start(iv, output);
          return cipher;
        };
        forge.rc2.createEncryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, true);
        };
        forge.rc2.startDecrypting = function(key, iv, output) {
          var cipher = forge.rc2.createDecryptionCipher(key, 128);
          cipher.start(iv, output);
          return cipher;
        };
        forge.rc2.createDecryptionCipher = function(key, bits2) {
          return createCipher(key, bits2, false);
        };
      }
    });
    var require_jsbn2 = __commonJS2({
      "../../node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        module2.exports = forge.jsbn = forge.jsbn || {};
        var dbits;
        var canary = 244837814094590;
        var j_lm = (canary & 16777215) == 15715070;
        function BigInteger(a2, b2, c2) {
          this.data = [];
          if (a2 != null)
            if ("number" == typeof a2)
              this.fromNumber(a2, b2, c2);
            else if (b2 == null && "string" != typeof a2)
              this.fromString(a2, 256);
            else
              this.fromString(a2, b2);
        }
        forge.jsbn.BigInteger = BigInteger;
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i2, x2, w2, j2, c2, n) {
          while (--n >= 0) {
            var v2 = x2 * this.data[i2++] + w2.data[j2] + c2;
            c2 = Math.floor(v2 / 67108864);
            w2.data[j2++] = v2 & 67108863;
          }
          return c2;
        }
        function am2(i2, x2, w2, j2, c2, n) {
          var xl = x2 & 32767, xh = x2 >> 15;
          while (--n >= 0) {
            var l2 = this.data[i2] & 32767;
            var h = this.data[i2++] >> 15;
            var m2 = xh * l2 + h * xl;
            l2 = xl * l2 + ((m2 & 32767) << 15) + w2.data[j2] + (c2 & 1073741823);
            c2 = (l2 >>> 30) + (m2 >>> 15) + xh * h + (c2 >>> 30);
            w2.data[j2++] = l2 & 1073741823;
          }
          return c2;
        }
        function am3(i2, x2, w2, j2, c2, n) {
          var xl = x2 & 16383, xh = x2 >> 14;
          while (--n >= 0) {
            var l2 = this.data[i2] & 16383;
            var h = this.data[i2++] >> 14;
            var m2 = xh * l2 + h * xl;
            l2 = xl * l2 + ((m2 & 16383) << 14) + w2.data[j2] + c2;
            c2 = (l2 >> 28) + (m2 >> 14) + xh * h;
            w2.data[j2++] = l2 & 268435455;
          }
          return c2;
        }
        if (typeof navigator === "undefined") {
          BigInteger.prototype.am = am3;
          dbits = 28;
        } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (j_lm && navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr;
        var vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv)
          BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv)
          BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv)
          BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s2, i2) {
          var c2 = BI_RC[s2.charCodeAt(i2)];
          return c2 == null ? -1 : c2;
        }
        function bnpCopyTo(r2) {
          for (var i2 = this.t - 1; i2 >= 0; --i2)
            r2.data[i2] = this.data[i2];
          r2.t = this.t;
          r2.s = this.s;
        }
        function bnpFromInt(x2) {
          this.t = 1;
          this.s = x2 < 0 ? -1 : 0;
          if (x2 > 0)
            this.data[0] = x2;
          else if (x2 < -1)
            this.data[0] = x2 + this.DV;
          else
            this.t = 0;
        }
        function nbv(i2) {
          var r2 = nbi();
          r2.fromInt(i2);
          return r2;
        }
        function bnpFromString(s2, b2) {
          var k2;
          if (b2 == 16)
            k2 = 4;
          else if (b2 == 8)
            k2 = 3;
          else if (b2 == 256)
            k2 = 8;
          else if (b2 == 2)
            k2 = 1;
          else if (b2 == 32)
            k2 = 5;
          else if (b2 == 4)
            k2 = 2;
          else {
            this.fromRadix(s2, b2);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i2 = s2.length, mi = false, sh = 0;
          while (--i2 >= 0) {
            var x2 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
            if (x2 < 0) {
              if (s2.charAt(i2) == "-")
                mi = true;
              continue;
            }
            mi = false;
            if (sh == 0)
              this.data[this.t++] = x2;
            else if (sh + k2 > this.DB) {
              this.data[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
              this.data[this.t++] = x2 >> this.DB - sh;
            } else
              this.data[this.t - 1] |= x2 << sh;
            sh += k2;
            if (sh >= this.DB)
              sh -= this.DB;
          }
          if (k2 == 8 && (s2[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0)
              this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
          }
          this.clamp();
          if (mi)
            BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c2 = this.s & this.DM;
          while (this.t > 0 && this.data[this.t - 1] == c2)
            --this.t;
        }
        function bnToString(b2) {
          if (this.s < 0)
            return "-" + this.negate().toString(b2);
          var k2;
          if (b2 == 16)
            k2 = 4;
          else if (b2 == 8)
            k2 = 3;
          else if (b2 == 2)
            k2 = 1;
          else if (b2 == 32)
            k2 = 5;
          else if (b2 == 4)
            k2 = 2;
          else
            return this.toRadix(b2);
          var km = (1 << k2) - 1, d, m2 = false, r2 = "", i2 = this.t;
          var p2 = this.DB - i2 * this.DB % k2;
          if (i2-- > 0) {
            if (p2 < this.DB && (d = this.data[i2] >> p2) > 0) {
              m2 = true;
              r2 = int2char(d);
            }
            while (i2 >= 0) {
              if (p2 < k2) {
                d = (this.data[i2] & (1 << p2) - 1) << k2 - p2;
                d |= this.data[--i2] >> (p2 += this.DB - k2);
              } else {
                d = this.data[i2] >> (p2 -= k2) & km;
                if (p2 <= 0) {
                  p2 += this.DB;
                  --i2;
                }
              }
              if (d > 0)
                m2 = true;
              if (m2)
                r2 += int2char(d);
            }
          }
          return m2 ? r2 : "0";
        }
        function bnNegate() {
          var r2 = nbi();
          BigInteger.ZERO.subTo(this, r2);
          return r2;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a2) {
          var r2 = this.s - a2.s;
          if (r2 != 0)
            return r2;
          var i2 = this.t;
          r2 = i2 - a2.t;
          if (r2 != 0)
            return this.s < 0 ? -r2 : r2;
          while (--i2 >= 0)
            if ((r2 = this.data[i2] - a2.data[i2]) != 0)
              return r2;
          return 0;
        }
        function nbits(x2) {
          var r2 = 1, t;
          if ((t = x2 >>> 16) != 0) {
            x2 = t;
            r2 += 16;
          }
          if ((t = x2 >> 8) != 0) {
            x2 = t;
            r2 += 8;
          }
          if ((t = x2 >> 4) != 0) {
            x2 = t;
            r2 += 4;
          }
          if ((t = x2 >> 2) != 0) {
            x2 = t;
            r2 += 2;
          }
          if ((t = x2 >> 1) != 0) {
            x2 = t;
            r2 += 1;
          }
          return r2;
        }
        function bnBitLength() {
          if (this.t <= 0)
            return 0;
          return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
        }
        function bnpDLShiftTo(n, r2) {
          var i2;
          for (i2 = this.t - 1; i2 >= 0; --i2)
            r2.data[i2 + n] = this.data[i2];
          for (i2 = n - 1; i2 >= 0; --i2)
            r2.data[i2] = 0;
          r2.t = this.t + n;
          r2.s = this.s;
        }
        function bnpDRShiftTo(n, r2) {
          for (var i2 = n; i2 < this.t; ++i2)
            r2.data[i2 - n] = this.data[i2];
          r2.t = Math.max(this.t - n, 0);
          r2.s = this.s;
        }
        function bnpLShiftTo(n, r2) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB), c2 = this.s << bs & this.DM, i2;
          for (i2 = this.t - 1; i2 >= 0; --i2) {
            r2.data[i2 + ds + 1] = this.data[i2] >> cbs | c2;
            c2 = (this.data[i2] & bm) << bs;
          }
          for (i2 = ds - 1; i2 >= 0; --i2)
            r2.data[i2] = 0;
          r2.data[ds] = c2;
          r2.t = this.t + ds + 1;
          r2.s = this.s;
          r2.clamp();
        }
        function bnpRShiftTo(n, r2) {
          r2.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r2.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r2.data[0] = this.data[ds] >> bs;
          for (var i2 = ds + 1; i2 < this.t; ++i2) {
            r2.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
            r2.data[i2 - ds] = this.data[i2] >> bs;
          }
          if (bs > 0)
            r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
          r2.t = this.t - ds;
          r2.clamp();
        }
        function bnpSubTo(a2, r2) {
          var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
          while (i2 < m2) {
            c2 += this.data[i2] - a2.data[i2];
            r2.data[i2++] = c2 & this.DM;
            c2 >>= this.DB;
          }
          if (a2.t < this.t) {
            c2 -= a2.s;
            while (i2 < this.t) {
              c2 += this.data[i2];
              r2.data[i2++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += this.s;
          } else {
            c2 += this.s;
            while (i2 < a2.t) {
              c2 -= a2.data[i2];
              r2.data[i2++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 -= a2.s;
          }
          r2.s = c2 < 0 ? -1 : 0;
          if (c2 < -1)
            r2.data[i2++] = this.DV + c2;
          else if (c2 > 0)
            r2.data[i2++] = c2;
          r2.t = i2;
          r2.clamp();
        }
        function bnpMultiplyTo(a2, r2) {
          var x2 = this.abs(), y2 = a2.abs();
          var i2 = x2.t;
          r2.t = i2 + y2.t;
          while (--i2 >= 0)
            r2.data[i2] = 0;
          for (i2 = 0; i2 < y2.t; ++i2)
            r2.data[i2 + x2.t] = x2.am(0, y2.data[i2], r2, i2, 0, x2.t);
          r2.s = 0;
          r2.clamp();
          if (this.s != a2.s)
            BigInteger.ZERO.subTo(r2, r2);
        }
        function bnpSquareTo(r2) {
          var x2 = this.abs();
          var i2 = r2.t = 2 * x2.t;
          while (--i2 >= 0)
            r2.data[i2] = 0;
          for (i2 = 0; i2 < x2.t - 1; ++i2) {
            var c2 = x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
            if ((r2.data[i2 + x2.t] += x2.am(i2 + 1, 2 * x2.data[i2], r2, 2 * i2 + 1, c2, x2.t - i2 - 1)) >= x2.DV) {
              r2.data[i2 + x2.t] -= x2.DV;
              r2.data[i2 + x2.t + 1] = 1;
            }
          }
          if (r2.t > 0)
            r2.data[r2.t - 1] += x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
          r2.s = 0;
          r2.clamp();
        }
        function bnpDivRemTo(m2, q2, r2) {
          var pm = m2.abs();
          if (pm.t <= 0)
            return;
          var pt2 = this.abs();
          if (pt2.t < pm.t) {
            if (q2 != null)
              q2.fromInt(0);
            if (r2 != null)
              this.copyTo(r2);
            return;
          }
          if (r2 == null)
            r2 = nbi();
          var y2 = nbi(), ts = this.s, ms = m2.s;
          var nsh = this.DB - nbits(pm.data[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y2);
            pt2.lShiftTo(nsh, r2);
          } else {
            pm.copyTo(y2);
            pt2.copyTo(r2);
          }
          var ys = y2.t;
          var y0 = y2.data[ys - 1];
          if (y0 == 0)
            return;
          var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y2.data[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
          var i2 = r2.t, j2 = i2 - ys, t = q2 == null ? nbi() : q2;
          y2.dlShiftTo(j2, t);
          if (r2.compareTo(t) >= 0) {
            r2.data[r2.t++] = 1;
            r2.subTo(t, r2);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y2, y2);
          while (y2.t < ys)
            y2.data[y2.t++] = 0;
          while (--j2 >= 0) {
            var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d2);
            if ((r2.data[i2] += y2.am(0, qd, r2, j2, 0, ys)) < qd) {
              y2.dlShiftTo(j2, t);
              r2.subTo(t, r2);
              while (r2.data[i2] < --qd)
                r2.subTo(t, r2);
            }
          }
          if (q2 != null) {
            r2.drShiftTo(ys, q2);
            if (ts != ms)
              BigInteger.ZERO.subTo(q2, q2);
          }
          r2.t = ys;
          r2.clamp();
          if (nsh > 0)
            r2.rShiftTo(nsh, r2);
          if (ts < 0)
            BigInteger.ZERO.subTo(r2, r2);
        }
        function bnMod(a2) {
          var r2 = nbi();
          this.abs().divRemTo(a2, null, r2);
          if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
            a2.subTo(r2, r2);
          return r2;
        }
        function Classic(m2) {
          this.m = m2;
        }
        function cConvert(x2) {
          if (x2.s < 0 || x2.compareTo(this.m) >= 0)
            return x2.mod(this.m);
          else
            return x2;
        }
        function cRevert(x2) {
          return x2;
        }
        function cReduce(x2) {
          x2.divRemTo(this.m, null, x2);
        }
        function cMulTo(x2, y2, r2) {
          x2.multiplyTo(y2, r2);
          this.reduce(r2);
        }
        function cSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1)
            return 0;
          var x2 = this.data[0];
          if ((x2 & 1) == 0)
            return 0;
          var y2 = x2 & 3;
          y2 = y2 * (2 - (x2 & 15) * y2) & 15;
          y2 = y2 * (2 - (x2 & 255) * y2) & 255;
          y2 = y2 * (2 - ((x2 & 65535) * y2 & 65535)) & 65535;
          y2 = y2 * (2 - x2 * y2 % this.DV) % this.DV;
          return y2 > 0 ? this.DV - y2 : -y2;
        }
        function Montgomery(m2) {
          this.m = m2;
          this.mp = m2.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << m2.DB - 15) - 1;
          this.mt2 = 2 * m2.t;
        }
        function montConvert(x2) {
          var r2 = nbi();
          x2.abs().dlShiftTo(this.m.t, r2);
          r2.divRemTo(this.m, null, r2);
          if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
            this.m.subTo(r2, r2);
          return r2;
        }
        function montRevert(x2) {
          var r2 = nbi();
          x2.copyTo(r2);
          this.reduce(r2);
          return r2;
        }
        function montReduce(x2) {
          while (x2.t <= this.mt2)
            x2.data[x2.t++] = 0;
          for (var i2 = 0; i2 < this.m.t; ++i2) {
            var j2 = x2.data[i2] & 32767;
            var u0 = j2 * this.mpl + ((j2 * this.mph + (x2.data[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
            j2 = i2 + this.m.t;
            x2.data[j2] += this.m.am(0, u0, x2, i2, 0, this.m.t);
            while (x2.data[j2] >= x2.DV) {
              x2.data[j2] -= x2.DV;
              x2.data[++j2]++;
            }
          }
          x2.clamp();
          x2.drShiftTo(this.m.t, x2);
          if (x2.compareTo(this.m) >= 0)
            x2.subTo(this.m, x2);
        }
        function montSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        function montMulTo(x2, y2, r2) {
          x2.multiplyTo(y2, r2);
          this.reduce(r2);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
        }
        function bnpExp(e2, z2) {
          if (e2 > 4294967295 || e2 < 1)
            return BigInteger.ONE;
          var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i2 = nbits(e2) - 1;
          g2.copyTo(r2);
          while (--i2 >= 0) {
            z2.sqrTo(r2, r22);
            if ((e2 & 1 << i2) > 0)
              z2.mulTo(r22, g2, r2);
            else {
              var t = r2;
              r2 = r22;
              r22 = t;
            }
          }
          return z2.revert(r2);
        }
        function bnModPowInt(e2, m2) {
          var z2;
          if (e2 < 256 || m2.isEven())
            z2 = new Classic(m2);
          else
            z2 = new Montgomery(m2);
          return this.exp(e2, z2);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r2 = nbi();
          this.copyTo(r2);
          return r2;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1)
              return this.data[0] - this.DV;
            else if (this.t == 0)
              return -1;
          } else if (this.t == 1)
            return this.data[0];
          else if (this.t == 0)
            return 0;
          return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
        }
        function bnpChunkSize(r2) {
          return Math.floor(Math.LN2 * this.DB / Math.log(r2));
        }
        function bnSigNum() {
          if (this.s < 0)
            return -1;
          else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
            return 0;
          else
            return 1;
        }
        function bnpToRadix(b2) {
          if (b2 == null)
            b2 = 10;
          if (this.signum() == 0 || b2 < 2 || b2 > 36)
            return "0";
          var cs = this.chunkSize(b2);
          var a2 = Math.pow(b2, cs);
          var d = nbv(a2), y2 = nbi(), z2 = nbi(), r2 = "";
          this.divRemTo(d, y2, z2);
          while (y2.signum() > 0) {
            r2 = (a2 + z2.intValue()).toString(b2).substr(1) + r2;
            y2.divRemTo(d, y2, z2);
          }
          return z2.intValue().toString(b2) + r2;
        }
        function bnpFromRadix(s2, b2) {
          this.fromInt(0);
          if (b2 == null)
            b2 = 10;
          var cs = this.chunkSize(b2);
          var d = Math.pow(b2, cs), mi = false, j2 = 0, w2 = 0;
          for (var i2 = 0; i2 < s2.length; ++i2) {
            var x2 = intAt(s2, i2);
            if (x2 < 0) {
              if (s2.charAt(i2) == "-" && this.signum() == 0)
                mi = true;
              continue;
            }
            w2 = b2 * w2 + x2;
            if (++j2 >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w2, 0);
              j2 = 0;
              w2 = 0;
            }
          }
          if (j2 > 0) {
            this.dMultiply(Math.pow(b2, j2));
            this.dAddOffset(w2, 0);
          }
          if (mi)
            BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a2, b2, c2) {
          if ("number" == typeof b2) {
            if (a2 < 2)
              this.fromInt(1);
            else {
              this.fromNumber(a2, c2);
              if (!this.testBit(a2 - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
              if (this.isEven())
                this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b2)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a2)
                  this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
              }
            }
          } else {
            var x2 = new Array(), t = a2 & 7;
            x2.length = (a2 >> 3) + 1;
            b2.nextBytes(x2);
            if (t > 0)
              x2[0] &= (1 << t) - 1;
            else
              x2[0] = 0;
            this.fromString(x2, 256);
          }
        }
        function bnToByteArray() {
          var i2 = this.t, r2 = new Array();
          r2[0] = this.s;
          var p2 = this.DB - i2 * this.DB % 8, d, k2 = 0;
          if (i2-- > 0) {
            if (p2 < this.DB && (d = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
              r2[k2++] = d | this.s << this.DB - p2;
            while (i2 >= 0) {
              if (p2 < 8) {
                d = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
                d |= this.data[--i2] >> (p2 += this.DB - 8);
              } else {
                d = this.data[i2] >> (p2 -= 8) & 255;
                if (p2 <= 0) {
                  p2 += this.DB;
                  --i2;
                }
              }
              if ((d & 128) != 0)
                d |= -256;
              if (k2 == 0 && (this.s & 128) != (d & 128))
                ++k2;
              if (k2 > 0 || d != this.s)
                r2[k2++] = d;
            }
          }
          return r2;
        }
        function bnEquals(a2) {
          return this.compareTo(a2) == 0;
        }
        function bnMin(a2) {
          return this.compareTo(a2) < 0 ? this : a2;
        }
        function bnMax(a2) {
          return this.compareTo(a2) > 0 ? this : a2;
        }
        function bnpBitwiseTo(a2, op, r2) {
          var i2, f2, m2 = Math.min(a2.t, this.t);
          for (i2 = 0; i2 < m2; ++i2)
            r2.data[i2] = op(this.data[i2], a2.data[i2]);
          if (a2.t < this.t) {
            f2 = a2.s & this.DM;
            for (i2 = m2; i2 < this.t; ++i2)
              r2.data[i2] = op(this.data[i2], f2);
            r2.t = this.t;
          } else {
            f2 = this.s & this.DM;
            for (i2 = m2; i2 < a2.t; ++i2)
              r2.data[i2] = op(f2, a2.data[i2]);
            r2.t = a2.t;
          }
          r2.s = op(this.s, a2.s);
          r2.clamp();
        }
        function op_and(x2, y2) {
          return x2 & y2;
        }
        function bnAnd(a2) {
          var r2 = nbi();
          this.bitwiseTo(a2, op_and, r2);
          return r2;
        }
        function op_or(x2, y2) {
          return x2 | y2;
        }
        function bnOr(a2) {
          var r2 = nbi();
          this.bitwiseTo(a2, op_or, r2);
          return r2;
        }
        function op_xor(x2, y2) {
          return x2 ^ y2;
        }
        function bnXor(a2) {
          var r2 = nbi();
          this.bitwiseTo(a2, op_xor, r2);
          return r2;
        }
        function op_andnot(x2, y2) {
          return x2 & ~y2;
        }
        function bnAndNot(a2) {
          var r2 = nbi();
          this.bitwiseTo(a2, op_andnot, r2);
          return r2;
        }
        function bnNot() {
          var r2 = nbi();
          for (var i2 = 0; i2 < this.t; ++i2)
            r2.data[i2] = this.DM & ~this.data[i2];
          r2.t = this.t;
          r2.s = ~this.s;
          return r2;
        }
        function bnShiftLeft(n) {
          var r2 = nbi();
          if (n < 0)
            this.rShiftTo(-n, r2);
          else
            this.lShiftTo(n, r2);
          return r2;
        }
        function bnShiftRight(n) {
          var r2 = nbi();
          if (n < 0)
            this.lShiftTo(-n, r2);
          else
            this.rShiftTo(n, r2);
          return r2;
        }
        function lbit(x2) {
          if (x2 == 0)
            return -1;
          var r2 = 0;
          if ((x2 & 65535) == 0) {
            x2 >>= 16;
            r2 += 16;
          }
          if ((x2 & 255) == 0) {
            x2 >>= 8;
            r2 += 8;
          }
          if ((x2 & 15) == 0) {
            x2 >>= 4;
            r2 += 4;
          }
          if ((x2 & 3) == 0) {
            x2 >>= 2;
            r2 += 2;
          }
          if ((x2 & 1) == 0)
            ++r2;
          return r2;
        }
        function bnGetLowestSetBit() {
          for (var i2 = 0; i2 < this.t; ++i2)
            if (this.data[i2] != 0)
              return i2 * this.DB + lbit(this.data[i2]);
          if (this.s < 0)
            return this.t * this.DB;
          return -1;
        }
        function cbit(x2) {
          var r2 = 0;
          while (x2 != 0) {
            x2 &= x2 - 1;
            ++r2;
          }
          return r2;
        }
        function bnBitCount() {
          var r2 = 0, x2 = this.s & this.DM;
          for (var i2 = 0; i2 < this.t; ++i2)
            r2 += cbit(this.data[i2] ^ x2);
          return r2;
        }
        function bnTestBit(n) {
          var j2 = Math.floor(n / this.DB);
          if (j2 >= this.t)
            return this.s != 0;
          return (this.data[j2] & 1 << n % this.DB) != 0;
        }
        function bnpChangeBit(n, op) {
          var r2 = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r2, op, r2);
          return r2;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a2, r2) {
          var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
          while (i2 < m2) {
            c2 += this.data[i2] + a2.data[i2];
            r2.data[i2++] = c2 & this.DM;
            c2 >>= this.DB;
          }
          if (a2.t < this.t) {
            c2 += a2.s;
            while (i2 < this.t) {
              c2 += this.data[i2];
              r2.data[i2++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += this.s;
          } else {
            c2 += this.s;
            while (i2 < a2.t) {
              c2 += a2.data[i2];
              r2.data[i2++] = c2 & this.DM;
              c2 >>= this.DB;
            }
            c2 += a2.s;
          }
          r2.s = c2 < 0 ? -1 : 0;
          if (c2 > 0)
            r2.data[i2++] = c2;
          else if (c2 < -1)
            r2.data[i2++] = this.DV + c2;
          r2.t = i2;
          r2.clamp();
        }
        function bnAdd(a2) {
          var r2 = nbi();
          this.addTo(a2, r2);
          return r2;
        }
        function bnSubtract(a2) {
          var r2 = nbi();
          this.subTo(a2, r2);
          return r2;
        }
        function bnMultiply(a2) {
          var r2 = nbi();
          this.multiplyTo(a2, r2);
          return r2;
        }
        function bnDivide(a2) {
          var r2 = nbi();
          this.divRemTo(a2, r2, null);
          return r2;
        }
        function bnRemainder(a2) {
          var r2 = nbi();
          this.divRemTo(a2, null, r2);
          return r2;
        }
        function bnDivideAndRemainder(a2) {
          var q2 = nbi(), r2 = nbi();
          this.divRemTo(a2, q2, r2);
          return new Array(q2, r2);
        }
        function bnpDMultiply(n) {
          this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w2) {
          if (n == 0)
            return;
          while (this.t <= w2)
            this.data[this.t++] = 0;
          this.data[w2] += n;
          while (this.data[w2] >= this.DV) {
            this.data[w2] -= this.DV;
            if (++w2 >= this.t)
              this.data[this.t++] = 0;
            ++this.data[w2];
          }
        }
        function NullExp() {
        }
        function nNop(x2) {
          return x2;
        }
        function nMulTo(x2, y2, r2) {
          x2.multiplyTo(y2, r2);
        }
        function nSqrTo(x2, r2) {
          x2.squareTo(r2);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e2) {
          return this.exp(e2, new NullExp());
        }
        function bnpMultiplyLowerTo(a2, n, r2) {
          var i2 = Math.min(this.t + a2.t, n);
          r2.s = 0;
          r2.t = i2;
          while (i2 > 0)
            r2.data[--i2] = 0;
          var j2;
          for (j2 = r2.t - this.t; i2 < j2; ++i2)
            r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
          for (j2 = Math.min(a2.t, n); i2 < j2; ++i2)
            this.am(0, a2.data[i2], r2, i2, 0, n - i2);
          r2.clamp();
        }
        function bnpMultiplyUpperTo(a2, n, r2) {
          --n;
          var i2 = r2.t = this.t + a2.t - n;
          r2.s = 0;
          while (--i2 >= 0)
            r2.data[i2] = 0;
          for (i2 = Math.max(n - this.t, 0); i2 < a2.t; ++i2)
            r2.data[this.t + i2 - n] = this.am(n - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n);
          r2.clamp();
          r2.drShiftTo(1, r2);
        }
        function Barrett(m2) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
          this.mu = this.r2.divide(m2);
          this.m = m2;
        }
        function barrettConvert(x2) {
          if (x2.s < 0 || x2.t > 2 * this.m.t)
            return x2.mod(this.m);
          else if (x2.compareTo(this.m) < 0)
            return x2;
          else {
            var r2 = nbi();
            x2.copyTo(r2);
            this.reduce(r2);
            return r2;
          }
        }
        function barrettRevert(x2) {
          return x2;
        }
        function barrettReduce(x2) {
          x2.drShiftTo(this.m.t - 1, this.r2);
          if (x2.t > this.m.t + 1) {
            x2.t = this.m.t + 1;
            x2.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x2.compareTo(this.r2) < 0)
            x2.dAddOffset(1, this.m.t + 1);
          x2.subTo(this.r2, x2);
          while (x2.compareTo(this.m) >= 0)
            x2.subTo(this.m, x2);
        }
        function barrettSqrTo(x2, r2) {
          x2.squareTo(r2);
          this.reduce(r2);
        }
        function barrettMulTo(x2, y2, r2) {
          x2.multiplyTo(y2, r2);
          this.reduce(r2);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e2, m2) {
          var i2 = e2.bitLength(), k2, r2 = nbv(1), z2;
          if (i2 <= 0)
            return r2;
          else if (i2 < 18)
            k2 = 1;
          else if (i2 < 48)
            k2 = 3;
          else if (i2 < 144)
            k2 = 4;
          else if (i2 < 768)
            k2 = 5;
          else
            k2 = 6;
          if (i2 < 8)
            z2 = new Classic(m2);
          else if (m2.isEven())
            z2 = new Barrett(m2);
          else
            z2 = new Montgomery(m2);
          var g2 = new Array(), n = 3, k1 = k2 - 1, km = (1 << k2) - 1;
          g2[1] = z2.convert(this);
          if (k2 > 1) {
            var g22 = nbi();
            z2.sqrTo(g2[1], g22);
            while (n <= km) {
              g2[n] = nbi();
              z2.mulTo(g22, g2[n - 2], g2[n]);
              n += 2;
            }
          }
          var j2 = e2.t - 1, w2, is1 = true, r22 = nbi(), t;
          i2 = nbits(e2.data[j2]) - 1;
          while (j2 >= 0) {
            if (i2 >= k1)
              w2 = e2.data[j2] >> i2 - k1 & km;
            else {
              w2 = (e2.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
              if (j2 > 0)
                w2 |= e2.data[j2 - 1] >> this.DB + i2 - k1;
            }
            n = k2;
            while ((w2 & 1) == 0) {
              w2 >>= 1;
              --n;
            }
            if ((i2 -= n) < 0) {
              i2 += this.DB;
              --j2;
            }
            if (is1) {
              g2[w2].copyTo(r2);
              is1 = false;
            } else {
              while (n > 1) {
                z2.sqrTo(r2, r22);
                z2.sqrTo(r22, r2);
                n -= 2;
              }
              if (n > 0)
                z2.sqrTo(r2, r22);
              else {
                t = r2;
                r2 = r22;
                r22 = t;
              }
              z2.mulTo(r22, g2[w2], r2);
            }
            while (j2 >= 0 && (e2.data[j2] & 1 << i2) == 0) {
              z2.sqrTo(r2, r22);
              t = r2;
              r2 = r22;
              r22 = t;
              if (--i2 < 0) {
                i2 = this.DB - 1;
                --j2;
              }
            }
          }
          return z2.revert(r2);
        }
        function bnGCD(a2) {
          var x2 = this.s < 0 ? this.negate() : this.clone();
          var y2 = a2.s < 0 ? a2.negate() : a2.clone();
          if (x2.compareTo(y2) < 0) {
            var t = x2;
            x2 = y2;
            y2 = t;
          }
          var i2 = x2.getLowestSetBit(), g2 = y2.getLowestSetBit();
          if (g2 < 0)
            return x2;
          if (i2 < g2)
            g2 = i2;
          if (g2 > 0) {
            x2.rShiftTo(g2, x2);
            y2.rShiftTo(g2, y2);
          }
          while (x2.signum() > 0) {
            if ((i2 = x2.getLowestSetBit()) > 0)
              x2.rShiftTo(i2, x2);
            if ((i2 = y2.getLowestSetBit()) > 0)
              y2.rShiftTo(i2, y2);
            if (x2.compareTo(y2) >= 0) {
              x2.subTo(y2, x2);
              x2.rShiftTo(1, x2);
            } else {
              y2.subTo(x2, y2);
              y2.rShiftTo(1, y2);
            }
          }
          if (g2 > 0)
            y2.lShiftTo(g2, y2);
          return y2;
        }
        function bnpModInt(n) {
          if (n <= 0)
            return 0;
          var d = this.DV % n, r2 = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0)
              r2 = this.data[0] % n;
            else
              for (var i2 = this.t - 1; i2 >= 0; --i2)
                r2 = (d * r2 + this.data[i2]) % n;
          return r2;
        }
        function bnModInverse(m2) {
          var ac = m2.isEven();
          if (this.isEven() && ac || m2.signum() == 0)
            return BigInteger.ZERO;
          var u2 = m2.clone(), v2 = this.clone();
          var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d = nbv(1);
          while (u2.signum() != 0) {
            while (u2.isEven()) {
              u2.rShiftTo(1, u2);
              if (ac) {
                if (!a2.isEven() || !b2.isEven()) {
                  a2.addTo(this, a2);
                  b2.subTo(m2, b2);
                }
                a2.rShiftTo(1, a2);
              } else if (!b2.isEven())
                b2.subTo(m2, b2);
              b2.rShiftTo(1, b2);
            }
            while (v2.isEven()) {
              v2.rShiftTo(1, v2);
              if (ac) {
                if (!c2.isEven() || !d.isEven()) {
                  c2.addTo(this, c2);
                  d.subTo(m2, d);
                }
                c2.rShiftTo(1, c2);
              } else if (!d.isEven())
                d.subTo(m2, d);
              d.rShiftTo(1, d);
            }
            if (u2.compareTo(v2) >= 0) {
              u2.subTo(v2, u2);
              if (ac)
                a2.subTo(c2, a2);
              b2.subTo(d, b2);
            } else {
              v2.subTo(u2, v2);
              if (ac)
                c2.subTo(a2, c2);
              d.subTo(b2, d);
            }
          }
          if (v2.compareTo(BigInteger.ONE) != 0)
            return BigInteger.ZERO;
          if (d.compareTo(m2) >= 0)
            return d.subtract(m2);
          if (d.signum() < 0)
            d.addTo(m2, d);
          else
            return d;
          if (d.signum() < 0)
            return d.add(m2);
          else
            return d;
        }
        var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t) {
          var i2, x2 = this.abs();
          if (x2.t == 1 && x2.data[0] <= lowprimes[lowprimes.length - 1]) {
            for (i2 = 0; i2 < lowprimes.length; ++i2)
              if (x2.data[0] == lowprimes[i2])
                return true;
            return false;
          }
          if (x2.isEven())
            return false;
          i2 = 1;
          while (i2 < lowprimes.length) {
            var m2 = lowprimes[i2], j2 = i2 + 1;
            while (j2 < lowprimes.length && m2 < lplim)
              m2 *= lowprimes[j2++];
            m2 = x2.modInt(m2);
            while (i2 < j2)
              if (m2 % lowprimes[i2++] == 0)
                return false;
          }
          return x2.millerRabin(t);
        }
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k2 = n1.getLowestSetBit();
          if (k2 <= 0)
            return false;
          var r2 = n1.shiftRight(k2);
          var prng = bnGetPrng();
          var a2;
          for (var i2 = 0; i2 < t; ++i2) {
            do {
              a2 = new BigInteger(this.bitLength(), prng);
            } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n1) >= 0);
            var y2 = a2.modPow(r2, this);
            if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
              var j2 = 1;
              while (j2++ < k2 && y2.compareTo(n1) != 0) {
                y2 = y2.modPowInt(2, this);
                if (y2.compareTo(BigInteger.ONE) == 0)
                  return false;
              }
              if (y2.compareTo(n1) != 0)
                return false;
            }
          }
          return true;
        }
        function bnGetPrng() {
          return {
            // x is an array to fill with bytes
            nextBytes: function(x2) {
              for (var i2 = 0; i2 < x2.length; ++i2) {
                x2[i2] = Math.floor(Math.random() * 256);
              }
            }
          };
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      }
    });
    var require_sha13 = __commonJS2({
      "../../node_modules/node-forge/lib/sha1.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_md2();
        require_util2();
        var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
        forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
        sha1.create = function() {
          if (!_initialized) {
            _init();
          }
          var _state = null;
          var _input = forge.util.createBuffer();
          var _w = new Array(80);
          var md = {
            algorithm: "sha1",
            blockLength: 64,
            digestLength: 20,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 8
          };
          md.start = function() {
            md.messageLength = 0;
            md.fullMessageLength = md.messageLength64 = [];
            var int32s = md.messageLengthSize / 4;
            for (var i2 = 0; i2 < int32s; ++i2) {
              md.fullMessageLength.push(0);
            }
            _input = forge.util.createBuffer();
            _state = {
              h0: 1732584193,
              h1: 4023233417,
              h2: 2562383102,
              h3: 271733878,
              h4: 3285377520
            };
            return md;
          };
          md.start();
          md.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
              md.fullMessageLength[i2] += len[1];
              len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
              md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_state, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md;
          };
          md.digest = function() {
            var finalBlock = forge.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
            var overflow = remaining & md.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
            var next2, carry;
            var bits2 = md.fullMessageLength[0] * 8;
            for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
              next2 = md.fullMessageLength[i2 + 1] * 8;
              carry = next2 / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next2 >>> 0;
            }
            finalBlock.putInt32(bits2);
            var s2 = {
              h0: _state.h0,
              h1: _state.h1,
              h2: _state.h2,
              h3: _state.h3,
              h4: _state.h4
            };
            _update(s2, _w, finalBlock);
            var rval = forge.util.createBuffer();
            rval.putInt32(s2.h0);
            rval.putInt32(s2.h1);
            rval.putInt32(s2.h2);
            rval.putInt32(s2.h3);
            rval.putInt32(s2.h4);
            return rval;
          };
          return md;
        };
        var _padding = null;
        var _initialized = false;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge.util.fillString(String.fromCharCode(0), 64);
          _initialized = true;
        }
        function _update(s2, w2, bytes) {
          var t, a2, b2, c2, d, e2, f2, i2;
          var len = bytes.length();
          while (len >= 64) {
            a2 = s2.h0;
            b2 = s2.h1;
            c2 = s2.h2;
            d = s2.h3;
            e2 = s2.h4;
            for (i2 = 0; i2 < 16; ++i2) {
              t = bytes.getInt32();
              w2[i2] = t;
              f2 = d ^ b2 & (c2 ^ d);
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            for (; i2 < 20; ++i2) {
              t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
              t = t << 1 | t >>> 31;
              w2[i2] = t;
              f2 = d ^ b2 & (c2 ^ d);
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            for (; i2 < 32; ++i2) {
              t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
              t = t << 1 | t >>> 31;
              w2[i2] = t;
              f2 = b2 ^ c2 ^ d;
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            for (; i2 < 40; ++i2) {
              t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
              t = t << 2 | t >>> 30;
              w2[i2] = t;
              f2 = b2 ^ c2 ^ d;
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            for (; i2 < 60; ++i2) {
              t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
              t = t << 2 | t >>> 30;
              w2[i2] = t;
              f2 = b2 & c2 | d & (b2 ^ c2);
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            for (; i2 < 80; ++i2) {
              t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
              t = t << 2 | t >>> 30;
              w2[i2] = t;
              f2 = b2 ^ c2 ^ d;
              t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t;
              e2 = d;
              d = c2;
              c2 = (b2 << 30 | b2 >>> 2) >>> 0;
              b2 = a2;
              a2 = t;
            }
            s2.h0 = s2.h0 + a2 | 0;
            s2.h1 = s2.h1 + b2 | 0;
            s2.h2 = s2.h2 + c2 | 0;
            s2.h3 = s2.h3 + d | 0;
            s2.h4 = s2.h4 + e2 | 0;
            len -= 64;
          }
        }
      }
    });
    var require_pkcs13 = __commonJS2({
      "../../node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        require_random2();
        require_sha13();
        var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
        pkcs1.encode_rsa_oaep = function(key, message, options) {
          var label;
          var seed;
          var md;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            seed = arguments[3] || void 0;
            md = arguments[4] || void 0;
          } else if (options) {
            label = options.label || void 0;
            seed = options.seed || void 0;
            md = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          if (!md) {
            md = forge.md.sha1.create();
          } else {
            md.start();
          }
          if (!mgf1Md) {
            mgf1Md = md;
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          var maxLength = keyLength - 2 * md.digestLength - 2;
          if (message.length > maxLength) {
            var error = new Error("RSAES-OAEP input message length is too long.");
            error.length = message.length;
            error.maxLength = maxLength;
            throw error;
          }
          if (!label) {
            label = "";
          }
          md.update(label, "raw");
          var lHash = md.digest();
          var PS = "";
          var PS_length = maxLength - message.length;
          for (var i2 = 0; i2 < PS_length; i2++) {
            PS += "\0";
          }
          var DB = lHash.getBytes() + PS + "" + message;
          if (!seed) {
            seed = forge.random.getBytes(md.digestLength);
          } else if (seed.length !== md.digestLength) {
            var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
            error.seedLength = seed.length;
            error.digestLength = md.digestLength;
            throw error;
          }
          var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
          var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
          var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
          var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
          return "\0" + maskedSeed + maskedDB;
        };
        pkcs1.decode_rsa_oaep = function(key, em, options) {
          var label;
          var md;
          var mgf1Md;
          if (typeof options === "string") {
            label = options;
            md = arguments[3] || void 0;
          } else if (options) {
            label = options.label || void 0;
            md = options.md || void 0;
            if (options.mgf1 && options.mgf1.md) {
              mgf1Md = options.mgf1.md;
            }
          }
          var keyLength = Math.ceil(key.n.bitLength() / 8);
          if (em.length !== keyLength) {
            var error = new Error("RSAES-OAEP encoded message length is invalid.");
            error.length = em.length;
            error.expectedLength = keyLength;
            throw error;
          }
          if (md === void 0) {
            md = forge.md.sha1.create();
          } else {
            md.start();
          }
          if (!mgf1Md) {
            mgf1Md = md;
          }
          if (keyLength < 2 * md.digestLength + 2) {
            throw new Error("RSAES-OAEP key is too short for the hash function.");
          }
          if (!label) {
            label = "";
          }
          md.update(label, "raw");
          var lHash = md.digest().getBytes();
          var y2 = em.charAt(0);
          var maskedSeed = em.substring(1, md.digestLength + 1);
          var maskedDB = em.substring(1 + md.digestLength);
          var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
          var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
          var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
          var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
          var lHashPrime = db.substring(0, md.digestLength);
          var error = y2 !== "\0";
          for (var i2 = 0; i2 < md.digestLength; ++i2) {
            error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
          }
          var in_ps = 1;
          var index = md.digestLength;
          for (var j2 = md.digestLength; j2 < db.length; j2++) {
            var code = db.charCodeAt(j2);
            var is_0 = code & 1 ^ 1;
            var error_mask = in_ps ? 65534 : 0;
            error |= code & error_mask;
            in_ps = in_ps & is_0;
            index += in_ps;
          }
          if (error || db.charCodeAt(index) !== 1) {
            throw new Error("Invalid RSAES-OAEP padding.");
          }
          return db.substring(index + 1);
        };
        function rsa_mgf1(seed, maskLength, hash22) {
          if (!hash22) {
            hash22 = forge.md.sha1.create();
          }
          var t = "";
          var count = Math.ceil(maskLength / hash22.digestLength);
          for (var i2 = 0; i2 < count; ++i2) {
            var c2 = String.fromCharCode(
              i2 >> 24 & 255,
              i2 >> 16 & 255,
              i2 >> 8 & 255,
              i2 & 255
            );
            hash22.start();
            hash22.update(seed + c2);
            t += hash22.digest().getBytes();
          }
          return t.substring(0, maskLength);
        }
      }
    });
    var require_prime2 = __commonJS2({
      "../../node_modules/node-forge/lib/prime.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        require_jsbn2();
        require_random2();
        (function() {
          if (forge.prime) {
            module2.exports = forge.prime;
            return;
          }
          var prime = module2.exports = forge.prime = forge.prime || {};
          var BigInteger = forge.jsbn.BigInteger;
          var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var op_or = function(x2, y2) {
            return x2 | y2;
          };
          prime.generateProbablePrime = function(bits2, options, callback) {
            if (typeof options === "function") {
              callback = options;
              options = {};
            }
            options = options || {};
            var algorithm = options.algorithm || "PRIMEINC";
            if (typeof algorithm === "string") {
              algorithm = { name: algorithm };
            }
            algorithm.options = algorithm.options || {};
            var prng = options.prng || forge.random;
            var rng = {
              // x is an array to fill with bytes
              nextBytes: function(x2) {
                var b2 = prng.getBytesSync(x2.length);
                for (var i2 = 0; i2 < x2.length; ++i2) {
                  x2[i2] = b2.charCodeAt(i2);
                }
              }
            };
            if (algorithm.name === "PRIMEINC") {
              return primeincFindPrime(bits2, rng, algorithm.options, callback);
            }
            throw new Error("Invalid prime generation algorithm: " + algorithm.name);
          };
          function primeincFindPrime(bits2, rng, options, callback) {
            if ("workers" in options) {
              return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
            }
            return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
          }
          function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
            var num = generateRandom(bits2, rng);
            var deltaIdx = 0;
            var mrTests = getMillerRabinTests(num.bitLength());
            if ("millerRabinTests" in options) {
              mrTests = options.millerRabinTests;
            }
            var maxBlockTime = 10;
            if ("maxBlockTime" in options) {
              maxBlockTime = options.maxBlockTime;
            }
            _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
          }
          function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
            var start = +/* @__PURE__ */ new Date();
            do {
              if (num.bitLength() > bits2) {
                num = generateRandom(bits2, rng);
              }
              if (num.isProbablePrime(mrTests)) {
                return callback(null, num);
              }
              num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
            forge.util.setImmediate(function() {
              _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
            });
          }
          function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
            if (typeof Worker === "undefined") {
              return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
            }
            var num = generateRandom(bits2, rng);
            var numWorkers = options.workers;
            var workLoad = options.workLoad || 100;
            var range = workLoad * 30 / 8;
            var workerScript = options.workerScript || "forge/prime.worker.js";
            if (numWorkers === -1) {
              return forge.util.estimateCores(function(err, cores) {
                if (err) {
                  cores = 2;
                }
                numWorkers = cores - 1;
                generate();
              });
            }
            generate();
            function generate() {
              numWorkers = Math.max(1, numWorkers);
              var workers = [];
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2] = new Worker(workerScript);
              }
              var running = numWorkers;
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].addEventListener("message", workerMessage);
              }
              var found = false;
              function workerMessage(e2) {
                if (found) {
                  return;
                }
                --running;
                var data = e2.data;
                if (data.found) {
                  for (var i22 = 0; i22 < workers.length; ++i22) {
                    workers[i22].terminate();
                  }
                  found = true;
                  return callback(null, new BigInteger(data.prime, 16));
                }
                if (num.bitLength() > bits2) {
                  num = generateRandom(bits2, rng);
                }
                var hex2 = num.toString(16);
                e2.target.postMessage({
                  hex: hex2,
                  workLoad
                });
                num.dAddOffset(range, 0);
              }
            }
          }
          function generateRandom(bits2, rng) {
            var num = new BigInteger(bits2, rng);
            var bits1 = bits2 - 1;
            if (!num.testBit(bits1)) {
              num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
            }
            num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
            return num;
          }
          function getMillerRabinTests(bits2) {
            if (bits2 <= 100)
              return 27;
            if (bits2 <= 150)
              return 18;
            if (bits2 <= 200)
              return 15;
            if (bits2 <= 250)
              return 12;
            if (bits2 <= 300)
              return 9;
            if (bits2 <= 350)
              return 8;
            if (bits2 <= 400)
              return 7;
            if (bits2 <= 500)
              return 6;
            if (bits2 <= 600)
              return 5;
            if (bits2 <= 800)
              return 4;
            if (bits2 <= 1250)
              return 3;
            return 2;
          }
        })();
      }
    });
    var require_rsa2 = __commonJS2({
      "../../node_modules/node-forge/lib/rsa.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        require_jsbn2();
        require_oids2();
        require_pkcs13();
        require_prime2();
        require_random2();
        require_util2();
        if (typeof BigInteger === "undefined") {
          BigInteger = forge.jsbn.BigInteger;
        }
        var BigInteger;
        var _crypto = forge.util.isNodejs ? require_crypto_browserify() : null;
        var asn1 = forge.asn1;
        var util = forge.util;
        forge.pki = forge.pki || {};
        module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
        var pki2 = forge.pki;
        var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
        var privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        var rsaPrivateKeyValidator = {
          // RSAPrivateKey
          name: "RSAPrivateKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "RSAPrivateKey.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // modulus (n)
            name: "RSAPrivateKey.modulus",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPrivateKey.publicExponent",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPublicExponent"
          }, {
            // privateExponent (d)
            name: "RSAPrivateKey.privateExponent",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrivateExponent"
          }, {
            // prime1 (p)
            name: "RSAPrivateKey.prime1",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime1"
          }, {
            // prime2 (q)
            name: "RSAPrivateKey.prime2",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyPrime2"
          }, {
            // exponent1 (d mod (p-1))
            name: "RSAPrivateKey.exponent1",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent1"
          }, {
            // exponent2 (d mod (q-1))
            name: "RSAPrivateKey.exponent2",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyExponent2"
          }, {
            // coefficient ((inverse of q) mod p)
            name: "RSAPrivateKey.coefficient",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyCoefficient"
          }]
        };
        var rsaPublicKeyValidator = {
          // RSAPublicKey
          name: "RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // modulus (n)
            name: "RSAPublicKey.modulus",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "publicKeyModulus"
          }, {
            // publicExponent (e)
            name: "RSAPublicKey.exponent",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "publicKeyExponent"
          }]
        };
        var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [{
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "publicKeyOid"
            }]
          }, {
            // subjectPublicKey
            name: "SubjectPublicKeyInfo.subjectPublicKey",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            value: [{
              // RSAPublicKey
              name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "rsaPublicKey"
            }]
          }]
        };
        var digestInfoValidator = {
          name: "DigestInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "DigestInfo.DigestAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "algorithmIdentifier"
            }, {
              // NULL paramters
              name: "DigestInfo.DigestAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.NULL,
              // captured only to check existence for md2 and md5
              capture: "parameters",
              optional: true,
              constructed: false
            }]
          }, {
            // digest
            name: "DigestInfo.digest",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "digest"
          }]
        };
        var emsaPkcs1v15encode = function(md) {
          var oid;
          if (md.algorithm in pki2.oids) {
            oid = pki2.oids[md.algorithm];
          } else {
            var error = new Error("Unknown message digest algorithm.");
            error.algorithm = md.algorithm;
            throw error;
          }
          var oidBytes = asn1.oidToDer(oid).getBytes();
          var digestInfo = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            []
          );
          var digestAlgorithm = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            []
          );
          digestAlgorithm.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            oidBytes
          ));
          digestAlgorithm.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.NULL,
            false,
            ""
          ));
          var digest = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            md.digest().getBytes()
          );
          digestInfo.value.push(digestAlgorithm);
          digestInfo.value.push(digest);
          return asn1.toDer(digestInfo).getBytes();
        };
        var _modPow = function(x2, key, pub) {
          if (pub) {
            return x2.modPow(key.e, key.n);
          }
          if (!key.p || !key.q) {
            return x2.modPow(key.d, key.n);
          }
          if (!key.dP) {
            key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
          }
          if (!key.dQ) {
            key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
          }
          if (!key.qInv) {
            key.qInv = key.q.modInverse(key.p);
          }
          var r2;
          do {
            r2 = new BigInteger(
              forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
              16
            );
          } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
          x2 = x2.multiply(r2.modPow(key.e, key.n)).mod(key.n);
          var xp = x2.mod(key.p).modPow(key.dP, key.p);
          var xq = x2.mod(key.q).modPow(key.dQ, key.q);
          while (xp.compareTo(xq) < 0) {
            xp = xp.add(key.p);
          }
          var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
          y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
          return y2;
        };
        pki2.rsa.encrypt = function(m2, key, bt) {
          var pub = bt;
          var eb;
          var k2 = Math.ceil(key.n.bitLength() / 8);
          if (bt !== false && bt !== true) {
            pub = bt === 2;
            eb = _encodePkcs1_v1_5(m2, key, bt);
          } else {
            eb = forge.util.createBuffer();
            eb.putBytes(m2);
          }
          var x2 = new BigInteger(eb.toHex(), 16);
          var y2 = _modPow(x2, key, pub);
          var yhex = y2.toString(16);
          var ed = forge.util.createBuffer();
          var zeros = k2 - Math.ceil(yhex.length / 2);
          while (zeros > 0) {
            ed.putByte(0);
            --zeros;
          }
          ed.putBytes(forge.util.hexToBytes(yhex));
          return ed.getBytes();
        };
        pki2.rsa.decrypt = function(ed, key, pub, ml) {
          var k2 = Math.ceil(key.n.bitLength() / 8);
          if (ed.length !== k2) {
            var error = new Error("Encrypted message length is invalid.");
            error.length = ed.length;
            error.expected = k2;
            throw error;
          }
          var y2 = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
          if (y2.compareTo(key.n) >= 0) {
            throw new Error("Encrypted message is invalid.");
          }
          var x2 = _modPow(y2, key, pub);
          var xhex = x2.toString(16);
          var eb = forge.util.createBuffer();
          var zeros = k2 - Math.ceil(xhex.length / 2);
          while (zeros > 0) {
            eb.putByte(0);
            --zeros;
          }
          eb.putBytes(forge.util.hexToBytes(xhex));
          if (ml !== false) {
            return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
          }
          return eb.getBytes();
        };
        pki2.rsa.createKeyPairGenerationState = function(bits2, e2, options) {
          if (typeof bits2 === "string") {
            bits2 = parseInt(bits2, 10);
          }
          bits2 = bits2 || 2048;
          options = options || {};
          var prng = options.prng || forge.random;
          var rng = {
            // x is an array to fill with bytes
            nextBytes: function(x2) {
              var b2 = prng.getBytesSync(x2.length);
              for (var i2 = 0; i2 < x2.length; ++i2) {
                x2[i2] = b2.charCodeAt(i2);
              }
            }
          };
          var algorithm = options.algorithm || "PRIMEINC";
          var rval;
          if (algorithm === "PRIMEINC") {
            rval = {
              algorithm,
              state: 0,
              bits: bits2,
              rng,
              eInt: e2 || 65537,
              e: new BigInteger(null),
              p: null,
              q: null,
              qBits: bits2 >> 1,
              pBits: bits2 - (bits2 >> 1),
              pqState: 0,
              num: null,
              keys: null
            };
            rval.e.fromInt(rval.eInt);
          } else {
            throw new Error("Invalid key generation algorithm: " + algorithm);
          }
          return rval;
        };
        pki2.rsa.stepKeyPairGenerationState = function(state, n) {
          if (!("algorithm" in state)) {
            state.algorithm = "PRIMEINC";
          }
          var THIRTY = new BigInteger(null);
          THIRTY.fromInt(30);
          var deltaIdx = 0;
          var op_or = function(x2, y2) {
            return x2 | y2;
          };
          var t1 = +/* @__PURE__ */ new Date();
          var t2;
          var total = 0;
          while (state.keys === null && (n <= 0 || total < n)) {
            if (state.state === 0) {
              var bits2 = state.p === null ? state.pBits : state.qBits;
              var bits1 = bits2 - 1;
              if (state.pqState === 0) {
                state.num = new BigInteger(bits2, state.rng);
                if (!state.num.testBit(bits1)) {
                  state.num.bitwiseTo(
                    BigInteger.ONE.shiftLeft(bits1),
                    op_or,
                    state.num
                  );
                }
                state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
                deltaIdx = 0;
                ++state.pqState;
              } else if (state.pqState === 1) {
                if (state.num.bitLength() > bits2) {
                  state.pqState = 0;
                } else if (state.num.isProbablePrime(
                  _getMillerRabinTests(state.num.bitLength())
                )) {
                  ++state.pqState;
                } else {
                  state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
                }
              } else if (state.pqState === 2) {
                state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
              } else if (state.pqState === 3) {
                state.pqState = 0;
                if (state.p === null) {
                  state.p = state.num;
                } else {
                  state.q = state.num;
                }
                if (state.p !== null && state.q !== null) {
                  ++state.state;
                }
                state.num = null;
              }
            } else if (state.state === 1) {
              if (state.p.compareTo(state.q) < 0) {
                state.num = state.p;
                state.p = state.q;
                state.q = state.num;
              }
              ++state.state;
            } else if (state.state === 2) {
              state.p1 = state.p.subtract(BigInteger.ONE);
              state.q1 = state.q.subtract(BigInteger.ONE);
              state.phi = state.p1.multiply(state.q1);
              ++state.state;
            } else if (state.state === 3) {
              if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
                ++state.state;
              } else {
                state.p = null;
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 4) {
              state.n = state.p.multiply(state.q);
              if (state.n.bitLength() === state.bits) {
                ++state.state;
              } else {
                state.q = null;
                state.state = 0;
              }
            } else if (state.state === 5) {
              var d = state.e.modInverse(state.phi);
              state.keys = {
                privateKey: pki2.rsa.setPrivateKey(
                  state.n,
                  state.e,
                  d,
                  state.p,
                  state.q,
                  d.mod(state.p1),
                  d.mod(state.q1),
                  state.q.modInverse(state.p)
                ),
                publicKey: pki2.rsa.setPublicKey(state.n, state.e)
              };
            }
            t2 = +/* @__PURE__ */ new Date();
            total += t2 - t1;
            t1 = t2;
          }
          return state.keys !== null;
        };
        pki2.rsa.generateKeyPair = function(bits2, e2, options, callback) {
          if (arguments.length === 1) {
            if (typeof bits2 === "object") {
              options = bits2;
              bits2 = void 0;
            } else if (typeof bits2 === "function") {
              callback = bits2;
              bits2 = void 0;
            }
          } else if (arguments.length === 2) {
            if (typeof bits2 === "number") {
              if (typeof e2 === "function") {
                callback = e2;
                e2 = void 0;
              } else if (typeof e2 !== "number") {
                options = e2;
                e2 = void 0;
              }
            } else {
              options = bits2;
              callback = e2;
              bits2 = void 0;
              e2 = void 0;
            }
          } else if (arguments.length === 3) {
            if (typeof e2 === "number") {
              if (typeof options === "function") {
                callback = options;
                options = void 0;
              }
            } else {
              callback = options;
              options = e2;
              e2 = void 0;
            }
          }
          options = options || {};
          if (bits2 === void 0) {
            bits2 = options.bits || 2048;
          }
          if (e2 === void 0) {
            e2 = options.e || 65537;
          }
          if (!forge.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e2 === 65537 || e2 === 3)) {
            if (callback) {
              if (_detectNodeCrypto("generateKeyPair")) {
                return _crypto.generateKeyPair("rsa", {
                  modulusLength: bits2,
                  publicExponent: e2,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                }, function(err, pub, priv) {
                  if (err) {
                    return callback(err);
                  }
                  callback(null, {
                    privateKey: pki2.privateKeyFromPem(priv),
                    publicKey: pki2.publicKeyFromPem(pub)
                  });
                });
              }
              if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
                return util.globalScope.crypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e2),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]).then(function(pair) {
                  return util.globalScope.crypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                }).then(void 0, function(err) {
                  callback(err);
                }).then(function(pkcs8) {
                  if (pkcs8) {
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn1.fromDer(forge.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  }
                });
              }
              if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
                var genOp = util.globalScope.msCrypto.subtle.generateKey({
                  name: "RSASSA-PKCS1-v1_5",
                  modulusLength: bits2,
                  publicExponent: _intToUint8Array(e2),
                  hash: { name: "SHA-256" }
                }, true, ["sign", "verify"]);
                genOp.oncomplete = function(e22) {
                  var pair = e22.target.result;
                  var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                    "pkcs8",
                    pair.privateKey
                  );
                  exportOp.oncomplete = function(e3) {
                    var pkcs8 = e3.target.result;
                    var privateKey = pki2.privateKeyFromAsn1(
                      asn1.fromDer(forge.util.createBuffer(pkcs8))
                    );
                    callback(null, {
                      privateKey,
                      publicKey: pki2.setRsaPublicKey(privateKey.n, privateKey.e)
                    });
                  };
                  exportOp.onerror = function(err) {
                    callback(err);
                  };
                };
                genOp.onerror = function(err) {
                  callback(err);
                };
                return;
              }
            } else {
              if (_detectNodeCrypto("generateKeyPairSync")) {
                var keypair = _crypto.generateKeyPairSync("rsa", {
                  modulusLength: bits2,
                  publicExponent: e2,
                  publicKeyEncoding: {
                    type: "spki",
                    format: "pem"
                  },
                  privateKeyEncoding: {
                    type: "pkcs8",
                    format: "pem"
                  }
                });
                return {
                  privateKey: pki2.privateKeyFromPem(keypair.privateKey),
                  publicKey: pki2.publicKeyFromPem(keypair.publicKey)
                };
              }
            }
          }
          var state = pki2.rsa.createKeyPairGenerationState(bits2, e2, options);
          if (!callback) {
            pki2.rsa.stepKeyPairGenerationState(state, 0);
            return state.keys;
          }
          _generateKeyPair(state, options, callback);
        };
        pki2.setRsaPublicKey = pki2.rsa.setPublicKey = function(n, e2) {
          var key = {
            n,
            e: e2
          };
          key.encrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = {
                encode: function(m2, key2, pub) {
                  return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
                }
              };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                encode: function(m2, key2) {
                  return forge.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { encode: function(e3) {
                return e3;
              } };
            } else if (typeof scheme === "string") {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            var e22 = scheme.encode(data, key, true);
            return pki2.rsa.encrypt(e22, key, true);
          };
          key.verify = function(digest, signature, scheme, options) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSASSA-PKCS1-V1_5";
            }
            if (options === void 0) {
              options = {
                _parseAllDigestBytes: true
              };
            }
            if (!("_parseAllDigestBytes" in options)) {
              options._parseAllDigestBytes = true;
            }
            if (scheme === "RSASSA-PKCS1-V1_5") {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  var obj = asn1.fromDer(d2, {
                    parseAllBytes: options._parseAllDigestBytes
                  });
                  var capture = {};
                  var errors = [];
                  if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                    var error = new Error(
                      "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                    );
                    error.errors = errors;
                    throw error;
                  }
                  var oid = asn1.derToOid(capture.algorithmIdentifier);
                  if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
                    var error = new Error(
                      "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                    );
                    error.oid = oid;
                    throw error;
                  }
                  if (oid === forge.oids.md2 || oid === forge.oids.md5) {
                    if (!("parameters" in capture)) {
                      throw new Error(
                        "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                      );
                    }
                  }
                  return digest2 === capture.digest;
                }
              };
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = {
                verify: function(digest2, d2) {
                  d2 = _decodePkcs1_v1_5(d2, key, true);
                  return digest2 === d2;
                }
              };
            }
            var d = pki2.rsa.decrypt(signature, key, true, false);
            return scheme.verify(digest, d, key.n.bitLength());
          };
          return key;
        };
        pki2.setRsaPrivateKey = pki2.rsa.setPrivateKey = function(n, e2, d, p2, q2, dP, dQ, qInv) {
          var key = {
            n,
            e: e2,
            d,
            p: p2,
            q: q2,
            dP,
            dQ,
            qInv
          };
          key.decrypt = function(data, scheme, schemeOptions) {
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            } else if (scheme === void 0) {
              scheme = "RSAES-PKCS1-V1_5";
            }
            var d2 = pki2.rsa.decrypt(data, key, false, false);
            if (scheme === "RSAES-PKCS1-V1_5") {
              scheme = { decode: _decodePkcs1_v1_5 };
            } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
              scheme = {
                decode: function(d3, key2) {
                  return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
                }
              };
            } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
              scheme = { decode: function(d3) {
                return d3;
              } };
            } else {
              throw new Error('Unsupported encryption scheme: "' + scheme + '".');
            }
            return scheme.decode(d2, key, false);
          };
          key.sign = function(md, scheme) {
            var bt = false;
            if (typeof scheme === "string") {
              scheme = scheme.toUpperCase();
            }
            if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
              scheme = { encode: emsaPkcs1v15encode };
              bt = 1;
            } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
              scheme = { encode: function() {
                return md;
              } };
              bt = 1;
            }
            var d2 = scheme.encode(md, key.n.bitLength());
            return pki2.rsa.encrypt(d2, key, bt);
          };
          return key;
        };
        pki2.wrapRsaPrivateKey = function(rsaKey) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version (0)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(0).getBytes()
            ),
            // privateKeyAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // PrivateKey
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(rsaKey).getBytes()
            )
          ]);
        };
        pki2.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
            obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
          }
          capture = {};
          errors = [];
          if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
            error.errors = errors;
            throw error;
          }
          var n, e2, d, p2, q2, dP, dQ, qInv;
          n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
          e2 = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
          d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
          p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
          q2 = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
          dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
          dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
          qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
          return pki2.setRsaPrivateKey(
            new BigInteger(n, 16),
            new BigInteger(e2, 16),
            new BigInteger(d, 16),
            new BigInteger(p2, 16),
            new BigInteger(q2, 16),
            new BigInteger(dP, 16),
            new BigInteger(dQ, 16),
            new BigInteger(qInv, 16)
          );
        };
        pki2.privateKeyToAsn1 = pki2.privateKeyToRSAPrivateKey = function(key) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version (0 = only 2 primes, 1 multiple primes)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(0).getBytes()
            ),
            // modulus (n)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            ),
            // privateExponent (d)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.d)
            ),
            // privateKeyPrime1 (p)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.p)
            ),
            // privateKeyPrime2 (q)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.q)
            ),
            // privateKeyExponent1 (dP)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.dP)
            ),
            // privateKeyExponent2 (dQ)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.dQ)
            ),
            // coefficient (qInv)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.qInv)
            )
          ]);
        };
        pki2.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
            var oid = asn1.derToOid(capture.publicKeyOid);
            if (oid !== pki2.oids.rsaEncryption) {
              var error = new Error("Cannot read public key. Unknown OID.");
              error.oid = oid;
              throw error;
            }
            obj = capture.rsaPublicKey;
          }
          errors = [];
          if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
            var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
            error.errors = errors;
            throw error;
          }
          var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
          var e2 = forge.util.createBuffer(capture.publicKeyExponent).toHex();
          return pki2.setRsaPublicKey(
            new BigInteger(n, 16),
            new BigInteger(e2, 16)
          );
        };
        pki2.publicKeyToAsn1 = pki2.publicKeyToSubjectPublicKeyInfo = function(key) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki2.oids.rsaEncryption).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // subjectPublicKey
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
              pki2.publicKeyToRSAPublicKey(key)
            ])
          ]);
        };
        pki2.publicKeyToRSAPublicKey = function(key) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // modulus (n)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.n)
            ),
            // publicExponent (e)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              _bnToBytes(key.e)
            )
          ]);
        };
        function _encodePkcs1_v1_5(m2, key, bt) {
          var eb = forge.util.createBuffer();
          var k2 = Math.ceil(key.n.bitLength() / 8);
          if (m2.length > k2 - 11) {
            var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
            error.length = m2.length;
            error.max = k2 - 11;
            throw error;
          }
          eb.putByte(0);
          eb.putByte(bt);
          var padNum = k2 - 3 - m2.length;
          var padByte;
          if (bt === 0 || bt === 1) {
            padByte = bt === 0 ? 0 : 255;
            for (var i2 = 0; i2 < padNum; ++i2) {
              eb.putByte(padByte);
            }
          } else {
            while (padNum > 0) {
              var numZeros = 0;
              var padBytes = forge.random.getBytes(padNum);
              for (var i2 = 0; i2 < padNum; ++i2) {
                padByte = padBytes.charCodeAt(i2);
                if (padByte === 0) {
                  ++numZeros;
                } else {
                  eb.putByte(padByte);
                }
              }
              padNum = numZeros;
            }
          }
          eb.putByte(0);
          eb.putBytes(m2);
          return eb;
        }
        function _decodePkcs1_v1_5(em, key, pub, ml) {
          var k2 = Math.ceil(key.n.bitLength() / 8);
          var eb = forge.util.createBuffer(em);
          var first = eb.getByte();
          var bt = eb.getByte();
          if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
            throw new Error("Encryption block is invalid.");
          }
          var padNum = 0;
          if (bt === 0) {
            padNum = k2 - 3 - ml;
            for (var i2 = 0; i2 < padNum; ++i2) {
              if (eb.getByte() !== 0) {
                throw new Error("Encryption block is invalid.");
              }
            }
          } else if (bt === 1) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() !== 255) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          } else if (bt === 2) {
            padNum = 0;
            while (eb.length() > 1) {
              if (eb.getByte() === 0) {
                --eb.read;
                break;
              }
              ++padNum;
            }
          }
          var zero2 = eb.getByte();
          if (zero2 !== 0 || padNum !== k2 - 3 - eb.length()) {
            throw new Error("Encryption block is invalid.");
          }
          return eb.getBytes();
        }
        function _generateKeyPair(state, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          var opts = {
            algorithm: {
              name: options.algorithm || "PRIMEINC",
              options: {
                workers: options.workers || 2,
                workLoad: options.workLoad || 100,
                workerScript: options.workerScript
              }
            }
          };
          if ("prng" in options) {
            opts.prng = options.prng;
          }
          generate();
          function generate() {
            getPrime(state.pBits, function(err, num) {
              if (err) {
                return callback(err);
              }
              state.p = num;
              if (state.q !== null) {
                return finish(err, state.q);
              }
              getPrime(state.qBits, finish);
            });
          }
          function getPrime(bits2, callback2) {
            forge.prime.generateProbablePrime(bits2, opts, callback2);
          }
          function finish(err, num) {
            if (err) {
              return callback(err);
            }
            state.q = num;
            if (state.p.compareTo(state.q) < 0) {
              var tmp = state.p;
              state.p = state.q;
              state.q = tmp;
            }
            if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = null;
              generate();
              return;
            }
            if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            state.p1 = state.p.subtract(BigInteger.ONE);
            state.q1 = state.q.subtract(BigInteger.ONE);
            state.phi = state.p1.multiply(state.q1);
            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
              state.p = state.q = null;
              generate();
              return;
            }
            state.n = state.p.multiply(state.q);
            if (state.n.bitLength() !== state.bits) {
              state.q = null;
              getPrime(state.qBits, finish);
              return;
            }
            var d = state.e.modInverse(state.phi);
            state.keys = {
              privateKey: pki2.rsa.setPrivateKey(
                state.n,
                state.e,
                d,
                state.p,
                state.q,
                d.mod(state.p1),
                d.mod(state.q1),
                state.q.modInverse(state.p)
              ),
              publicKey: pki2.rsa.setPublicKey(state.n, state.e)
            };
            callback(null, state.keys);
          }
        }
        function _bnToBytes(b2) {
          var hex2 = b2.toString(16);
          if (hex2[0] >= "8") {
            hex2 = "00" + hex2;
          }
          var bytes = forge.util.hexToBytes(hex2);
          if (bytes.length > 1 && // leading 0x00 for positive integer
          (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
            return bytes.substr(1);
          }
          return bytes;
        }
        function _getMillerRabinTests(bits2) {
          if (bits2 <= 100)
            return 27;
          if (bits2 <= 150)
            return 18;
          if (bits2 <= 200)
            return 15;
          if (bits2 <= 250)
            return 12;
          if (bits2 <= 300)
            return 9;
          if (bits2 <= 350)
            return 8;
          if (bits2 <= 400)
            return 7;
          if (bits2 <= 500)
            return 6;
          if (bits2 <= 600)
            return 5;
          if (bits2 <= 800)
            return 4;
          if (bits2 <= 1250)
            return 3;
          return 2;
        }
        function _detectNodeCrypto(fn) {
          return forge.util.isNodejs && typeof _crypto[fn] === "function";
        }
        function _detectSubtleCrypto(fn) {
          return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
        }
        function _detectSubtleMsCrypto(fn) {
          return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
        }
        function _intToUint8Array(x2) {
          var bytes = forge.util.hexToBytes(x2.toString(16));
          var buffer = new Uint8Array(bytes.length);
          for (var i2 = 0; i2 < bytes.length; ++i2) {
            buffer[i2] = bytes.charCodeAt(i2);
          }
          return buffer;
        }
      }
    });
    var require_pbe2 = __commonJS2({
      "../../node_modules/node-forge/lib/pbe.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_asn12();
        require_des2();
        require_md2();
        require_oids2();
        require_pbkdf22();
        require_pem2();
        require_random2();
        require_rc22();
        require_rsa2();
        require_util2();
        if (typeof BigInteger === "undefined") {
          BigInteger = forge.jsbn.BigInteger;
        }
        var BigInteger;
        var asn1 = forge.asn1;
        var pki2 = forge.pki = forge.pki || {};
        module2.exports = pki2.pbe = forge.pbe = forge.pbe || {};
        var oids = pki2.oids;
        var encryptedPrivateKeyValidator = {
          name: "EncryptedPrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "encryptionOid"
            }, {
              name: "AlgorithmIdentifier.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "encryptionParams"
            }]
          }, {
            // encryptedData
            name: "EncryptedPrivateKeyInfo.encryptedData",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "encryptedData"
          }]
        };
        var PBES2AlgorithmsValidator = {
          name: "PBES2Algorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.keyDerivationFunc.oid",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "kdfOid"
            }, {
              name: "PBES2Algorithms.params",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PBES2Algorithms.params.salt",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OCTETSTRING,
                constructed: false,
                capture: "kdfSalt"
              }, {
                name: "PBES2Algorithms.params.iterationCount",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: "kdfIterationCount"
              }, {
                name: "PBES2Algorithms.params.keyLength",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "keyLength"
              }, {
                // prf
                name: "PBES2Algorithms.params.prf",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                optional: true,
                value: [{
                  name: "PBES2Algorithms.params.prf.algorithm",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OID,
                  constructed: false,
                  capture: "prfOid"
                }]
              }]
            }]
          }, {
            name: "PBES2Algorithms.encryptionScheme",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.encryptionScheme.oid",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "encOid"
            }, {
              name: "PBES2Algorithms.encryptionScheme.iv",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "encIv"
            }]
          }]
        };
        var pkcs12PbeParamsValidator = {
          name: "pkcs-12PbeParams",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "pkcs-12PbeParams.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "salt"
          }, {
            name: "pkcs-12PbeParams.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "iterations"
          }]
        };
        pki2.encryptPrivateKeyInfo = function(obj, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || "aes128";
          options.prfAlgorithm = options.prfAlgorithm || "sha1";
          var salt = forge.random.getBytesSync(options.saltSize);
          var count = options.count;
          var countBytes = asn1.integerToDer(count);
          var dkLen;
          var encryptionAlgorithm;
          var encryptedData;
          if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
            var ivLen, encOid, cipherFn;
            switch (options.algorithm) {
              case "aes128":
                dkLen = 16;
                ivLen = 16;
                encOid = oids["aes128-CBC"];
                cipherFn = forge.aes.createEncryptionCipher;
                break;
              case "aes192":
                dkLen = 24;
                ivLen = 16;
                encOid = oids["aes192-CBC"];
                cipherFn = forge.aes.createEncryptionCipher;
                break;
              case "aes256":
                dkLen = 32;
                ivLen = 16;
                encOid = oids["aes256-CBC"];
                cipherFn = forge.aes.createEncryptionCipher;
                break;
              case "des":
                dkLen = 8;
                ivLen = 8;
                encOid = oids["desCBC"];
                cipherFn = forge.des.createEncryptionCipher;
                break;
              default:
                var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
                error.algorithm = options.algorithm;
                throw error;
            }
            var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
            var md = prfAlgorithmToMessageDigest(prfAlgorithm);
            var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
            var iv = forge.random.getBytesSync(ivLen);
            var cipher = cipherFn(dk);
            cipher.start(iv);
            cipher.update(asn1.toDer(obj));
            cipher.finish();
            encryptedData = cipher.output.getBytes();
            var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
            encryptionAlgorithm = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // keyDerivationFunc
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OID,
                      false,
                      asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                    ),
                    // PBKDF2-params
                    params
                  ]),
                  // encryptionScheme
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OID,
                      false,
                      asn1.oidToDer(encOid).getBytes()
                    ),
                    // iv
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      iv
                    )
                  ])
                ])
              ]
            );
          } else if (options.algorithm === "3des") {
            dkLen = 24;
            var saltBytes = new forge.util.ByteBuffer(salt);
            var dk = pki2.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
            var iv = pki2.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
            var cipher = forge.des.createEncryptionCipher(dk);
            cipher.start(iv);
            cipher.update(asn1.toDer(obj));
            cipher.finish();
            encryptedData = cipher.output.getBytes();
            encryptionAlgorithm = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
                ),
                // pkcs-12PbeParams
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // salt
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
                  // iteration count
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.INTEGER,
                    false,
                    countBytes.getBytes()
                  )
                ])
              ]
            );
          } else {
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
          }
          var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // encryptionAlgorithm
            encryptionAlgorithm,
            // encryptedData
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              encryptedData
            )
          ]);
          return rval;
        };
        pki2.decryptPrivateKeyInfo = function(obj, password) {
          var rval = null;
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
            var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.encryptionOid);
          var cipher = pki2.pbe.getCipher(oid, capture.encryptionParams, password);
          var encrypted = forge.util.createBuffer(capture.encryptedData);
          cipher.update(encrypted);
          if (cipher.finish()) {
            rval = asn1.fromDer(cipher.output);
          }
          return rval;
        };
        pki2.encryptedPrivateKeyToPem = function(epki, maxline) {
          var msg = {
            type: "ENCRYPTED PRIVATE KEY",
            body: asn1.toDer(epki).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.encryptedPrivateKeyFromPem = function(pem) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY") {
            var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
          }
          return asn1.fromDer(msg.body);
        };
        pki2.encryptRsaPrivateKey = function(rsaKey, password, options) {
          options = options || {};
          if (!options.legacy) {
            var rval = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(rsaKey));
            rval = pki2.encryptPrivateKeyInfo(rval, password, options);
            return pki2.encryptedPrivateKeyToPem(rval);
          }
          var algorithm;
          var iv;
          var dkLen;
          var cipherFn;
          switch (options.algorithm) {
            case "aes128":
              algorithm = "AES-128-CBC";
              dkLen = 16;
              iv = forge.random.getBytesSync(16);
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes192":
              algorithm = "AES-192-CBC";
              dkLen = 24;
              iv = forge.random.getBytesSync(16);
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes256":
              algorithm = "AES-256-CBC";
              dkLen = 32;
              iv = forge.random.getBytesSync(16);
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "3des":
              algorithm = "DES-EDE3-CBC";
              dkLen = 24;
              iv = forge.random.getBytesSync(8);
              cipherFn = forge.des.createEncryptionCipher;
              break;
            case "des":
              algorithm = "DES-CBC";
              dkLen = 8;
              iv = forge.random.getBytesSync(8);
              cipherFn = forge.des.createEncryptionCipher;
              break;
            default:
              var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
              error.algorithm = options.algorithm;
              throw error;
          }
          var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
          var cipher = cipherFn(dk);
          cipher.start(iv);
          cipher.update(asn1.toDer(pki2.privateKeyToAsn1(rsaKey)));
          cipher.finish();
          var msg = {
            type: "RSA PRIVATE KEY",
            procType: {
              version: "4",
              type: "ENCRYPTED"
            },
            dekInfo: {
              algorithm,
              parameters: forge.util.bytesToHex(iv).toUpperCase()
            },
            body: cipher.output.getBytes()
          };
          return forge.pem.encode(msg);
        };
        pki2.decryptRsaPrivateKey = function(pem, password) {
          var rval = null;
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
            error.headerType = error;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            var dkLen;
            var cipherFn;
            switch (msg.dekInfo.algorithm) {
              case "DES-CBC":
                dkLen = 8;
                cipherFn = forge.des.createDecryptionCipher;
                break;
              case "DES-EDE3-CBC":
                dkLen = 24;
                cipherFn = forge.des.createDecryptionCipher;
                break;
              case "AES-128-CBC":
                dkLen = 16;
                cipherFn = forge.aes.createDecryptionCipher;
                break;
              case "AES-192-CBC":
                dkLen = 24;
                cipherFn = forge.aes.createDecryptionCipher;
                break;
              case "AES-256-CBC":
                dkLen = 32;
                cipherFn = forge.aes.createDecryptionCipher;
                break;
              case "RC2-40-CBC":
                dkLen = 5;
                cipherFn = function(key) {
                  return forge.rc2.createDecryptionCipher(key, 40);
                };
                break;
              case "RC2-64-CBC":
                dkLen = 8;
                cipherFn = function(key) {
                  return forge.rc2.createDecryptionCipher(key, 64);
                };
                break;
              case "RC2-128-CBC":
                dkLen = 16;
                cipherFn = function(key) {
                  return forge.rc2.createDecryptionCipher(key, 128);
                };
                break;
              default:
                var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
                error.algorithm = msg.dekInfo.algorithm;
                throw error;
            }
            var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
            var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
            var cipher = cipherFn(dk);
            cipher.start(iv);
            cipher.update(forge.util.createBuffer(msg.body));
            if (cipher.finish()) {
              rval = cipher.output.getBytes();
            } else {
              return rval;
            }
          } else {
            rval = msg.body;
          }
          if (msg.type === "ENCRYPTED PRIVATE KEY") {
            rval = pki2.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
          } else {
            rval = asn1.fromDer(rval);
          }
          if (rval !== null) {
            rval = pki2.privateKeyFromAsn1(rval);
          }
          return rval;
        };
        pki2.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
          var j2, l2;
          if (typeof md === "undefined" || md === null) {
            if (!("sha1" in forge.md)) {
              throw new Error('"sha1" hash algorithm unavailable.');
            }
            md = forge.md.sha1.create();
          }
          var u2 = md.digestLength;
          var v2 = md.blockLength;
          var result = new forge.util.ByteBuffer();
          var passBuf = new forge.util.ByteBuffer();
          if (password !== null && password !== void 0) {
            for (l2 = 0; l2 < password.length; l2++) {
              passBuf.putInt16(password.charCodeAt(l2));
            }
            passBuf.putInt16(0);
          }
          var p2 = passBuf.length();
          var s2 = salt.length();
          var D2 = new forge.util.ByteBuffer();
          D2.fillWithByte(id, v2);
          var Slen = v2 * Math.ceil(s2 / v2);
          var S2 = new forge.util.ByteBuffer();
          for (l2 = 0; l2 < Slen; l2++) {
            S2.putByte(salt.at(l2 % s2));
          }
          var Plen = v2 * Math.ceil(p2 / v2);
          var P2 = new forge.util.ByteBuffer();
          for (l2 = 0; l2 < Plen; l2++) {
            P2.putByte(passBuf.at(l2 % p2));
          }
          var I2 = S2;
          I2.putBuffer(P2);
          var c2 = Math.ceil(n / u2);
          for (var i2 = 1; i2 <= c2; i2++) {
            var buf = new forge.util.ByteBuffer();
            buf.putBytes(D2.bytes());
            buf.putBytes(I2.bytes());
            for (var round = 0; round < iter; round++) {
              md.start();
              md.update(buf.getBytes());
              buf = md.digest();
            }
            var B2 = new forge.util.ByteBuffer();
            for (l2 = 0; l2 < v2; l2++) {
              B2.putByte(buf.at(l2 % u2));
            }
            var k2 = Math.ceil(s2 / v2) + Math.ceil(p2 / v2);
            var Inew = new forge.util.ByteBuffer();
            for (j2 = 0; j2 < k2; j2++) {
              var chunk = new forge.util.ByteBuffer(I2.getBytes(v2));
              var x2 = 511;
              for (l2 = B2.length() - 1; l2 >= 0; l2--) {
                x2 = x2 >> 8;
                x2 += B2.at(l2) + chunk.at(l2);
                chunk.setAt(l2, x2 & 255);
              }
              Inew.putBuffer(chunk);
            }
            I2 = Inew;
            result.putBuffer(buf);
          }
          result.truncate(result.length() - n);
          return result;
        };
        pki2.pbe.getCipher = function(oid, params, password) {
          switch (oid) {
            case pki2.oids["pkcs5PBES2"]:
              return pki2.pbe.getCipherForPBES2(oid, params, password);
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              return pki2.pbe.getCipherForPKCS12PBE(oid, params, password);
            default:
              var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
              error.oid = oid;
              error.supportedOids = [
                "pkcs5PBES2",
                "pbeWithSHAAnd3-KeyTripleDES-CBC",
                "pbewithSHAAnd40BitRC2-CBC"
              ];
              throw error;
          }
        };
        pki2.pbe.getCipherForPBES2 = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          oid = asn1.derToOid(capture.kdfOid);
          if (oid !== pki2.oids["pkcs5PBKDF2"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
            error.oid = oid;
            error.supportedOids = ["pkcs5PBKDF2"];
            throw error;
          }
          oid = asn1.derToOid(capture.encOid);
          if (oid !== pki2.oids["aes128-CBC"] && oid !== pki2.oids["aes192-CBC"] && oid !== pki2.oids["aes256-CBC"] && oid !== pki2.oids["des-EDE3-CBC"] && oid !== pki2.oids["desCBC"]) {
            var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
            error.oid = oid;
            error.supportedOids = [
              "aes128-CBC",
              "aes192-CBC",
              "aes256-CBC",
              "des-EDE3-CBC",
              "desCBC"
            ];
            throw error;
          }
          var salt = capture.kdfSalt;
          var count = forge.util.createBuffer(capture.kdfIterationCount);
          count = count.getInt(count.length() << 3);
          var dkLen;
          var cipherFn;
          switch (pki2.oids[oid]) {
            case "aes128-CBC":
              dkLen = 16;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "aes192-CBC":
              dkLen = 24;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "aes256-CBC":
              dkLen = 32;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "des-EDE3-CBC":
              dkLen = 24;
              cipherFn = forge.des.createDecryptionCipher;
              break;
            case "desCBC":
              dkLen = 8;
              cipherFn = forge.des.createDecryptionCipher;
              break;
          }
          var md = prfOidToMessageDigest(capture.prfOid);
          var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
          var iv = capture.encIv;
          var cipher = cipherFn(dk);
          cipher.start(iv);
          return cipher;
        };
        pki2.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
            var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
            error.errors = errors;
            throw error;
          }
          var salt = forge.util.createBuffer(capture.salt);
          var count = forge.util.createBuffer(capture.iterations);
          count = count.getInt(count.length() << 3);
          var dkLen, dIvLen, cipherFn;
          switch (oid) {
            case pki2.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
              dkLen = 24;
              dIvLen = 8;
              cipherFn = forge.des.startDecrypting;
              break;
            case pki2.oids["pbewithSHAAnd40BitRC2-CBC"]:
              dkLen = 5;
              dIvLen = 8;
              cipherFn = function(key2, iv2) {
                var cipher = forge.rc2.createDecryptionCipher(key2, 40);
                cipher.start(iv2, null);
                return cipher;
              };
              break;
            default:
              var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
              error.oid = oid;
              throw error;
          }
          var md = prfOidToMessageDigest(capture.prfOid);
          var key = pki2.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
          md.start();
          var iv = pki2.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
          return cipherFn(key, iv);
        };
        pki2.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
          if (typeof md === "undefined" || md === null) {
            if (!("md5" in forge.md)) {
              throw new Error('"md5" hash algorithm unavailable.');
            }
            md = forge.md.md5.create();
          }
          if (salt === null) {
            salt = "";
          }
          var digests = [hash22(md, password + salt)];
          for (var length2 = 16, i2 = 1; length2 < dkLen; ++i2, length2 += 16) {
            digests.push(hash22(md, digests[i2 - 1] + password + salt));
          }
          return digests.join("").substr(0, dkLen);
        };
        function hash22(md, bytes) {
          return md.start().update(bytes).digest().getBytes();
        }
        function prfOidToMessageDigest(prfOid) {
          var prfAlgorithm;
          if (!prfOid) {
            prfAlgorithm = "hmacWithSHA1";
          } else {
            prfAlgorithm = pki2.oids[asn1.derToOid(prfOid)];
            if (!prfAlgorithm) {
              var error = new Error("Unsupported PRF OID.");
              error.oid = prfOid;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
            }
          }
          return prfAlgorithmToMessageDigest(prfAlgorithm);
        }
        function prfAlgorithmToMessageDigest(prfAlgorithm) {
          var factory = forge.md;
          switch (prfAlgorithm) {
            case "hmacWithSHA224":
              factory = forge.md.sha512;
            case "hmacWithSHA1":
            case "hmacWithSHA256":
            case "hmacWithSHA384":
            case "hmacWithSHA512":
              prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
              break;
            default:
              var error = new Error("Unsupported PRF algorithm.");
              error.algorithm = prfAlgorithm;
              error.supported = [
                "hmacWithSHA1",
                "hmacWithSHA224",
                "hmacWithSHA256",
                "hmacWithSHA384",
                "hmacWithSHA512"
              ];
              throw error;
          }
          if (!factory || !(prfAlgorithm in factory)) {
            throw new Error("Unknown hash algorithm: " + prfAlgorithm);
          }
          return factory[prfAlgorithm].create();
        }
        function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
          var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // salt
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              salt
            ),
            // iteration count
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              countBytes.getBytes()
            )
          ]);
          if (prfAlgorithm !== "hmacWithSHA1") {
            params.value.push(
              // key length
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                forge.util.hexToBytes(dkLen.toString(16))
              ),
              // AlgorithmIdentifier
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // algorithm
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(pki2.oids[prfAlgorithm]).getBytes()
                ),
                // parameters (null)
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            );
          }
          return params;
        }
      }
    });
    var require_pkcs7asn12 = __commonJS2({
      "../../node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        require_util2();
        var asn1 = forge.asn1;
        var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
        forge.pkcs7 = forge.pkcs7 || {};
        forge.pkcs7.asn1 = p7v;
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "ContentInfo.ContentType",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            captureAsn1: "content"
          }]
        };
        p7v.contentInfoValidator = contentInfoValidator;
        var encryptedContentInfoValidator = {
          name: "EncryptedContentInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedContentInfo.contentType",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
              tagClass: asn1.Class.UNIVERSAL,
              captureAsn1: "encParameter"
            }]
          }, {
            name: "EncryptedContentInfo.encryptedContent",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            /* The PKCS#7 structure output by OpenSSL somewhat differs from what
             * other implementations do generate.
             *
             * OpenSSL generates a structure like this:
             * SEQUENCE {
             *    ...
             *    [0]
             *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *       ...
             * }
             *
             * Whereas other implementations (and this PKCS#7 module) generate:
             * SEQUENCE {
             *    ...
             *    [0] {
             *       OCTET STRING
             *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
             *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
             *          ...
             *    }
             * }
             *
             * In order to support both, we just capture the context specific
             * field here.  The OCTET STRING bit is removed below.
             */
            capture: "encryptedContent",
            captureAsn1: "encryptedContentAsn1"
          }]
        };
        p7v.envelopedDataValidator = {
          name: "EnvelopedData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EnvelopedData.Version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "EnvelopedData.RecipientInfos",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true,
            captureAsn1: "recipientInfos"
          }].concat(encryptedContentInfoValidator)
        };
        p7v.encryptedDataValidator = {
          name: "EncryptedData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedData.Version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          }].concat(encryptedContentInfoValidator)
        };
        var signerValidator = {
          name: "SignerInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false
          }, {
            name: "SignerInfo.issuerAndSerialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.issuerAndSerialNumber.issuer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "SignerInfo.issuerAndSerialNumber.serialNumber",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "SignerInfo.digestAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "SignerInfo.digestAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "digestAlgorithm"
            }, {
              name: "SignerInfo.digestAlgorithm.parameter",
              tagClass: asn1.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "digestParameter",
              optional: true
            }]
          }, {
            name: "SignerInfo.authenticatedAttributes",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            capture: "authenticatedAttributes"
          }, {
            name: "SignerInfo.digestEncryptionAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            capture: "signatureAlgorithm"
          }, {
            name: "SignerInfo.encryptedDigest",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "signature"
          }, {
            name: "SignerInfo.unauthenticatedAttributes",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            capture: "unauthenticatedAttributes"
          }]
        };
        p7v.signedDataValidator = {
          name: "SignedData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "SignedData.Version",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            {
              name: "SignedData.DigestAlgorithms",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true,
              captureAsn1: "digestAlgorithms"
            },
            contentInfoValidator,
            {
              name: "SignedData.Certificates",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 0,
              optional: true,
              captureAsn1: "certificates"
            },
            {
              name: "SignedData.CertificateRevocationLists",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 1,
              optional: true,
              captureAsn1: "crls"
            },
            {
              name: "SignedData.SignerInfos",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              capture: "signerInfos",
              optional: true,
              value: [signerValidator]
            }
          ]
        };
        p7v.recipientInfoValidator = {
          name: "RecipientInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          }, {
            name: "RecipientInfo.issuerAndSerial",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.issuerAndSerial.issuer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "issuer"
            }, {
              name: "RecipientInfo.issuerAndSerial.serialNumber",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "serial"
            }]
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "encAlgorithm"
            }, {
              name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
              tagClass: asn1.Class.UNIVERSAL,
              constructed: false,
              captureAsn1: "encParameter",
              optional: true
            }]
          }, {
            name: "RecipientInfo.encryptedKey",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "encKey"
          }]
        };
      }
    });
    var require_mgf12 = __commonJS2({
      "../../node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        forge.mgf = forge.mgf || {};
        var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
        mgf1.create = function(md) {
          var mgf = {
            /**
             * Generate mask of specified length.
             *
             * @param {String} seed The seed for mask generation.
             * @param maskLen Number of bytes to generate.
             * @return {String} The generated mask.
             */
            generate: function(seed, maskLen) {
              var t = new forge.util.ByteBuffer();
              var len = Math.ceil(maskLen / md.digestLength);
              for (var i2 = 0; i2 < len; i2++) {
                var c2 = new forge.util.ByteBuffer();
                c2.putInt32(i2);
                md.start();
                md.update(seed + c2.getBytes());
                t.putBuffer(md.digest());
              }
              t.truncate(t.length() - maskLen);
              return t.getBytes();
            }
          };
          return mgf;
        };
      }
    });
    var require_mgf2 = __commonJS2({
      "../../node_modules/node-forge/lib/mgf.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_mgf12();
        module2.exports = forge.mgf = forge.mgf || {};
        forge.mgf.mgf1 = forge.mgf1;
      }
    });
    var require_pss2 = __commonJS2({
      "../../node_modules/node-forge/lib/pss.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_random2();
        require_util2();
        var pss = module2.exports = forge.pss = forge.pss || {};
        pss.create = function(options) {
          if (arguments.length === 3) {
            options = {
              md: arguments[0],
              mgf: arguments[1],
              saltLength: arguments[2]
            };
          }
          var hash22 = options.md;
          var mgf = options.mgf;
          var hLen = hash22.digestLength;
          var salt_ = options.salt || null;
          if (typeof salt_ === "string") {
            salt_ = forge.util.createBuffer(salt_);
          }
          var sLen;
          if ("saltLength" in options) {
            sLen = options.saltLength;
          } else if (salt_ !== null) {
            sLen = salt_.length();
          } else {
            throw new Error("Salt length not specified or specific salt not given.");
          }
          if (salt_ !== null && salt_.length() !== sLen) {
            throw new Error("Given salt length does not match length of given salt.");
          }
          var prng = options.prng || forge.random;
          var pssobj = {};
          pssobj.encode = function(md, modBits) {
            var i2;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            var mHash = md.digest().getBytes();
            if (emLen < hLen + sLen + 2) {
              throw new Error("Message is too long to encrypt.");
            }
            var salt;
            if (salt_ === null) {
              salt = prng.getBytesSync(sLen);
            } else {
              salt = salt_.bytes();
            }
            var m_ = new forge.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash22.start();
            hash22.update(m_.getBytes());
            var h = hash22.digest().getBytes();
            var ps = new forge.util.ByteBuffer();
            ps.fillWithByte(0, emLen - sLen - hLen - 2);
            ps.putByte(1);
            ps.putBytes(salt);
            var db = ps.getBytes();
            var maskLen = emLen - hLen - 1;
            var dbMask = mgf.generate(h, maskLen);
            var maskedDB = "";
            for (i2 = 0; i2 < maskLen; i2++) {
              maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
            }
            var mask = 65280 >> 8 * emLen - emBits & 255;
            maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
            return maskedDB + h + String.fromCharCode(188);
          };
          pssobj.verify = function(mHash, em, modBits) {
            var i2;
            var emBits = modBits - 1;
            var emLen = Math.ceil(emBits / 8);
            em = em.substr(-emLen);
            if (emLen < hLen + sLen + 2) {
              throw new Error("Inconsistent parameters to PSS signature verification.");
            }
            if (em.charCodeAt(emLen - 1) !== 188) {
              throw new Error("Encoded message does not end in 0xBC.");
            }
            var maskLen = emLen - hLen - 1;
            var maskedDB = em.substr(0, maskLen);
            var h = em.substr(maskLen, hLen);
            var mask = 65280 >> 8 * emLen - emBits & 255;
            if ((maskedDB.charCodeAt(0) & mask) !== 0) {
              throw new Error("Bits beyond keysize not zero as expected.");
            }
            var dbMask = mgf.generate(h, maskLen);
            var db = "";
            for (i2 = 0; i2 < maskLen; i2++) {
              db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
            }
            db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
            var checkLen = emLen - hLen - sLen - 2;
            for (i2 = 0; i2 < checkLen; i2++) {
              if (db.charCodeAt(i2) !== 0) {
                throw new Error("Leftmost octets not zero as expected");
              }
            }
            if (db.charCodeAt(checkLen) !== 1) {
              throw new Error("Inconsistent PSS signature, 0x01 marker not found");
            }
            var salt = db.substr(-sLen);
            var m_ = new forge.util.ByteBuffer();
            m_.fillWithByte(0, 8);
            m_.putBytes(mHash);
            m_.putBytes(salt);
            hash22.start();
            hash22.update(m_.getBytes());
            var h_ = hash22.digest().getBytes();
            return h === h_;
          };
          return pssobj;
        };
      }
    });
    var require_x5092 = __commonJS2({
      "../../node_modules/node-forge/lib/x509.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_asn12();
        require_des2();
        require_md2();
        require_mgf2();
        require_oids2();
        require_pem2();
        require_pss2();
        require_rsa2();
        require_util2();
        var asn1 = forge.asn1;
        var pki2 = module2.exports = forge.pki = forge.pki || {};
        var oids = pki2.oids;
        var _shortNames = {};
        _shortNames["CN"] = oids["commonName"];
        _shortNames["commonName"] = "CN";
        _shortNames["C"] = oids["countryName"];
        _shortNames["countryName"] = "C";
        _shortNames["L"] = oids["localityName"];
        _shortNames["localityName"] = "L";
        _shortNames["ST"] = oids["stateOrProvinceName"];
        _shortNames["stateOrProvinceName"] = "ST";
        _shortNames["O"] = oids["organizationName"];
        _shortNames["organizationName"] = "O";
        _shortNames["OU"] = oids["organizationalUnitName"];
        _shortNames["organizationalUnitName"] = "OU";
        _shortNames["E"] = oids["emailAddress"];
        _shortNames["emailAddress"] = "E";
        var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
        var x509CertificateValidator = {
          name: "Certificate",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "tbsCertificate",
            value: [
              {
                name: "Certificate.TBSCertificate.version",
                tagClass: asn1.Class.CONTEXT_SPECIFIC,
                type: 0,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.version.integer",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.INTEGER,
                  constructed: false,
                  capture: "certVersion"
                }]
              },
              {
                name: "Certificate.TBSCertificate.serialNumber",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: "certSerialNumber"
              },
              {
                name: "Certificate.TBSCertificate.signature",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "Certificate.TBSCertificate.signature.algorithm",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OID,
                  constructed: false,
                  capture: "certinfoSignatureOid"
                }, {
                  name: "Certificate.TBSCertificate.signature.parameters",
                  tagClass: asn1.Class.UNIVERSAL,
                  optional: true,
                  captureAsn1: "certinfoSignatureParams"
                }]
              },
              {
                name: "Certificate.TBSCertificate.issuer",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certIssuer"
              },
              {
                name: "Certificate.TBSCertificate.validity",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                // Note: UTC and generalized times may both appear so the capture
                // names are based on their detected order, the names used below
                // are only for the common case, which validity time really means
                // "notBefore" and which means "notAfter" will be determined by order
                value: [{
                  // notBefore (Time) (UTC time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity1UTCTime"
                }, {
                  // notBefore (Time) (generalized time case)
                  name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity2GeneralizedTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.UTCTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity3UTCTime"
                }, {
                  // notAfter (Time) (only UTC time is supported)
                  name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.GENERALIZEDTIME,
                  constructed: false,
                  optional: true,
                  capture: "certValidity4GeneralizedTime"
                }]
              },
              {
                // Name (subject) (RDNSequence)
                name: "Certificate.TBSCertificate.subject",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                captureAsn1: "certSubject"
              },
              // SubjectPublicKeyInfo
              publicKeyValidator,
              {
                // issuerUniqueID (optional)
                name: "Certificate.TBSCertificate.issuerUniqueID",
                tagClass: asn1.Class.CONTEXT_SPECIFIC,
                type: 1,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.issuerUniqueID.id",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certIssuerUniqueId"
                }]
              },
              {
                // subjectUniqueID (optional)
                name: "Certificate.TBSCertificate.subjectUniqueID",
                tagClass: asn1.Class.CONTEXT_SPECIFIC,
                type: 2,
                constructed: true,
                optional: true,
                value: [{
                  name: "Certificate.TBSCertificate.subjectUniqueID.id",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.BITSTRING,
                  constructed: false,
                  // TODO: support arbitrary bit length ids
                  captureBitStringValue: "certSubjectUniqueId"
                }]
              },
              {
                // Extensions (optional)
                name: "Certificate.TBSCertificate.extensions",
                tagClass: asn1.Class.CONTEXT_SPECIFIC,
                type: 3,
                constructed: true,
                captureAsn1: "certExtensions",
                optional: true
              }
            ]
          }, {
            // AlgorithmIdentifier (signature algorithm)
            name: "Certificate.signatureAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              // algorithm
              name: "Certificate.signatureAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certSignatureParams"
            }]
          }, {
            // SignatureValue
            name: "Certificate.signatureValue",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certSignature"
          }]
        };
        var rsassaPssParameterValidator = {
          name: "rsapss",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "rsapss.hashAlgorithm",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "hashOid"
                /* parameter block omitted, for SHA1 NULL anyhow. */
              }]
            }]
          }, {
            name: "rsapss.maskGenAlgorithm",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Class.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "maskGenOid"
              }, {
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OID,
                  constructed: false,
                  capture: "maskGenHashOid"
                  /* parameter block omitted, for SHA1 NULL anyhow. */
                }]
              }]
            }]
          }, {
            name: "rsapss.saltLength",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            optional: true,
            value: [{
              name: "rsapss.saltLength.saltLength",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Class.INTEGER,
              constructed: false,
              capture: "saltLength"
            }]
          }, {
            name: "rsapss.trailerField",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            optional: true,
            value: [{
              name: "rsapss.trailer.trailer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Class.INTEGER,
              constructed: false,
              capture: "trailer"
            }]
          }]
        };
        var certificationRequestInfoValidator = {
          name: "CertificationRequestInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfo",
          value: [
            {
              name: "CertificationRequestInfo.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certificationRequestInfoVersion"
            },
            {
              // Name (subject) (RDNSequence)
              name: "CertificationRequestInfo.subject",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certificationRequestInfoSubject"
            },
            // SubjectPublicKeyInfo
            publicKeyValidator,
            {
              name: "CertificationRequestInfo.attributes",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              capture: "certificationRequestInfoAttributes",
              value: [{
                name: "CertificationRequestInfo.attributes",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "CertificationRequestInfo.attributes.type",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OID,
                  constructed: false
                }, {
                  name: "CertificationRequestInfo.attributes.value",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.SET,
                  constructed: true
                }]
              }]
            }
          ]
        };
        var certificationRequestValidator = {
          name: "CertificationRequest",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "csr",
          value: [
            certificationRequestInfoValidator,
            {
              // AlgorithmIdentifier (signature algorithm)
              name: "CertificationRequest.signatureAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                // algorithm
                name: "CertificationRequest.signatureAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "csrSignatureOid"
              }, {
                name: "CertificationRequest.signatureAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                optional: true,
                captureAsn1: "csrSignatureParams"
              }]
            },
            {
              // signature
              name: "CertificationRequest.signature",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "csrSignature"
            }
          ]
        };
        pki2.RDNAttributesAsArray = function(rdn, md) {
          var rval = [];
          var set, attr, obj;
          for (var si = 0; si < rdn.value.length; ++si) {
            set = rdn.value[si];
            for (var i2 = 0; i2 < set.value.length; ++i2) {
              obj = {};
              attr = set.value[i2];
              obj.type = asn1.derToOid(attr.value[0].value);
              obj.value = attr.value[1].value;
              obj.valueTagClass = attr.value[1].type;
              if (obj.type in oids) {
                obj.name = oids[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (md) {
                md.update(obj.type);
                md.update(obj.value);
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        pki2.CRIAttributesAsArray = function(attributes) {
          var rval = [];
          for (var si = 0; si < attributes.length; ++si) {
            var seq = attributes[si];
            var type = asn1.derToOid(seq.value[0].value);
            var values = seq.value[1].value;
            for (var vi = 0; vi < values.length; ++vi) {
              var obj = {};
              obj.type = type;
              obj.value = values[vi].value;
              obj.valueTagClass = values[vi].type;
              if (obj.type in oids) {
                obj.name = oids[obj.type];
                if (obj.name in _shortNames) {
                  obj.shortName = _shortNames[obj.name];
                }
              }
              if (obj.type === oids.extensionRequest) {
                obj.extensions = [];
                for (var ei = 0; ei < obj.value.length; ++ei) {
                  obj.extensions.push(pki2.certificateExtensionFromAsn1(obj.value[ei]));
                }
              }
              rval.push(obj);
            }
          }
          return rval;
        };
        function _getAttribute(obj, options) {
          if (typeof options === "string") {
            options = { shortName: options };
          }
          var rval = null;
          var attr;
          for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
            attr = obj.attributes[i2];
            if (options.type && options.type === attr.type) {
              rval = attr;
            } else if (options.name && options.name === attr.name) {
              rval = attr;
            } else if (options.shortName && options.shortName === attr.shortName) {
              rval = attr;
            }
          }
          return rval;
        }
        var _readSignatureParameters = function(oid, obj, fillDefaults) {
          var params = {};
          if (oid !== oids["RSASSA-PSS"]) {
            return params;
          }
          if (fillDefaults) {
            params = {
              hash: {
                algorithmOid: oids["sha1"]
              },
              mgf: {
                algorithmOid: oids["mgf1"],
                hash: {
                  algorithmOid: oids["sha1"]
                }
              },
              saltLength: 20
            };
          }
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
            var error = new Error("Cannot read RSASSA-PSS parameter block.");
            error.errors = errors;
            throw error;
          }
          if (capture.hashOid !== void 0) {
            params.hash = params.hash || {};
            params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
          }
          if (capture.maskGenOid !== void 0) {
            params.mgf = params.mgf || {};
            params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
            params.mgf.hash = params.mgf.hash || {};
            params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
          }
          if (capture.saltLength !== void 0) {
            params.saltLength = capture.saltLength.charCodeAt(0);
          }
          return params;
        };
        var _createSignatureDigest = function(options) {
          switch (oids[options.signatureOid]) {
            case "sha1WithRSAEncryption":
            case "sha1WithRSASignature":
              return forge.md.sha1.create();
            case "md5WithRSAEncryption":
              return forge.md.md5.create();
            case "sha256WithRSAEncryption":
              return forge.md.sha256.create();
            case "sha384WithRSAEncryption":
              return forge.md.sha384.create();
            case "sha512WithRSAEncryption":
              return forge.md.sha512.create();
            case "RSASSA-PSS":
              return forge.md.sha256.create();
            default:
              var error = new Error(
                "Could not compute " + options.type + " digest. Unknown signature OID."
              );
              error.signatureOid = options.signatureOid;
              throw error;
          }
        };
        var _verifySignature = function(options) {
          var cert = options.certificate;
          var scheme;
          switch (cert.signatureOid) {
            case oids.sha1WithRSAEncryption:
            case oids.sha1WithRSASignature:
              break;
            case oids["RSASSA-PSS"]:
              var hash22, mgf;
              hash22 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
              if (hash22 === void 0 || forge.md[hash22] === void 0) {
                var error = new Error("Unsupported MGF hash function.");
                error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash22;
                throw error;
              }
              mgf = oids[cert.signatureParameters.mgf.algorithmOid];
              if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                var error = new Error("Unsupported MGF function.");
                error.oid = cert.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash22].create());
              hash22 = oids[cert.signatureParameters.hash.algorithmOid];
              if (hash22 === void 0 || forge.md[hash22] === void 0) {
                var error = new Error("Unsupported RSASSA-PSS hash function.");
                error.oid = cert.signatureParameters.hash.algorithmOid;
                error.name = hash22;
                throw error;
              }
              scheme = forge.pss.create(
                forge.md[hash22].create(),
                mgf,
                cert.signatureParameters.saltLength
              );
              break;
          }
          return cert.publicKey.verify(
            options.md.digest().getBytes(),
            options.signature,
            scheme
          );
        };
        pki2.certificateFromPem = function(pem, computeHash, strict) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
            var error = new Error(
              'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
            );
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error(
              "Could not convert certificate from PEM; PEM is encrypted."
            );
          }
          var obj = asn1.fromDer(msg.body, strict);
          return pki2.certificateFromAsn1(obj, computeHash);
        };
        pki2.certificateToPem = function(cert, maxline) {
          var msg = {
            type: "CERTIFICATE",
            body: asn1.toDer(pki2.certificateToAsn1(cert)).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.publicKeyFromPem = function(pem) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
            var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert public key from PEM; PEM is encrypted.");
          }
          var obj = asn1.fromDer(msg.body);
          return pki2.publicKeyFromAsn1(obj);
        };
        pki2.publicKeyToPem = function(key, maxline) {
          var msg = {
            type: "PUBLIC KEY",
            body: asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
          var msg = {
            type: "RSA PUBLIC KEY",
            body: asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md = options.md || forge.md.sha1.create();
          var type = options.type || "RSAPublicKey";
          var bytes;
          switch (type) {
            case "RSAPublicKey":
              bytes = asn1.toDer(pki2.publicKeyToRSAPublicKey(key)).getBytes();
              break;
            case "SubjectPublicKeyInfo":
              bytes = asn1.toDer(pki2.publicKeyToAsn1(key)).getBytes();
              break;
            default:
              throw new Error('Unknown fingerprint type "' + options.type + '".');
          }
          md.start();
          md.update(bytes);
          var digest = md.digest();
          if (options.encoding === "hex") {
            var hex2 = digest.toHex();
            if (options.delimiter) {
              return hex2.match(/.{2}/g).join(options.delimiter);
            }
            return hex2;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        pki2.certificationRequestFromPem = function(pem, computeHash, strict) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "CERTIFICATE REQUEST") {
            var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
          }
          var obj = asn1.fromDer(msg.body, strict);
          return pki2.certificationRequestFromAsn1(obj, computeHash);
        };
        pki2.certificationRequestToPem = function(csr, maxline) {
          var msg = {
            type: "CERTIFICATE REQUEST",
            body: asn1.toDer(pki2.certificationRequestToAsn1(csr)).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.createCertificate = function() {
          var cert = {};
          cert.version = 2;
          cert.serialNumber = "00";
          cert.signatureOid = null;
          cert.signature = null;
          cert.siginfo = {};
          cert.siginfo.algorithmOid = null;
          cert.validity = {};
          cert.validity.notBefore = /* @__PURE__ */ new Date();
          cert.validity.notAfter = /* @__PURE__ */ new Date();
          cert.issuer = {};
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = [];
          cert.issuer.hash = null;
          cert.subject = {};
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = [];
          cert.subject.hash = null;
          cert.extensions = [];
          cert.publicKey = null;
          cert.md = null;
          cert.setSubject = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.subject.attributes = attrs;
            delete cert.subject.uniqueId;
            if (uniqueId) {
              cert.subject.uniqueId = uniqueId;
            }
            cert.subject.hash = null;
          };
          cert.setIssuer = function(attrs, uniqueId) {
            _fillMissingFields(attrs);
            cert.issuer.attributes = attrs;
            delete cert.issuer.uniqueId;
            if (uniqueId) {
              cert.issuer.uniqueId = uniqueId;
            }
            cert.issuer.hash = null;
          };
          cert.setExtensions = function(exts) {
            for (var i2 = 0; i2 < exts.length; ++i2) {
              _fillMissingExtensionFields(exts[i2], { cert });
            }
            cert.extensions = exts;
          };
          cert.getExtension = function(options) {
            if (typeof options === "string") {
              options = { name: options };
            }
            var rval = null;
            var ext;
            for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
              ext = cert.extensions[i2];
              if (options.id && ext.id === options.id) {
                rval = ext;
              } else if (options.name && ext.name === options.name) {
                rval = ext;
              }
            }
            return rval;
          };
          cert.sign = function(key, md) {
            cert.md = md || forge.md.sha1.create();
            var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
              error.algorithm = cert.md.algorithm;
              throw error;
            }
            cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
            cert.tbsCertificate = pki2.getTBSCertificate(cert);
            var bytes = asn1.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
            cert.signature = key.sign(cert.md);
          };
          cert.verify = function(child) {
            var rval = false;
            if (!cert.issued(child)) {
              var issuer = child.issuer;
              var subject = cert.subject;
              var error = new Error(
                "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
              );
              error.expectedIssuer = subject.attributes;
              error.actualIssuer = issuer.attributes;
              throw error;
            }
            var md = child.md;
            if (md === null) {
              md = _createSignatureDigest({
                signatureOid: child.signatureOid,
                type: "certificate"
              });
              var tbsCertificate = child.tbsCertificate || pki2.getTBSCertificate(child);
              var bytes = asn1.toDer(tbsCertificate);
              md.update(bytes.getBytes());
            }
            if (md !== null) {
              rval = _verifySignature({
                certificate: cert,
                md,
                signature: child.signature
              });
            }
            return rval;
          };
          cert.isIssuer = function(parent) {
            var rval = false;
            var i2 = cert.issuer;
            var s2 = parent.subject;
            if (i2.hash && s2.hash) {
              rval = i2.hash === s2.hash;
            } else if (i2.attributes.length === s2.attributes.length) {
              rval = true;
              var iattr, sattr;
              for (var n = 0; rval && n < i2.attributes.length; ++n) {
                iattr = i2.attributes[n];
                sattr = s2.attributes[n];
                if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
                  rval = false;
                }
              }
            }
            return rval;
          };
          cert.issued = function(child) {
            return child.isIssuer(cert);
          };
          cert.generateSubjectKeyIdentifier = function() {
            return pki2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
          };
          cert.verifySubjectKeyIdentifier = function() {
            var oid = oids["subjectKeyIdentifier"];
            for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
              var ext = cert.extensions[i2];
              if (ext.id === oid) {
                var ski = cert.generateSubjectKeyIdentifier().getBytes();
                return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
              }
            }
            return false;
          };
          return cert;
        };
        pki2.certificateFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
            var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var cert = pki2.createCertificate();
          cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
          var serial = forge.util.createBuffer(capture.certSerialNumber);
          cert.serialNumber = serial.toHex();
          cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
          cert.signatureParameters = _readSignatureParameters(
            cert.signatureOid,
            capture.certSignatureParams,
            true
          );
          cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
          cert.siginfo.parameters = _readSignatureParameters(
            cert.siginfo.algorithmOid,
            capture.certinfoSignatureParams,
            false
          );
          cert.signature = capture.certSignature;
          var validity = [];
          if (capture.certValidity1UTCTime !== void 0) {
            validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
          }
          if (capture.certValidity2GeneralizedTime !== void 0) {
            validity.push(asn1.generalizedTimeToDate(
              capture.certValidity2GeneralizedTime
            ));
          }
          if (capture.certValidity3UTCTime !== void 0) {
            validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
          }
          if (capture.certValidity4GeneralizedTime !== void 0) {
            validity.push(asn1.generalizedTimeToDate(
              capture.certValidity4GeneralizedTime
            ));
          }
          if (validity.length > 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
          }
          if (validity.length < 2) {
            throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
          }
          cert.validity.notBefore = validity[0];
          cert.validity.notAfter = validity[1];
          cert.tbsCertificate = capture.tbsCertificate;
          if (computeHash) {
            cert.md = _createSignatureDigest({
              signatureOid: cert.signatureOid,
              type: "certificate"
            });
            var bytes = asn1.toDer(cert.tbsCertificate);
            cert.md.update(bytes.getBytes());
          }
          var imd = forge.md.sha1.create();
          var ibytes = asn1.toDer(capture.certIssuer);
          imd.update(ibytes.getBytes());
          cert.issuer.getField = function(sn) {
            return _getAttribute(cert.issuer, sn);
          };
          cert.issuer.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.issuer.attributes.push(attr);
          };
          cert.issuer.attributes = pki2.RDNAttributesAsArray(capture.certIssuer);
          if (capture.certIssuerUniqueId) {
            cert.issuer.uniqueId = capture.certIssuerUniqueId;
          }
          cert.issuer.hash = imd.digest().toHex();
          var smd = forge.md.sha1.create();
          var sbytes = asn1.toDer(capture.certSubject);
          smd.update(sbytes.getBytes());
          cert.subject.getField = function(sn) {
            return _getAttribute(cert.subject, sn);
          };
          cert.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            cert.subject.attributes.push(attr);
          };
          cert.subject.attributes = pki2.RDNAttributesAsArray(capture.certSubject);
          if (capture.certSubjectUniqueId) {
            cert.subject.uniqueId = capture.certSubjectUniqueId;
          }
          cert.subject.hash = smd.digest().toHex();
          if (capture.certExtensions) {
            cert.extensions = pki2.certificateExtensionsFromAsn1(capture.certExtensions);
          } else {
            cert.extensions = [];
          }
          cert.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          return cert;
        };
        pki2.certificateExtensionsFromAsn1 = function(exts) {
          var rval = [];
          for (var i2 = 0; i2 < exts.value.length; ++i2) {
            var extseq = exts.value[i2];
            for (var ei = 0; ei < extseq.value.length; ++ei) {
              rval.push(pki2.certificateExtensionFromAsn1(extseq.value[ei]));
            }
          }
          return rval;
        };
        pki2.certificateExtensionFromAsn1 = function(ext) {
          var e2 = {};
          e2.id = asn1.derToOid(ext.value[0].value);
          e2.critical = false;
          if (ext.value[1].type === asn1.Type.BOOLEAN) {
            e2.critical = ext.value[1].value.charCodeAt(0) !== 0;
            e2.value = ext.value[2].value;
          } else {
            e2.value = ext.value[1].value;
          }
          if (e2.id in oids) {
            e2.name = oids[e2.id];
            if (e2.name === "keyUsage") {
              var ev = asn1.fromDer(e2.value);
              var b2 = 0;
              var b3 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
                b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
              }
              e2.digitalSignature = (b2 & 128) === 128;
              e2.nonRepudiation = (b2 & 64) === 64;
              e2.keyEncipherment = (b2 & 32) === 32;
              e2.dataEncipherment = (b2 & 16) === 16;
              e2.keyAgreement = (b2 & 8) === 8;
              e2.keyCertSign = (b2 & 4) === 4;
              e2.cRLSign = (b2 & 2) === 2;
              e2.encipherOnly = (b2 & 1) === 1;
              e2.decipherOnly = (b3 & 128) === 128;
            } else if (e2.name === "basicConstraints") {
              var ev = asn1.fromDer(e2.value);
              if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
                e2.cA = ev.value[0].value.charCodeAt(0) !== 0;
              } else {
                e2.cA = false;
              }
              var value = null;
              if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
                value = ev.value[0].value;
              } else if (ev.value.length > 1) {
                value = ev.value[1].value;
              }
              if (value !== null) {
                e2.pathLenConstraint = asn1.derToInteger(value);
              }
            } else if (e2.name === "extKeyUsage") {
              var ev = asn1.fromDer(e2.value);
              for (var vi = 0; vi < ev.value.length; ++vi) {
                var oid = asn1.derToOid(ev.value[vi].value);
                if (oid in oids) {
                  e2[oids[oid]] = true;
                } else {
                  e2[oid] = true;
                }
              }
            } else if (e2.name === "nsCertType") {
              var ev = asn1.fromDer(e2.value);
              var b2 = 0;
              if (ev.value.length > 1) {
                b2 = ev.value.charCodeAt(1);
              }
              e2.client = (b2 & 128) === 128;
              e2.server = (b2 & 64) === 64;
              e2.email = (b2 & 32) === 32;
              e2.objsign = (b2 & 16) === 16;
              e2.reserved = (b2 & 8) === 8;
              e2.sslCA = (b2 & 4) === 4;
              e2.emailCA = (b2 & 2) === 2;
              e2.objCA = (b2 & 1) === 1;
            } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
              e2.altNames = [];
              var gn;
              var ev = asn1.fromDer(e2.value);
              for (var n = 0; n < ev.value.length; ++n) {
                gn = ev.value[n];
                var altName = {
                  type: gn.type,
                  value: gn.value
                };
                e2.altNames.push(altName);
                switch (gn.type) {
                  case 1:
                  case 2:
                  case 6:
                    break;
                  case 7:
                    altName.ip = forge.util.bytesToIP(gn.value);
                    break;
                  case 8:
                    altName.oid = asn1.derToOid(gn.value);
                    break;
                  default:
                }
              }
            } else if (e2.name === "subjectKeyIdentifier") {
              var ev = asn1.fromDer(e2.value);
              e2.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
            }
          }
          return e2;
        };
        pki2.certificationRequestFromAsn1 = function(obj, computeHash) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.publicKeyOid);
          if (oid !== pki2.oids.rsaEncryption) {
            throw new Error("Cannot read public key. OID is not RSA.");
          }
          var csr = pki2.createCertificationRequest();
          csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
          csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
          csr.signatureParameters = _readSignatureParameters(
            csr.signatureOid,
            capture.csrSignatureParams,
            true
          );
          csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
          csr.siginfo.parameters = _readSignatureParameters(
            csr.siginfo.algorithmOid,
            capture.csrSignatureParams,
            false
          );
          csr.signature = capture.csrSignature;
          csr.certificationRequestInfo = capture.certificationRequestInfo;
          if (computeHash) {
            csr.md = _createSignatureDigest({
              signatureOid: csr.signatureOid,
              type: "certification request"
            });
            var bytes = asn1.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
          }
          var smd = forge.md.sha1.create();
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = pki2.RDNAttributesAsArray(
            capture.certificationRequestInfoSubject,
            smd
          );
          csr.subject.hash = smd.digest().toHex();
          csr.publicKey = pki2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.attributes = pki2.CRIAttributesAsArray(
            capture.certificationRequestInfoAttributes || []
          );
          return csr;
        };
        pki2.createCertificationRequest = function() {
          var csr = {};
          csr.version = 0;
          csr.signatureOid = null;
          csr.signature = null;
          csr.siginfo = {};
          csr.siginfo.algorithmOid = null;
          csr.subject = {};
          csr.subject.getField = function(sn) {
            return _getAttribute(csr.subject, sn);
          };
          csr.subject.addField = function(attr) {
            _fillMissingFields([attr]);
            csr.subject.attributes.push(attr);
          };
          csr.subject.attributes = [];
          csr.subject.hash = null;
          csr.publicKey = null;
          csr.attributes = [];
          csr.getAttribute = function(sn) {
            return _getAttribute(csr, sn);
          };
          csr.addAttribute = function(attr) {
            _fillMissingFields([attr]);
            csr.attributes.push(attr);
          };
          csr.md = null;
          csr.setSubject = function(attrs) {
            _fillMissingFields(attrs);
            csr.subject.attributes = attrs;
            csr.subject.hash = null;
          };
          csr.setAttributes = function(attrs) {
            _fillMissingFields(attrs);
            csr.attributes = attrs;
          };
          csr.sign = function(key, md) {
            csr.md = md || forge.md.sha1.create();
            var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
            if (!algorithmOid) {
              var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
              error.algorithm = csr.md.algorithm;
              throw error;
            }
            csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
            csr.certificationRequestInfo = pki2.getCertificationRequestInfo(csr);
            var bytes = asn1.toDer(csr.certificationRequestInfo);
            csr.md.update(bytes.getBytes());
            csr.signature = key.sign(csr.md);
          };
          csr.verify = function() {
            var rval = false;
            var md = csr.md;
            if (md === null) {
              md = _createSignatureDigest({
                signatureOid: csr.signatureOid,
                type: "certification request"
              });
              var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
              var bytes = asn1.toDer(cri);
              md.update(bytes.getBytes());
            }
            if (md !== null) {
              rval = _verifySignature({
                certificate: csr,
                md,
                signature: csr.signature
              });
            }
            return rval;
          };
          return csr;
        };
        function _dnToAsn1(obj) {
          var rval = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            []
          );
          var attr, set;
          var attrs = obj.attributes;
          for (var i2 = 0; i2 < attrs.length; ++i2) {
            attr = attrs[i2];
            var value = attr.value;
            var valueTagClass = asn1.Type.PRINTABLESTRING;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
              if (valueTagClass === asn1.Type.UTF8) {
                value = forge.util.encodeUtf8(value);
              }
            }
            set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // AttributeType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(attr.type).getBytes()
                ),
                // AttributeValue
                asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
              ])
            ]);
            rval.value.push(set);
          }
          return rval;
        }
        function _fillMissingFields(attrs) {
          var attr;
          for (var i2 = 0; i2 < attrs.length; ++i2) {
            attr = attrs[i2];
            if (typeof attr.name === "undefined") {
              if (attr.type && attr.type in pki2.oids) {
                attr.name = pki2.oids[attr.type];
              } else if (attr.shortName && attr.shortName in _shortNames) {
                attr.name = pki2.oids[_shortNames[attr.shortName]];
              }
            }
            if (typeof attr.type === "undefined") {
              if (attr.name && attr.name in pki2.oids) {
                attr.type = pki2.oids[attr.name];
              } else {
                var error = new Error("Attribute type not specified.");
                error.attribute = attr;
                throw error;
              }
            }
            if (typeof attr.shortName === "undefined") {
              if (attr.name && attr.name in _shortNames) {
                attr.shortName = _shortNames[attr.name];
              }
            }
            if (attr.type === oids.extensionRequest) {
              attr.valueConstructed = true;
              attr.valueTagClass = asn1.Type.SEQUENCE;
              if (!attr.value && attr.extensions) {
                attr.value = [];
                for (var ei = 0; ei < attr.extensions.length; ++ei) {
                  attr.value.push(pki2.certificateExtensionToAsn1(
                    _fillMissingExtensionFields(attr.extensions[ei])
                  ));
                }
              }
            }
            if (typeof attr.value === "undefined") {
              var error = new Error("Attribute value not specified.");
              error.attribute = attr;
              throw error;
            }
          }
        }
        function _fillMissingExtensionFields(e2, options) {
          options = options || {};
          if (typeof e2.name === "undefined") {
            if (e2.id && e2.id in pki2.oids) {
              e2.name = pki2.oids[e2.id];
            }
          }
          if (typeof e2.id === "undefined") {
            if (e2.name && e2.name in pki2.oids) {
              e2.id = pki2.oids[e2.name];
            } else {
              var error = new Error("Extension ID not specified.");
              error.extension = e2;
              throw error;
            }
          }
          if (typeof e2.value !== "undefined") {
            return e2;
          }
          if (e2.name === "keyUsage") {
            var unused = 0;
            var b2 = 0;
            var b3 = 0;
            if (e2.digitalSignature) {
              b2 |= 128;
              unused = 7;
            }
            if (e2.nonRepudiation) {
              b2 |= 64;
              unused = 6;
            }
            if (e2.keyEncipherment) {
              b2 |= 32;
              unused = 5;
            }
            if (e2.dataEncipherment) {
              b2 |= 16;
              unused = 4;
            }
            if (e2.keyAgreement) {
              b2 |= 8;
              unused = 3;
            }
            if (e2.keyCertSign) {
              b2 |= 4;
              unused = 2;
            }
            if (e2.cRLSign) {
              b2 |= 2;
              unused = 1;
            }
            if (e2.encipherOnly) {
              b2 |= 1;
              unused = 0;
            }
            if (e2.decipherOnly) {
              b3 |= 128;
              unused = 7;
            }
            var value = String.fromCharCode(unused);
            if (b3 !== 0) {
              value += String.fromCharCode(b2) + String.fromCharCode(b3);
            } else if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              value
            );
          } else if (e2.name === "basicConstraints") {
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              []
            );
            if (e2.cA) {
              e2.value.value.push(asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BOOLEAN,
                false,
                String.fromCharCode(255)
              ));
            }
            if ("pathLenConstraint" in e2) {
              e2.value.value.push(asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(e2.pathLenConstraint).getBytes()
              ));
            }
          } else if (e2.name === "extKeyUsage") {
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              []
            );
            var seq = e2.value.value;
            for (var key in e2) {
              if (e2[key] !== true) {
                continue;
              }
              if (key in oids) {
                seq.push(asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids[key]).getBytes()
                ));
              } else if (key.indexOf(".") !== -1) {
                seq.push(asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(key).getBytes()
                ));
              }
            }
          } else if (e2.name === "nsCertType") {
            var unused = 0;
            var b2 = 0;
            if (e2.client) {
              b2 |= 128;
              unused = 7;
            }
            if (e2.server) {
              b2 |= 64;
              unused = 6;
            }
            if (e2.email) {
              b2 |= 32;
              unused = 5;
            }
            if (e2.objsign) {
              b2 |= 16;
              unused = 4;
            }
            if (e2.reserved) {
              b2 |= 8;
              unused = 3;
            }
            if (e2.sslCA) {
              b2 |= 4;
              unused = 2;
            }
            if (e2.emailCA) {
              b2 |= 2;
              unused = 1;
            }
            if (e2.objCA) {
              b2 |= 1;
              unused = 0;
            }
            var value = String.fromCharCode(unused);
            if (b2 !== 0) {
              value += String.fromCharCode(b2);
            }
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              value
            );
          } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
            e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
            var altName;
            for (var n = 0; n < e2.altNames.length; ++n) {
              altName = e2.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e2;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn1.oidToDer(asn1.oidToDer(altName.oid));
                } else {
                  value = asn1.oidToDer(value);
                }
              }
              e2.value.value.push(asn1.create(
                asn1.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
          } else if (e2.name === "nsComment" && options.cert) {
            if (!/^[\x00-\x7F]*$/.test(e2.comment) || e2.comment.length < 1 || e2.comment.length > 128) {
              throw new Error('Invalid "nsComment" content.');
            }
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.IA5STRING,
              false,
              e2.comment
            );
          } else if (e2.name === "subjectKeyIdentifier" && options.cert) {
            var ski = options.cert.generateSubjectKeyIdentifier();
            e2.subjectKeyIdentifier = ski.toHex();
            e2.value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              ski.getBytes()
            );
          } else if (e2.name === "authorityKeyIdentifier" && options.cert) {
            e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
            var seq = e2.value.value;
            if (e2.keyIdentifier) {
              var keyIdentifier = e2.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e2.keyIdentifier;
              seq.push(
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
              );
            }
            if (e2.authorityCertIssuer) {
              var authorityCertIssuer = [
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
                  _dnToAsn1(e2.authorityCertIssuer === true ? options.cert.issuer : e2.authorityCertIssuer)
                ])
              ];
              seq.push(
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
              );
            }
            if (e2.serialNumber) {
              var serialNumber = forge.util.hexToBytes(e2.serialNumber === true ? options.cert.serialNumber : e2.serialNumber);
              seq.push(
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
              );
            }
          } else if (e2.name === "cRLDistributionPoints") {
            e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
            var seq = e2.value.value;
            var subSeq = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              []
            );
            var fullNameGeneralNames = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var altName;
            for (var n = 0; n < e2.altNames.length; ++n) {
              altName = e2.altNames[n];
              var value = altName.value;
              if (altName.type === 7 && altName.ip) {
                value = forge.util.bytesFromIP(altName.ip);
                if (value === null) {
                  var error = new Error(
                    'Extension "ip" value is not a valid IPv4 or IPv6 address.'
                  );
                  error.extension = e2;
                  throw error;
                }
              } else if (altName.type === 8) {
                if (altName.oid) {
                  value = asn1.oidToDer(asn1.oidToDer(altName.oid));
                } else {
                  value = asn1.oidToDer(value);
                }
              }
              fullNameGeneralNames.value.push(asn1.create(
                asn1.Class.CONTEXT_SPECIFIC,
                altName.type,
                false,
                value
              ));
            }
            subSeq.value.push(asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              [fullNameGeneralNames]
            ));
            seq.push(subSeq);
          }
          if (typeof e2.value === "undefined") {
            var error = new Error("Extension value not specified.");
            error.extension = e2;
            throw error;
          }
          return e2;
        }
        function _signatureParametersToAsn1(oid, params) {
          switch (oid) {
            case oids["RSASSA-PSS"]:
              var parts = [];
              if (params.hash.algorithmOid !== void 0) {
                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OID,
                      false,
                      asn1.oidToDer(params.hash.algorithmOid).getBytes()
                    ),
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                  ])
                ]));
              }
              if (params.mgf.algorithmOid !== void 0) {
                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OID,
                      false,
                      asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                    ),
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                      asn1.create(
                        asn1.Class.UNIVERSAL,
                        asn1.Type.OID,
                        false,
                        asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                      ),
                      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                    ])
                  ])
                ]));
              }
              if (params.saltLength !== void 0) {
                parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.INTEGER,
                    false,
                    asn1.integerToDer(params.saltLength).getBytes()
                  )
                ]));
              }
              return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
            default:
              return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
          }
        }
        function _CRIAttributesToAsn1(csr) {
          var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
          if (csr.attributes.length === 0) {
            return rval;
          }
          var attrs = csr.attributes;
          for (var i2 = 0; i2 < attrs.length; ++i2) {
            var attr = attrs[i2];
            var value = attr.value;
            var valueTagClass = asn1.Type.UTF8;
            if ("valueTagClass" in attr) {
              valueTagClass = attr.valueTagClass;
            }
            if (valueTagClass === asn1.Type.UTF8) {
              value = forge.util.encodeUtf8(value);
            }
            var valueConstructed = false;
            if ("valueConstructed" in attr) {
              valueConstructed = attr.valueConstructed;
            }
            var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // AttributeType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(attr.type).getBytes()
              ),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
                // AttributeValue
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  valueTagClass,
                  valueConstructed,
                  value
                )
              ])
            ]);
            rval.value.push(seq);
          }
          return rval;
        }
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        function _dateToAsn1(date) {
          if (date >= jan_1_1950 && date < jan_1_2050) {
            return asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.UTCTIME,
              false,
              asn1.dateToUtcTime(date)
            );
          } else {
            return asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.GENERALIZEDTIME,
              false,
              asn1.dateToGeneralizedTime(date)
            );
          }
        }
        pki2.getTBSCertificate = function(cert) {
          var notBefore = _dateToAsn1(cert.validity.notBefore);
          var notAfter = _dateToAsn1(cert.validity.notAfter);
          var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // integer
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(cert.version).getBytes()
              )
            ]),
            // serialNumber
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              forge.util.hexToBytes(cert.serialNumber)
            ),
            // signature
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(
                cert.siginfo.algorithmOid,
                cert.siginfo.parameters
              )
            ]),
            // issuer
            _dnToAsn1(cert.issuer),
            // validity
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              notBefore,
              notAfter
            ]),
            // subject
            _dnToAsn1(cert.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(cert.publicKey)
          ]);
          if (cert.issuer.uniqueId) {
            tbs.value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.issuer.uniqueId
                )
              ])
            );
          }
          if (cert.subject.uniqueId) {
            tbs.value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.BITSTRING,
                  false,
                  // TODO: support arbitrary bit length ids
                  String.fromCharCode(0) + cert.subject.uniqueId
                )
              ])
            );
          }
          if (cert.extensions.length > 0) {
            tbs.value.push(pki2.certificateExtensionsToAsn1(cert.extensions));
          }
          return tbs;
        };
        pki2.getCertificationRequestInfo = function(csr) {
          var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(csr.version).getBytes()
            ),
            // subject
            _dnToAsn1(csr.subject),
            // SubjectPublicKeyInfo
            pki2.publicKeyToAsn1(csr.publicKey),
            // attributes
            _CRIAttributesToAsn1(csr)
          ]);
          return cri;
        };
        pki2.distinguishedNameToAsn1 = function(dn) {
          return _dnToAsn1(dn);
        };
        pki2.certificateToAsn1 = function(cert) {
          var tbsCertificate = cert.tbsCertificate || pki2.getTBSCertificate(cert);
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // TBSCertificate
            tbsCertificate,
            // AlgorithmIdentifier (signature algorithm)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(cert.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
            ]),
            // SignatureValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + cert.signature
            )
          ]);
        };
        pki2.certificateExtensionsToAsn1 = function(exts) {
          var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
          var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          rval.value.push(seq);
          for (var i2 = 0; i2 < exts.length; ++i2) {
            seq.value.push(pki2.certificateExtensionToAsn1(exts[i2]));
          }
          return rval;
        };
        pki2.certificateExtensionToAsn1 = function(ext) {
          var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          extseq.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ext.id).getBytes()
          ));
          if (ext.critical) {
            extseq.value.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BOOLEAN,
              false,
              String.fromCharCode(255)
            ));
          }
          var value = ext.value;
          if (typeof ext.value !== "string") {
            value = asn1.toDer(value).getBytes();
          }
          extseq.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            value
          ));
          return extseq;
        };
        pki2.certificationRequestToAsn1 = function(csr) {
          var cri = csr.certificationRequestInfo || pki2.getCertificationRequestInfo(csr);
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // CertificationRequestInfo
            cri,
            // AlgorithmIdentifier (signature algorithm)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(csr.signatureOid).getBytes()
              ),
              // parameters
              _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
            ]),
            // signature
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              String.fromCharCode(0) + csr.signature
            )
          ]);
        };
        pki2.createCaStore = function(certs) {
          var caStore = {
            // stored certificates
            certs: {}
          };
          caStore.getIssuer = function(cert2) {
            var rval = getBySubject(cert2.issuer);
            return rval;
          };
          caStore.addCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              if (cert2.subject.hash in caStore.certs) {
                var tmp = caStore.certs[cert2.subject.hash];
                if (!forge.util.isArray(tmp)) {
                  tmp = [tmp];
                }
                tmp.push(cert2);
                caStore.certs[cert2.subject.hash] = tmp;
              } else {
                caStore.certs[cert2.subject.hash] = cert2;
              }
            }
          };
          caStore.hasCertificate = function(cert2) {
            if (typeof cert2 === "string") {
              cert2 = forge.pki.certificateFromPem(cert2);
            }
            var match2 = getBySubject(cert2.subject);
            if (!match2) {
              return false;
            }
            if (!forge.util.isArray(match2)) {
              match2 = [match2];
            }
            var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i22 = 0; i22 < match2.length; ++i22) {
              var der2 = asn1.toDer(pki2.certificateToAsn1(match2[i22])).getBytes();
              if (der1 === der2) {
                return true;
              }
            }
            return false;
          };
          caStore.listAllCertificates = function() {
            var certList = [];
            for (var hash22 in caStore.certs) {
              if (caStore.certs.hasOwnProperty(hash22)) {
                var value = caStore.certs[hash22];
                if (!forge.util.isArray(value)) {
                  certList.push(value);
                } else {
                  for (var i22 = 0; i22 < value.length; ++i22) {
                    certList.push(value[i22]);
                  }
                }
              }
            }
            return certList;
          };
          caStore.removeCertificate = function(cert2) {
            var result;
            if (typeof cert2 === "string") {
              cert2 = forge.pki.certificateFromPem(cert2);
            }
            ensureSubjectHasHash(cert2.subject);
            if (!caStore.hasCertificate(cert2)) {
              return null;
            }
            var match2 = getBySubject(cert2.subject);
            if (!forge.util.isArray(match2)) {
              result = caStore.certs[cert2.subject.hash];
              delete caStore.certs[cert2.subject.hash];
              return result;
            }
            var der1 = asn1.toDer(pki2.certificateToAsn1(cert2)).getBytes();
            for (var i22 = 0; i22 < match2.length; ++i22) {
              var der2 = asn1.toDer(pki2.certificateToAsn1(match2[i22])).getBytes();
              if (der1 === der2) {
                result = match2[i22];
                match2.splice(i22, 1);
              }
            }
            if (match2.length === 0) {
              delete caStore.certs[cert2.subject.hash];
            }
            return result;
          };
          function getBySubject(subject) {
            ensureSubjectHasHash(subject);
            return caStore.certs[subject.hash] || null;
          }
          function ensureSubjectHasHash(subject) {
            if (!subject.hash) {
              var md = forge.md.sha1.create();
              subject.attributes = pki2.RDNAttributesAsArray(_dnToAsn1(subject), md);
              subject.hash = md.digest().toHex();
            }
          }
          if (certs) {
            for (var i2 = 0; i2 < certs.length; ++i2) {
              var cert = certs[i2];
              caStore.addCertificate(cert);
            }
          }
          return caStore;
        };
        pki2.certificateError = {
          bad_certificate: "forge.pki.BadCertificate",
          unsupported_certificate: "forge.pki.UnsupportedCertificate",
          certificate_revoked: "forge.pki.CertificateRevoked",
          certificate_expired: "forge.pki.CertificateExpired",
          certificate_unknown: "forge.pki.CertificateUnknown",
          unknown_ca: "forge.pki.UnknownCertificateAuthority"
        };
        pki2.verifyCertificateChain = function(caStore, chain, options) {
          if (typeof options === "function") {
            options = { verify: options };
          }
          options = options || {};
          chain = chain.slice(0);
          var certs = chain.slice(0);
          var validityCheckDate = options.validityCheckDate;
          if (typeof validityCheckDate === "undefined") {
            validityCheckDate = /* @__PURE__ */ new Date();
          }
          var first = true;
          var error = null;
          var depth = 0;
          do {
            var cert = chain.shift();
            var parent = null;
            var selfSigned = false;
            if (validityCheckDate) {
              if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
                error = {
                  message: "Certificate is not valid yet or has expired.",
                  error: pki2.certificateError.certificate_expired,
                  notBefore: cert.validity.notBefore,
                  notAfter: cert.validity.notAfter,
                  // TODO: we might want to reconsider renaming 'now' to
                  // 'validityCheckDate' should this API be changed in the future.
                  now: validityCheckDate
                };
              }
            }
            if (error === null) {
              parent = chain[0] || caStore.getIssuer(cert);
              if (parent === null) {
                if (cert.isIssuer(cert)) {
                  selfSigned = true;
                  parent = cert;
                }
              }
              if (parent) {
                var parents = parent;
                if (!forge.util.isArray(parents)) {
                  parents = [parents];
                }
                var verified = false;
                while (!verified && parents.length > 0) {
                  parent = parents.shift();
                  try {
                    verified = parent.verify(cert);
                  } catch (ex) {
                  }
                }
                if (!verified) {
                  error = {
                    message: "Certificate signature is invalid.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
                error = {
                  message: "Certificate is not trusted.",
                  error: pki2.certificateError.unknown_ca
                };
              }
            }
            if (error === null && parent && !cert.isIssuer(parent)) {
              error = {
                message: "Certificate issuer is invalid.",
                error: pki2.certificateError.bad_certificate
              };
            }
            if (error === null) {
              var se2 = {
                keyUsage: true,
                basicConstraints: true
              };
              for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
                var ext = cert.extensions[i2];
                if (ext.critical && !(ext.name in se2)) {
                  error = {
                    message: "Certificate has an unsupported critical extension.",
                    error: pki2.certificateError.unsupported_certificate
                  };
                }
              }
            }
            if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
              var bcExt = cert.getExtension("basicConstraints");
              var keyUsageExt = cert.getExtension("keyUsage");
              if (keyUsageExt !== null) {
                if (!keyUsageExt.keyCertSign || bcExt === null) {
                  error = {
                    message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
              if (error === null && bcExt !== null && !bcExt.cA) {
                error = {
                  message: "Certificate basicConstraints indicates the certificate is not a CA.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
                var pathLen = depth - 1;
                if (pathLen > bcExt.pathLenConstraint) {
                  error = {
                    message: "Certificate basicConstraints pathLenConstraint violated.",
                    error: pki2.certificateError.bad_certificate
                  };
                }
              }
            }
            var vfd = error === null ? true : error.error;
            var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
            if (ret === true) {
              error = null;
            } else {
              if (vfd === true) {
                error = {
                  message: "The application rejected the certificate.",
                  error: pki2.certificateError.bad_certificate
                };
              }
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.error) {
                    error.error = ret.error;
                  }
                } else if (typeof ret === "string") {
                  error.error = ret;
                }
              }
              throw error;
            }
            first = false;
            ++depth;
          } while (chain.length > 0);
          return true;
        };
      }
    });
    var require_pkcs122 = __commonJS2({
      "../../node_modules/node-forge/lib/pkcs12.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        require_hmac2();
        require_oids2();
        require_pkcs7asn12();
        require_pbe2();
        require_random2();
        require_rsa2();
        require_sha13();
        require_util2();
        require_x5092();
        var asn1 = forge.asn1;
        var pki2 = forge.pki;
        var p12 = module2.exports = forge.pkcs12 = forge.pkcs12 || {};
        var contentInfoValidator = {
          name: "ContentInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          // a ContentInfo
          constructed: true,
          value: [{
            name: "ContentInfo.contentType",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "contentType"
          }, {
            name: "ContentInfo.content",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "content"
          }]
        };
        var pfxValidator = {
          name: "PFX",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [
            {
              name: "PFX.version",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "version"
            },
            contentInfoValidator,
            {
              name: "PFX.macData",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              optional: true,
              captureAsn1: "mac",
              value: [{
                name: "PFX.macData.mac",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                // DigestInfo
                constructed: true,
                value: [{
                  name: "PFX.macData.mac.digestAlgorithm",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.SEQUENCE,
                  // DigestAlgorithmIdentifier
                  constructed: true,
                  value: [{
                    name: "PFX.macData.mac.digestAlgorithm.algorithm",
                    tagClass: asn1.Class.UNIVERSAL,
                    type: asn1.Type.OID,
                    constructed: false,
                    capture: "macAlgorithm"
                  }, {
                    name: "PFX.macData.mac.digestAlgorithm.parameters",
                    tagClass: asn1.Class.UNIVERSAL,
                    captureAsn1: "macAlgorithmParameters"
                  }]
                }, {
                  name: "PFX.macData.mac.digest",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OCTETSTRING,
                  constructed: false,
                  capture: "macDigest"
                }]
              }, {
                name: "PFX.macData.macSalt",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OCTETSTRING,
                constructed: false,
                capture: "macSalt"
              }, {
                name: "PFX.macData.iterations",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                optional: true,
                capture: "macIterations"
              }]
            }
          ]
        };
        var safeBagValidator = {
          name: "SafeBag",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SafeBag.bagId",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "bagId"
          }, {
            name: "SafeBag.bagValue",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            constructed: true,
            captureAsn1: "bagValue"
          }, {
            name: "SafeBag.bagAttributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true,
            optional: true,
            capture: "bagAttributes"
          }]
        };
        var attributeValidator = {
          name: "Attribute",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Attribute.attrId",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "oid"
          }, {
            name: "Attribute.attrValues",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true,
            capture: "values"
          }]
        };
        var certBagValidator = {
          name: "CertBag",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertBag.certId",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "certId"
          }, {
            name: "CertBag.certValue",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            constructed: true,
            /* So far we only support X.509 certificates (which are wrapped in
               an OCTET STRING, hence hard code that here). */
            value: [{
              name: "CertBag.certValue[0]",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Class.OCTETSTRING,
              constructed: false,
              capture: "cert"
            }]
          }]
        };
        function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
          var result = [];
          for (var i2 = 0; i2 < safeContents.length; i2++) {
            for (var j2 = 0; j2 < safeContents[i2].safeBags.length; j2++) {
              var bag = safeContents[i2].safeBags[j2];
              if (bagType !== void 0 && bag.type !== bagType) {
                continue;
              }
              if (attrName === null) {
                result.push(bag);
                continue;
              }
              if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
                result.push(bag);
              }
            }
          }
          return result;
        }
        p12.pkcs12FromAsn1 = function(obj, strict, password) {
          if (typeof strict === "string") {
            password = strict;
            strict = true;
          } else if (strict === void 0) {
            strict = true;
          }
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, pfxValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
            error.errors = error;
            throw error;
          }
          var pfx = {
            version: capture.version.charCodeAt(0),
            safeContents: [],
            /**
             * Gets bags with matching attributes.
             *
             * @param filter the attributes to filter by:
             *          [localKeyId] the localKeyId to search for.
             *          [localKeyIdHex] the localKeyId in hex to search for.
             *          [friendlyName] the friendly name to search for.
             *          [bagType] bag type to narrow each attribute search by.
             *
             * @return a map of attribute type to an array of matching bags or, if no
             *           attribute was given but a bag type, the map key will be the
             *           bag type.
             */
            getBags: function(filter2) {
              var rval = {};
              var localKeyId;
              if ("localKeyId" in filter2) {
                localKeyId = filter2.localKeyId;
              } else if ("localKeyIdHex" in filter2) {
                localKeyId = forge.util.hexToBytes(filter2.localKeyIdHex);
              }
              if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
                rval[filter2.bagType] = _getBagsByAttribute(
                  pfx.safeContents,
                  null,
                  null,
                  filter2.bagType
                );
              }
              if (localKeyId !== void 0) {
                rval.localKeyId = _getBagsByAttribute(
                  pfx.safeContents,
                  "localKeyId",
                  localKeyId,
                  filter2.bagType
                );
              }
              if ("friendlyName" in filter2) {
                rval.friendlyName = _getBagsByAttribute(
                  pfx.safeContents,
                  "friendlyName",
                  filter2.friendlyName,
                  filter2.bagType
                );
              }
              return rval;
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching friendlyName attribute.
             *
             * @param friendlyName the friendly name to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching friendlyName attribute.
             */
            getBagsByFriendlyName: function(friendlyName, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "friendlyName",
                friendlyName,
                bagType
              );
            },
            /**
             * DEPRECATED: use getBags() instead.
             *
             * Get bags with matching localKeyId attribute.
             *
             * @param localKeyId the localKeyId to search for.
             * @param [bagType] bag type to narrow search by.
             *
             * @return an array of bags with matching localKeyId attribute.
             */
            getBagsByLocalKeyId: function(localKeyId, bagType) {
              return _getBagsByAttribute(
                pfx.safeContents,
                "localKeyId",
                localKeyId,
                bagType
              );
            }
          };
          if (capture.version.charCodeAt(0) !== 3) {
            var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
            error.version = capture.version.charCodeAt(0);
            throw error;
          }
          if (asn1.derToOid(capture.contentType) !== pki2.oids.data) {
            var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
            error.oid = asn1.derToOid(capture.contentType);
            throw error;
          }
          var data = capture.content.value[0];
          if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
            throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
          }
          data = _decodePkcs7Data(data);
          if (capture.mac) {
            var md = null;
            var macKeyBytes = 0;
            var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
            switch (macAlgorithm) {
              case pki2.oids.sha1:
                md = forge.md.sha1.create();
                macKeyBytes = 20;
                break;
              case pki2.oids.sha256:
                md = forge.md.sha256.create();
                macKeyBytes = 32;
                break;
              case pki2.oids.sha384:
                md = forge.md.sha384.create();
                macKeyBytes = 48;
                break;
              case pki2.oids.sha512:
                md = forge.md.sha512.create();
                macKeyBytes = 64;
                break;
              case pki2.oids.md5:
                md = forge.md.md5.create();
                macKeyBytes = 16;
                break;
            }
            if (md === null) {
              throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
            }
            var macSalt = new forge.util.ByteBuffer(capture.macSalt);
            var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
            var macKey = p12.generateKey(
              password,
              macSalt,
              3,
              macIterations,
              macKeyBytes,
              md
            );
            var mac = forge.hmac.create();
            mac.start(md, macKey);
            mac.update(data.value);
            var macValue = mac.getMac();
            if (macValue.getBytes() !== capture.macDigest) {
              throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
            }
          }
          _decodeAuthenticatedSafe(pfx, data.value, strict, password);
          return pfx;
        };
        function _decodePkcs7Data(data) {
          if (data.composed || data.constructed) {
            var value = forge.util.createBuffer();
            for (var i2 = 0; i2 < data.value.length; ++i2) {
              value.putBytes(data.value[i2].value);
            }
            data.composed = data.constructed = false;
            data.value = value.getBytes();
          }
          return data;
        }
        function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
          authSafe = asn1.fromDer(authSafe, strict);
          if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
            throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
          }
          for (var i2 = 0; i2 < authSafe.value.length; i2++) {
            var contentInfo = authSafe.value[i2];
            var capture = {};
            var errors = [];
            if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
              var error = new Error("Cannot read ContentInfo.");
              error.errors = errors;
              throw error;
            }
            var obj = {
              encrypted: false
            };
            var safeContents = null;
            var data = capture.content.value[0];
            switch (asn1.derToOid(capture.contentType)) {
              case pki2.oids.data:
                if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
                  throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
                }
                safeContents = _decodePkcs7Data(data).value;
                break;
              case pki2.oids.encryptedData:
                safeContents = _decryptSafeContents(data, password);
                obj.encrypted = true;
                break;
              default:
                var error = new Error("Unsupported PKCS#12 contentType.");
                error.contentType = asn1.derToOid(capture.contentType);
                throw error;
            }
            obj.safeBags = _decodeSafeContents(safeContents, strict, password);
            pfx.safeContents.push(obj);
          }
        }
        function _decryptSafeContents(data, password) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(
            data,
            forge.pkcs7.asn1.encryptedDataValidator,
            capture,
            errors
          )) {
            var error = new Error("Cannot read EncryptedContentInfo.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.contentType);
          if (oid !== pki2.oids.data) {
            var error = new Error(
              "PKCS#12 EncryptedContentInfo ContentType is not Data."
            );
            error.oid = oid;
            throw error;
          }
          oid = asn1.derToOid(capture.encAlgorithm);
          var cipher = pki2.pbe.getCipher(oid, capture.encParameter, password);
          var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
          var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
          cipher.update(encrypted);
          if (!cipher.finish()) {
            throw new Error("Failed to decrypt PKCS#12 SafeContents.");
          }
          return cipher.output.getBytes();
        }
        function _decodeSafeContents(safeContents, strict, password) {
          if (!strict && safeContents.length === 0) {
            return [];
          }
          safeContents = asn1.fromDer(safeContents, strict);
          if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
            throw new Error(
              "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
            );
          }
          var res = [];
          for (var i2 = 0; i2 < safeContents.value.length; i2++) {
            var safeBag = safeContents.value[i2];
            var capture = {};
            var errors = [];
            if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
              var error = new Error("Cannot read SafeBag.");
              error.errors = errors;
              throw error;
            }
            var bag = {
              type: asn1.derToOid(capture.bagId),
              attributes: _decodeBagAttributes(capture.bagAttributes)
            };
            res.push(bag);
            var validator, decoder;
            var bagAsn1 = capture.bagValue.value[0];
            switch (bag.type) {
              case pki2.oids.pkcs8ShroudedKeyBag:
                bagAsn1 = pki2.decryptPrivateKeyInfo(bagAsn1, password);
                if (bagAsn1 === null) {
                  throw new Error(
                    "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
                  );
                }
              case pki2.oids.keyBag:
                try {
                  bag.key = pki2.privateKeyFromAsn1(bagAsn1);
                } catch (e2) {
                  bag.key = null;
                  bag.asn1 = bagAsn1;
                }
                continue;
              case pki2.oids.certBag:
                validator = certBagValidator;
                decoder = function() {
                  if (asn1.derToOid(capture.certId) !== pki2.oids.x509Certificate) {
                    var error2 = new Error(
                      "Unsupported certificate type, only X.509 supported."
                    );
                    error2.oid = asn1.derToOid(capture.certId);
                    throw error2;
                  }
                  var certAsn1 = asn1.fromDer(capture.cert, strict);
                  try {
                    bag.cert = pki2.certificateFromAsn1(certAsn1, true);
                  } catch (e2) {
                    bag.cert = null;
                    bag.asn1 = certAsn1;
                  }
                };
                break;
              default:
                var error = new Error("Unsupported PKCS#12 SafeBag type.");
                error.oid = bag.type;
                throw error;
            }
            if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
              var error = new Error("Cannot read PKCS#12 " + validator.name);
              error.errors = errors;
              throw error;
            }
            decoder();
          }
          return res;
        }
        function _decodeBagAttributes(attributes) {
          var decodedAttrs = {};
          if (attributes !== void 0) {
            for (var i2 = 0; i2 < attributes.length; ++i2) {
              var capture = {};
              var errors = [];
              if (!asn1.validate(attributes[i2], attributeValidator, capture, errors)) {
                var error = new Error("Cannot read PKCS#12 BagAttribute.");
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.oid);
              if (pki2.oids[oid] === void 0) {
                continue;
              }
              decodedAttrs[pki2.oids[oid]] = [];
              for (var j2 = 0; j2 < capture.values.length; ++j2) {
                decodedAttrs[pki2.oids[oid]].push(capture.values[j2].value);
              }
            }
          }
          return decodedAttrs;
        }
        p12.toPkcs12Asn1 = function(key, cert, password, options) {
          options = options || {};
          options.saltSize = options.saltSize || 8;
          options.count = options.count || 2048;
          options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
          if (!("useMac" in options)) {
            options.useMac = true;
          }
          if (!("localKeyId" in options)) {
            options.localKeyId = null;
          }
          if (!("generateLocalKeyId" in options)) {
            options.generateLocalKeyId = true;
          }
          var localKeyId = options.localKeyId;
          var bagAttrs;
          if (localKeyId !== null) {
            localKeyId = forge.util.hexToBytes(localKeyId);
          } else if (options.generateLocalKeyId) {
            if (cert) {
              var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
              if (typeof pairedCert === "string") {
                pairedCert = pki2.certificateFromPem(pairedCert);
              }
              var sha1 = forge.md.sha1.create();
              sha1.update(asn1.toDer(pki2.certificateToAsn1(pairedCert)).getBytes());
              localKeyId = sha1.digest().getBytes();
            } else {
              localKeyId = forge.random.getBytes(20);
            }
          }
          var attrs = [];
          if (localKeyId !== null) {
            attrs.push(
              // localKeyID
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // attrId
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(pki2.oids.localKeyId).getBytes()
                ),
                // attrValues
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OCTETSTRING,
                    false,
                    localKeyId
                  )
                ])
              ])
            );
          }
          if ("friendlyName" in options) {
            attrs.push(
              // friendlyName
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // attrId
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(pki2.oids.friendlyName).getBytes()
                ),
                // attrValues
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.BMPSTRING,
                    false,
                    options.friendlyName
                  )
                ])
              ])
            );
          }
          if (attrs.length > 0) {
            bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
          }
          var contents = [];
          var chain = [];
          if (cert !== null) {
            if (forge.util.isArray(cert)) {
              chain = cert;
            } else {
              chain = [cert];
            }
          }
          var certSafeBags = [];
          for (var i2 = 0; i2 < chain.length; ++i2) {
            cert = chain[i2];
            if (typeof cert === "string") {
              cert = pki2.certificateFromPem(cert);
            }
            var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
            var certAsn1 = pki2.certificateToAsn1(cert);
            var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // bagId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki2.oids.certBag).getBytes()
              ),
              // bagValue
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                // CertBag
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // certId
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(pki2.oids.x509Certificate).getBytes()
                  ),
                  // certValue (x509Certificate)
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      asn1.toDer(certAsn1).getBytes()
                    )
                  ])
                ])
              ]),
              // bagAttributes (OPTIONAL)
              certBagAttrs
            ]);
            certSafeBags.push(certSafeBag);
          }
          if (certSafeBags.length > 0) {
            var certSafeContents = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              certSafeBags
            );
            var certCI = (
              // PKCS#7 ContentInfo
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // contentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn1.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OCTETSTRING,
                    false,
                    asn1.toDer(certSafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(certCI);
          }
          var keyBag = null;
          if (key !== null) {
            var pkAsn1 = pki2.wrapRsaPrivateKey(pki2.privateKeyToAsn1(key));
            if (password === null) {
              keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // bagId
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(pki2.oids.keyBag).getBytes()
                ),
                // bagValue
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  // PrivateKeyInfo
                  pkAsn1
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            } else {
              keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // bagId
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(pki2.oids.pkcs8ShroudedKeyBag).getBytes()
                ),
                // bagValue
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  // EncryptedPrivateKeyInfo
                  pki2.encryptPrivateKeyInfo(pkAsn1, password, options)
                ]),
                // bagAttributes (OPTIONAL)
                bagAttrs
              ]);
            }
            var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
            var keyCI = (
              // PKCS#7 ContentInfo
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // contentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  // OID for the content type is 'data'
                  asn1.oidToDer(pki2.oids.data).getBytes()
                ),
                // content
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OCTETSTRING,
                    false,
                    asn1.toDer(keySafeContents).getBytes()
                  )
                ])
              ])
            );
            contents.push(keyCI);
          }
          var safe = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            contents
          );
          var macData;
          if (options.useMac) {
            var sha1 = forge.md.sha1.create();
            var macSalt = new forge.util.ByteBuffer(
              forge.random.getBytes(options.saltSize)
            );
            var count = options.count;
            var key = p12.generateKey(password, macSalt, 3, count, 20);
            var mac = forge.hmac.create();
            mac.start(sha1, key);
            mac.update(asn1.toDer(safe).getBytes());
            var macValue = mac.getMac();
            macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // mac DigestInfo
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // digestAlgorithm
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // algorithm = SHA-1
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(pki2.oids.sha1).getBytes()
                  ),
                  // parameters = Null
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ]),
                // digest
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  macValue.getBytes()
                )
              ]),
              // macSalt OCTET STRING
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                macSalt.getBytes()
              ),
              // iterations INTEGER (XXX: Only support count < 65536)
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(count).getBytes()
              )
            ]);
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version (3)
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(3).getBytes()
            ),
            // PKCS#7 ContentInfo
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // contentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                // OID for the content type is 'data'
                asn1.oidToDer(pki2.oids.data).getBytes()
              ),
              // content
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(safe).getBytes()
                )
              ])
            ]),
            macData
          ]);
        };
        p12.generateKey = forge.pbe.generatePkcs12Key;
      }
    });
    var require_pki2 = __commonJS2({
      "../../node_modules/node-forge/lib/pki.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        require_oids2();
        require_pbe2();
        require_pem2();
        require_pbkdf22();
        require_pkcs122();
        require_pss2();
        require_rsa2();
        require_util2();
        require_x5092();
        var asn1 = forge.asn1;
        var pki2 = module2.exports = forge.pki = forge.pki || {};
        pki2.pemToDer = function(pem) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PEM to DER; PEM is encrypted.");
          }
          return forge.util.createBuffer(msg.body);
        };
        pki2.privateKeyFromPem = function(pem) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
            var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert private key from PEM; PEM is encrypted.");
          }
          var obj = asn1.fromDer(msg.body);
          return pki2.privateKeyFromAsn1(obj);
        };
        pki2.privateKeyToPem = function(key, maxline) {
          var msg = {
            type: "RSA PRIVATE KEY",
            body: asn1.toDer(pki2.privateKeyToAsn1(key)).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
        pki2.privateKeyInfoToPem = function(pki3, maxline) {
          var msg = {
            type: "PRIVATE KEY",
            body: asn1.toDer(pki3).getBytes()
          };
          return forge.pem.encode(msg, { maxline });
        };
      }
    });
    var require_tls2 = __commonJS2({
      "../../node_modules/node-forge/lib/tls.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        require_hmac2();
        require_md53();
        require_pem2();
        require_pki2();
        require_random2();
        require_sha13();
        require_util2();
        var prf_TLS1 = function(secret, label, seed, length2) {
          var rval = forge.util.createBuffer();
          var idx = secret.length >> 1;
          var slen = idx + (secret.length & 1);
          var s1 = secret.substr(0, slen);
          var s2 = secret.substr(idx, slen);
          var ai = forge.util.createBuffer();
          var hmac = forge.hmac.create();
          seed = label + seed;
          var md5itr = Math.ceil(length2 / 16);
          var sha1itr = Math.ceil(length2 / 20);
          hmac.start("MD5", s1);
          var md5bytes = forge.util.createBuffer();
          ai.putBytes(seed);
          for (var i2 = 0; i2 < md5itr; ++i2) {
            hmac.start(null, null);
            hmac.update(ai.getBytes());
            ai.putBuffer(hmac.digest());
            hmac.start(null, null);
            hmac.update(ai.bytes() + seed);
            md5bytes.putBuffer(hmac.digest());
          }
          hmac.start("SHA1", s2);
          var sha1bytes = forge.util.createBuffer();
          ai.clear();
          ai.putBytes(seed);
          for (var i2 = 0; i2 < sha1itr; ++i2) {
            hmac.start(null, null);
            hmac.update(ai.getBytes());
            ai.putBuffer(hmac.digest());
            hmac.start(null, null);
            hmac.update(ai.bytes() + seed);
            sha1bytes.putBuffer(hmac.digest());
          }
          rval.putBytes(forge.util.xorBytes(
            md5bytes.getBytes(),
            sha1bytes.getBytes(),
            length2
          ));
          return rval;
        };
        var hmac_sha1 = function(key2, seqNum, record) {
          var hmac = forge.hmac.create();
          hmac.start("SHA1", key2);
          var b2 = forge.util.createBuffer();
          b2.putInt32(seqNum[0]);
          b2.putInt32(seqNum[1]);
          b2.putByte(record.type);
          b2.putByte(record.version.major);
          b2.putByte(record.version.minor);
          b2.putInt16(record.length);
          b2.putBytes(record.fragment.bytes());
          hmac.update(b2.getBytes());
          return hmac.digest().getBytes();
        };
        var deflate = function(c2, record, s2) {
          var rval = false;
          try {
            var bytes = c2.deflate(record.fragment.getBytes());
            record.fragment = forge.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var inflate = function(c2, record, s2) {
          var rval = false;
          try {
            var bytes = c2.inflate(record.fragment.getBytes());
            record.fragment = forge.util.createBuffer(bytes);
            record.length = bytes.length;
            rval = true;
          } catch (ex) {
          }
          return rval;
        };
        var readVector = function(b2, lenBytes) {
          var len = 0;
          switch (lenBytes) {
            case 1:
              len = b2.getByte();
              break;
            case 2:
              len = b2.getInt16();
              break;
            case 3:
              len = b2.getInt24();
              break;
            case 4:
              len = b2.getInt32();
              break;
          }
          return forge.util.createBuffer(b2.getBytes(len));
        };
        var writeVector = function(b2, lenBytes, v2) {
          b2.putInt(v2.length(), lenBytes << 3);
          b2.putBuffer(v2);
        };
        var tls = {};
        tls.Versions = {
          TLS_1_0: { major: 3, minor: 1 },
          TLS_1_1: { major: 3, minor: 2 },
          TLS_1_2: { major: 3, minor: 3 }
        };
        tls.SupportedVersions = [
          tls.Versions.TLS_1_1,
          tls.Versions.TLS_1_0
        ];
        tls.Version = tls.SupportedVersions[0];
        tls.MaxFragment = 16384 - 1024;
        tls.ConnectionEnd = {
          server: 0,
          client: 1
        };
        tls.PRFAlgorithm = {
          tls_prf_sha256: 0
        };
        tls.BulkCipherAlgorithm = {
          none: null,
          rc4: 0,
          des3: 1,
          aes: 2
        };
        tls.CipherType = {
          stream: 0,
          block: 1,
          aead: 2
        };
        tls.MACAlgorithm = {
          none: null,
          hmac_md5: 0,
          hmac_sha1: 1,
          hmac_sha256: 2,
          hmac_sha384: 3,
          hmac_sha512: 4
        };
        tls.CompressionMethod = {
          none: 0,
          deflate: 1
        };
        tls.ContentType = {
          change_cipher_spec: 20,
          alert: 21,
          handshake: 22,
          application_data: 23,
          heartbeat: 24
        };
        tls.HandshakeType = {
          hello_request: 0,
          client_hello: 1,
          server_hello: 2,
          certificate: 11,
          server_key_exchange: 12,
          certificate_request: 13,
          server_hello_done: 14,
          certificate_verify: 15,
          client_key_exchange: 16,
          finished: 20
        };
        tls.Alert = {};
        tls.Alert.Level = {
          warning: 1,
          fatal: 2
        };
        tls.Alert.Description = {
          close_notify: 0,
          unexpected_message: 10,
          bad_record_mac: 20,
          decryption_failed: 21,
          record_overflow: 22,
          decompression_failure: 30,
          handshake_failure: 40,
          bad_certificate: 42,
          unsupported_certificate: 43,
          certificate_revoked: 44,
          certificate_expired: 45,
          certificate_unknown: 46,
          illegal_parameter: 47,
          unknown_ca: 48,
          access_denied: 49,
          decode_error: 50,
          decrypt_error: 51,
          export_restriction: 60,
          protocol_version: 70,
          insufficient_security: 71,
          internal_error: 80,
          user_canceled: 90,
          no_renegotiation: 100
        };
        tls.HeartbeatMessageType = {
          heartbeat_request: 1,
          heartbeat_response: 2
        };
        tls.CipherSuites = {};
        tls.getCipherSuite = function(twoBytes) {
          var rval = null;
          for (var key2 in tls.CipherSuites) {
            var cs = tls.CipherSuites[key2];
            if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
              rval = cs;
              break;
            }
          }
          return rval;
        };
        tls.handleUnexpected = function(c2, record) {
          var ignore = !c2.open && c2.entity === tls.ConnectionEnd.client;
          if (!ignore) {
            c2.error(c2, {
              message: "Unexpected message. Received TLS record out of order.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unexpected_message
              }
            });
          }
        };
        tls.handleHelloRequest = function(c2, record, length2) {
          if (!c2.handshaking && c2.handshakes > 0) {
            tls.queue(c2, tls.createAlert(c2, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.no_renegotiation
            }));
            tls.flush(c2);
          }
          c2.process();
        };
        tls.parseHelloMessage = function(c2, record, length2) {
          var msg = null;
          var client = c2.entity === tls.ConnectionEnd.client;
          if (length2 < 38) {
            c2.error(c2, {
              message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else {
            var b2 = record.fragment;
            var remaining = b2.length();
            msg = {
              version: {
                major: b2.getByte(),
                minor: b2.getByte()
              },
              random: forge.util.createBuffer(b2.getBytes(32)),
              session_id: readVector(b2, 1),
              extensions: []
            };
            if (client) {
              msg.cipher_suite = b2.getBytes(2);
              msg.compression_method = b2.getByte();
            } else {
              msg.cipher_suites = readVector(b2, 2);
              msg.compression_methods = readVector(b2, 1);
            }
            remaining = length2 - (remaining - b2.length());
            if (remaining > 0) {
              var exts = readVector(b2, 2);
              while (exts.length() > 0) {
                msg.extensions.push({
                  type: [exts.getByte(), exts.getByte()],
                  data: readVector(exts, 2)
                });
              }
              if (!client) {
                for (var i2 = 0; i2 < msg.extensions.length; ++i2) {
                  var ext = msg.extensions[i2];
                  if (ext.type[0] === 0 && ext.type[1] === 0) {
                    var snl = readVector(ext.data, 2);
                    while (snl.length() > 0) {
                      var snType = snl.getByte();
                      if (snType !== 0) {
                        break;
                      }
                      c2.session.extensions.server_name.serverNameList.push(
                        readVector(snl, 2).getBytes()
                      );
                    }
                  }
                }
              }
            }
            if (c2.session.version) {
              if (msg.version.major !== c2.session.version.major || msg.version.minor !== c2.session.version.minor) {
                return c2.error(c2, {
                  message: "TLS version change is disallowed during renegotiation.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            if (client) {
              c2.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
            } else {
              var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
              while (tmp.length() > 0) {
                c2.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
                if (c2.session.cipherSuite !== null) {
                  break;
                }
              }
            }
            if (c2.session.cipherSuite === null) {
              return c2.error(c2, {
                message: "No cipher suites in common.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.handshake_failure
                },
                cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
              });
            }
            if (client) {
              c2.session.compressionMethod = msg.compression_method;
            } else {
              c2.session.compressionMethod = tls.CompressionMethod.none;
            }
          }
          return msg;
        };
        tls.createSecurityParameters = function(c2, msg) {
          var client = c2.entity === tls.ConnectionEnd.client;
          var msgRandom = msg.random.bytes();
          var cRandom = client ? c2.session.sp.client_random : msgRandom;
          var sRandom = client ? msgRandom : tls.createRandom().getBytes();
          c2.session.sp = {
            entity: c2.entity,
            prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
            bulk_cipher_algorithm: null,
            cipher_type: null,
            enc_key_length: null,
            block_length: null,
            fixed_iv_length: null,
            record_iv_length: null,
            mac_algorithm: null,
            mac_length: null,
            mac_key_length: null,
            compression_algorithm: c2.session.compressionMethod,
            pre_master_secret: null,
            master_secret: null,
            client_random: cRandom,
            server_random: sRandom
          };
        };
        tls.handleServerHello = function(c2, record, length2) {
          var msg = tls.parseHelloMessage(c2, record, length2);
          if (c2.fail) {
            return;
          }
          if (msg.version.minor <= c2.version.minor) {
            c2.version.minor = msg.version.minor;
          } else {
            return c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
          c2.session.version = c2.version;
          var sessionId = msg.session_id.bytes();
          if (sessionId.length > 0 && sessionId === c2.session.id) {
            c2.expect = SCC;
            c2.session.resuming = true;
            c2.session.sp.server_random = msg.random.bytes();
          } else {
            c2.expect = SCE;
            c2.session.resuming = false;
            tls.createSecurityParameters(c2, msg);
          }
          c2.session.id = sessionId;
          c2.process();
        };
        tls.handleClientHello = function(c2, record, length2) {
          var msg = tls.parseHelloMessage(c2, record, length2);
          if (c2.fail) {
            return;
          }
          var sessionId = msg.session_id.bytes();
          var session = null;
          if (c2.sessionCache) {
            session = c2.sessionCache.getSession(sessionId);
            if (session === null) {
              sessionId = "";
            } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
              session = null;
              sessionId = "";
            }
          }
          if (sessionId.length === 0) {
            sessionId = forge.random.getBytes(32);
          }
          c2.session.id = sessionId;
          c2.session.clientHelloVersion = msg.version;
          c2.session.sp = {};
          if (session) {
            c2.version = c2.session.version = session.version;
            c2.session.sp = session.sp;
          } else {
            var version4;
            for (var i2 = 1; i2 < tls.SupportedVersions.length; ++i2) {
              version4 = tls.SupportedVersions[i2];
              if (version4.minor <= msg.version.minor) {
                break;
              }
            }
            c2.version = { major: version4.major, minor: version4.minor };
            c2.session.version = c2.version;
          }
          if (session !== null) {
            c2.expect = CCC;
            c2.session.resuming = true;
            c2.session.sp.client_random = msg.random.bytes();
          } else {
            c2.expect = c2.verifyClient !== false ? CCE : CKE;
            c2.session.resuming = false;
            tls.createSecurityParameters(c2, msg);
          }
          c2.open = true;
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createServerHello(c2)
          }));
          if (c2.session.resuming) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c2.state.pending = tls.createConnectionState(c2);
            c2.state.current.write = c2.state.pending.write;
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c2)
            }));
          } else {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c2)
            }));
            if (!c2.fail) {
              tls.queue(c2, tls.createRecord(c2, {
                type: tls.ContentType.handshake,
                data: tls.createServerKeyExchange(c2)
              }));
              if (c2.verifyClient !== false) {
                tls.queue(c2, tls.createRecord(c2, {
                  type: tls.ContentType.handshake,
                  data: tls.createCertificateRequest(c2)
                }));
              }
              tls.queue(c2, tls.createRecord(c2, {
                type: tls.ContentType.handshake,
                data: tls.createServerHelloDone(c2)
              }));
            }
          }
          tls.flush(c2);
          c2.process();
        };
        tls.handleCertificate = function(c2, record, length2) {
          if (length2 < 3) {
            return c2.error(c2, {
              message: "Invalid Certificate message. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b2 = record.fragment;
          var msg = {
            certificate_list: readVector(b2, 3)
          };
          var cert, asn1;
          var certs = [];
          try {
            while (msg.certificate_list.length() > 0) {
              cert = readVector(msg.certificate_list, 3);
              asn1 = forge.asn1.fromDer(cert);
              cert = forge.pki.certificateFromAsn1(asn1, true);
              certs.push(cert);
            }
          } catch (ex) {
            return c2.error(c2, {
              message: "Could not parse certificate list.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              }
            });
          }
          var client = c2.entity === tls.ConnectionEnd.client;
          if ((client || c2.verifyClient === true) && certs.length === 0) {
            c2.error(c2, {
              message: client ? "No server certificate provided." : "No client certificate provided.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          } else if (certs.length === 0) {
            c2.expect = client ? SKE : CKE;
          } else {
            if (client) {
              c2.session.serverCertificate = certs[0];
            } else {
              c2.session.clientCertificate = certs[0];
            }
            if (tls.verifyCertificateChain(c2, certs)) {
              c2.expect = client ? SKE : CKE;
            }
          }
          c2.process();
        };
        tls.handleServerKeyExchange = function(c2, record, length2) {
          if (length2 > 0) {
            return c2.error(c2, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          c2.expect = SCR;
          c2.process();
        };
        tls.handleClientKeyExchange = function(c2, record, length2) {
          if (length2 < 48) {
            return c2.error(c2, {
              message: "Invalid key parameters. Only RSA is supported.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.unsupported_certificate
              }
            });
          }
          var b2 = record.fragment;
          var msg = {
            enc_pre_master_secret: readVector(b2, 2).getBytes()
          };
          var privateKey = null;
          if (c2.getPrivateKey) {
            try {
              privateKey = c2.getPrivateKey(c2, c2.session.serverCertificate);
              privateKey = forge.pki.privateKeyFromPem(privateKey);
            } catch (ex) {
              c2.error(c2, {
                message: "Could not get private key.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
          }
          if (privateKey === null) {
            return c2.error(c2, {
              message: "No private key set.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
          try {
            var sp = c2.session.sp;
            sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
            var version4 = c2.session.clientHelloVersion;
            if (version4.major !== sp.pre_master_secret.charCodeAt(0) || version4.minor !== sp.pre_master_secret.charCodeAt(1)) {
              throw new Error("TLS version rollback attack detected.");
            }
          } catch (ex) {
            sp.pre_master_secret = forge.random.getBytes(48);
          }
          c2.expect = CCC;
          if (c2.session.clientCertificate !== null) {
            c2.expect = CCV;
          }
          c2.process();
        };
        tls.handleCertificateRequest = function(c2, record, length2) {
          if (length2 < 3) {
            return c2.error(c2, {
              message: "Invalid CertificateRequest. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b2 = record.fragment;
          var msg = {
            certificate_types: readVector(b2, 1),
            certificate_authorities: readVector(b2, 2)
          };
          c2.session.certificateRequest = msg;
          c2.expect = SHD;
          c2.process();
        };
        tls.handleCertificateVerify = function(c2, record, length2) {
          if (length2 < 2) {
            return c2.error(c2, {
              message: "Invalid CertificateVerify. Message too short.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var b2 = record.fragment;
          b2.read -= 4;
          var msgBytes = b2.bytes();
          b2.read += 4;
          var msg = {
            signature: readVector(b2, 2).getBytes()
          };
          var verify22 = forge.util.createBuffer();
          verify22.putBuffer(c2.session.md5.digest());
          verify22.putBuffer(c2.session.sha1.digest());
          verify22 = verify22.getBytes();
          try {
            var cert = c2.session.clientCertificate;
            if (!cert.publicKey.verify(verify22, msg.signature, "NONE")) {
              throw new Error("CertificateVerify signature does not match.");
            }
            c2.session.md5.update(msgBytes);
            c2.session.sha1.update(msgBytes);
          } catch (ex) {
            return c2.error(c2, {
              message: "Bad signature in CertificateVerify.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.handshake_failure
              }
            });
          }
          c2.expect = CCC;
          c2.process();
        };
        tls.handleServerHelloDone = function(c2, record, length2) {
          if (length2 > 0) {
            return c2.error(c2, {
              message: "Invalid ServerHelloDone message. Invalid length.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.record_overflow
              }
            });
          }
          if (c2.serverCertificate === null) {
            var error = {
              message: "No server certificate provided. Not enough security.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.insufficient_security
              }
            };
            var depth = 0;
            var ret = c2.verify(c2, error.alert.description, depth, []);
            if (ret !== true) {
              if (ret || ret === 0) {
                if (typeof ret === "object" && !forge.util.isArray(ret)) {
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                } else if (typeof ret === "number") {
                  error.alert.description = ret;
                }
              }
              return c2.error(c2, error);
            }
          }
          if (c2.session.certificateRequest !== null) {
            record = tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createCertificate(c2)
            });
            tls.queue(c2, record);
          }
          record = tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createClientKeyExchange(c2)
          });
          tls.queue(c2, record);
          c2.expect = SER;
          var callback = function(c22, signature) {
            if (c22.session.certificateRequest !== null && c22.session.clientCertificate !== null) {
              tls.queue(c22, tls.createRecord(c22, {
                type: tls.ContentType.handshake,
                data: tls.createCertificateVerify(c22, signature)
              }));
            }
            tls.queue(c22, tls.createRecord(c22, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c22.state.pending = tls.createConnectionState(c22);
            c22.state.current.write = c22.state.pending.write;
            tls.queue(c22, tls.createRecord(c22, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c22)
            }));
            c22.expect = SCC;
            tls.flush(c22);
            c22.process();
          };
          if (c2.session.certificateRequest === null || c2.session.clientCertificate === null) {
            return callback(c2, null);
          }
          tls.getClientSignature(c2, callback);
        };
        tls.handleChangeCipherSpec = function(c2, record) {
          if (record.fragment.getByte() !== 1) {
            return c2.error(c2, {
              message: "Invalid ChangeCipherSpec message received.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.illegal_parameter
              }
            });
          }
          var client = c2.entity === tls.ConnectionEnd.client;
          if (c2.session.resuming && client || !c2.session.resuming && !client) {
            c2.state.pending = tls.createConnectionState(c2);
          }
          c2.state.current.read = c2.state.pending.read;
          if (!c2.session.resuming && client || c2.session.resuming && !client) {
            c2.state.pending = null;
          }
          c2.expect = client ? SFI : CFI;
          c2.process();
        };
        tls.handleFinished = function(c2, record, length2) {
          var b2 = record.fragment;
          b2.read -= 4;
          var msgBytes = b2.bytes();
          b2.read += 4;
          var vd = record.fragment.getBytes();
          b2 = forge.util.createBuffer();
          b2.putBuffer(c2.session.md5.digest());
          b2.putBuffer(c2.session.sha1.digest());
          var client = c2.entity === tls.ConnectionEnd.client;
          var label = client ? "server finished" : "client finished";
          var sp = c2.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
          if (b2.getBytes() !== vd) {
            return c2.error(c2, {
              message: "Invalid verify_data in Finished message.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.decrypt_error
              }
            });
          }
          c2.session.md5.update(msgBytes);
          c2.session.sha1.update(msgBytes);
          if (c2.session.resuming && client || !c2.session.resuming && !client) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.change_cipher_spec,
              data: tls.createChangeCipherSpec()
            }));
            c2.state.current.write = c2.state.pending.write;
            c2.state.pending = null;
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createFinished(c2)
            }));
          }
          c2.expect = client ? SAD : CAD;
          c2.handshaking = false;
          ++c2.handshakes;
          c2.peerCertificate = client ? c2.session.serverCertificate : c2.session.clientCertificate;
          tls.flush(c2);
          c2.isConnected = true;
          c2.connected(c2);
          c2.process();
        };
        tls.handleAlert = function(c2, record) {
          var b2 = record.fragment;
          var alert = {
            level: b2.getByte(),
            description: b2.getByte()
          };
          var msg;
          switch (alert.description) {
            case tls.Alert.Description.close_notify:
              msg = "Connection closed.";
              break;
            case tls.Alert.Description.unexpected_message:
              msg = "Unexpected message.";
              break;
            case tls.Alert.Description.bad_record_mac:
              msg = "Bad record MAC.";
              break;
            case tls.Alert.Description.decryption_failed:
              msg = "Decryption failed.";
              break;
            case tls.Alert.Description.record_overflow:
              msg = "Record overflow.";
              break;
            case tls.Alert.Description.decompression_failure:
              msg = "Decompression failed.";
              break;
            case tls.Alert.Description.handshake_failure:
              msg = "Handshake failure.";
              break;
            case tls.Alert.Description.bad_certificate:
              msg = "Bad certificate.";
              break;
            case tls.Alert.Description.unsupported_certificate:
              msg = "Unsupported certificate.";
              break;
            case tls.Alert.Description.certificate_revoked:
              msg = "Certificate revoked.";
              break;
            case tls.Alert.Description.certificate_expired:
              msg = "Certificate expired.";
              break;
            case tls.Alert.Description.certificate_unknown:
              msg = "Certificate unknown.";
              break;
            case tls.Alert.Description.illegal_parameter:
              msg = "Illegal parameter.";
              break;
            case tls.Alert.Description.unknown_ca:
              msg = "Unknown certificate authority.";
              break;
            case tls.Alert.Description.access_denied:
              msg = "Access denied.";
              break;
            case tls.Alert.Description.decode_error:
              msg = "Decode error.";
              break;
            case tls.Alert.Description.decrypt_error:
              msg = "Decrypt error.";
              break;
            case tls.Alert.Description.export_restriction:
              msg = "Export restriction.";
              break;
            case tls.Alert.Description.protocol_version:
              msg = "Unsupported protocol version.";
              break;
            case tls.Alert.Description.insufficient_security:
              msg = "Insufficient security.";
              break;
            case tls.Alert.Description.internal_error:
              msg = "Internal error.";
              break;
            case tls.Alert.Description.user_canceled:
              msg = "User canceled.";
              break;
            case tls.Alert.Description.no_renegotiation:
              msg = "Renegotiation not supported.";
              break;
            default:
              msg = "Unknown error.";
              break;
          }
          if (alert.description === tls.Alert.Description.close_notify) {
            return c2.close();
          }
          c2.error(c2, {
            message: msg,
            send: false,
            // origin is the opposite end
            origin: c2.entity === tls.ConnectionEnd.client ? "server" : "client",
            alert
          });
          c2.process();
        };
        tls.handleHandshake = function(c2, record) {
          var b2 = record.fragment;
          var type = b2.getByte();
          var length2 = b2.getInt24();
          if (length2 > b2.length()) {
            c2.fragmented = record;
            record.fragment = forge.util.createBuffer();
            b2.read -= 4;
            return c2.process();
          }
          c2.fragmented = null;
          b2.read -= 4;
          var bytes = b2.bytes(length2 + 4);
          b2.read += 4;
          if (type in hsTable[c2.entity][c2.expect]) {
            if (c2.entity === tls.ConnectionEnd.server && !c2.open && !c2.fail) {
              c2.handshaking = true;
              c2.session = {
                version: null,
                extensions: {
                  server_name: {
                    serverNameList: []
                  }
                },
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                clientCertificate: null,
                md5: forge.md.md5.create(),
                sha1: forge.md.sha1.create()
              };
            }
            if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
              c2.session.md5.update(bytes);
              c2.session.sha1.update(bytes);
            }
            hsTable[c2.entity][c2.expect][type](c2, record, length2);
          } else {
            tls.handleUnexpected(c2, record);
          }
        };
        tls.handleApplicationData = function(c2, record) {
          c2.data.putBuffer(record.fragment);
          c2.dataReady(c2);
          c2.process();
        };
        tls.handleHeartbeat = function(c2, record) {
          var b2 = record.fragment;
          var type = b2.getByte();
          var length2 = b2.getInt16();
          var payload = b2.getBytes(length2);
          if (type === tls.HeartbeatMessageType.heartbeat_request) {
            if (c2.handshaking || length2 > payload.length) {
              return c2.process();
            }
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_response,
                payload
              )
            }));
            tls.flush(c2);
          } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
            if (payload !== c2.expectedHeartbeatPayload) {
              return c2.process();
            }
            if (c2.heartbeatReceived) {
              c2.heartbeatReceived(c2, forge.util.createBuffer(payload));
            }
          }
          c2.process();
        };
        var SHE = 0;
        var SCE = 1;
        var SKE = 2;
        var SCR = 3;
        var SHD = 4;
        var SCC = 5;
        var SFI = 6;
        var SAD = 7;
        var SER = 8;
        var CHE = 0;
        var CCE = 1;
        var CKE = 2;
        var CCV = 3;
        var CCC = 4;
        var CFI = 5;
        var CAD = 6;
        var __ = tls.handleUnexpected;
        var R0 = tls.handleChangeCipherSpec;
        var R1 = tls.handleAlert;
        var R2 = tls.handleHandshake;
        var R3 = tls.handleApplicationData;
        var R4 = tls.handleHeartbeat;
        var ctTable = [];
        ctTable[tls.ConnectionEnd.client] = [
          //      CC,AL,HS,AD,HB
          /*SHE*/
          [__, R1, R2, __, R4],
          /*SCE*/
          [__, R1, R2, __, R4],
          /*SKE*/
          [__, R1, R2, __, R4],
          /*SCR*/
          [__, R1, R2, __, R4],
          /*SHD*/
          [__, R1, R2, __, R4],
          /*SCC*/
          [R0, R1, __, __, R4],
          /*SFI*/
          [__, R1, R2, __, R4],
          /*SAD*/
          [__, R1, R2, R3, R4],
          /*SER*/
          [__, R1, R2, __, R4]
        ];
        ctTable[tls.ConnectionEnd.server] = [
          //      CC,AL,HS,AD
          /*CHE*/
          [__, R1, R2, __, R4],
          /*CCE*/
          [__, R1, R2, __, R4],
          /*CKE*/
          [__, R1, R2, __, R4],
          /*CCV*/
          [__, R1, R2, __, R4],
          /*CCC*/
          [R0, R1, __, __, R4],
          /*CFI*/
          [__, R1, R2, __, R4],
          /*CAD*/
          [__, R1, R2, R3, R4],
          /*CER*/
          [__, R1, R2, __, R4]
        ];
        var H0 = tls.handleHelloRequest;
        var H1 = tls.handleServerHello;
        var H2 = tls.handleCertificate;
        var H3 = tls.handleServerKeyExchange;
        var H4 = tls.handleCertificateRequest;
        var H5 = tls.handleServerHelloDone;
        var H6 = tls.handleFinished;
        var hsTable = [];
        hsTable[tls.ConnectionEnd.client] = [
          //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
          /*SHE*/
          [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SCE*/
          [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
          /*SKE*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
          /*SCR*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
          /*SHD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
          /*SCC*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SFI*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*SAD*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*SER*/
          [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        var H7 = tls.handleClientHello;
        var H8 = tls.handleClientKeyExchange;
        var H9 = tls.handleCertificateVerify;
        hsTable[tls.ConnectionEnd.server] = [
          //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
          /*CHE*/
          [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CCE*/
          [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
          /*CKE*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
          /*CCV*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
          /*CCC*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CFI*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
          /*CAD*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
          /*CER*/
          [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
        ];
        tls.generateKeys = function(c2, sp) {
          var prf = prf_TLS1;
          var random = sp.client_random + sp.server_random;
          if (!c2.session.resuming) {
            sp.master_secret = prf(
              sp.pre_master_secret,
              "master secret",
              random,
              48
            ).bytes();
            sp.pre_master_secret = null;
          }
          random = sp.server_random + sp.client_random;
          var length2 = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
          var tls10 = c2.version.major === tls.Versions.TLS_1_0.major && c2.version.minor === tls.Versions.TLS_1_0.minor;
          if (tls10) {
            length2 += 2 * sp.fixed_iv_length;
          }
          var km = prf(sp.master_secret, "key expansion", random, length2);
          var rval = {
            client_write_MAC_key: km.getBytes(sp.mac_key_length),
            server_write_MAC_key: km.getBytes(sp.mac_key_length),
            client_write_key: km.getBytes(sp.enc_key_length),
            server_write_key: km.getBytes(sp.enc_key_length)
          };
          if (tls10) {
            rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
            rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
          }
          return rval;
        };
        tls.createConnectionState = function(c2) {
          var client = c2.entity === tls.ConnectionEnd.client;
          var createMode = function() {
            var mode = {
              // two 32-bit numbers, first is most significant
              sequenceNumber: [0, 0],
              macKey: null,
              macLength: 0,
              macFunction: null,
              cipherState: null,
              cipherFunction: function(record) {
                return true;
              },
              compressionState: null,
              compressFunction: function(record) {
                return true;
              },
              updateSequenceNumber: function() {
                if (mode.sequenceNumber[1] === 4294967295) {
                  mode.sequenceNumber[1] = 0;
                  ++mode.sequenceNumber[0];
                } else {
                  ++mode.sequenceNumber[1];
                }
              }
            };
            return mode;
          };
          var state = {
            read: createMode(),
            write: createMode()
          };
          state.read.update = function(c22, record) {
            if (!state.read.cipherFunction(record, state.read)) {
              c22.error(c22, {
                message: "Could not decrypt record or bad MAC.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  // doesn't matter if decryption failed or MAC was
                  // invalid, return the same error so as not to reveal
                  // which one occurred
                  description: tls.Alert.Description.bad_record_mac
                }
              });
            } else if (!state.read.compressFunction(c22, record, state.read)) {
              c22.error(c22, {
                message: "Could not decompress record.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.decompression_failure
                }
              });
            }
            return !c22.fail;
          };
          state.write.update = function(c22, record) {
            if (!state.write.compressFunction(c22, record, state.write)) {
              c22.error(c22, {
                message: "Could not compress record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else if (!state.write.cipherFunction(record, state.write)) {
              c22.error(c22, {
                message: "Could not encrypt record.",
                send: false,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
            return !c22.fail;
          };
          if (c2.session) {
            var sp = c2.session.sp;
            c2.session.cipherSuite.initSecurityParameters(sp);
            sp.keys = tls.generateKeys(c2, sp);
            state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
            state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
            c2.session.cipherSuite.initConnectionState(state, c2, sp);
            switch (sp.compression_algorithm) {
              case tls.CompressionMethod.none:
                break;
              case tls.CompressionMethod.deflate:
                state.read.compressFunction = inflate;
                state.write.compressFunction = deflate;
                break;
              default:
                throw new Error("Unsupported compression algorithm.");
            }
          }
          return state;
        };
        tls.createRandom = function() {
          var d = /* @__PURE__ */ new Date();
          var utc = +d + d.getTimezoneOffset() * 6e4;
          var rval = forge.util.createBuffer();
          rval.putInt32(utc);
          rval.putBytes(forge.random.getBytes(28));
          return rval;
        };
        tls.createRecord = function(c2, options) {
          if (!options.data) {
            return null;
          }
          var record = {
            type: options.type,
            version: {
              major: c2.version.major,
              minor: c2.version.minor
            },
            length: options.data.length(),
            fragment: options.data
          };
          return record;
        };
        tls.createAlert = function(c2, alert) {
          var b2 = forge.util.createBuffer();
          b2.putByte(alert.level);
          b2.putByte(alert.description);
          return tls.createRecord(c2, {
            type: tls.ContentType.alert,
            data: b2
          });
        };
        tls.createClientHello = function(c2) {
          c2.session.clientHelloVersion = {
            major: c2.version.major,
            minor: c2.version.minor
          };
          var cipherSuites = forge.util.createBuffer();
          for (var i2 = 0; i2 < c2.cipherSuites.length; ++i2) {
            var cs = c2.cipherSuites[i2];
            cipherSuites.putByte(cs.id[0]);
            cipherSuites.putByte(cs.id[1]);
          }
          var cSuites = cipherSuites.length();
          var compressionMethods = forge.util.createBuffer();
          compressionMethods.putByte(tls.CompressionMethod.none);
          var cMethods = compressionMethods.length();
          var extensions = forge.util.createBuffer();
          if (c2.virtualHost) {
            var ext = forge.util.createBuffer();
            ext.putByte(0);
            ext.putByte(0);
            var serverName = forge.util.createBuffer();
            serverName.putByte(0);
            writeVector(serverName, 2, forge.util.createBuffer(c2.virtualHost));
            var snList = forge.util.createBuffer();
            writeVector(snList, 2, serverName);
            writeVector(ext, 2, snList);
            extensions.putBuffer(ext);
          }
          var extLength = extensions.length();
          if (extLength > 0) {
            extLength += 2;
          }
          var sessionId = c2.session.id;
          var length2 = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + cSuites + // cipher suites vector
          1 + cMethods + // compression methods vector
          extLength;
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_hello);
          rval.putInt24(length2);
          rval.putByte(c2.version.major);
          rval.putByte(c2.version.minor);
          rval.putBytes(c2.session.sp.client_random);
          writeVector(rval, 1, forge.util.createBuffer(sessionId));
          writeVector(rval, 2, cipherSuites);
          writeVector(rval, 1, compressionMethods);
          if (extLength > 0) {
            writeVector(rval, 2, extensions);
          }
          return rval;
        };
        tls.createServerHello = function(c2) {
          var sessionId = c2.session.id;
          var length2 = sessionId.length + 1 + // session ID vector
          2 + // version (major + minor)
          4 + 28 + // random time and random bytes
          2 + // chosen cipher suite
          1;
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello);
          rval.putInt24(length2);
          rval.putByte(c2.version.major);
          rval.putByte(c2.version.minor);
          rval.putBytes(c2.session.sp.server_random);
          writeVector(rval, 1, forge.util.createBuffer(sessionId));
          rval.putByte(c2.session.cipherSuite.id[0]);
          rval.putByte(c2.session.cipherSuite.id[1]);
          rval.putByte(c2.session.compressionMethod);
          return rval;
        };
        tls.createCertificate = function(c2) {
          var client = c2.entity === tls.ConnectionEnd.client;
          var cert = null;
          if (c2.getCertificate) {
            var hint;
            if (client) {
              hint = c2.session.certificateRequest;
            } else {
              hint = c2.session.extensions.server_name.serverNameList;
            }
            cert = c2.getCertificate(c2, hint);
          }
          var certList = forge.util.createBuffer();
          if (cert !== null) {
            try {
              if (!forge.util.isArray(cert)) {
                cert = [cert];
              }
              var asn1 = null;
              for (var i2 = 0; i2 < cert.length; ++i2) {
                var msg = forge.pem.decode(cert[i2])[0];
                if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
                  var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                  error.headerType = msg.type;
                  throw error;
                }
                if (msg.procType && msg.procType.type === "ENCRYPTED") {
                  throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
                }
                var der = forge.util.createBuffer(msg.body);
                if (asn1 === null) {
                  asn1 = forge.asn1.fromDer(der.bytes(), false);
                }
                var certBuffer = forge.util.createBuffer();
                writeVector(certBuffer, 3, der);
                certList.putBuffer(certBuffer);
              }
              cert = forge.pki.certificateFromAsn1(asn1);
              if (client) {
                c2.session.clientCertificate = cert;
              } else {
                c2.session.serverCertificate = cert;
              }
            } catch (ex) {
              return c2.error(c2, {
                message: "Could not send certificate list.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.bad_certificate
                }
              });
            }
          }
          var length2 = 3 + certList.length();
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate);
          rval.putInt24(length2);
          writeVector(rval, 3, certList);
          return rval;
        };
        tls.createClientKeyExchange = function(c2) {
          var b2 = forge.util.createBuffer();
          b2.putByte(c2.session.clientHelloVersion.major);
          b2.putByte(c2.session.clientHelloVersion.minor);
          b2.putBytes(forge.random.getBytes(46));
          var sp = c2.session.sp;
          sp.pre_master_secret = b2.getBytes();
          var key2 = c2.session.serverCertificate.publicKey;
          b2 = key2.encrypt(sp.pre_master_secret);
          var length2 = b2.length + 2;
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.client_key_exchange);
          rval.putInt24(length2);
          rval.putInt16(b2.length);
          rval.putBytes(b2);
          return rval;
        };
        tls.createServerKeyExchange = function(c2) {
          var length2 = 0;
          var rval = forge.util.createBuffer();
          if (length2 > 0) {
            rval.putByte(tls.HandshakeType.server_key_exchange);
            rval.putInt24(length2);
          }
          return rval;
        };
        tls.getClientSignature = function(c2, callback) {
          var b2 = forge.util.createBuffer();
          b2.putBuffer(c2.session.md5.digest());
          b2.putBuffer(c2.session.sha1.digest());
          b2 = b2.getBytes();
          c2.getSignature = c2.getSignature || function(c22, b22, callback2) {
            var privateKey = null;
            if (c22.getPrivateKey) {
              try {
                privateKey = c22.getPrivateKey(c22, c22.session.clientCertificate);
                privateKey = forge.pki.privateKeyFromPem(privateKey);
              } catch (ex) {
                c22.error(c22, {
                  message: "Could not get private key.",
                  cause: ex,
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.internal_error
                  }
                });
              }
            }
            if (privateKey === null) {
              c22.error(c22, {
                message: "No private key set.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            } else {
              b22 = privateKey.sign(b22, null);
            }
            callback2(c22, b22);
          };
          c2.getSignature(c2, b2, callback);
        };
        tls.createCertificateVerify = function(c2, signature) {
          var length2 = signature.length + 2;
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_verify);
          rval.putInt24(length2);
          rval.putInt16(signature.length);
          rval.putBytes(signature);
          return rval;
        };
        tls.createCertificateRequest = function(c2) {
          var certTypes = forge.util.createBuffer();
          certTypes.putByte(1);
          var cAs = forge.util.createBuffer();
          for (var key2 in c2.caStore.certs) {
            var cert = c2.caStore.certs[key2];
            var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
            var byteBuffer = forge.asn1.toDer(dn);
            cAs.putInt16(byteBuffer.length());
            cAs.putBuffer(byteBuffer);
          }
          var length2 = 1 + certTypes.length() + 2 + cAs.length();
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.certificate_request);
          rval.putInt24(length2);
          writeVector(rval, 1, certTypes);
          writeVector(rval, 2, cAs);
          return rval;
        };
        tls.createServerHelloDone = function(c2) {
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.server_hello_done);
          rval.putInt24(0);
          return rval;
        };
        tls.createChangeCipherSpec = function() {
          var rval = forge.util.createBuffer();
          rval.putByte(1);
          return rval;
        };
        tls.createFinished = function(c2) {
          var b2 = forge.util.createBuffer();
          b2.putBuffer(c2.session.md5.digest());
          b2.putBuffer(c2.session.sha1.digest());
          var client = c2.entity === tls.ConnectionEnd.client;
          var sp = c2.session.sp;
          var vdl = 12;
          var prf = prf_TLS1;
          var label = client ? "client finished" : "server finished";
          b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
          var rval = forge.util.createBuffer();
          rval.putByte(tls.HandshakeType.finished);
          rval.putInt24(b2.length());
          rval.putBuffer(b2);
          return rval;
        };
        tls.createHeartbeat = function(type, payload, payloadLength) {
          if (typeof payloadLength === "undefined") {
            payloadLength = payload.length;
          }
          var rval = forge.util.createBuffer();
          rval.putByte(type);
          rval.putInt16(payloadLength);
          rval.putBytes(payload);
          var plaintextLength = rval.length();
          var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
          rval.putBytes(forge.random.getBytes(paddingLength));
          return rval;
        };
        tls.queue = function(c2, record) {
          if (!record) {
            return;
          }
          if (record.fragment.length() === 0) {
            if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
              return;
            }
          }
          if (record.type === tls.ContentType.handshake) {
            var bytes = record.fragment.bytes();
            c2.session.md5.update(bytes);
            c2.session.sha1.update(bytes);
            bytes = null;
          }
          var records;
          if (record.fragment.length() <= tls.MaxFragment) {
            records = [record];
          } else {
            records = [];
            var data = record.fragment.bytes();
            while (data.length > tls.MaxFragment) {
              records.push(tls.createRecord(c2, {
                type: record.type,
                data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
              }));
              data = data.slice(tls.MaxFragment);
            }
            if (data.length > 0) {
              records.push(tls.createRecord(c2, {
                type: record.type,
                data: forge.util.createBuffer(data)
              }));
            }
          }
          for (var i2 = 0; i2 < records.length && !c2.fail; ++i2) {
            var rec = records[i2];
            var s2 = c2.state.current.write;
            if (s2.update(c2, rec)) {
              c2.records.push(rec);
            }
          }
        };
        tls.flush = function(c2) {
          for (var i2 = 0; i2 < c2.records.length; ++i2) {
            var record = c2.records[i2];
            c2.tlsData.putByte(record.type);
            c2.tlsData.putByte(record.version.major);
            c2.tlsData.putByte(record.version.minor);
            c2.tlsData.putInt16(record.fragment.length());
            c2.tlsData.putBuffer(c2.records[i2].fragment);
          }
          c2.records = [];
          return c2.tlsDataReady(c2);
        };
        var _certErrorToAlertDesc = function(error) {
          switch (error) {
            case true:
              return true;
            case forge.pki.certificateError.bad_certificate:
              return tls.Alert.Description.bad_certificate;
            case forge.pki.certificateError.unsupported_certificate:
              return tls.Alert.Description.unsupported_certificate;
            case forge.pki.certificateError.certificate_revoked:
              return tls.Alert.Description.certificate_revoked;
            case forge.pki.certificateError.certificate_expired:
              return tls.Alert.Description.certificate_expired;
            case forge.pki.certificateError.certificate_unknown:
              return tls.Alert.Description.certificate_unknown;
            case forge.pki.certificateError.unknown_ca:
              return tls.Alert.Description.unknown_ca;
            default:
              return tls.Alert.Description.bad_certificate;
          }
        };
        var _alertDescToCertError = function(desc) {
          switch (desc) {
            case true:
              return true;
            case tls.Alert.Description.bad_certificate:
              return forge.pki.certificateError.bad_certificate;
            case tls.Alert.Description.unsupported_certificate:
              return forge.pki.certificateError.unsupported_certificate;
            case tls.Alert.Description.certificate_revoked:
              return forge.pki.certificateError.certificate_revoked;
            case tls.Alert.Description.certificate_expired:
              return forge.pki.certificateError.certificate_expired;
            case tls.Alert.Description.certificate_unknown:
              return forge.pki.certificateError.certificate_unknown;
            case tls.Alert.Description.unknown_ca:
              return forge.pki.certificateError.unknown_ca;
            default:
              return forge.pki.certificateError.bad_certificate;
          }
        };
        tls.verifyCertificateChain = function(c2, chain) {
          try {
            var options = {};
            for (var key2 in c2.verifyOptions) {
              options[key2] = c2.verifyOptions[key2];
            }
            options.verify = function(vfd, depth, chain2) {
              var desc = _certErrorToAlertDesc(vfd);
              var ret = c2.verify(c2, vfd, depth, chain2);
              if (ret !== true) {
                if (typeof ret === "object" && !forge.util.isArray(ret)) {
                  var error = new Error("The application rejected the certificate.");
                  error.send = true;
                  error.alert = {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.bad_certificate
                  };
                  if (ret.message) {
                    error.message = ret.message;
                  }
                  if (ret.alert) {
                    error.alert.description = ret.alert;
                  }
                  throw error;
                }
                if (ret !== vfd) {
                  ret = _alertDescToCertError(ret);
                }
              }
              return ret;
            };
            forge.pki.verifyCertificateChain(c2.caStore, chain, options);
          } catch (ex) {
            var err = ex;
            if (typeof err !== "object" || forge.util.isArray(err)) {
              err = {
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: _certErrorToAlertDesc(ex)
                }
              };
            }
            if (!("send" in err)) {
              err.send = true;
            }
            if (!("alert" in err)) {
              err.alert = {
                level: tls.Alert.Level.fatal,
                description: _certErrorToAlertDesc(err.error)
              };
            }
            c2.error(c2, err);
          }
          return !c2.fail;
        };
        tls.createSessionCache = function(cache, capacity) {
          var rval = null;
          if (cache && cache.getSession && cache.setSession && cache.order) {
            rval = cache;
          } else {
            rval = {};
            rval.cache = cache || {};
            rval.capacity = Math.max(capacity || 100, 1);
            rval.order = [];
            for (var key2 in cache) {
              if (rval.order.length <= capacity) {
                rval.order.push(key2);
              } else {
                delete cache[key2];
              }
            }
            rval.getSession = function(sessionId) {
              var session = null;
              var key3 = null;
              if (sessionId) {
                key3 = forge.util.bytesToHex(sessionId);
              } else if (rval.order.length > 0) {
                key3 = rval.order[0];
              }
              if (key3 !== null && key3 in rval.cache) {
                session = rval.cache[key3];
                delete rval.cache[key3];
                for (var i2 in rval.order) {
                  if (rval.order[i2] === key3) {
                    rval.order.splice(i2, 1);
                    break;
                  }
                }
              }
              return session;
            };
            rval.setSession = function(sessionId, session) {
              if (rval.order.length === rval.capacity) {
                var key3 = rval.order.shift();
                delete rval.cache[key3];
              }
              var key3 = forge.util.bytesToHex(sessionId);
              rval.order.push(key3);
              rval.cache[key3] = session;
            };
          }
          return rval;
        };
        tls.createConnection = function(options) {
          var caStore = null;
          if (options.caStore) {
            if (forge.util.isArray(options.caStore)) {
              caStore = forge.pki.createCaStore(options.caStore);
            } else {
              caStore = options.caStore;
            }
          } else {
            caStore = forge.pki.createCaStore();
          }
          var cipherSuites = options.cipherSuites || null;
          if (cipherSuites === null) {
            cipherSuites = [];
            for (var key2 in tls.CipherSuites) {
              cipherSuites.push(tls.CipherSuites[key2]);
            }
          }
          var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
          var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
          var c2 = {
            version: { major: tls.Version.major, minor: tls.Version.minor },
            entity,
            sessionId: options.sessionId,
            caStore,
            sessionCache,
            cipherSuites,
            connected: options.connected,
            virtualHost: options.virtualHost || null,
            verifyClient: options.verifyClient || false,
            verify: options.verify || function(cn, vfd, dpth, cts) {
              return vfd;
            },
            verifyOptions: options.verifyOptions || {},
            getCertificate: options.getCertificate || null,
            getPrivateKey: options.getPrivateKey || null,
            getSignature: options.getSignature || null,
            input: forge.util.createBuffer(),
            tlsData: forge.util.createBuffer(),
            data: forge.util.createBuffer(),
            tlsDataReady: options.tlsDataReady,
            dataReady: options.dataReady,
            heartbeatReceived: options.heartbeatReceived,
            closed: options.closed,
            error: function(c22, ex) {
              ex.origin = ex.origin || (c22.entity === tls.ConnectionEnd.client ? "client" : "server");
              if (ex.send) {
                tls.queue(c22, tls.createAlert(c22, ex.alert));
                tls.flush(c22);
              }
              var fatal = ex.fatal !== false;
              if (fatal) {
                c22.fail = true;
              }
              options.error(c22, ex);
              if (fatal) {
                c22.close(false);
              }
            },
            deflate: options.deflate || null,
            inflate: options.inflate || null
          };
          c2.reset = function(clearFail) {
            c2.version = { major: tls.Version.major, minor: tls.Version.minor };
            c2.record = null;
            c2.session = null;
            c2.peerCertificate = null;
            c2.state = {
              pending: null,
              current: null
            };
            c2.expect = c2.entity === tls.ConnectionEnd.client ? SHE : CHE;
            c2.fragmented = null;
            c2.records = [];
            c2.open = false;
            c2.handshakes = 0;
            c2.handshaking = false;
            c2.isConnected = false;
            c2.fail = !(clearFail || typeof clearFail === "undefined");
            c2.input.clear();
            c2.tlsData.clear();
            c2.data.clear();
            c2.state.current = tls.createConnectionState(c2);
          };
          c2.reset();
          var _update = function(c22, record) {
            var aligned = record.type - tls.ContentType.change_cipher_spec;
            var handlers = ctTable[c22.entity][c22.expect];
            if (aligned in handlers) {
              handlers[aligned](c22, record);
            } else {
              tls.handleUnexpected(c22, record);
            }
          };
          var _readRecordHeader = function(c22) {
            var rval = 0;
            var b2 = c22.input;
            var len = b2.length();
            if (len < 5) {
              rval = 5 - len;
            } else {
              c22.record = {
                type: b2.getByte(),
                version: {
                  major: b2.getByte(),
                  minor: b2.getByte()
                },
                length: b2.getInt16(),
                fragment: forge.util.createBuffer(),
                ready: false
              };
              var compatibleVersion = c22.record.version.major === c22.version.major;
              if (compatibleVersion && c22.session && c22.session.version) {
                compatibleVersion = c22.record.version.minor === c22.version.minor;
              }
              if (!compatibleVersion) {
                c22.error(c22, {
                  message: "Incompatible TLS version.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.protocol_version
                  }
                });
              }
            }
            return rval;
          };
          var _readRecord = function(c22) {
            var rval = 0;
            var b2 = c22.input;
            var len = b2.length();
            if (len < c22.record.length) {
              rval = c22.record.length - len;
            } else {
              c22.record.fragment.putBytes(b2.getBytes(c22.record.length));
              b2.compact();
              var s2 = c22.state.current.read;
              if (s2.update(c22, c22.record)) {
                if (c22.fragmented !== null) {
                  if (c22.fragmented.type === c22.record.type) {
                    c22.fragmented.fragment.putBuffer(c22.record.fragment);
                    c22.record = c22.fragmented;
                  } else {
                    c22.error(c22, {
                      message: "Invalid fragmented record.",
                      send: true,
                      alert: {
                        level: tls.Alert.Level.fatal,
                        description: tls.Alert.Description.unexpected_message
                      }
                    });
                  }
                }
                c22.record.ready = true;
              }
            }
            return rval;
          };
          c2.handshake = function(sessionId) {
            if (c2.entity !== tls.ConnectionEnd.client) {
              c2.error(c2, {
                message: "Cannot initiate handshake as a server.",
                fatal: false
              });
            } else if (c2.handshaking) {
              c2.error(c2, {
                message: "Handshake already in progress.",
                fatal: false
              });
            } else {
              if (c2.fail && !c2.open && c2.handshakes === 0) {
                c2.fail = false;
              }
              c2.handshaking = true;
              sessionId = sessionId || "";
              var session = null;
              if (sessionId.length > 0) {
                if (c2.sessionCache) {
                  session = c2.sessionCache.getSession(sessionId);
                }
                if (session === null) {
                  sessionId = "";
                }
              }
              if (sessionId.length === 0 && c2.sessionCache) {
                session = c2.sessionCache.getSession();
                if (session !== null) {
                  sessionId = session.id;
                }
              }
              c2.session = {
                id: sessionId,
                version: null,
                cipherSuite: null,
                compressionMethod: null,
                serverCertificate: null,
                certificateRequest: null,
                clientCertificate: null,
                sp: {},
                md5: forge.md.md5.create(),
                sha1: forge.md.sha1.create()
              };
              if (session) {
                c2.version = session.version;
                c2.session.sp = session.sp;
              }
              c2.session.sp.client_random = tls.createRandom().getBytes();
              c2.open = true;
              tls.queue(c2, tls.createRecord(c2, {
                type: tls.ContentType.handshake,
                data: tls.createClientHello(c2)
              }));
              tls.flush(c2);
            }
          };
          c2.process = function(data) {
            var rval = 0;
            if (data) {
              c2.input.putBytes(data);
            }
            if (!c2.fail) {
              if (c2.record !== null && c2.record.ready && c2.record.fragment.isEmpty()) {
                c2.record = null;
              }
              if (c2.record === null) {
                rval = _readRecordHeader(c2);
              }
              if (!c2.fail && c2.record !== null && !c2.record.ready) {
                rval = _readRecord(c2);
              }
              if (!c2.fail && c2.record !== null && c2.record.ready) {
                _update(c2, c2.record);
              }
            }
            return rval;
          };
          c2.prepare = function(data) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.application_data,
              data: forge.util.createBuffer(data)
            }));
            return tls.flush(c2);
          };
          c2.prepareHeartbeatRequest = function(payload, payloadLength) {
            if (payload instanceof forge.util.ByteBuffer) {
              payload = payload.bytes();
            }
            if (typeof payloadLength === "undefined") {
              payloadLength = payload.length;
            }
            c2.expectedHeartbeatPayload = payload;
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.heartbeat,
              data: tls.createHeartbeat(
                tls.HeartbeatMessageType.heartbeat_request,
                payload,
                payloadLength
              )
            }));
            return tls.flush(c2);
          };
          c2.close = function(clearFail) {
            if (!c2.fail && c2.sessionCache && c2.session) {
              var session = {
                id: c2.session.id,
                version: c2.session.version,
                sp: c2.session.sp
              };
              session.sp.keys = null;
              c2.sessionCache.setSession(session.id, session);
            }
            if (c2.open) {
              c2.open = false;
              c2.input.clear();
              if (c2.isConnected || c2.handshaking) {
                c2.isConnected = c2.handshaking = false;
                tls.queue(c2, tls.createAlert(c2, {
                  level: tls.Alert.Level.warning,
                  description: tls.Alert.Description.close_notify
                }));
                tls.flush(c2);
              }
              c2.closed(c2);
            }
            c2.reset(clearFail);
          };
          return c2;
        };
        module2.exports = forge.tls = forge.tls || {};
        for (key in tls) {
          if (typeof tls[key] !== "function") {
            forge.tls[key] = tls[key];
          }
        }
        var key;
        forge.tls.prf_tls1 = prf_TLS1;
        forge.tls.hmac_sha1 = hmac_sha1;
        forge.tls.createSessionCache = tls.createSessionCache;
        forge.tls.createConnection = tls.createConnection;
      }
    });
    var require_aesCipherSuites2 = __commonJS2({
      "../../node_modules/node-forge/lib/aesCipherSuites.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_tls2();
        var tls = module2.exports = forge.tls;
        tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
          id: [0, 47],
          name: "TLS_RSA_WITH_AES_128_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 16;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
          id: [0, 53],
          name: "TLS_RSA_WITH_AES_256_CBC_SHA",
          initSecurityParameters: function(sp) {
            sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
            sp.cipher_type = tls.CipherType.block;
            sp.enc_key_length = 32;
            sp.block_length = 16;
            sp.fixed_iv_length = 16;
            sp.record_iv_length = 16;
            sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
            sp.mac_length = 20;
            sp.mac_key_length = 20;
          },
          initConnectionState
        };
        function initConnectionState(state, c2, sp) {
          var client = c2.entity === forge.tls.ConnectionEnd.client;
          state.read.cipherState = {
            init: false,
            cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
            iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
          };
          state.write.cipherState = {
            init: false,
            cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
            iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
          };
          state.read.cipherFunction = decrypt_aes_cbc_sha1;
          state.write.cipherFunction = encrypt_aes_cbc_sha1;
          state.read.macLength = state.write.macLength = sp.mac_length;
          state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
        }
        function encrypt_aes_cbc_sha1(record, s2) {
          var rval = false;
          var mac = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
          record.fragment.putBytes(mac);
          s2.updateSequenceNumber();
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s2.cipherState.init ? null : s2.cipherState.iv;
          } else {
            iv = forge.random.getBytesSync(16);
          }
          s2.cipherState.init = true;
          var cipher = s2.cipherState.cipher;
          cipher.start({ iv });
          if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
            cipher.output.putBytes(iv);
          }
          cipher.update(record.fragment);
          if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
            record.fragment = cipher.output;
            record.length = record.fragment.length();
            rval = true;
          }
          return rval;
        }
        function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
          if (!decrypt) {
            var padding = blockSize - input.length() % blockSize;
            input.fillWithByte(padding - 1, padding);
          }
          return true;
        }
        function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
          var rval = true;
          if (decrypt) {
            var len = output.length();
            var paddingLength = output.last();
            for (var i2 = len - 1 - paddingLength; i2 < len - 1; ++i2) {
              rval = rval && output.at(i2) == paddingLength;
            }
            if (rval) {
              output.truncate(paddingLength + 1);
            }
          }
          return rval;
        }
        function decrypt_aes_cbc_sha1(record, s2) {
          var rval = false;
          var iv;
          if (record.version.minor === tls.Versions.TLS_1_0.minor) {
            iv = s2.cipherState.init ? null : s2.cipherState.iv;
          } else {
            iv = record.fragment.getBytes(16);
          }
          s2.cipherState.init = true;
          var cipher = s2.cipherState.cipher;
          cipher.start({ iv });
          cipher.update(record.fragment);
          rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
          var macLen = s2.macLength;
          var mac = forge.random.getBytesSync(macLen);
          var len = cipher.output.length();
          if (len >= macLen) {
            record.fragment = cipher.output.getBytes(len - macLen);
            mac = cipher.output.getBytes(macLen);
          } else {
            record.fragment = cipher.output.getBytes();
          }
          record.fragment = forge.util.createBuffer(record.fragment);
          record.length = record.fragment.length();
          var mac2 = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
          s2.updateSequenceNumber();
          rval = compareMacs(s2.macKey, mac, mac2) && rval;
          return rval;
        }
        function compareMacs(key, mac1, mac2) {
          var hmac = forge.hmac.create();
          hmac.start("SHA1", key);
          hmac.update(mac1);
          mac1 = hmac.digest().getBytes();
          hmac.start(null, null);
          hmac.update(mac2);
          mac2 = hmac.digest().getBytes();
          return mac1 === mac2;
        }
      }
    });
    var require_sha5122 = __commonJS2({
      "../../node_modules/node-forge/lib/sha512.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_md2();
        require_util2();
        var sha512 = module2.exports = forge.sha512 = forge.sha512 || {};
        forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
        var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
        sha384.create = function() {
          return sha512.create("SHA-384");
        };
        forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
        forge.sha512.sha256 = forge.sha512.sha256 || {
          create: function() {
            return sha512.create("SHA-512/256");
          }
        };
        forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
        forge.sha512.sha224 = forge.sha512.sha224 || {
          create: function() {
            return sha512.create("SHA-512/224");
          }
        };
        forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
        sha512.create = function(algorithm) {
          if (!_initialized) {
            _init();
          }
          if (typeof algorithm === "undefined") {
            algorithm = "SHA-512";
          }
          if (!(algorithm in _states)) {
            throw new Error("Invalid SHA-512 algorithm: " + algorithm);
          }
          var _state = _states[algorithm];
          var _h = null;
          var _input = forge.util.createBuffer();
          var _w = new Array(80);
          for (var wi = 0; wi < 80; ++wi) {
            _w[wi] = new Array(2);
          }
          var digestLength = 64;
          switch (algorithm) {
            case "SHA-384":
              digestLength = 48;
              break;
            case "SHA-512/256":
              digestLength = 32;
              break;
            case "SHA-512/224":
              digestLength = 28;
              break;
          }
          var md = {
            // SHA-512 => sha512
            algorithm: algorithm.replace("-", "").toLowerCase(),
            blockLength: 128,
            digestLength,
            // 56-bit length of message so far (does not including padding)
            messageLength: 0,
            // true message length
            fullMessageLength: null,
            // size of message length in bytes
            messageLengthSize: 16
          };
          md.start = function() {
            md.messageLength = 0;
            md.fullMessageLength = md.messageLength128 = [];
            var int32s = md.messageLengthSize / 4;
            for (var i2 = 0; i2 < int32s; ++i2) {
              md.fullMessageLength.push(0);
            }
            _input = forge.util.createBuffer();
            _h = new Array(_state.length);
            for (var i2 = 0; i2 < _state.length; ++i2) {
              _h[i2] = _state[i2].slice(0);
            }
            return md;
          };
          md.start();
          md.update = function(msg, encoding) {
            if (encoding === "utf8") {
              msg = forge.util.encodeUtf8(msg);
            }
            var len = msg.length;
            md.messageLength += len;
            len = [len / 4294967296 >>> 0, len >>> 0];
            for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
              md.fullMessageLength[i2] += len[1];
              len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
              md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
              len[0] = len[1] / 4294967296 >>> 0;
            }
            _input.putBytes(msg);
            _update(_h, _w, _input);
            if (_input.read > 2048 || _input.length() === 0) {
              _input.compact();
            }
            return md;
          };
          md.digest = function() {
            var finalBlock = forge.util.createBuffer();
            finalBlock.putBytes(_input.bytes());
            var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
            var overflow = remaining & md.blockLength - 1;
            finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
            var next2, carry;
            var bits2 = md.fullMessageLength[0] * 8;
            for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
              next2 = md.fullMessageLength[i2 + 1] * 8;
              carry = next2 / 4294967296 >>> 0;
              bits2 += carry;
              finalBlock.putInt32(bits2 >>> 0);
              bits2 = next2 >>> 0;
            }
            finalBlock.putInt32(bits2);
            var h = new Array(_h.length);
            for (var i2 = 0; i2 < _h.length; ++i2) {
              h[i2] = _h[i2].slice(0);
            }
            _update(h, _w, finalBlock);
            var rval = forge.util.createBuffer();
            var hlen;
            if (algorithm === "SHA-512") {
              hlen = h.length;
            } else if (algorithm === "SHA-384") {
              hlen = h.length - 2;
            } else {
              hlen = h.length - 4;
            }
            for (var i2 = 0; i2 < hlen; ++i2) {
              rval.putInt32(h[i2][0]);
              if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
                rval.putInt32(h[i2][1]);
              }
            }
            return rval;
          };
          return md;
        };
        var _padding = null;
        var _initialized = false;
        var _k = null;
        var _states = null;
        function _init() {
          _padding = String.fromCharCode(128);
          _padding += forge.util.fillString(String.fromCharCode(0), 128);
          _k = [
            [1116352408, 3609767458],
            [1899447441, 602891725],
            [3049323471, 3964484399],
            [3921009573, 2173295548],
            [961987163, 4081628472],
            [1508970993, 3053834265],
            [2453635748, 2937671579],
            [2870763221, 3664609560],
            [3624381080, 2734883394],
            [310598401, 1164996542],
            [607225278, 1323610764],
            [1426881987, 3590304994],
            [1925078388, 4068182383],
            [2162078206, 991336113],
            [2614888103, 633803317],
            [3248222580, 3479774868],
            [3835390401, 2666613458],
            [4022224774, 944711139],
            [264347078, 2341262773],
            [604807628, 2007800933],
            [770255983, 1495990901],
            [1249150122, 1856431235],
            [1555081692, 3175218132],
            [1996064986, 2198950837],
            [2554220882, 3999719339],
            [2821834349, 766784016],
            [2952996808, 2566594879],
            [3210313671, 3203337956],
            [3336571891, 1034457026],
            [3584528711, 2466948901],
            [113926993, 3758326383],
            [338241895, 168717936],
            [666307205, 1188179964],
            [773529912, 1546045734],
            [1294757372, 1522805485],
            [1396182291, 2643833823],
            [1695183700, 2343527390],
            [1986661051, 1014477480],
            [2177026350, 1206759142],
            [2456956037, 344077627],
            [2730485921, 1290863460],
            [2820302411, 3158454273],
            [3259730800, 3505952657],
            [3345764771, 106217008],
            [3516065817, 3606008344],
            [3600352804, 1432725776],
            [4094571909, 1467031594],
            [275423344, 851169720],
            [430227734, 3100823752],
            [506948616, 1363258195],
            [659060556, 3750685593],
            [883997877, 3785050280],
            [958139571, 3318307427],
            [1322822218, 3812723403],
            [1537002063, 2003034995],
            [1747873779, 3602036899],
            [1955562222, 1575990012],
            [2024104815, 1125592928],
            [2227730452, 2716904306],
            [2361852424, 442776044],
            [2428436474, 593698344],
            [2756734187, 3733110249],
            [3204031479, 2999351573],
            [3329325298, 3815920427],
            [3391569614, 3928383900],
            [3515267271, 566280711],
            [3940187606, 3454069534],
            [4118630271, 4000239992],
            [116418474, 1914138554],
            [174292421, 2731055270],
            [289380356, 3203993006],
            [460393269, 320620315],
            [685471733, 587496836],
            [852142971, 1086792851],
            [1017036298, 365543100],
            [1126000580, 2618297676],
            [1288033470, 3409855158],
            [1501505948, 4234509866],
            [1607167915, 987167468],
            [1816402316, 1246189591]
          ];
          _states = {};
          _states["SHA-512"] = [
            [1779033703, 4089235720],
            [3144134277, 2227873595],
            [1013904242, 4271175723],
            [2773480762, 1595750129],
            [1359893119, 2917565137],
            [2600822924, 725511199],
            [528734635, 4215389547],
            [1541459225, 327033209]
          ];
          _states["SHA-384"] = [
            [3418070365, 3238371032],
            [1654270250, 914150663],
            [2438529370, 812702999],
            [355462360, 4144912697],
            [1731405415, 4290775857],
            [2394180231, 1750603025],
            [3675008525, 1694076839],
            [1203062813, 3204075428]
          ];
          _states["SHA-512/256"] = [
            [573645204, 4230739756],
            [2673172387, 3360449730],
            [596883563, 1867755857],
            [2520282905, 1497426621],
            [2519219938, 2827943907],
            [3193839141, 1401305490],
            [721525244, 746961066],
            [246885852, 2177182882]
          ];
          _states["SHA-512/224"] = [
            [2352822216, 424955298],
            [1944164710, 2312950998],
            [502970286, 855612546],
            [1738396948, 1479516111],
            [258812777, 2077511080],
            [2011393907, 79989058],
            [1067287976, 1780299464],
            [286451373, 2446758561]
          ];
          _initialized = true;
        }
        function _update(s2, w2, bytes) {
          var t1_hi, t1_lo;
          var t2_hi, t2_lo;
          var s0_hi, s0_lo;
          var s1_hi, s1_lo;
          var ch_hi, ch_lo;
          var maj_hi, maj_lo;
          var a_hi, a_lo;
          var b_hi, b_lo;
          var c_hi, c_lo;
          var d_hi, d_lo;
          var e_hi, e_lo;
          var f_hi, f_lo;
          var g_hi, g_lo;
          var h_hi, h_lo;
          var i2, hi, lo, w22, w7, w15, w16;
          var len = bytes.length();
          while (len >= 128) {
            for (i2 = 0; i2 < 16; ++i2) {
              w2[i2][0] = bytes.getInt32() >>> 0;
              w2[i2][1] = bytes.getInt32() >>> 0;
            }
            for (; i2 < 80; ++i2) {
              w22 = w2[i2 - 2];
              hi = w22[0];
              lo = w22[1];
              t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
              (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
              hi >>> 6) >>> 0;
              t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
              (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
              (hi << 26 | lo >>> 6)) >>> 0;
              w15 = w2[i2 - 15];
              hi = w15[0];
              lo = w15[1];
              t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
              (hi >>> 8 | lo << 24) ^ // ROTR 8
              hi >>> 7) >>> 0;
              t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
              (hi << 24 | lo >>> 8) ^ // ROTR 8
              (hi << 25 | lo >>> 7)) >>> 0;
              w7 = w2[i2 - 7];
              w16 = w2[i2 - 16];
              lo = t1_lo + w7[1] + t2_lo + w16[1];
              w2[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
              w2[i2][1] = lo >>> 0;
            }
            a_hi = s2[0][0];
            a_lo = s2[0][1];
            b_hi = s2[1][0];
            b_lo = s2[1][1];
            c_hi = s2[2][0];
            c_lo = s2[2][1];
            d_hi = s2[3][0];
            d_lo = s2[3][1];
            e_hi = s2[4][0];
            e_lo = s2[4][1];
            f_hi = s2[5][0];
            f_lo = s2[5][1];
            g_hi = s2[6][0];
            g_lo = s2[6][1];
            h_hi = s2[7][0];
            h_lo = s2[7][1];
            for (i2 = 0; i2 < 80; ++i2) {
              s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
              (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
              (e_lo >>> 9 | e_hi << 23)) >>> 0;
              s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
              (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
              (e_lo << 23 | e_hi >>> 9)) >>> 0;
              ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
              ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
              s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
              (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo >>> 7 | a_hi << 25)) >>> 0;
              s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
              (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
              (a_lo << 25 | a_hi >>> 7)) >>> 0;
              maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
              maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
              lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w2[i2][1];
              t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w2[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
              t1_lo = lo >>> 0;
              lo = s0_lo + maj_lo;
              t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
              t2_lo = lo >>> 0;
              h_hi = g_hi;
              h_lo = g_lo;
              g_hi = f_hi;
              g_lo = f_lo;
              f_hi = e_hi;
              f_lo = e_lo;
              lo = d_lo + t1_lo;
              e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
              e_lo = lo >>> 0;
              d_hi = c_hi;
              d_lo = c_lo;
              c_hi = b_hi;
              c_lo = b_lo;
              b_hi = a_hi;
              b_lo = a_lo;
              lo = t1_lo + t2_lo;
              a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
              a_lo = lo >>> 0;
            }
            lo = s2[0][1] + a_lo;
            s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[0][1] = lo >>> 0;
            lo = s2[1][1] + b_lo;
            s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[1][1] = lo >>> 0;
            lo = s2[2][1] + c_lo;
            s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[2][1] = lo >>> 0;
            lo = s2[3][1] + d_lo;
            s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[3][1] = lo >>> 0;
            lo = s2[4][1] + e_lo;
            s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[4][1] = lo >>> 0;
            lo = s2[5][1] + f_lo;
            s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[5][1] = lo >>> 0;
            lo = s2[6][1] + g_lo;
            s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[6][1] = lo >>> 0;
            lo = s2[7][1] + h_lo;
            s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
            s2[7][1] = lo >>> 0;
            len -= 128;
          }
        }
      }
    });
    var require_asn1_validator2 = __commonJS2({
      "../../node_modules/node-forge/lib/asn1-validator.js"(exports2) {
        "use strict";
        var forge = require_forge2();
        require_asn12();
        var asn1 = forge.asn1;
        exports2.privateKeyValidator = {
          // PrivateKeyInfo
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // Version (INTEGER)
            name: "PrivateKeyInfo.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "privateKeyVersion"
          }, {
            // privateKeyAlgorithm
            name: "PrivateKeyInfo.privateKeyAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "privateKeyOid"
            }]
          }, {
            // PrivateKey
            name: "PrivateKeyInfo",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "privateKey"
          }]
        };
        exports2.publicKeyValidator = {
          name: "SubjectPublicKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "subjectPublicKeyInfo",
          value: [
            {
              name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "AlgorithmIdentifier.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "publicKeyOid"
              }]
            },
            // capture group for ed25519PublicKey
            {
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              composed: true,
              captureBitStringValue: "ed25519PublicKey"
            }
            // FIXME: this is capture group for rsaPublicKey, use it in this API or
            // discard?
            /* {
              // subjectPublicKey
              name: 'SubjectPublicKeyInfo.subjectPublicKey',
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              value: [{
                // RSAPublicKey
                name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                optional: true,
                captureAsn1: 'rsaPublicKey'
              }]
            } */
          ]
        };
      }
    });
    var require_ed255192 = __commonJS2({
      "../../node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_jsbn2();
        require_random2();
        require_sha5122();
        require_util2();
        var asn1Validator = require_asn1_validator2();
        var publicKeyValidator = asn1Validator.publicKeyValidator;
        var privateKeyValidator = asn1Validator.privateKeyValidator;
        if (typeof BigInteger === "undefined") {
          BigInteger = forge.jsbn.BigInteger;
        }
        var BigInteger;
        var ByteBuffer = forge.util.ByteBuffer;
        var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
        forge.pki = forge.pki || {};
        module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
        var ed25519 = forge.ed25519;
        ed25519.constants = {};
        ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
        ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
        ed25519.constants.SEED_BYTE_LENGTH = 32;
        ed25519.constants.SIGN_BYTE_LENGTH = 64;
        ed25519.constants.HASH_BYTE_LENGTH = 64;
        ed25519.generateKeyPair = function(options) {
          options = options || {};
          var seed = options.seed;
          if (seed === void 0) {
            seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
          } else if (typeof seed === "string") {
            if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
              throw new TypeError(
                '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
              );
            }
          } else if (!(seed instanceof Uint8Array)) {
            throw new TypeError(
              '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
            );
          }
          seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
          for (var i2 = 0; i2 < 32; ++i2) {
            sk[i2] = seed[i2];
          }
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, privateKey: sk };
        };
        ed25519.privateKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge.asn1.derToOid(capture.privateKeyOid);
          var ed25519Oid = forge.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var privateKey = capture.privateKey;
          var privateKeyBytes = messageToNativeBuffer({
            message: forge.asn1.fromDer(privateKey).value,
            encoding: "binary"
          });
          return { privateKeyBytes };
        };
        ed25519.publicKeyFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
          if (!valid) {
            var error = new Error("Invalid Key.");
            error.errors = errors;
            throw error;
          }
          var oid = forge.asn1.derToOid(capture.publicKeyOid);
          var ed25519Oid = forge.oids.EdDSA25519;
          if (oid !== ed25519Oid) {
            throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
          }
          var publicKeyBytes = capture.ed25519PublicKey;
          if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new Error("Key length is invalid.");
          }
          return messageToNativeBuffer({
            message: publicKeyBytes,
            encoding: "binary"
          });
        };
        ed25519.publicKeyFromPrivateKey = function(options) {
          options = options || {};
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
          for (var i2 = 0; i2 < pk.length; ++i2) {
            pk[i2] = privateKey[32 + i2];
          }
          return pk;
        };
        ed25519.sign = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          var privateKey = messageToNativeBuffer({
            message: options.privateKey,
            encoding: "binary"
          });
          if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
            var keyPair = ed25519.generateKeyPair({ seed: privateKey });
            privateKey = keyPair.privateKey;
          } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
            );
          }
          var signedMsg = new NativeBuffer(
            ed25519.constants.SIGN_BYTE_LENGTH + msg.length
          );
          crypto_sign(signedMsg, msg, msg.length, privateKey);
          var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
          for (var i2 = 0; i2 < sig.length; ++i2) {
            sig[i2] = signedMsg[i2];
          }
          return sig;
        };
        ed25519.verify = function(options) {
          options = options || {};
          var msg = messageToNativeBuffer(options);
          if (options.signature === void 0) {
            throw new TypeError(
              '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
            );
          }
          var sig = messageToNativeBuffer({
            message: options.signature,
            encoding: "binary"
          });
          if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
            throw new TypeError(
              '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
            );
          }
          var publicKey = messageToNativeBuffer({
            message: options.publicKey,
            encoding: "binary"
          });
          if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
            throw new TypeError(
              '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
            );
          }
          var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var m2 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
          var i2;
          for (i2 = 0; i2 < ed25519.constants.SIGN_BYTE_LENGTH; ++i2) {
            sm[i2] = sig[i2];
          }
          for (i2 = 0; i2 < msg.length; ++i2) {
            sm[i2 + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i2];
          }
          return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
        };
        function messageToNativeBuffer(options) {
          var message = options.message;
          if (message instanceof Uint8Array || message instanceof NativeBuffer) {
            return message;
          }
          var encoding = options.encoding;
          if (message === void 0) {
            if (options.md) {
              message = options.md.digest().getBytes();
              encoding = "binary";
            } else {
              throw new TypeError('"options.message" or "options.md" not specified.');
            }
          }
          if (typeof message === "string" && !encoding) {
            throw new TypeError('"options.encoding" must be "binary" or "utf8".');
          }
          if (typeof message === "string") {
            if (typeof Buffer !== "undefined") {
              return Buffer.from(message, encoding);
            }
            message = new ByteBuffer(message, encoding);
          } else if (!(message instanceof ByteBuffer)) {
            throw new TypeError(
              '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
            );
          }
          var buffer = new NativeBuffer(message.length());
          for (var i2 = 0; i2 < buffer.length; ++i2) {
            buffer[i2] = message.at(i2);
          }
          return buffer;
        }
        var gf0 = gf();
        var gf1 = gf([1]);
        var D2 = gf([
          30883,
          4953,
          19914,
          30187,
          55467,
          16705,
          2637,
          112,
          59544,
          30585,
          16505,
          36039,
          65139,
          11119,
          27886,
          20995
        ]);
        var D22 = gf([
          61785,
          9906,
          39828,
          60374,
          45398,
          33411,
          5274,
          224,
          53552,
          61171,
          33010,
          6542,
          64743,
          22239,
          55772,
          9222
        ]);
        var X2 = gf([
          54554,
          36645,
          11616,
          51542,
          42930,
          38181,
          51040,
          26924,
          56412,
          64982,
          57905,
          49316,
          21502,
          52590,
          14035,
          8553
        ]);
        var Y2 = gf([
          26200,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214,
          26214
        ]);
        var L2 = new Float64Array([
          237,
          211,
          245,
          92,
          26,
          99,
          18,
          88,
          214,
          156,
          247,
          162,
          222,
          249,
          222,
          20,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          16
        ]);
        var I2 = gf([
          41136,
          18958,
          6951,
          50414,
          58488,
          44335,
          6150,
          12099,
          55207,
          15867,
          153,
          11085,
          57099,
          20417,
          9344,
          11139
        ]);
        function sha512(msg, msgLen) {
          var md = forge.md.sha512.create();
          var buffer = new ByteBuffer(msg);
          md.update(buffer.getBytes(msgLen), "binary");
          var hash22 = md.digest().getBytes();
          if (typeof Buffer !== "undefined") {
            return Buffer.from(hash22, "binary");
          }
          var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
          for (var i2 = 0; i2 < 64; ++i2) {
            out[i2] = hash22.charCodeAt(i2);
          }
          return out;
        }
        function crypto_sign_keypair(pk, sk) {
          var p2 = [gf(), gf(), gf(), gf()];
          var i2;
          var d = sha512(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          scalarbase(p2, d);
          pack(pk, p2);
          for (i2 = 0; i2 < 32; ++i2) {
            sk[i2 + 32] = pk[i2];
          }
          return 0;
        }
        function crypto_sign(sm, m2, n, sk) {
          var i2, j2, x2 = new Float64Array(64);
          var p2 = [gf(), gf(), gf(), gf()];
          var d = sha512(sk, 32);
          d[0] &= 248;
          d[31] &= 127;
          d[31] |= 64;
          var smlen = n + 64;
          for (i2 = 0; i2 < n; ++i2) {
            sm[64 + i2] = m2[i2];
          }
          for (i2 = 0; i2 < 32; ++i2) {
            sm[32 + i2] = d[32 + i2];
          }
          var r2 = sha512(sm.subarray(32), n + 32);
          reduce(r2);
          scalarbase(p2, r2);
          pack(sm, p2);
          for (i2 = 32; i2 < 64; ++i2) {
            sm[i2] = sk[i2];
          }
          var h = sha512(sm, n + 64);
          reduce(h);
          for (i2 = 32; i2 < 64; ++i2) {
            x2[i2] = 0;
          }
          for (i2 = 0; i2 < 32; ++i2) {
            x2[i2] = r2[i2];
          }
          for (i2 = 0; i2 < 32; ++i2) {
            for (j2 = 0; j2 < 32; j2++) {
              x2[i2 + j2] += h[i2] * d[j2];
            }
          }
          modL(sm.subarray(32), x2);
          return smlen;
        }
        function crypto_sign_open(m2, sm, n, pk) {
          var i2, mlen;
          var t = new NativeBuffer(32);
          var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
          mlen = -1;
          if (n < 64) {
            return -1;
          }
          if (unpackneg(q2, pk)) {
            return -1;
          }
          for (i2 = 0; i2 < n; ++i2) {
            m2[i2] = sm[i2];
          }
          for (i2 = 0; i2 < 32; ++i2) {
            m2[i2 + 32] = pk[i2];
          }
          var h = sha512(m2, n);
          reduce(h);
          scalarmult(p2, q2, h);
          scalarbase(q2, sm.subarray(32));
          add2(p2, q2);
          pack(t, p2);
          n -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i2 = 0; i2 < n; ++i2) {
              m2[i2] = 0;
            }
            return -1;
          }
          for (i2 = 0; i2 < n; ++i2) {
            m2[i2] = sm[i2 + 64];
          }
          mlen = n;
          return mlen;
        }
        function modL(r2, x2) {
          var carry, i2, j2, k2;
          for (i2 = 63; i2 >= 32; --i2) {
            carry = 0;
            for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
              x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
              carry = x2[j2] + 128 >> 8;
              x2[j2] -= carry * 256;
            }
            x2[j2] += carry;
            x2[i2] = 0;
          }
          carry = 0;
          for (j2 = 0; j2 < 32; ++j2) {
            x2[j2] += carry - (x2[31] >> 4) * L2[j2];
            carry = x2[j2] >> 8;
            x2[j2] &= 255;
          }
          for (j2 = 0; j2 < 32; ++j2) {
            x2[j2] -= carry * L2[j2];
          }
          for (i2 = 0; i2 < 32; ++i2) {
            x2[i2 + 1] += x2[i2] >> 8;
            r2[i2] = x2[i2] & 255;
          }
        }
        function reduce(r2) {
          var x2 = new Float64Array(64);
          for (var i2 = 0; i2 < 64; ++i2) {
            x2[i2] = r2[i2];
            r2[i2] = 0;
          }
          modL(r2, x2);
        }
        function add2(p2, q2) {
          var a2 = gf(), b2 = gf(), c2 = gf(), d = gf(), e2 = gf(), f2 = gf(), g2 = gf(), h = gf(), t = gf();
          Z2(a2, p2[1], p2[0]);
          Z2(t, q2[1], q2[0]);
          M2(a2, a2, t);
          A2(b2, p2[0], p2[1]);
          A2(t, q2[0], q2[1]);
          M2(b2, b2, t);
          M2(c2, p2[3], q2[3]);
          M2(c2, c2, D22);
          M2(d, p2[2], q2[2]);
          A2(d, d, d);
          Z2(e2, b2, a2);
          Z2(f2, d, c2);
          A2(g2, d, c2);
          A2(h, b2, a2);
          M2(p2[0], e2, f2);
          M2(p2[1], h, g2);
          M2(p2[2], g2, f2);
          M2(p2[3], e2, h);
        }
        function cswap(p2, q2, b2) {
          for (var i2 = 0; i2 < 4; ++i2) {
            sel25519(p2[i2], q2[i2], b2);
          }
        }
        function pack(r2, p2) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p2[2]);
          M2(tx, p2[0], zi);
          M2(ty, p2[1], zi);
          pack25519(r2, ty);
          r2[31] ^= par25519(tx) << 7;
        }
        function pack25519(o2, n) {
          var i2, j2, b2;
          var m2 = gf(), t = gf();
          for (i2 = 0; i2 < 16; ++i2) {
            t[i2] = n[i2];
          }
          car25519(t);
          car25519(t);
          car25519(t);
          for (j2 = 0; j2 < 2; ++j2) {
            m2[0] = t[0] - 65517;
            for (i2 = 1; i2 < 15; ++i2) {
              m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
              m2[i2 - 1] &= 65535;
            }
            m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
            b2 = m2[15] >> 16 & 1;
            m2[14] &= 65535;
            sel25519(t, m2, 1 - b2);
          }
          for (i2 = 0; i2 < 16; i2++) {
            o2[2 * i2] = t[i2] & 255;
            o2[2 * i2 + 1] = t[i2] >> 8;
          }
        }
        function unpackneg(r2, p2) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r2[2], gf1);
          unpack25519(r2[1], p2);
          S2(num, r2[1]);
          M2(den, num, D2);
          Z2(num, num, r2[2]);
          A2(den, r2[2], den);
          S2(den2, den);
          S2(den4, den2);
          M2(den6, den4, den2);
          M2(t, den6, num);
          M2(t, t, den);
          pow2523(t, t);
          M2(t, t, num);
          M2(t, t, den);
          M2(t, t, den);
          M2(r2[0], t, den);
          S2(chk, r2[0]);
          M2(chk, chk, den);
          if (neq25519(chk, num)) {
            M2(r2[0], r2[0], I2);
          }
          S2(chk, r2[0]);
          M2(chk, chk, den);
          if (neq25519(chk, num)) {
            return -1;
          }
          if (par25519(r2[0]) === p2[31] >> 7) {
            Z2(r2[0], gf0, r2[0]);
          }
          M2(r2[3], r2[0], r2[1]);
          return 0;
        }
        function unpack25519(o2, n) {
          var i2;
          for (i2 = 0; i2 < 16; ++i2) {
            o2[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
          }
          o2[15] &= 32767;
        }
        function pow2523(o2, i2) {
          var c2 = gf();
          var a2;
          for (a2 = 0; a2 < 16; ++a2) {
            c2[a2] = i2[a2];
          }
          for (a2 = 250; a2 >= 0; --a2) {
            S2(c2, c2);
            if (a2 !== 1) {
              M2(c2, c2, i2);
            }
          }
          for (a2 = 0; a2 < 16; ++a2) {
            o2[a2] = c2[a2];
          }
        }
        function neq25519(a2, b2) {
          var c2 = new NativeBuffer(32);
          var d = new NativeBuffer(32);
          pack25519(c2, a2);
          pack25519(d, b2);
          return crypto_verify_32(c2, 0, d, 0);
        }
        function crypto_verify_32(x2, xi, y2, yi) {
          return vn(x2, xi, y2, yi, 32);
        }
        function vn(x2, xi, y2, yi, n) {
          var i2, d = 0;
          for (i2 = 0; i2 < n; ++i2) {
            d |= x2[xi + i2] ^ y2[yi + i2];
          }
          return (1 & d - 1 >>> 8) - 1;
        }
        function par25519(a2) {
          var d = new NativeBuffer(32);
          pack25519(d, a2);
          return d[0] & 1;
        }
        function scalarmult(p2, q2, s2) {
          var b2, i2;
          set25519(p2[0], gf0);
          set25519(p2[1], gf1);
          set25519(p2[2], gf1);
          set25519(p2[3], gf0);
          for (i2 = 255; i2 >= 0; --i2) {
            b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
            cswap(p2, q2, b2);
            add2(q2, p2);
            add2(p2, p2);
            cswap(p2, q2, b2);
          }
        }
        function scalarbase(p2, s2) {
          var q2 = [gf(), gf(), gf(), gf()];
          set25519(q2[0], X2);
          set25519(q2[1], Y2);
          set25519(q2[2], gf1);
          M2(q2[3], X2, Y2);
          scalarmult(p2, q2, s2);
        }
        function set25519(r2, a2) {
          var i2;
          for (i2 = 0; i2 < 16; i2++) {
            r2[i2] = a2[i2] | 0;
          }
        }
        function inv25519(o2, i2) {
          var c2 = gf();
          var a2;
          for (a2 = 0; a2 < 16; ++a2) {
            c2[a2] = i2[a2];
          }
          for (a2 = 253; a2 >= 0; --a2) {
            S2(c2, c2);
            if (a2 !== 2 && a2 !== 4) {
              M2(c2, c2, i2);
            }
          }
          for (a2 = 0; a2 < 16; ++a2) {
            o2[a2] = c2[a2];
          }
        }
        function car25519(o2) {
          var i2, v2, c2 = 1;
          for (i2 = 0; i2 < 16; ++i2) {
            v2 = o2[i2] + c2 + 65535;
            c2 = Math.floor(v2 / 65536);
            o2[i2] = v2 - c2 * 65536;
          }
          o2[0] += c2 - 1 + 37 * (c2 - 1);
        }
        function sel25519(p2, q2, b2) {
          var t, c2 = ~(b2 - 1);
          for (var i2 = 0; i2 < 16; ++i2) {
            t = c2 & (p2[i2] ^ q2[i2]);
            p2[i2] ^= t;
            q2[i2] ^= t;
          }
        }
        function gf(init2) {
          var i2, r2 = new Float64Array(16);
          if (init2) {
            for (i2 = 0; i2 < init2.length; ++i2) {
              r2[i2] = init2[i2];
            }
          }
          return r2;
        }
        function A2(o2, a2, b2) {
          for (var i2 = 0; i2 < 16; ++i2) {
            o2[i2] = a2[i2] + b2[i2];
          }
        }
        function Z2(o2, a2, b2) {
          for (var i2 = 0; i2 < 16; ++i2) {
            o2[i2] = a2[i2] - b2[i2];
          }
        }
        function S2(o2, a2) {
          M2(o2, a2, a2);
        }
        function M2(o2, a2, b2) {
          var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
          v2 = a2[0];
          t0 += v2 * b0;
          t1 += v2 * b1;
          t2 += v2 * b22;
          t3 += v2 * b3;
          t4 += v2 * b4;
          t5 += v2 * b5;
          t6 += v2 * b6;
          t7 += v2 * b7;
          t8 += v2 * b8;
          t9 += v2 * b9;
          t10 += v2 * b10;
          t11 += v2 * b11;
          t12 += v2 * b12;
          t13 += v2 * b13;
          t14 += v2 * b14;
          t15 += v2 * b15;
          v2 = a2[1];
          t1 += v2 * b0;
          t2 += v2 * b1;
          t3 += v2 * b22;
          t4 += v2 * b3;
          t5 += v2 * b4;
          t6 += v2 * b5;
          t7 += v2 * b6;
          t8 += v2 * b7;
          t9 += v2 * b8;
          t10 += v2 * b9;
          t11 += v2 * b10;
          t12 += v2 * b11;
          t13 += v2 * b12;
          t14 += v2 * b13;
          t15 += v2 * b14;
          t16 += v2 * b15;
          v2 = a2[2];
          t2 += v2 * b0;
          t3 += v2 * b1;
          t4 += v2 * b22;
          t5 += v2 * b3;
          t6 += v2 * b4;
          t7 += v2 * b5;
          t8 += v2 * b6;
          t9 += v2 * b7;
          t10 += v2 * b8;
          t11 += v2 * b9;
          t12 += v2 * b10;
          t13 += v2 * b11;
          t14 += v2 * b12;
          t15 += v2 * b13;
          t16 += v2 * b14;
          t17 += v2 * b15;
          v2 = a2[3];
          t3 += v2 * b0;
          t4 += v2 * b1;
          t5 += v2 * b22;
          t6 += v2 * b3;
          t7 += v2 * b4;
          t8 += v2 * b5;
          t9 += v2 * b6;
          t10 += v2 * b7;
          t11 += v2 * b8;
          t12 += v2 * b9;
          t13 += v2 * b10;
          t14 += v2 * b11;
          t15 += v2 * b12;
          t16 += v2 * b13;
          t17 += v2 * b14;
          t18 += v2 * b15;
          v2 = a2[4];
          t4 += v2 * b0;
          t5 += v2 * b1;
          t6 += v2 * b22;
          t7 += v2 * b3;
          t8 += v2 * b4;
          t9 += v2 * b5;
          t10 += v2 * b6;
          t11 += v2 * b7;
          t12 += v2 * b8;
          t13 += v2 * b9;
          t14 += v2 * b10;
          t15 += v2 * b11;
          t16 += v2 * b12;
          t17 += v2 * b13;
          t18 += v2 * b14;
          t19 += v2 * b15;
          v2 = a2[5];
          t5 += v2 * b0;
          t6 += v2 * b1;
          t7 += v2 * b22;
          t8 += v2 * b3;
          t9 += v2 * b4;
          t10 += v2 * b5;
          t11 += v2 * b6;
          t12 += v2 * b7;
          t13 += v2 * b8;
          t14 += v2 * b9;
          t15 += v2 * b10;
          t16 += v2 * b11;
          t17 += v2 * b12;
          t18 += v2 * b13;
          t19 += v2 * b14;
          t20 += v2 * b15;
          v2 = a2[6];
          t6 += v2 * b0;
          t7 += v2 * b1;
          t8 += v2 * b22;
          t9 += v2 * b3;
          t10 += v2 * b4;
          t11 += v2 * b5;
          t12 += v2 * b6;
          t13 += v2 * b7;
          t14 += v2 * b8;
          t15 += v2 * b9;
          t16 += v2 * b10;
          t17 += v2 * b11;
          t18 += v2 * b12;
          t19 += v2 * b13;
          t20 += v2 * b14;
          t21 += v2 * b15;
          v2 = a2[7];
          t7 += v2 * b0;
          t8 += v2 * b1;
          t9 += v2 * b22;
          t10 += v2 * b3;
          t11 += v2 * b4;
          t12 += v2 * b5;
          t13 += v2 * b6;
          t14 += v2 * b7;
          t15 += v2 * b8;
          t16 += v2 * b9;
          t17 += v2 * b10;
          t18 += v2 * b11;
          t19 += v2 * b12;
          t20 += v2 * b13;
          t21 += v2 * b14;
          t22 += v2 * b15;
          v2 = a2[8];
          t8 += v2 * b0;
          t9 += v2 * b1;
          t10 += v2 * b22;
          t11 += v2 * b3;
          t12 += v2 * b4;
          t13 += v2 * b5;
          t14 += v2 * b6;
          t15 += v2 * b7;
          t16 += v2 * b8;
          t17 += v2 * b9;
          t18 += v2 * b10;
          t19 += v2 * b11;
          t20 += v2 * b12;
          t21 += v2 * b13;
          t22 += v2 * b14;
          t23 += v2 * b15;
          v2 = a2[9];
          t9 += v2 * b0;
          t10 += v2 * b1;
          t11 += v2 * b22;
          t12 += v2 * b3;
          t13 += v2 * b4;
          t14 += v2 * b5;
          t15 += v2 * b6;
          t16 += v2 * b7;
          t17 += v2 * b8;
          t18 += v2 * b9;
          t19 += v2 * b10;
          t20 += v2 * b11;
          t21 += v2 * b12;
          t22 += v2 * b13;
          t23 += v2 * b14;
          t24 += v2 * b15;
          v2 = a2[10];
          t10 += v2 * b0;
          t11 += v2 * b1;
          t12 += v2 * b22;
          t13 += v2 * b3;
          t14 += v2 * b4;
          t15 += v2 * b5;
          t16 += v2 * b6;
          t17 += v2 * b7;
          t18 += v2 * b8;
          t19 += v2 * b9;
          t20 += v2 * b10;
          t21 += v2 * b11;
          t22 += v2 * b12;
          t23 += v2 * b13;
          t24 += v2 * b14;
          t25 += v2 * b15;
          v2 = a2[11];
          t11 += v2 * b0;
          t12 += v2 * b1;
          t13 += v2 * b22;
          t14 += v2 * b3;
          t15 += v2 * b4;
          t16 += v2 * b5;
          t17 += v2 * b6;
          t18 += v2 * b7;
          t19 += v2 * b8;
          t20 += v2 * b9;
          t21 += v2 * b10;
          t22 += v2 * b11;
          t23 += v2 * b12;
          t24 += v2 * b13;
          t25 += v2 * b14;
          t26 += v2 * b15;
          v2 = a2[12];
          t12 += v2 * b0;
          t13 += v2 * b1;
          t14 += v2 * b22;
          t15 += v2 * b3;
          t16 += v2 * b4;
          t17 += v2 * b5;
          t18 += v2 * b6;
          t19 += v2 * b7;
          t20 += v2 * b8;
          t21 += v2 * b9;
          t22 += v2 * b10;
          t23 += v2 * b11;
          t24 += v2 * b12;
          t25 += v2 * b13;
          t26 += v2 * b14;
          t27 += v2 * b15;
          v2 = a2[13];
          t13 += v2 * b0;
          t14 += v2 * b1;
          t15 += v2 * b22;
          t16 += v2 * b3;
          t17 += v2 * b4;
          t18 += v2 * b5;
          t19 += v2 * b6;
          t20 += v2 * b7;
          t21 += v2 * b8;
          t22 += v2 * b9;
          t23 += v2 * b10;
          t24 += v2 * b11;
          t25 += v2 * b12;
          t26 += v2 * b13;
          t27 += v2 * b14;
          t28 += v2 * b15;
          v2 = a2[14];
          t14 += v2 * b0;
          t15 += v2 * b1;
          t16 += v2 * b22;
          t17 += v2 * b3;
          t18 += v2 * b4;
          t19 += v2 * b5;
          t20 += v2 * b6;
          t21 += v2 * b7;
          t22 += v2 * b8;
          t23 += v2 * b9;
          t24 += v2 * b10;
          t25 += v2 * b11;
          t26 += v2 * b12;
          t27 += v2 * b13;
          t28 += v2 * b14;
          t29 += v2 * b15;
          v2 = a2[15];
          t15 += v2 * b0;
          t16 += v2 * b1;
          t17 += v2 * b22;
          t18 += v2 * b3;
          t19 += v2 * b4;
          t20 += v2 * b5;
          t21 += v2 * b6;
          t22 += v2 * b7;
          t23 += v2 * b8;
          t24 += v2 * b9;
          t25 += v2 * b10;
          t26 += v2 * b11;
          t27 += v2 * b12;
          t28 += v2 * b13;
          t29 += v2 * b14;
          t30 += v2 * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c2 = 1;
          v2 = t0 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t0 = v2 - c2 * 65536;
          v2 = t1 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t1 = v2 - c2 * 65536;
          v2 = t2 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t2 = v2 - c2 * 65536;
          v2 = t3 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t3 = v2 - c2 * 65536;
          v2 = t4 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t4 = v2 - c2 * 65536;
          v2 = t5 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t5 = v2 - c2 * 65536;
          v2 = t6 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t6 = v2 - c2 * 65536;
          v2 = t7 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t7 = v2 - c2 * 65536;
          v2 = t8 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t8 = v2 - c2 * 65536;
          v2 = t9 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t9 = v2 - c2 * 65536;
          v2 = t10 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t10 = v2 - c2 * 65536;
          v2 = t11 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t11 = v2 - c2 * 65536;
          v2 = t12 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t12 = v2 - c2 * 65536;
          v2 = t13 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t13 = v2 - c2 * 65536;
          v2 = t14 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t14 = v2 - c2 * 65536;
          v2 = t15 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t15 = v2 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          c2 = 1;
          v2 = t0 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t0 = v2 - c2 * 65536;
          v2 = t1 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t1 = v2 - c2 * 65536;
          v2 = t2 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t2 = v2 - c2 * 65536;
          v2 = t3 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t3 = v2 - c2 * 65536;
          v2 = t4 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t4 = v2 - c2 * 65536;
          v2 = t5 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t5 = v2 - c2 * 65536;
          v2 = t6 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t6 = v2 - c2 * 65536;
          v2 = t7 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t7 = v2 - c2 * 65536;
          v2 = t8 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t8 = v2 - c2 * 65536;
          v2 = t9 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t9 = v2 - c2 * 65536;
          v2 = t10 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t10 = v2 - c2 * 65536;
          v2 = t11 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t11 = v2 - c2 * 65536;
          v2 = t12 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t12 = v2 - c2 * 65536;
          v2 = t13 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t13 = v2 - c2 * 65536;
          v2 = t14 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t14 = v2 - c2 * 65536;
          v2 = t15 + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          t15 = v2 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          o2[0] = t0;
          o2[1] = t1;
          o2[2] = t2;
          o2[3] = t3;
          o2[4] = t4;
          o2[5] = t5;
          o2[6] = t6;
          o2[7] = t7;
          o2[8] = t8;
          o2[9] = t9;
          o2[10] = t10;
          o2[11] = t11;
          o2[12] = t12;
          o2[13] = t13;
          o2[14] = t14;
          o2[15] = t15;
        }
      }
    });
    var require_kem2 = __commonJS2({
      "../../node_modules/node-forge/lib/kem.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        require_random2();
        require_jsbn2();
        module2.exports = forge.kem = forge.kem || {};
        var BigInteger = forge.jsbn.BigInteger;
        forge.kem.rsa = {};
        forge.kem.rsa.create = function(kdf, options) {
          options = options || {};
          var prng = options.prng || forge.random;
          var kem = {};
          kem.encrypt = function(publicKey, keyLength) {
            var byteLength2 = Math.ceil(publicKey.n.bitLength() / 8);
            var r2;
            do {
              r2 = new BigInteger(
                forge.util.bytesToHex(prng.getBytesSync(byteLength2)),
                16
              ).mod(publicKey.n);
            } while (r2.compareTo(BigInteger.ONE) <= 0);
            r2 = forge.util.hexToBytes(r2.toString(16));
            var zeros = byteLength2 - r2.length;
            if (zeros > 0) {
              r2 = forge.util.fillString(String.fromCharCode(0), zeros) + r2;
            }
            var encapsulation = publicKey.encrypt(r2, "NONE");
            var key = kdf.generate(r2, keyLength);
            return { encapsulation, key };
          };
          kem.decrypt = function(privateKey, encapsulation, keyLength) {
            var r2 = privateKey.decrypt(encapsulation, "NONE");
            return kdf.generate(r2, keyLength);
          };
          return kem;
        };
        forge.kem.kdf1 = function(md, digestLength) {
          _createKDF(this, md, 0, digestLength || md.digestLength);
        };
        forge.kem.kdf2 = function(md, digestLength) {
          _createKDF(this, md, 1, digestLength || md.digestLength);
        };
        function _createKDF(kdf, md, counterStart, digestLength) {
          kdf.generate = function(x2, length2) {
            var key = new forge.util.ByteBuffer();
            var k2 = Math.ceil(length2 / digestLength) + counterStart;
            var c2 = new forge.util.ByteBuffer();
            for (var i2 = counterStart; i2 < k2; ++i2) {
              c2.putInt32(i2);
              md.start();
              md.update(x2 + c2.getBytes());
              var hash22 = md.digest();
              key.putBytes(hash22.getBytes(digestLength));
            }
            key.truncate(key.length() - length2);
            return key.getBytes();
          };
        }
      }
    });
    var require_log2 = __commonJS2({
      "../../node_modules/node-forge/lib/log.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_util2();
        module2.exports = forge.log = forge.log || {};
        forge.log.levels = [
          "none",
          "error",
          "warning",
          "info",
          "debug",
          "verbose",
          "max"
        ];
        var sLevelInfo = {};
        var sLoggers = [];
        var sConsoleLogger = null;
        forge.log.LEVEL_LOCKED = 1 << 1;
        forge.log.NO_LEVEL_CHECK = 1 << 2;
        forge.log.INTERPOLATE = 1 << 3;
        for (i2 = 0; i2 < forge.log.levels.length; ++i2) {
          level = forge.log.levels[i2];
          sLevelInfo[level] = {
            index: i2,
            name: level.toUpperCase()
          };
        }
        var level;
        var i2;
        forge.log.logMessage = function(message) {
          var messageLevelIndex = sLevelInfo[message.level].index;
          for (var i22 = 0; i22 < sLoggers.length; ++i22) {
            var logger4 = sLoggers[i22];
            if (logger4.flags & forge.log.NO_LEVEL_CHECK) {
              logger4.f(message);
            } else {
              var loggerLevelIndex = sLevelInfo[logger4.level].index;
              if (messageLevelIndex <= loggerLevelIndex) {
                logger4.f(logger4, message);
              }
            }
          }
        };
        forge.log.prepareStandard = function(message) {
          if (!("standard" in message)) {
            message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
            " [" + message.category + "] " + message.message;
          }
        };
        forge.log.prepareFull = function(message) {
          if (!("full" in message)) {
            var args = [message.message];
            args = args.concat([]);
            message.full = forge.util.format.apply(this, args);
          }
        };
        forge.log.prepareStandardFull = function(message) {
          if (!("standardFull" in message)) {
            forge.log.prepareStandard(message);
            message.standardFull = message.standard;
          }
        };
        if (true) {
          levels = ["error", "warning", "info", "debug", "verbose"];
          for (i2 = 0; i2 < levels.length; ++i2) {
            (function(level2) {
              forge.log[level2] = function(category, message) {
                var args = Array.prototype.slice.call(arguments).slice(2);
                var msg = {
                  timestamp: /* @__PURE__ */ new Date(),
                  level: level2,
                  category,
                  message,
                  "arguments": args
                  /*standard*/
                  /*full*/
                  /*fullMessage*/
                };
                forge.log.logMessage(msg);
              };
            })(levels[i2]);
          }
        }
        var levels;
        var i2;
        forge.log.makeLogger = function(logFunction) {
          var logger4 = {
            flags: 0,
            f: logFunction
          };
          forge.log.setLevel(logger4, "none");
          return logger4;
        };
        forge.log.setLevel = function(logger4, level2) {
          var rval = false;
          if (logger4 && !(logger4.flags & forge.log.LEVEL_LOCKED)) {
            for (var i22 = 0; i22 < forge.log.levels.length; ++i22) {
              var aValidLevel = forge.log.levels[i22];
              if (level2 == aValidLevel) {
                logger4.level = level2;
                rval = true;
                break;
              }
            }
          }
          return rval;
        };
        forge.log.lock = function(logger4, lock2) {
          if (typeof lock2 === "undefined" || lock2) {
            logger4.flags |= forge.log.LEVEL_LOCKED;
          } else {
            logger4.flags &= ~forge.log.LEVEL_LOCKED;
          }
        };
        forge.log.addLogger = function(logger4) {
          sLoggers.push(logger4);
        };
        if (typeof console !== "undefined" && "log" in console) {
          if (console.error && console.warn && console.info && console.debug) {
            levelHandlers = {
              error: console.error,
              warning: console.warn,
              info: console.info,
              debug: console.debug,
              verbose: console.debug
            };
            f2 = function(logger4, message) {
              forge.log.prepareStandard(message);
              var handler = levelHandlers[message.level];
              var args = [message.standard];
              args = args.concat(message["arguments"].slice());
              handler.apply(console, args);
            };
            logger3 = forge.log.makeLogger(f2);
          } else {
            f2 = function(logger4, message) {
              forge.log.prepareStandardFull(message);
              console.log(message.standardFull);
            };
            logger3 = forge.log.makeLogger(f2);
          }
          forge.log.setLevel(logger3, "debug");
          forge.log.addLogger(logger3);
          sConsoleLogger = logger3;
        } else {
          console = {
            log: function() {
            }
          };
        }
        var logger3;
        var levelHandlers;
        var f2;
        if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
          query = new URL(window.location.href).searchParams;
          if (query.has("console.level")) {
            forge.log.setLevel(
              sConsoleLogger,
              query.get("console.level").slice(-1)[0]
            );
          }
          if (query.has("console.lock")) {
            lock = query.get("console.lock").slice(-1)[0];
            if (lock == "true") {
              forge.log.lock(sConsoleLogger);
            }
          }
        }
        var query;
        var lock;
        forge.log.consoleLogger = sConsoleLogger;
      }
    });
    var require_md_all2 = __commonJS2({
      "../../node_modules/node-forge/lib/md.all.js"(exports2, module2) {
        "use strict";
        module2.exports = require_md2();
        require_md53();
        require_sha13();
        require_sha2562();
        require_sha5122();
      }
    });
    var require_pkcs72 = __commonJS2({
      "../../node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_asn12();
        require_des2();
        require_oids2();
        require_pem2();
        require_pkcs7asn12();
        require_random2();
        require_util2();
        require_x5092();
        var asn1 = forge.asn1;
        var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
        p7.messageFromPem = function(pem) {
          var msg = forge.pem.decode(pem)[0];
          if (msg.type !== "PKCS7") {
            var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
            error.headerType = msg.type;
            throw error;
          }
          if (msg.procType && msg.procType.type === "ENCRYPTED") {
            throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
          }
          var obj = asn1.fromDer(msg.body);
          return p7.messageFromAsn1(obj);
        };
        p7.messageToPem = function(msg, maxline) {
          var pemObj = {
            type: "PKCS7",
            body: asn1.toDer(msg.toAsn1()).getBytes()
          };
          return forge.pem.encode(pemObj, { maxline });
        };
        p7.messageFromAsn1 = function(obj) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
            error.errors = errors;
            throw error;
          }
          var contentType = asn1.derToOid(capture.contentType);
          var msg;
          switch (contentType) {
            case forge.pki.oids.envelopedData:
              msg = p7.createEnvelopedData();
              break;
            case forge.pki.oids.encryptedData:
              msg = p7.createEncryptedData();
              break;
            case forge.pki.oids.signedData:
              msg = p7.createSignedData();
              break;
            default:
              throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
          }
          msg.fromAsn1(capture.content.value[0]);
          return msg;
        };
        p7.createSignedData = function() {
          var msg = null;
          msg = {
            type: forge.pki.oids.signedData,
            version: 1,
            certificates: [],
            crls: [],
            // TODO: add json-formatted signer stuff here?
            signers: [],
            // populated during sign()
            digestAlgorithmIdentifiers: [],
            contentInfo: null,
            signerInfos: [],
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
              msg.certificates = [];
              msg.crls = [];
              msg.digestAlgorithmIdentifiers = [];
              msg.contentInfo = null;
              msg.signerInfos = [];
              if (msg.rawCapture.certificates) {
                var certs = msg.rawCapture.certificates.value;
                for (var i2 = 0; i2 < certs.length; ++i2) {
                  msg.certificates.push(forge.pki.certificateFromAsn1(certs[i2]));
                }
              }
            },
            toAsn1: function() {
              if (!msg.contentInfo) {
                msg.sign();
              }
              var certs = [];
              for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
                certs.push(forge.pki.certificateToAsn1(msg.certificates[i2]));
              }
              var crls = [];
              var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // Version
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.INTEGER,
                    false,
                    asn1.integerToDer(msg.version).getBytes()
                  ),
                  // DigestAlgorithmIdentifiers
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.SET,
                    true,
                    msg.digestAlgorithmIdentifiers
                  ),
                  // ContentInfo
                  msg.contentInfo
                ])
              ]);
              if (certs.length > 0) {
                signedData.value[0].value.push(
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
                );
              }
              if (crls.length > 0) {
                signedData.value[0].value.push(
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
                );
              }
              signedData.value[0].value.push(
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  msg.signerInfos
                )
              );
              return asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SEQUENCE,
                true,
                [
                  // ContentType
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(msg.type).getBytes()
                  ),
                  // [0] SignedData
                  signedData
                ]
              );
            },
            /**
             * Add (another) entity to list of signers.
             *
             * Note: If authenticatedAttributes are provided, then, per RFC 2315,
             * they must include at least two attributes: content type and
             * message digest. The message digest attribute value will be
             * auto-calculated during signing and will be ignored if provided.
             *
             * Here's an example of providing these two attributes:
             *
             * forge.pkcs7.createSignedData();
             * p7.addSigner({
             *   issuer: cert.issuer.attributes,
             *   serialNumber: cert.serialNumber,
             *   key: privateKey,
             *   digestAlgorithm: forge.pki.oids.sha1,
             *   authenticatedAttributes: [{
             *     type: forge.pki.oids.contentType,
             *     value: forge.pki.oids.data
             *   }, {
             *     type: forge.pki.oids.messageDigest
             *   }]
             * });
             *
             * TODO: Support [subjectKeyIdentifier] as signer's ID.
             *
             * @param signer the signer information:
             *          key the signer's private key.
             *          [certificate] a certificate containing the public key
             *            associated with the signer's private key; use this option as
             *            an alternative to specifying signer.issuer and
             *            signer.serialNumber.
             *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
             *          [serialNumber] the signer's certificate's serial number in
             *           hexadecimal (eg: cert.serialNumber).
             *          [digestAlgorithm] the message digest OID, as a string, to use
             *            (eg: forge.pki.oids.sha1).
             *          [authenticatedAttributes] an optional array of attributes
             *            to also sign along with the content.
             */
            addSigner: function(signer) {
              var issuer = signer.issuer;
              var serialNumber = signer.serialNumber;
              if (signer.certificate) {
                var cert = signer.certificate;
                if (typeof cert === "string") {
                  cert = forge.pki.certificateFromPem(cert);
                }
                issuer = cert.issuer.attributes;
                serialNumber = cert.serialNumber;
              }
              var key = signer.key;
              if (!key) {
                throw new Error(
                  "Could not add PKCS#7 signer; no private key specified."
                );
              }
              if (typeof key === "string") {
                key = forge.pki.privateKeyFromPem(key);
              }
              var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
              switch (digestAlgorithm) {
                case forge.pki.oids.sha1:
                case forge.pki.oids.sha256:
                case forge.pki.oids.sha384:
                case forge.pki.oids.sha512:
                case forge.pki.oids.md5:
                  break;
                default:
                  throw new Error(
                    "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
                  );
              }
              var authenticatedAttributes = signer.authenticatedAttributes || [];
              if (authenticatedAttributes.length > 0) {
                var contentType = false;
                var messageDigest = false;
                for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
                  var attr = authenticatedAttributes[i2];
                  if (!contentType && attr.type === forge.pki.oids.contentType) {
                    contentType = true;
                    if (messageDigest) {
                      break;
                    }
                    continue;
                  }
                  if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                    messageDigest = true;
                    if (contentType) {
                      break;
                    }
                    continue;
                  }
                }
                if (!contentType || !messageDigest) {
                  throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
                }
              }
              msg.signers.push({
                key,
                version: 1,
                issuer,
                serialNumber,
                digestAlgorithm,
                signatureAlgorithm: forge.pki.oids.rsaEncryption,
                signature: null,
                authenticatedAttributes,
                unauthenticatedAttributes: []
              });
            },
            /**
             * Signs the content.
             * @param options Options to apply when signing:
             *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
             */
            sign: function(options) {
              options = options || {};
              if (typeof msg.content !== "object" || msg.contentInfo === null) {
                msg.contentInfo = asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  [
                    // ContentType
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OID,
                      false,
                      asn1.oidToDer(forge.pki.oids.data).getBytes()
                    )
                  ]
                );
                if ("content" in msg) {
                  var content;
                  if (msg.content instanceof forge.util.ByteBuffer) {
                    content = msg.content.bytes();
                  } else if (typeof msg.content === "string") {
                    content = forge.util.encodeUtf8(msg.content);
                  }
                  if (options.detached) {
                    msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
                  } else {
                    msg.contentInfo.value.push(
                      // [0] EXPLICIT content
                      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                        asn1.create(
                          asn1.Class.UNIVERSAL,
                          asn1.Type.OCTETSTRING,
                          false,
                          content
                        )
                      ])
                    );
                  }
                }
              }
              if (msg.signers.length === 0) {
                return;
              }
              var mds = addDigestAlgorithmIds();
              addSignerInfos(mds);
            },
            verify: function() {
              throw new Error("PKCS#7 signature verification not yet implemented.");
            },
            /**
             * Add a certificate.
             *
             * @param cert the certificate to add.
             */
            addCertificate: function(cert) {
              if (typeof cert === "string") {
                cert = forge.pki.certificateFromPem(cert);
              }
              msg.certificates.push(cert);
            },
            /**
             * Add a certificate revokation list.
             *
             * @param crl the certificate revokation list to add.
             */
            addCertificateRevokationList: function(crl) {
              throw new Error("PKCS#7 CRL support not yet implemented.");
            }
          };
          return msg;
          function addDigestAlgorithmIds() {
            var mds = {};
            for (var i2 = 0; i2 < msg.signers.length; ++i2) {
              var signer = msg.signers[i2];
              var oid = signer.digestAlgorithm;
              if (!(oid in mds)) {
                mds[oid] = forge.md[forge.pki.oids[oid]].create();
              }
              if (signer.authenticatedAttributes.length === 0) {
                signer.md = mds[oid];
              } else {
                signer.md = forge.md[forge.pki.oids[oid]].create();
              }
            }
            msg.digestAlgorithmIdentifiers = [];
            for (var oid in mds) {
              msg.digestAlgorithmIdentifiers.push(
                // AlgorithmIdentifier
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  // algorithm
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(oid).getBytes()
                  ),
                  // parameters (null)
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              );
            }
            return mds;
          }
          function addSignerInfos(mds) {
            var content;
            if (msg.detachedContent) {
              content = msg.detachedContent;
            } else {
              content = msg.contentInfo.value[1];
              content = content.value[0];
            }
            if (!content) {
              throw new Error(
                "Could not sign PKCS#7 message; there is no content to sign."
              );
            }
            var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
            var bytes = asn1.toDer(content);
            bytes.getByte();
            asn1.getBerValueLength(bytes);
            bytes = bytes.getBytes();
            for (var oid in mds) {
              mds[oid].start().update(bytes);
            }
            var signingTime = /* @__PURE__ */ new Date();
            for (var i2 = 0; i2 < msg.signers.length; ++i2) {
              var signer = msg.signers[i2];
              if (signer.authenticatedAttributes.length === 0) {
                if (contentType !== forge.pki.oids.data) {
                  throw new Error(
                    "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
                  );
                }
              } else {
                signer.authenticatedAttributesAsn1 = asn1.create(
                  asn1.Class.CONTEXT_SPECIFIC,
                  0,
                  true,
                  []
                );
                var attrsAsn1 = asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  []
                );
                for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
                  var attr = signer.authenticatedAttributes[ai];
                  if (attr.type === forge.pki.oids.messageDigest) {
                    attr.value = mds[signer.digestAlgorithm].digest();
                  } else if (attr.type === forge.pki.oids.signingTime) {
                    if (!attr.value) {
                      attr.value = signingTime;
                    }
                  }
                  attrsAsn1.value.push(_attributeToAsn1(attr));
                  signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
                }
                bytes = asn1.toDer(attrsAsn1).getBytes();
                signer.md.start().update(bytes);
              }
              signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
            }
            msg.signerInfos = _signersToAsn1(msg.signers);
          }
        };
        p7.createEncryptedData = function() {
          var msg = null;
          msg = {
            type: forge.pki.oids.encryptedData,
            version: 0,
            encryptedContent: {
              algorithm: forge.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EncryptedData content block (in ASN.1 format)
             *
             * @param obj The ASN.1 representation of the EncryptedData content block
             */
            fromAsn1: function(obj) {
              _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
            },
            /**
             * Decrypt encrypted content
             *
             * @param key The (symmetric) key as a byte buffer
             */
            decrypt: function(key) {
              if (key !== void 0) {
                msg.encryptedContent.key = key;
              }
              _decryptContent(msg);
            }
          };
          return msg;
        };
        p7.createEnvelopedData = function() {
          var msg = null;
          msg = {
            type: forge.pki.oids.envelopedData,
            version: 0,
            recipients: [],
            encryptedContent: {
              algorithm: forge.pki.oids["aes256-CBC"]
            },
            /**
             * Reads an EnvelopedData content block (in ASN.1 format)
             *
             * @param obj the ASN.1 representation of the EnvelopedData content block.
             */
            fromAsn1: function(obj) {
              var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
              msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
            },
            toAsn1: function() {
              return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(msg.type).getBytes()
                ),
                // [0] EnvelopedData
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    // Version
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.INTEGER,
                      false,
                      asn1.integerToDer(msg.version).getBytes()
                    ),
                    // RecipientInfos
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.SET,
                      true,
                      _recipientsToAsn1(msg.recipients)
                    ),
                    // EncryptedContentInfo
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.SEQUENCE,
                      true,
                      _encryptedContentToAsn1(msg.encryptedContent)
                    )
                  ])
                ])
              ]);
            },
            /**
             * Find recipient by X.509 certificate's issuer.
             *
             * @param cert the certificate with the issuer to look for.
             *
             * @return the recipient object.
             */
            findRecipient: function(cert) {
              var sAttr = cert.issuer.attributes;
              for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
                var r2 = msg.recipients[i2];
                var rAttr = r2.issuer;
                if (r2.serialNumber !== cert.serialNumber) {
                  continue;
                }
                if (rAttr.length !== sAttr.length) {
                  continue;
                }
                var match2 = true;
                for (var j2 = 0; j2 < sAttr.length; ++j2) {
                  if (rAttr[j2].type !== sAttr[j2].type || rAttr[j2].value !== sAttr[j2].value) {
                    match2 = false;
                    break;
                  }
                }
                if (match2) {
                  return r2;
                }
              }
              return null;
            },
            /**
             * Decrypt enveloped content
             *
             * @param recipient The recipient object related to the private key
             * @param privKey The (RSA) private key object
             */
            decrypt: function(recipient, privKey) {
              if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
                switch (recipient.encryptedContent.algorithm) {
                  case forge.pki.oids.rsaEncryption:
                  case forge.pki.oids.desCBC:
                    var key = privKey.decrypt(recipient.encryptedContent.content);
                    msg.encryptedContent.key = forge.util.createBuffer(key);
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
              _decryptContent(msg);
            },
            /**
             * Add (another) entity to list of recipients.
             *
             * @param cert The certificate of the entity to add.
             */
            addRecipient: function(cert) {
              msg.recipients.push({
                version: 0,
                issuer: cert.issuer.attributes,
                serialNumber: cert.serialNumber,
                encryptedContent: {
                  // We simply assume rsaEncryption here, since forge.pki only
                  // supports RSA so far.  If the PKI module supports other
                  // ciphers one day, we need to modify this one as well.
                  algorithm: forge.pki.oids.rsaEncryption,
                  key: cert.publicKey
                }
              });
            },
            /**
             * Encrypt enveloped content.
             *
             * This function supports two optional arguments, cipher and key, which
             * can be used to influence symmetric encryption.  Unless cipher is
             * provided, the cipher specified in encryptedContent.algorithm is used
             * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
             * is (re-)used.  If that one's not set, a random key will be generated
             * automatically.
             *
             * @param [key] The key to be used for symmetric encryption.
             * @param [cipher] The OID of the symmetric cipher to use.
             */
            encrypt: function(key, cipher) {
              if (msg.encryptedContent.content === void 0) {
                cipher = cipher || msg.encryptedContent.algorithm;
                key = key || msg.encryptedContent.key;
                var keyLen, ivLen, ciphFn;
                switch (cipher) {
                  case forge.pki.oids["aes128-CBC"]:
                    keyLen = 16;
                    ivLen = 16;
                    ciphFn = forge.aes.createEncryptionCipher;
                    break;
                  case forge.pki.oids["aes192-CBC"]:
                    keyLen = 24;
                    ivLen = 16;
                    ciphFn = forge.aes.createEncryptionCipher;
                    break;
                  case forge.pki.oids["aes256-CBC"]:
                    keyLen = 32;
                    ivLen = 16;
                    ciphFn = forge.aes.createEncryptionCipher;
                    break;
                  case forge.pki.oids["des-EDE3-CBC"]:
                    keyLen = 24;
                    ivLen = 8;
                    ciphFn = forge.des.createEncryptionCipher;
                    break;
                  default:
                    throw new Error("Unsupported symmetric cipher, OID " + cipher);
                }
                if (key === void 0) {
                  key = forge.util.createBuffer(forge.random.getBytes(keyLen));
                } else if (key.length() != keyLen) {
                  throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
                }
                msg.encryptedContent.algorithm = cipher;
                msg.encryptedContent.key = key;
                msg.encryptedContent.parameter = forge.util.createBuffer(
                  forge.random.getBytes(ivLen)
                );
                var ciph = ciphFn(key);
                ciph.start(msg.encryptedContent.parameter.copy());
                ciph.update(msg.content);
                if (!ciph.finish()) {
                  throw new Error("Symmetric encryption failed.");
                }
                msg.encryptedContent.content = ciph.output;
              }
              for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
                var recipient = msg.recipients[i2];
                if (recipient.encryptedContent.content !== void 0) {
                  continue;
                }
                switch (recipient.encryptedContent.algorithm) {
                  case forge.pki.oids.rsaEncryption:
                    recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                      msg.encryptedContent.key.data
                    );
                    break;
                  default:
                    throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
                }
              }
            }
          };
          return msg;
        };
        function _recipientFromAsn1(obj) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
            error.errors = errors;
            throw error;
          }
          return {
            version: capture.version.charCodeAt(0),
            issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
            serialNumber: forge.util.createBuffer(capture.serial).toHex(),
            encryptedContent: {
              algorithm: asn1.derToOid(capture.encAlgorithm),
              parameter: capture.encParameter ? capture.encParameter.value : void 0,
              content: capture.encKey
            }
          };
        }
        function _recipientToAsn1(obj) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // Version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(obj.version).getBytes()
            ),
            // IssuerAndSerialNumber
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Name
              forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // Serial
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                forge.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // KeyEncryptionAlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
              ),
              // Parameter, force NULL, only RSA supported for now.
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // EncryptedKey
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              obj.encryptedContent.content
            )
          ]);
        }
        function _recipientsFromAsn1(infos) {
          var ret = [];
          for (var i2 = 0; i2 < infos.length; ++i2) {
            ret.push(_recipientFromAsn1(infos[i2]));
          }
          return ret;
        }
        function _recipientsToAsn1(recipients) {
          var ret = [];
          for (var i2 = 0; i2 < recipients.length; ++i2) {
            ret.push(_recipientToAsn1(recipients[i2]));
          }
          return ret;
        }
        function _signerToAsn1(obj) {
          var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(obj.version).getBytes()
            ),
            // issuerAndSerialNumber
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // name
              forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
              // serial
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                forge.util.hexToBytes(obj.serialNumber)
              )
            ]),
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(obj.digestAlgorithm).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          ]);
          if (obj.authenticatedAttributesAsn1) {
            rval.value.push(obj.authenticatedAttributesAsn1);
          }
          rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(obj.signatureAlgorithm).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
          rval.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            obj.signature
          ));
          if (obj.unauthenticatedAttributes.length > 0) {
            var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
            for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
              var attr = obj.unauthenticatedAttributes[i2];
              attrsAsn1.values.push(_attributeToAsn1(attr));
            }
            rval.value.push(attrsAsn1);
          }
          return rval;
        }
        function _signersToAsn1(signers) {
          var ret = [];
          for (var i2 = 0; i2 < signers.length; ++i2) {
            ret.push(_signerToAsn1(signers[i2]));
          }
          return ret;
        }
        function _attributeToAsn1(attr) {
          var value;
          if (attr.type === forge.pki.oids.contentType) {
            value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.value).getBytes()
            );
          } else if (attr.type === forge.pki.oids.messageDigest) {
            value = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              attr.value.bytes()
            );
          } else if (attr.type === forge.pki.oids.signingTime) {
            var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
            var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
            var date = attr.value;
            if (typeof date === "string") {
              var timestamp = Date.parse(date);
              if (!isNaN(timestamp)) {
                date = new Date(timestamp);
              } else if (date.length === 13) {
                date = asn1.utcTimeToDate(date);
              } else {
                date = asn1.generalizedTimeToDate(date);
              }
            }
            if (date >= jan_1_1950 && date < jan_1_2050) {
              value = asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.UTCTIME,
                false,
                asn1.dateToUtcTime(date)
              );
            } else {
              value = asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.GENERALIZEDTIME,
                false,
                asn1.dateToGeneralizedTime(date)
              );
            }
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              // AttributeValue
              value
            ])
          ]);
        }
        function _encryptedContentToAsn1(ec) {
          return [
            // ContentType, always Data for the moment
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(forge.pki.oids.data).getBytes()
            ),
            // ContentEncryptionAlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(ec.algorithm).getBytes()
              ),
              // Parameters (IV)
              !ec.parameter ? void 0 : asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                ec.parameter.getBytes()
              )
            ]),
            // [0] EncryptedContent
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                ec.content.getBytes()
              )
            ])
          ];
        }
        function _fromAsn1(msg, obj, validator) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(obj, validator, capture, errors)) {
            var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
            error.errors = error;
            throw error;
          }
          var contentType = asn1.derToOid(capture.contentType);
          if (contentType !== forge.pki.oids.data) {
            throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
          }
          if (capture.encryptedContent) {
            var content = "";
            if (forge.util.isArray(capture.encryptedContent)) {
              for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
                if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
                }
                content += capture.encryptedContent[i2].value;
              }
            } else {
              content = capture.encryptedContent;
            }
            msg.encryptedContent = {
              algorithm: asn1.derToOid(capture.encAlgorithm),
              parameter: forge.util.createBuffer(capture.encParameter.value),
              content: forge.util.createBuffer(content)
            };
          }
          if (capture.content) {
            var content = "";
            if (forge.util.isArray(capture.content)) {
              for (var i2 = 0; i2 < capture.content.length; ++i2) {
                if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
                  throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
                }
                content += capture.content[i2].value;
              }
            } else {
              content = capture.content;
            }
            msg.content = forge.util.createBuffer(content);
          }
          msg.version = capture.version.charCodeAt(0);
          msg.rawCapture = capture;
          return capture;
        }
        function _decryptContent(msg) {
          if (msg.encryptedContent.key === void 0) {
            throw new Error("Symmetric key not available.");
          }
          if (msg.content === void 0) {
            var ciph;
            switch (msg.encryptedContent.algorithm) {
              case forge.pki.oids["aes128-CBC"]:
              case forge.pki.oids["aes192-CBC"]:
              case forge.pki.oids["aes256-CBC"]:
                ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
                break;
              case forge.pki.oids["desCBC"]:
              case forge.pki.oids["des-EDE3-CBC"]:
                ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
            }
            ciph.start(msg.encryptedContent.parameter);
            ciph.update(msg.encryptedContent.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric decryption failed.");
            }
            msg.content = ciph.output;
          }
        }
      }
    });
    var require_ssh2 = __commonJS2({
      "../../node_modules/node-forge/lib/ssh.js"(exports2, module2) {
        "use strict";
        var forge = require_forge2();
        require_aes2();
        require_hmac2();
        require_md53();
        require_sha13();
        require_util2();
        var ssh = module2.exports = forge.ssh = forge.ssh || {};
        ssh.privateKeyToPutty = function(privateKey, passphrase, comment2) {
          comment2 = comment2 || "";
          passphrase = passphrase || "";
          var algorithm = "ssh-rsa";
          var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
          var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
          ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
          ppk += "Comment: " + comment2 + "\r\n";
          var pubbuffer = forge.util.createBuffer();
          _addStringToBuffer(pubbuffer, algorithm);
          _addBigIntegerToBuffer(pubbuffer, privateKey.e);
          _addBigIntegerToBuffer(pubbuffer, privateKey.n);
          var pub = forge.util.encode64(pubbuffer.bytes(), 64);
          var length2 = Math.floor(pub.length / 66) + 1;
          ppk += "Public-Lines: " + length2 + "\r\n";
          ppk += pub;
          var privbuffer = forge.util.createBuffer();
          _addBigIntegerToBuffer(privbuffer, privateKey.d);
          _addBigIntegerToBuffer(privbuffer, privateKey.p);
          _addBigIntegerToBuffer(privbuffer, privateKey.q);
          _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
          var priv;
          if (!passphrase) {
            priv = forge.util.encode64(privbuffer.bytes(), 64);
          } else {
            var encLen = privbuffer.length() + 16 - 1;
            encLen -= encLen % 16;
            var padding = _sha1(privbuffer.bytes());
            padding.truncate(padding.length() - encLen + privbuffer.length());
            privbuffer.putBuffer(padding);
            var aeskey = forge.util.createBuffer();
            aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
            aeskey.putBuffer(_sha1("\0\0\0", passphrase));
            var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
            cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
            cipher.update(privbuffer.copy());
            cipher.finish();
            var encrypted = cipher.output;
            encrypted.truncate(16);
            priv = forge.util.encode64(encrypted.bytes(), 64);
          }
          length2 = Math.floor(priv.length / 66) + 1;
          ppk += "\r\nPrivate-Lines: " + length2 + "\r\n";
          ppk += priv;
          var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
          var macbuffer = forge.util.createBuffer();
          _addStringToBuffer(macbuffer, algorithm);
          _addStringToBuffer(macbuffer, encryptionAlgorithm);
          _addStringToBuffer(macbuffer, comment2);
          macbuffer.putInt32(pubbuffer.length());
          macbuffer.putBuffer(pubbuffer);
          macbuffer.putInt32(privbuffer.length());
          macbuffer.putBuffer(privbuffer);
          var hmac = forge.hmac.create();
          hmac.start("sha1", mackey);
          hmac.update(macbuffer.bytes());
          ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
          return ppk;
        };
        ssh.publicKeyToOpenSSH = function(key, comment2) {
          var type = "ssh-rsa";
          comment2 = comment2 || "";
          var buffer = forge.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment2;
        };
        ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
          if (!passphrase) {
            return forge.pki.privateKeyToPem(privateKey);
          }
          return forge.pki.encryptRsaPrivateKey(
            privateKey,
            passphrase,
            { legacy: true, algorithm: "aes128" }
          );
        };
        ssh.getPublicKeyFingerprint = function(key, options) {
          options = options || {};
          var md = options.md || forge.md.md5.create();
          var type = "ssh-rsa";
          var buffer = forge.util.createBuffer();
          _addStringToBuffer(buffer, type);
          _addBigIntegerToBuffer(buffer, key.e);
          _addBigIntegerToBuffer(buffer, key.n);
          md.start();
          md.update(buffer.getBytes());
          var digest = md.digest();
          if (options.encoding === "hex") {
            var hex2 = digest.toHex();
            if (options.delimiter) {
              return hex2.match(/.{2}/g).join(options.delimiter);
            }
            return hex2;
          } else if (options.encoding === "binary") {
            return digest.getBytes();
          } else if (options.encoding) {
            throw new Error('Unknown encoding "' + options.encoding + '".');
          }
          return digest;
        };
        function _addBigIntegerToBuffer(buffer, val) {
          var hexVal = val.toString(16);
          if (hexVal[0] >= "8") {
            hexVal = "00" + hexVal;
          }
          var bytes = forge.util.hexToBytes(hexVal);
          buffer.putInt32(bytes.length);
          buffer.putBytes(bytes);
        }
        function _addStringToBuffer(buffer, val) {
          buffer.putInt32(val.length);
          buffer.putString(val);
        }
        function _sha1() {
          var sha = forge.md.sha1.create();
          var num = arguments.length;
          for (var i2 = 0; i2 < num; ++i2) {
            sha.update(arguments[i2]);
          }
          return sha.digest();
        }
      }
    });
    var require_lib3 = __commonJS2({
      "../../node_modules/node-forge/lib/index.js"(exports2, module2) {
        "use strict";
        module2.exports = require_forge2();
        require_aes2();
        require_aesCipherSuites2();
        require_asn12();
        require_cipher2();
        require_des2();
        require_ed255192();
        require_hmac2();
        require_kem2();
        require_log2();
        require_md_all2();
        require_mgf12();
        require_pbkdf22();
        require_pem2();
        require_pkcs13();
        require_pkcs122();
        require_pkcs72();
        require_pki2();
        require_prime2();
        require_prng2();
        require_pss2();
        require_random2();
        require_rc22();
        require_ssh2();
        require_tls2();
        require_util2();
      }
    });
    var require_bn = __commonJS2({
      "../../node_modules/bn.js/lib/bn.js"(exports2, module2) {
        "use strict";
        (function(module3, exports22) {
          "use strict";
          function assert2(val, msg) {
            if (!val)
              throw new Error(msg || "Assertion failed");
          }
          function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
          function BN2(number, base, endian) {
            if (BN2.isBN(number)) {
              return number;
            }
            this.negative = 0;
            this.words = null;
            this.length = 0;
            this.red = null;
            if (number !== null) {
              if (base === "le" || base === "be") {
                endian = base;
                base = 10;
              }
              this._init(number || 0, base || 10, endian || "be");
            }
          }
          if (typeof module3 === "object") {
            module3.exports = BN2;
          } else {
            exports22.BN = BN2;
          }
          BN2.BN = BN2;
          BN2.wordSize = 26;
          var Buffer3;
          try {
            if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
              Buffer3 = window.Buffer;
            } else {
              Buffer3 = (init_dist(), __toCommonJS(dist_exports)).Buffer;
            }
          } catch (e2) {
          }
          BN2.isBN = function isBN(num) {
            if (num instanceof BN2) {
              return true;
            }
            return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
          };
          BN2.max = function max(left, right) {
            if (left.cmp(right) > 0)
              return left;
            return right;
          };
          BN2.min = function min(left, right) {
            if (left.cmp(right) < 0)
              return left;
            return right;
          };
          BN2.prototype._init = function init2(number, base, endian) {
            if (typeof number === "number") {
              return this._initNumber(number, base, endian);
            }
            if (typeof number === "object") {
              return this._initArray(number, base, endian);
            }
            if (base === "hex") {
              base = 16;
            }
            assert2(base === (base | 0) && base >= 2 && base <= 36);
            number = number.toString().replace(/\s+/g, "");
            var start = 0;
            if (number[0] === "-") {
              start++;
              this.negative = 1;
            }
            if (start < number.length) {
              if (base === 16) {
                this._parseHex(number, start, endian);
              } else {
                this._parseBase(number, base, start);
                if (endian === "le") {
                  this._initArray(this.toArray(), base, endian);
                }
              }
            }
          };
          BN2.prototype._initNumber = function _initNumber(number, base, endian) {
            if (number < 0) {
              this.negative = 1;
              number = -number;
            }
            if (number < 67108864) {
              this.words = [number & 67108863];
              this.length = 1;
            } else if (number < 4503599627370496) {
              this.words = [
                number & 67108863,
                number / 67108864 & 67108863
              ];
              this.length = 2;
            } else {
              assert2(number < 9007199254740992);
              this.words = [
                number & 67108863,
                number / 67108864 & 67108863,
                1
              ];
              this.length = 3;
            }
            if (endian !== "le")
              return;
            this._initArray(this.toArray(), base, endian);
          };
          BN2.prototype._initArray = function _initArray(number, base, endian) {
            assert2(typeof number.length === "number");
            if (number.length <= 0) {
              this.words = [0];
              this.length = 1;
              return this;
            }
            this.length = Math.ceil(number.length / 3);
            this.words = new Array(this.length);
            for (var i2 = 0; i2 < this.length; i2++) {
              this.words[i2] = 0;
            }
            var j2, w2;
            var off = 0;
            if (endian === "be") {
              for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
                w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
                this.words[j2] |= w2 << off & 67108863;
                this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
                off += 24;
                if (off >= 26) {
                  off -= 26;
                  j2++;
                }
              }
            } else if (endian === "le") {
              for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
                w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
                this.words[j2] |= w2 << off & 67108863;
                this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
                off += 24;
                if (off >= 26) {
                  off -= 26;
                  j2++;
                }
              }
            }
            return this._strip();
          };
          function parseHex4Bits(string2, index) {
            var c2 = string2.charCodeAt(index);
            if (c2 >= 48 && c2 <= 57) {
              return c2 - 48;
            } else if (c2 >= 65 && c2 <= 70) {
              return c2 - 55;
            } else if (c2 >= 97 && c2 <= 102) {
              return c2 - 87;
            } else {
              assert2(false, "Invalid character in " + string2);
            }
          }
          function parseHexByte(string2, lowerBound, index) {
            var r2 = parseHex4Bits(string2, index);
            if (index - 1 >= lowerBound) {
              r2 |= parseHex4Bits(string2, index - 1) << 4;
            }
            return r2;
          }
          BN2.prototype._parseHex = function _parseHex(number, start, endian) {
            this.length = Math.ceil((number.length - start) / 6);
            this.words = new Array(this.length);
            for (var i2 = 0; i2 < this.length; i2++) {
              this.words[i2] = 0;
            }
            var off = 0;
            var j2 = 0;
            var w2;
            if (endian === "be") {
              for (i2 = number.length - 1; i2 >= start; i2 -= 2) {
                w2 = parseHexByte(number, start, i2) << off;
                this.words[j2] |= w2 & 67108863;
                if (off >= 18) {
                  off -= 18;
                  j2 += 1;
                  this.words[j2] |= w2 >>> 26;
                } else {
                  off += 8;
                }
              }
            } else {
              var parseLength = number.length - start;
              for (i2 = parseLength % 2 === 0 ? start + 1 : start; i2 < number.length; i2 += 2) {
                w2 = parseHexByte(number, start, i2) << off;
                this.words[j2] |= w2 & 67108863;
                if (off >= 18) {
                  off -= 18;
                  j2 += 1;
                  this.words[j2] |= w2 >>> 26;
                } else {
                  off += 8;
                }
              }
            }
            this._strip();
          };
          function parseBase(str, start, end, mul2) {
            var r2 = 0;
            var b2 = 0;
            var len = Math.min(str.length, end);
            for (var i2 = start; i2 < len; i2++) {
              var c2 = str.charCodeAt(i2) - 48;
              r2 *= mul2;
              if (c2 >= 49) {
                b2 = c2 - 49 + 10;
              } else if (c2 >= 17) {
                b2 = c2 - 17 + 10;
              } else {
                b2 = c2;
              }
              assert2(c2 >= 0 && b2 < mul2, "Invalid character");
              r2 += b2;
            }
            return r2;
          }
          BN2.prototype._parseBase = function _parseBase(number, base, start) {
            this.words = [0];
            this.length = 1;
            for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
              limbLen++;
            }
            limbLen--;
            limbPow = limbPow / base | 0;
            var total = number.length - start;
            var mod2 = total % limbLen;
            var end = Math.min(total, total - mod2) + start;
            var word = 0;
            for (var i2 = start; i2 < end; i2 += limbLen) {
              word = parseBase(number, i2, i2 + limbLen, base);
              this.imuln(limbPow);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            if (mod2 !== 0) {
              var pow2 = 1;
              word = parseBase(number, i2, number.length, base);
              for (i2 = 0; i2 < mod2; i2++) {
                pow2 *= base;
              }
              this.imuln(pow2);
              if (this.words[0] + word < 67108864) {
                this.words[0] += word;
              } else {
                this._iaddn(word);
              }
            }
            this._strip();
          };
          BN2.prototype.copy = function copy2(dest) {
            dest.words = new Array(this.length);
            for (var i2 = 0; i2 < this.length; i2++) {
              dest.words[i2] = this.words[i2];
            }
            dest.length = this.length;
            dest.negative = this.negative;
            dest.red = this.red;
          };
          function move(dest, src) {
            dest.words = src.words;
            dest.length = src.length;
            dest.negative = src.negative;
            dest.red = src.red;
          }
          BN2.prototype._move = function _move(dest) {
            move(dest, this);
          };
          BN2.prototype.clone = function clone() {
            var r2 = new BN2(null);
            this.copy(r2);
            return r2;
          };
          BN2.prototype._expand = function _expand(size) {
            while (this.length < size) {
              this.words[this.length++] = 0;
            }
            return this;
          };
          BN2.prototype._strip = function strip() {
            while (this.length > 1 && this.words[this.length - 1] === 0) {
              this.length--;
            }
            return this._normSign();
          };
          BN2.prototype._normSign = function _normSign() {
            if (this.length === 1 && this.words[0] === 0) {
              this.negative = 0;
            }
            return this;
          };
          if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
            try {
              BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect;
            } catch (e2) {
              BN2.prototype.inspect = inspect;
            }
          } else {
            BN2.prototype.inspect = inspect;
          }
          function inspect() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
          }
          var zeros = [
            "",
            "0",
            "00",
            "000",
            "0000",
            "00000",
            "000000",
            "0000000",
            "00000000",
            "000000000",
            "0000000000",
            "00000000000",
            "000000000000",
            "0000000000000",
            "00000000000000",
            "000000000000000",
            "0000000000000000",
            "00000000000000000",
            "000000000000000000",
            "0000000000000000000",
            "00000000000000000000",
            "000000000000000000000",
            "0000000000000000000000",
            "00000000000000000000000",
            "000000000000000000000000",
            "0000000000000000000000000"
          ];
          var groupSizes = [
            0,
            0,
            25,
            16,
            12,
            11,
            10,
            9,
            8,
            8,
            7,
            7,
            7,
            7,
            6,
            6,
            6,
            6,
            6,
            6,
            6,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5,
            5
          ];
          var groupBases = [
            0,
            0,
            33554432,
            43046721,
            16777216,
            48828125,
            60466176,
            40353607,
            16777216,
            43046721,
            1e7,
            19487171,
            35831808,
            62748517,
            7529536,
            11390625,
            16777216,
            24137569,
            34012224,
            47045881,
            64e6,
            4084101,
            5153632,
            6436343,
            7962624,
            9765625,
            11881376,
            14348907,
            17210368,
            20511149,
            243e5,
            28629151,
            33554432,
            39135393,
            45435424,
            52521875,
            60466176
          ];
          BN2.prototype.toString = function toString3(base, padding) {
            base = base || 10;
            padding = padding | 0 || 1;
            var out;
            if (base === 16 || base === "hex") {
              out = "";
              var off = 0;
              var carry = 0;
              for (var i2 = 0; i2 < this.length; i2++) {
                var w2 = this.words[i2];
                var word = ((w2 << off | carry) & 16777215).toString(16);
                carry = w2 >>> 24 - off & 16777215;
                off += 2;
                if (off >= 26) {
                  off -= 26;
                  i2--;
                }
                if (carry !== 0 || i2 !== this.length - 1) {
                  out = zeros[6 - word.length] + word + out;
                } else {
                  out = word + out;
                }
              }
              if (carry !== 0) {
                out = carry.toString(16) + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            if (base === (base | 0) && base >= 2 && base <= 36) {
              var groupSize = groupSizes[base];
              var groupBase = groupBases[base];
              out = "";
              var c2 = this.clone();
              c2.negative = 0;
              while (!c2.isZero()) {
                var r2 = c2.modrn(groupBase).toString(base);
                c2 = c2.idivn(groupBase);
                if (!c2.isZero()) {
                  out = zeros[groupSize - r2.length] + r2 + out;
                } else {
                  out = r2 + out;
                }
              }
              if (this.isZero()) {
                out = "0" + out;
              }
              while (out.length % padding !== 0) {
                out = "0" + out;
              }
              if (this.negative !== 0) {
                out = "-" + out;
              }
              return out;
            }
            assert2(false, "Base should be between 2 and 36");
          };
          BN2.prototype.toNumber = function toNumber2() {
            var ret = this.words[0];
            if (this.length === 2) {
              ret += this.words[1] * 67108864;
            } else if (this.length === 3 && this.words[2] === 1) {
              ret += 4503599627370496 + this.words[1] * 67108864;
            } else if (this.length > 2) {
              assert2(false, "Number can only safely store up to 53 bits");
            }
            return this.negative !== 0 ? -ret : ret;
          };
          BN2.prototype.toJSON = function toJSON() {
            return this.toString(16, 2);
          };
          if (Buffer3) {
            BN2.prototype.toBuffer = function toBuffer(endian, length2) {
              return this.toArrayLike(Buffer3, endian, length2);
            };
          }
          BN2.prototype.toArray = function toArray2(endian, length2) {
            return this.toArrayLike(Array, endian, length2);
          };
          var allocate = function allocate2(ArrayType, size) {
            if (ArrayType.allocUnsafe) {
              return ArrayType.allocUnsafe(size);
            }
            return new ArrayType(size);
          };
          BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
            this._strip();
            var byteLength2 = this.byteLength();
            var reqLength = length2 || Math.max(1, byteLength2);
            assert2(byteLength2 <= reqLength, "byte array longer than desired length");
            assert2(reqLength > 0, "Requested array length <= 0");
            var res = allocate(ArrayType, reqLength);
            var postfix = endian === "le" ? "LE" : "BE";
            this["_toArrayLike" + postfix](res, byteLength2);
            return res;
          };
          BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength2) {
            var position2 = 0;
            var carry = 0;
            for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
              var word = this.words[i2] << shift | carry;
              res[position2++] = word & 255;
              if (position2 < res.length) {
                res[position2++] = word >> 8 & 255;
              }
              if (position2 < res.length) {
                res[position2++] = word >> 16 & 255;
              }
              if (shift === 6) {
                if (position2 < res.length) {
                  res[position2++] = word >> 24 & 255;
                }
                carry = 0;
                shift = 0;
              } else {
                carry = word >>> 24;
                shift += 2;
              }
            }
            if (position2 < res.length) {
              res[position2++] = carry;
              while (position2 < res.length) {
                res[position2++] = 0;
              }
            }
          };
          BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength2) {
            var position2 = res.length - 1;
            var carry = 0;
            for (var i2 = 0, shift = 0; i2 < this.length; i2++) {
              var word = this.words[i2] << shift | carry;
              res[position2--] = word & 255;
              if (position2 >= 0) {
                res[position2--] = word >> 8 & 255;
              }
              if (position2 >= 0) {
                res[position2--] = word >> 16 & 255;
              }
              if (shift === 6) {
                if (position2 >= 0) {
                  res[position2--] = word >> 24 & 255;
                }
                carry = 0;
                shift = 0;
              } else {
                carry = word >>> 24;
                shift += 2;
              }
            }
            if (position2 >= 0) {
              res[position2--] = carry;
              while (position2 >= 0) {
                res[position2--] = 0;
              }
            }
          };
          if (Math.clz32) {
            BN2.prototype._countBits = function _countBits(w2) {
              return 32 - Math.clz32(w2);
            };
          } else {
            BN2.prototype._countBits = function _countBits(w2) {
              var t = w2;
              var r2 = 0;
              if (t >= 4096) {
                r2 += 13;
                t >>>= 13;
              }
              if (t >= 64) {
                r2 += 7;
                t >>>= 7;
              }
              if (t >= 8) {
                r2 += 4;
                t >>>= 4;
              }
              if (t >= 2) {
                r2 += 2;
                t >>>= 2;
              }
              return r2 + t;
            };
          }
          BN2.prototype._zeroBits = function _zeroBits(w2) {
            if (w2 === 0)
              return 26;
            var t = w2;
            var r2 = 0;
            if ((t & 8191) === 0) {
              r2 += 13;
              t >>>= 13;
            }
            if ((t & 127) === 0) {
              r2 += 7;
              t >>>= 7;
            }
            if ((t & 15) === 0) {
              r2 += 4;
              t >>>= 4;
            }
            if ((t & 3) === 0) {
              r2 += 2;
              t >>>= 2;
            }
            if ((t & 1) === 0) {
              r2++;
            }
            return r2;
          };
          BN2.prototype.bitLength = function bitLength2() {
            var w2 = this.words[this.length - 1];
            var hi = this._countBits(w2);
            return (this.length - 1) * 26 + hi;
          };
          function toBitArray(num) {
            var w2 = new Array(num.bitLength());
            for (var bit = 0; bit < w2.length; bit++) {
              var off = bit / 26 | 0;
              var wbit = bit % 26;
              w2[bit] = num.words[off] >>> wbit & 1;
            }
            return w2;
          }
          BN2.prototype.zeroBits = function zeroBits() {
            if (this.isZero())
              return 0;
            var r2 = 0;
            for (var i2 = 0; i2 < this.length; i2++) {
              var b2 = this._zeroBits(this.words[i2]);
              r2 += b2;
              if (b2 !== 26)
                break;
            }
            return r2;
          };
          BN2.prototype.byteLength = function byteLength2() {
            return Math.ceil(this.bitLength() / 8);
          };
          BN2.prototype.toTwos = function toTwos(width) {
            if (this.negative !== 0) {
              return this.abs().inotn(width).iaddn(1);
            }
            return this.clone();
          };
          BN2.prototype.fromTwos = function fromTwos(width) {
            if (this.testn(width - 1)) {
              return this.notn(width).iaddn(1).ineg();
            }
            return this.clone();
          };
          BN2.prototype.isNeg = function isNeg() {
            return this.negative !== 0;
          };
          BN2.prototype.neg = function neg2() {
            return this.clone().ineg();
          };
          BN2.prototype.ineg = function ineg() {
            if (!this.isZero()) {
              this.negative ^= 1;
            }
            return this;
          };
          BN2.prototype.iuor = function iuor(num) {
            while (this.length < num.length) {
              this.words[this.length++] = 0;
            }
            for (var i2 = 0; i2 < num.length; i2++) {
              this.words[i2] = this.words[i2] | num.words[i2];
            }
            return this._strip();
          };
          BN2.prototype.ior = function ior(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuor(num);
          };
          BN2.prototype.or = function or(num) {
            if (this.length > num.length)
              return this.clone().ior(num);
            return num.clone().ior(this);
          };
          BN2.prototype.uor = function uor(num) {
            if (this.length > num.length)
              return this.clone().iuor(num);
            return num.clone().iuor(this);
          };
          BN2.prototype.iuand = function iuand(num) {
            var b2;
            if (this.length > num.length) {
              b2 = num;
            } else {
              b2 = this;
            }
            for (var i2 = 0; i2 < b2.length; i2++) {
              this.words[i2] = this.words[i2] & num.words[i2];
            }
            this.length = b2.length;
            return this._strip();
          };
          BN2.prototype.iand = function iand(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuand(num);
          };
          BN2.prototype.and = function and(num) {
            if (this.length > num.length)
              return this.clone().iand(num);
            return num.clone().iand(this);
          };
          BN2.prototype.uand = function uand(num) {
            if (this.length > num.length)
              return this.clone().iuand(num);
            return num.clone().iuand(this);
          };
          BN2.prototype.iuxor = function iuxor(num) {
            var a2;
            var b2;
            if (this.length > num.length) {
              a2 = this;
              b2 = num;
            } else {
              a2 = num;
              b2 = this;
            }
            for (var i2 = 0; i2 < b2.length; i2++) {
              this.words[i2] = a2.words[i2] ^ b2.words[i2];
            }
            if (this !== a2) {
              for (; i2 < a2.length; i2++) {
                this.words[i2] = a2.words[i2];
              }
            }
            this.length = a2.length;
            return this._strip();
          };
          BN2.prototype.ixor = function ixor(num) {
            assert2((this.negative | num.negative) === 0);
            return this.iuxor(num);
          };
          BN2.prototype.xor = function xor(num) {
            if (this.length > num.length)
              return this.clone().ixor(num);
            return num.clone().ixor(this);
          };
          BN2.prototype.uxor = function uxor(num) {
            if (this.length > num.length)
              return this.clone().iuxor(num);
            return num.clone().iuxor(this);
          };
          BN2.prototype.inotn = function inotn(width) {
            assert2(typeof width === "number" && width >= 0);
            var bytesNeeded = Math.ceil(width / 26) | 0;
            var bitsLeft = width % 26;
            this._expand(bytesNeeded);
            if (bitsLeft > 0) {
              bytesNeeded--;
            }
            for (var i2 = 0; i2 < bytesNeeded; i2++) {
              this.words[i2] = ~this.words[i2] & 67108863;
            }
            if (bitsLeft > 0) {
              this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
            }
            return this._strip();
          };
          BN2.prototype.notn = function notn(width) {
            return this.clone().inotn(width);
          };
          BN2.prototype.setn = function setn(bit, val) {
            assert2(typeof bit === "number" && bit >= 0);
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            this._expand(off + 1);
            if (val) {
              this.words[off] = this.words[off] | 1 << wbit;
            } else {
              this.words[off] = this.words[off] & ~(1 << wbit);
            }
            return this._strip();
          };
          BN2.prototype.iadd = function iadd(num) {
            var r2;
            if (this.negative !== 0 && num.negative === 0) {
              this.negative = 0;
              r2 = this.isub(num);
              this.negative ^= 1;
              return this._normSign();
            } else if (this.negative === 0 && num.negative !== 0) {
              num.negative = 0;
              r2 = this.isub(num);
              num.negative = 1;
              return r2._normSign();
            }
            var a2, b2;
            if (this.length > num.length) {
              a2 = this;
              b2 = num;
            } else {
              a2 = num;
              b2 = this;
            }
            var carry = 0;
            for (var i2 = 0; i2 < b2.length; i2++) {
              r2 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
              this.words[i2] = r2 & 67108863;
              carry = r2 >>> 26;
            }
            for (; carry !== 0 && i2 < a2.length; i2++) {
              r2 = (a2.words[i2] | 0) + carry;
              this.words[i2] = r2 & 67108863;
              carry = r2 >>> 26;
            }
            this.length = a2.length;
            if (carry !== 0) {
              this.words[this.length] = carry;
              this.length++;
            } else if (a2 !== this) {
              for (; i2 < a2.length; i2++) {
                this.words[i2] = a2.words[i2];
              }
            }
            return this;
          };
          BN2.prototype.add = function add2(num) {
            var res;
            if (num.negative !== 0 && this.negative === 0) {
              num.negative = 0;
              res = this.sub(num);
              num.negative ^= 1;
              return res;
            } else if (num.negative === 0 && this.negative !== 0) {
              this.negative = 0;
              res = num.sub(this);
              this.negative = 1;
              return res;
            }
            if (this.length > num.length)
              return this.clone().iadd(num);
            return num.clone().iadd(this);
          };
          BN2.prototype.isub = function isub(num) {
            if (num.negative !== 0) {
              num.negative = 0;
              var r2 = this.iadd(num);
              num.negative = 1;
              return r2._normSign();
            } else if (this.negative !== 0) {
              this.negative = 0;
              this.iadd(num);
              this.negative = 1;
              return this._normSign();
            }
            var cmp = this.cmp(num);
            if (cmp === 0) {
              this.negative = 0;
              this.length = 1;
              this.words[0] = 0;
              return this;
            }
            var a2, b2;
            if (cmp > 0) {
              a2 = this;
              b2 = num;
            } else {
              a2 = num;
              b2 = this;
            }
            var carry = 0;
            for (var i2 = 0; i2 < b2.length; i2++) {
              r2 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
              carry = r2 >> 26;
              this.words[i2] = r2 & 67108863;
            }
            for (; carry !== 0 && i2 < a2.length; i2++) {
              r2 = (a2.words[i2] | 0) + carry;
              carry = r2 >> 26;
              this.words[i2] = r2 & 67108863;
            }
            if (carry === 0 && i2 < a2.length && a2 !== this) {
              for (; i2 < a2.length; i2++) {
                this.words[i2] = a2.words[i2];
              }
            }
            this.length = Math.max(this.length, i2);
            if (a2 !== this) {
              this.negative = 1;
            }
            return this._strip();
          };
          BN2.prototype.sub = function sub2(num) {
            return this.clone().isub(num);
          };
          function smallMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            var len = self2.length + num.length | 0;
            out.length = len;
            len = len - 1 | 0;
            var a2 = self2.words[0] | 0;
            var b2 = num.words[0] | 0;
            var r2 = a2 * b2;
            var lo = r2 & 67108863;
            var carry = r2 / 67108864 | 0;
            out.words[0] = lo;
            for (var k2 = 1; k2 < len; k2++) {
              var ncarry = carry >>> 26;
              var rword = carry & 67108863;
              var maxJ = Math.min(k2, num.length - 1);
              for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
                var i2 = k2 - j2 | 0;
                a2 = self2.words[i2] | 0;
                b2 = num.words[j2] | 0;
                r2 = a2 * b2 + rword;
                ncarry += r2 / 67108864 | 0;
                rword = r2 & 67108863;
              }
              out.words[k2] = rword | 0;
              carry = ncarry | 0;
            }
            if (carry !== 0) {
              out.words[k2] = carry | 0;
            } else {
              out.length--;
            }
            return out._strip();
          }
          var comb10MulTo = function comb10MulTo2(self2, num, out) {
            var a2 = self2.words;
            var b2 = num.words;
            var o2 = out.words;
            var c2 = 0;
            var lo;
            var mid;
            var hi;
            var a0 = a2[0] | 0;
            var al0 = a0 & 8191;
            var ah0 = a0 >>> 13;
            var a1 = a2[1] | 0;
            var al1 = a1 & 8191;
            var ah1 = a1 >>> 13;
            var a22 = a2[2] | 0;
            var al2 = a22 & 8191;
            var ah2 = a22 >>> 13;
            var a3 = a2[3] | 0;
            var al3 = a3 & 8191;
            var ah3 = a3 >>> 13;
            var a4 = a2[4] | 0;
            var al4 = a4 & 8191;
            var ah4 = a4 >>> 13;
            var a5 = a2[5] | 0;
            var al5 = a5 & 8191;
            var ah5 = a5 >>> 13;
            var a6 = a2[6] | 0;
            var al6 = a6 & 8191;
            var ah6 = a6 >>> 13;
            var a7 = a2[7] | 0;
            var al7 = a7 & 8191;
            var ah7 = a7 >>> 13;
            var a8 = a2[8] | 0;
            var al8 = a8 & 8191;
            var ah8 = a8 >>> 13;
            var a9 = a2[9] | 0;
            var al9 = a9 & 8191;
            var ah9 = a9 >>> 13;
            var b0 = b2[0] | 0;
            var bl0 = b0 & 8191;
            var bh0 = b0 >>> 13;
            var b1 = b2[1] | 0;
            var bl1 = b1 & 8191;
            var bh1 = b1 >>> 13;
            var b22 = b2[2] | 0;
            var bl2 = b22 & 8191;
            var bh2 = b22 >>> 13;
            var b3 = b2[3] | 0;
            var bl3 = b3 & 8191;
            var bh3 = b3 >>> 13;
            var b4 = b2[4] | 0;
            var bl4 = b4 & 8191;
            var bh4 = b4 >>> 13;
            var b5 = b2[5] | 0;
            var bl5 = b5 & 8191;
            var bh5 = b5 >>> 13;
            var b6 = b2[6] | 0;
            var bl6 = b6 & 8191;
            var bh6 = b6 >>> 13;
            var b7 = b2[7] | 0;
            var bl7 = b7 & 8191;
            var bh7 = b7 >>> 13;
            var b8 = b2[8] | 0;
            var bl8 = b8 & 8191;
            var bh8 = b8 >>> 13;
            var b9 = b2[9] | 0;
            var bl9 = b9 & 8191;
            var bh9 = b9 >>> 13;
            out.negative = self2.negative ^ num.negative;
            out.length = 19;
            lo = Math.imul(al0, bl0);
            mid = Math.imul(al0, bh0);
            mid = mid + Math.imul(ah0, bl0) | 0;
            hi = Math.imul(ah0, bh0);
            var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
            w0 &= 67108863;
            lo = Math.imul(al1, bl0);
            mid = Math.imul(al1, bh0);
            mid = mid + Math.imul(ah1, bl0) | 0;
            hi = Math.imul(ah1, bh0);
            lo = lo + Math.imul(al0, bl1) | 0;
            mid = mid + Math.imul(al0, bh1) | 0;
            mid = mid + Math.imul(ah0, bl1) | 0;
            hi = hi + Math.imul(ah0, bh1) | 0;
            var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
            w1 &= 67108863;
            lo = Math.imul(al2, bl0);
            mid = Math.imul(al2, bh0);
            mid = mid + Math.imul(ah2, bl0) | 0;
            hi = Math.imul(ah2, bh0);
            lo = lo + Math.imul(al1, bl1) | 0;
            mid = mid + Math.imul(al1, bh1) | 0;
            mid = mid + Math.imul(ah1, bl1) | 0;
            hi = hi + Math.imul(ah1, bh1) | 0;
            lo = lo + Math.imul(al0, bl2) | 0;
            mid = mid + Math.imul(al0, bh2) | 0;
            mid = mid + Math.imul(ah0, bl2) | 0;
            hi = hi + Math.imul(ah0, bh2) | 0;
            var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
            w2 &= 67108863;
            lo = Math.imul(al3, bl0);
            mid = Math.imul(al3, bh0);
            mid = mid + Math.imul(ah3, bl0) | 0;
            hi = Math.imul(ah3, bh0);
            lo = lo + Math.imul(al2, bl1) | 0;
            mid = mid + Math.imul(al2, bh1) | 0;
            mid = mid + Math.imul(ah2, bl1) | 0;
            hi = hi + Math.imul(ah2, bh1) | 0;
            lo = lo + Math.imul(al1, bl2) | 0;
            mid = mid + Math.imul(al1, bh2) | 0;
            mid = mid + Math.imul(ah1, bl2) | 0;
            hi = hi + Math.imul(ah1, bh2) | 0;
            lo = lo + Math.imul(al0, bl3) | 0;
            mid = mid + Math.imul(al0, bh3) | 0;
            mid = mid + Math.imul(ah0, bl3) | 0;
            hi = hi + Math.imul(ah0, bh3) | 0;
            var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
            w3 &= 67108863;
            lo = Math.imul(al4, bl0);
            mid = Math.imul(al4, bh0);
            mid = mid + Math.imul(ah4, bl0) | 0;
            hi = Math.imul(ah4, bh0);
            lo = lo + Math.imul(al3, bl1) | 0;
            mid = mid + Math.imul(al3, bh1) | 0;
            mid = mid + Math.imul(ah3, bl1) | 0;
            hi = hi + Math.imul(ah3, bh1) | 0;
            lo = lo + Math.imul(al2, bl2) | 0;
            mid = mid + Math.imul(al2, bh2) | 0;
            mid = mid + Math.imul(ah2, bl2) | 0;
            hi = hi + Math.imul(ah2, bh2) | 0;
            lo = lo + Math.imul(al1, bl3) | 0;
            mid = mid + Math.imul(al1, bh3) | 0;
            mid = mid + Math.imul(ah1, bl3) | 0;
            hi = hi + Math.imul(ah1, bh3) | 0;
            lo = lo + Math.imul(al0, bl4) | 0;
            mid = mid + Math.imul(al0, bh4) | 0;
            mid = mid + Math.imul(ah0, bl4) | 0;
            hi = hi + Math.imul(ah0, bh4) | 0;
            var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
            w4 &= 67108863;
            lo = Math.imul(al5, bl0);
            mid = Math.imul(al5, bh0);
            mid = mid + Math.imul(ah5, bl0) | 0;
            hi = Math.imul(ah5, bh0);
            lo = lo + Math.imul(al4, bl1) | 0;
            mid = mid + Math.imul(al4, bh1) | 0;
            mid = mid + Math.imul(ah4, bl1) | 0;
            hi = hi + Math.imul(ah4, bh1) | 0;
            lo = lo + Math.imul(al3, bl2) | 0;
            mid = mid + Math.imul(al3, bh2) | 0;
            mid = mid + Math.imul(ah3, bl2) | 0;
            hi = hi + Math.imul(ah3, bh2) | 0;
            lo = lo + Math.imul(al2, bl3) | 0;
            mid = mid + Math.imul(al2, bh3) | 0;
            mid = mid + Math.imul(ah2, bl3) | 0;
            hi = hi + Math.imul(ah2, bh3) | 0;
            lo = lo + Math.imul(al1, bl4) | 0;
            mid = mid + Math.imul(al1, bh4) | 0;
            mid = mid + Math.imul(ah1, bl4) | 0;
            hi = hi + Math.imul(ah1, bh4) | 0;
            lo = lo + Math.imul(al0, bl5) | 0;
            mid = mid + Math.imul(al0, bh5) | 0;
            mid = mid + Math.imul(ah0, bl5) | 0;
            hi = hi + Math.imul(ah0, bh5) | 0;
            var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
            w5 &= 67108863;
            lo = Math.imul(al6, bl0);
            mid = Math.imul(al6, bh0);
            mid = mid + Math.imul(ah6, bl0) | 0;
            hi = Math.imul(ah6, bh0);
            lo = lo + Math.imul(al5, bl1) | 0;
            mid = mid + Math.imul(al5, bh1) | 0;
            mid = mid + Math.imul(ah5, bl1) | 0;
            hi = hi + Math.imul(ah5, bh1) | 0;
            lo = lo + Math.imul(al4, bl2) | 0;
            mid = mid + Math.imul(al4, bh2) | 0;
            mid = mid + Math.imul(ah4, bl2) | 0;
            hi = hi + Math.imul(ah4, bh2) | 0;
            lo = lo + Math.imul(al3, bl3) | 0;
            mid = mid + Math.imul(al3, bh3) | 0;
            mid = mid + Math.imul(ah3, bl3) | 0;
            hi = hi + Math.imul(ah3, bh3) | 0;
            lo = lo + Math.imul(al2, bl4) | 0;
            mid = mid + Math.imul(al2, bh4) | 0;
            mid = mid + Math.imul(ah2, bl4) | 0;
            hi = hi + Math.imul(ah2, bh4) | 0;
            lo = lo + Math.imul(al1, bl5) | 0;
            mid = mid + Math.imul(al1, bh5) | 0;
            mid = mid + Math.imul(ah1, bl5) | 0;
            hi = hi + Math.imul(ah1, bh5) | 0;
            lo = lo + Math.imul(al0, bl6) | 0;
            mid = mid + Math.imul(al0, bh6) | 0;
            mid = mid + Math.imul(ah0, bl6) | 0;
            hi = hi + Math.imul(ah0, bh6) | 0;
            var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
            w6 &= 67108863;
            lo = Math.imul(al7, bl0);
            mid = Math.imul(al7, bh0);
            mid = mid + Math.imul(ah7, bl0) | 0;
            hi = Math.imul(ah7, bh0);
            lo = lo + Math.imul(al6, bl1) | 0;
            mid = mid + Math.imul(al6, bh1) | 0;
            mid = mid + Math.imul(ah6, bl1) | 0;
            hi = hi + Math.imul(ah6, bh1) | 0;
            lo = lo + Math.imul(al5, bl2) | 0;
            mid = mid + Math.imul(al5, bh2) | 0;
            mid = mid + Math.imul(ah5, bl2) | 0;
            hi = hi + Math.imul(ah5, bh2) | 0;
            lo = lo + Math.imul(al4, bl3) | 0;
            mid = mid + Math.imul(al4, bh3) | 0;
            mid = mid + Math.imul(ah4, bl3) | 0;
            hi = hi + Math.imul(ah4, bh3) | 0;
            lo = lo + Math.imul(al3, bl4) | 0;
            mid = mid + Math.imul(al3, bh4) | 0;
            mid = mid + Math.imul(ah3, bl4) | 0;
            hi = hi + Math.imul(ah3, bh4) | 0;
            lo = lo + Math.imul(al2, bl5) | 0;
            mid = mid + Math.imul(al2, bh5) | 0;
            mid = mid + Math.imul(ah2, bl5) | 0;
            hi = hi + Math.imul(ah2, bh5) | 0;
            lo = lo + Math.imul(al1, bl6) | 0;
            mid = mid + Math.imul(al1, bh6) | 0;
            mid = mid + Math.imul(ah1, bl6) | 0;
            hi = hi + Math.imul(ah1, bh6) | 0;
            lo = lo + Math.imul(al0, bl7) | 0;
            mid = mid + Math.imul(al0, bh7) | 0;
            mid = mid + Math.imul(ah0, bl7) | 0;
            hi = hi + Math.imul(ah0, bh7) | 0;
            var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
            w7 &= 67108863;
            lo = Math.imul(al8, bl0);
            mid = Math.imul(al8, bh0);
            mid = mid + Math.imul(ah8, bl0) | 0;
            hi = Math.imul(ah8, bh0);
            lo = lo + Math.imul(al7, bl1) | 0;
            mid = mid + Math.imul(al7, bh1) | 0;
            mid = mid + Math.imul(ah7, bl1) | 0;
            hi = hi + Math.imul(ah7, bh1) | 0;
            lo = lo + Math.imul(al6, bl2) | 0;
            mid = mid + Math.imul(al6, bh2) | 0;
            mid = mid + Math.imul(ah6, bl2) | 0;
            hi = hi + Math.imul(ah6, bh2) | 0;
            lo = lo + Math.imul(al5, bl3) | 0;
            mid = mid + Math.imul(al5, bh3) | 0;
            mid = mid + Math.imul(ah5, bl3) | 0;
            hi = hi + Math.imul(ah5, bh3) | 0;
            lo = lo + Math.imul(al4, bl4) | 0;
            mid = mid + Math.imul(al4, bh4) | 0;
            mid = mid + Math.imul(ah4, bl4) | 0;
            hi = hi + Math.imul(ah4, bh4) | 0;
            lo = lo + Math.imul(al3, bl5) | 0;
            mid = mid + Math.imul(al3, bh5) | 0;
            mid = mid + Math.imul(ah3, bl5) | 0;
            hi = hi + Math.imul(ah3, bh5) | 0;
            lo = lo + Math.imul(al2, bl6) | 0;
            mid = mid + Math.imul(al2, bh6) | 0;
            mid = mid + Math.imul(ah2, bl6) | 0;
            hi = hi + Math.imul(ah2, bh6) | 0;
            lo = lo + Math.imul(al1, bl7) | 0;
            mid = mid + Math.imul(al1, bh7) | 0;
            mid = mid + Math.imul(ah1, bl7) | 0;
            hi = hi + Math.imul(ah1, bh7) | 0;
            lo = lo + Math.imul(al0, bl8) | 0;
            mid = mid + Math.imul(al0, bh8) | 0;
            mid = mid + Math.imul(ah0, bl8) | 0;
            hi = hi + Math.imul(ah0, bh8) | 0;
            var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
            w8 &= 67108863;
            lo = Math.imul(al9, bl0);
            mid = Math.imul(al9, bh0);
            mid = mid + Math.imul(ah9, bl0) | 0;
            hi = Math.imul(ah9, bh0);
            lo = lo + Math.imul(al8, bl1) | 0;
            mid = mid + Math.imul(al8, bh1) | 0;
            mid = mid + Math.imul(ah8, bl1) | 0;
            hi = hi + Math.imul(ah8, bh1) | 0;
            lo = lo + Math.imul(al7, bl2) | 0;
            mid = mid + Math.imul(al7, bh2) | 0;
            mid = mid + Math.imul(ah7, bl2) | 0;
            hi = hi + Math.imul(ah7, bh2) | 0;
            lo = lo + Math.imul(al6, bl3) | 0;
            mid = mid + Math.imul(al6, bh3) | 0;
            mid = mid + Math.imul(ah6, bl3) | 0;
            hi = hi + Math.imul(ah6, bh3) | 0;
            lo = lo + Math.imul(al5, bl4) | 0;
            mid = mid + Math.imul(al5, bh4) | 0;
            mid = mid + Math.imul(ah5, bl4) | 0;
            hi = hi + Math.imul(ah5, bh4) | 0;
            lo = lo + Math.imul(al4, bl5) | 0;
            mid = mid + Math.imul(al4, bh5) | 0;
            mid = mid + Math.imul(ah4, bl5) | 0;
            hi = hi + Math.imul(ah4, bh5) | 0;
            lo = lo + Math.imul(al3, bl6) | 0;
            mid = mid + Math.imul(al3, bh6) | 0;
            mid = mid + Math.imul(ah3, bl6) | 0;
            hi = hi + Math.imul(ah3, bh6) | 0;
            lo = lo + Math.imul(al2, bl7) | 0;
            mid = mid + Math.imul(al2, bh7) | 0;
            mid = mid + Math.imul(ah2, bl7) | 0;
            hi = hi + Math.imul(ah2, bh7) | 0;
            lo = lo + Math.imul(al1, bl8) | 0;
            mid = mid + Math.imul(al1, bh8) | 0;
            mid = mid + Math.imul(ah1, bl8) | 0;
            hi = hi + Math.imul(ah1, bh8) | 0;
            lo = lo + Math.imul(al0, bl9) | 0;
            mid = mid + Math.imul(al0, bh9) | 0;
            mid = mid + Math.imul(ah0, bl9) | 0;
            hi = hi + Math.imul(ah0, bh9) | 0;
            var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
            w9 &= 67108863;
            lo = Math.imul(al9, bl1);
            mid = Math.imul(al9, bh1);
            mid = mid + Math.imul(ah9, bl1) | 0;
            hi = Math.imul(ah9, bh1);
            lo = lo + Math.imul(al8, bl2) | 0;
            mid = mid + Math.imul(al8, bh2) | 0;
            mid = mid + Math.imul(ah8, bl2) | 0;
            hi = hi + Math.imul(ah8, bh2) | 0;
            lo = lo + Math.imul(al7, bl3) | 0;
            mid = mid + Math.imul(al7, bh3) | 0;
            mid = mid + Math.imul(ah7, bl3) | 0;
            hi = hi + Math.imul(ah7, bh3) | 0;
            lo = lo + Math.imul(al6, bl4) | 0;
            mid = mid + Math.imul(al6, bh4) | 0;
            mid = mid + Math.imul(ah6, bl4) | 0;
            hi = hi + Math.imul(ah6, bh4) | 0;
            lo = lo + Math.imul(al5, bl5) | 0;
            mid = mid + Math.imul(al5, bh5) | 0;
            mid = mid + Math.imul(ah5, bl5) | 0;
            hi = hi + Math.imul(ah5, bh5) | 0;
            lo = lo + Math.imul(al4, bl6) | 0;
            mid = mid + Math.imul(al4, bh6) | 0;
            mid = mid + Math.imul(ah4, bl6) | 0;
            hi = hi + Math.imul(ah4, bh6) | 0;
            lo = lo + Math.imul(al3, bl7) | 0;
            mid = mid + Math.imul(al3, bh7) | 0;
            mid = mid + Math.imul(ah3, bl7) | 0;
            hi = hi + Math.imul(ah3, bh7) | 0;
            lo = lo + Math.imul(al2, bl8) | 0;
            mid = mid + Math.imul(al2, bh8) | 0;
            mid = mid + Math.imul(ah2, bl8) | 0;
            hi = hi + Math.imul(ah2, bh8) | 0;
            lo = lo + Math.imul(al1, bl9) | 0;
            mid = mid + Math.imul(al1, bh9) | 0;
            mid = mid + Math.imul(ah1, bl9) | 0;
            hi = hi + Math.imul(ah1, bh9) | 0;
            var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
            w10 &= 67108863;
            lo = Math.imul(al9, bl2);
            mid = Math.imul(al9, bh2);
            mid = mid + Math.imul(ah9, bl2) | 0;
            hi = Math.imul(ah9, bh2);
            lo = lo + Math.imul(al8, bl3) | 0;
            mid = mid + Math.imul(al8, bh3) | 0;
            mid = mid + Math.imul(ah8, bl3) | 0;
            hi = hi + Math.imul(ah8, bh3) | 0;
            lo = lo + Math.imul(al7, bl4) | 0;
            mid = mid + Math.imul(al7, bh4) | 0;
            mid = mid + Math.imul(ah7, bl4) | 0;
            hi = hi + Math.imul(ah7, bh4) | 0;
            lo = lo + Math.imul(al6, bl5) | 0;
            mid = mid + Math.imul(al6, bh5) | 0;
            mid = mid + Math.imul(ah6, bl5) | 0;
            hi = hi + Math.imul(ah6, bh5) | 0;
            lo = lo + Math.imul(al5, bl6) | 0;
            mid = mid + Math.imul(al5, bh6) | 0;
            mid = mid + Math.imul(ah5, bl6) | 0;
            hi = hi + Math.imul(ah5, bh6) | 0;
            lo = lo + Math.imul(al4, bl7) | 0;
            mid = mid + Math.imul(al4, bh7) | 0;
            mid = mid + Math.imul(ah4, bl7) | 0;
            hi = hi + Math.imul(ah4, bh7) | 0;
            lo = lo + Math.imul(al3, bl8) | 0;
            mid = mid + Math.imul(al3, bh8) | 0;
            mid = mid + Math.imul(ah3, bl8) | 0;
            hi = hi + Math.imul(ah3, bh8) | 0;
            lo = lo + Math.imul(al2, bl9) | 0;
            mid = mid + Math.imul(al2, bh9) | 0;
            mid = mid + Math.imul(ah2, bl9) | 0;
            hi = hi + Math.imul(ah2, bh9) | 0;
            var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
            w11 &= 67108863;
            lo = Math.imul(al9, bl3);
            mid = Math.imul(al9, bh3);
            mid = mid + Math.imul(ah9, bl3) | 0;
            hi = Math.imul(ah9, bh3);
            lo = lo + Math.imul(al8, bl4) | 0;
            mid = mid + Math.imul(al8, bh4) | 0;
            mid = mid + Math.imul(ah8, bl4) | 0;
            hi = hi + Math.imul(ah8, bh4) | 0;
            lo = lo + Math.imul(al7, bl5) | 0;
            mid = mid + Math.imul(al7, bh5) | 0;
            mid = mid + Math.imul(ah7, bl5) | 0;
            hi = hi + Math.imul(ah7, bh5) | 0;
            lo = lo + Math.imul(al6, bl6) | 0;
            mid = mid + Math.imul(al6, bh6) | 0;
            mid = mid + Math.imul(ah6, bl6) | 0;
            hi = hi + Math.imul(ah6, bh6) | 0;
            lo = lo + Math.imul(al5, bl7) | 0;
            mid = mid + Math.imul(al5, bh7) | 0;
            mid = mid + Math.imul(ah5, bl7) | 0;
            hi = hi + Math.imul(ah5, bh7) | 0;
            lo = lo + Math.imul(al4, bl8) | 0;
            mid = mid + Math.imul(al4, bh8) | 0;
            mid = mid + Math.imul(ah4, bl8) | 0;
            hi = hi + Math.imul(ah4, bh8) | 0;
            lo = lo + Math.imul(al3, bl9) | 0;
            mid = mid + Math.imul(al3, bh9) | 0;
            mid = mid + Math.imul(ah3, bl9) | 0;
            hi = hi + Math.imul(ah3, bh9) | 0;
            var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
            w12 &= 67108863;
            lo = Math.imul(al9, bl4);
            mid = Math.imul(al9, bh4);
            mid = mid + Math.imul(ah9, bl4) | 0;
            hi = Math.imul(ah9, bh4);
            lo = lo + Math.imul(al8, bl5) | 0;
            mid = mid + Math.imul(al8, bh5) | 0;
            mid = mid + Math.imul(ah8, bl5) | 0;
            hi = hi + Math.imul(ah8, bh5) | 0;
            lo = lo + Math.imul(al7, bl6) | 0;
            mid = mid + Math.imul(al7, bh6) | 0;
            mid = mid + Math.imul(ah7, bl6) | 0;
            hi = hi + Math.imul(ah7, bh6) | 0;
            lo = lo + Math.imul(al6, bl7) | 0;
            mid = mid + Math.imul(al6, bh7) | 0;
            mid = mid + Math.imul(ah6, bl7) | 0;
            hi = hi + Math.imul(ah6, bh7) | 0;
            lo = lo + Math.imul(al5, bl8) | 0;
            mid = mid + Math.imul(al5, bh8) | 0;
            mid = mid + Math.imul(ah5, bl8) | 0;
            hi = hi + Math.imul(ah5, bh8) | 0;
            lo = lo + Math.imul(al4, bl9) | 0;
            mid = mid + Math.imul(al4, bh9) | 0;
            mid = mid + Math.imul(ah4, bl9) | 0;
            hi = hi + Math.imul(ah4, bh9) | 0;
            var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
            w13 &= 67108863;
            lo = Math.imul(al9, bl5);
            mid = Math.imul(al9, bh5);
            mid = mid + Math.imul(ah9, bl5) | 0;
            hi = Math.imul(ah9, bh5);
            lo = lo + Math.imul(al8, bl6) | 0;
            mid = mid + Math.imul(al8, bh6) | 0;
            mid = mid + Math.imul(ah8, bl6) | 0;
            hi = hi + Math.imul(ah8, bh6) | 0;
            lo = lo + Math.imul(al7, bl7) | 0;
            mid = mid + Math.imul(al7, bh7) | 0;
            mid = mid + Math.imul(ah7, bl7) | 0;
            hi = hi + Math.imul(ah7, bh7) | 0;
            lo = lo + Math.imul(al6, bl8) | 0;
            mid = mid + Math.imul(al6, bh8) | 0;
            mid = mid + Math.imul(ah6, bl8) | 0;
            hi = hi + Math.imul(ah6, bh8) | 0;
            lo = lo + Math.imul(al5, bl9) | 0;
            mid = mid + Math.imul(al5, bh9) | 0;
            mid = mid + Math.imul(ah5, bl9) | 0;
            hi = hi + Math.imul(ah5, bh9) | 0;
            var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
            w14 &= 67108863;
            lo = Math.imul(al9, bl6);
            mid = Math.imul(al9, bh6);
            mid = mid + Math.imul(ah9, bl6) | 0;
            hi = Math.imul(ah9, bh6);
            lo = lo + Math.imul(al8, bl7) | 0;
            mid = mid + Math.imul(al8, bh7) | 0;
            mid = mid + Math.imul(ah8, bl7) | 0;
            hi = hi + Math.imul(ah8, bh7) | 0;
            lo = lo + Math.imul(al7, bl8) | 0;
            mid = mid + Math.imul(al7, bh8) | 0;
            mid = mid + Math.imul(ah7, bl8) | 0;
            hi = hi + Math.imul(ah7, bh8) | 0;
            lo = lo + Math.imul(al6, bl9) | 0;
            mid = mid + Math.imul(al6, bh9) | 0;
            mid = mid + Math.imul(ah6, bl9) | 0;
            hi = hi + Math.imul(ah6, bh9) | 0;
            var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
            w15 &= 67108863;
            lo = Math.imul(al9, bl7);
            mid = Math.imul(al9, bh7);
            mid = mid + Math.imul(ah9, bl7) | 0;
            hi = Math.imul(ah9, bh7);
            lo = lo + Math.imul(al8, bl8) | 0;
            mid = mid + Math.imul(al8, bh8) | 0;
            mid = mid + Math.imul(ah8, bl8) | 0;
            hi = hi + Math.imul(ah8, bh8) | 0;
            lo = lo + Math.imul(al7, bl9) | 0;
            mid = mid + Math.imul(al7, bh9) | 0;
            mid = mid + Math.imul(ah7, bl9) | 0;
            hi = hi + Math.imul(ah7, bh9) | 0;
            var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
            w16 &= 67108863;
            lo = Math.imul(al9, bl8);
            mid = Math.imul(al9, bh8);
            mid = mid + Math.imul(ah9, bl8) | 0;
            hi = Math.imul(ah9, bh8);
            lo = lo + Math.imul(al8, bl9) | 0;
            mid = mid + Math.imul(al8, bh9) | 0;
            mid = mid + Math.imul(ah8, bl9) | 0;
            hi = hi + Math.imul(ah8, bh9) | 0;
            var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
            w17 &= 67108863;
            lo = Math.imul(al9, bl9);
            mid = Math.imul(al9, bh9);
            mid = mid + Math.imul(ah9, bl9) | 0;
            hi = Math.imul(ah9, bh9);
            var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
            c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
            w18 &= 67108863;
            o2[0] = w0;
            o2[1] = w1;
            o2[2] = w2;
            o2[3] = w3;
            o2[4] = w4;
            o2[5] = w5;
            o2[6] = w6;
            o2[7] = w7;
            o2[8] = w8;
            o2[9] = w9;
            o2[10] = w10;
            o2[11] = w11;
            o2[12] = w12;
            o2[13] = w13;
            o2[14] = w14;
            o2[15] = w15;
            o2[16] = w16;
            o2[17] = w17;
            o2[18] = w18;
            if (c2 !== 0) {
              o2[19] = c2;
              out.length++;
            }
            return out;
          };
          if (!Math.imul) {
            comb10MulTo = smallMulTo;
          }
          function bigMulTo(self2, num, out) {
            out.negative = num.negative ^ self2.negative;
            out.length = self2.length + num.length;
            var carry = 0;
            var hncarry = 0;
            for (var k2 = 0; k2 < out.length - 1; k2++) {
              var ncarry = hncarry;
              hncarry = 0;
              var rword = carry & 67108863;
              var maxJ = Math.min(k2, num.length - 1);
              for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
                var i2 = k2 - j2;
                var a2 = self2.words[i2] | 0;
                var b2 = num.words[j2] | 0;
                var r2 = a2 * b2;
                var lo = r2 & 67108863;
                ncarry = ncarry + (r2 / 67108864 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 67108863;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 67108863;
              }
              out.words[k2] = rword;
              carry = ncarry;
              ncarry = hncarry;
            }
            if (carry !== 0) {
              out.words[k2] = carry;
            } else {
              out.length--;
            }
            return out._strip();
          }
          function jumboMulTo(self2, num, out) {
            return bigMulTo(self2, num, out);
          }
          BN2.prototype.mulTo = function mulTo(num, out) {
            var res;
            var len = this.length + num.length;
            if (this.length === 10 && num.length === 10) {
              res = comb10MulTo(this, num, out);
            } else if (len < 63) {
              res = smallMulTo(this, num, out);
            } else if (len < 1024) {
              res = bigMulTo(this, num, out);
            } else {
              res = jumboMulTo(this, num, out);
            }
            return res;
          };
          function FFTM(x2, y2) {
            this.x = x2;
            this.y = y2;
          }
          FFTM.prototype.makeRBT = function makeRBT(N2) {
            var t = new Array(N2);
            var l2 = BN2.prototype._countBits(N2) - 1;
            for (var i2 = 0; i2 < N2; i2++) {
              t[i2] = this.revBin(i2, l2, N2);
            }
            return t;
          };
          FFTM.prototype.revBin = function revBin(x2, l2, N2) {
            if (x2 === 0 || x2 === N2 - 1)
              return x2;
            var rb = 0;
            for (var i2 = 0; i2 < l2; i2++) {
              rb |= (x2 & 1) << l2 - i2 - 1;
              x2 >>= 1;
            }
            return rb;
          };
          FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
            for (var i2 = 0; i2 < N2; i2++) {
              rtws[i2] = rws[rbt[i2]];
              itws[i2] = iws[rbt[i2]];
            }
          };
          FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
            this.permute(rbt, rws, iws, rtws, itws, N2);
            for (var s2 = 1; s2 < N2; s2 <<= 1) {
              var l2 = s2 << 1;
              var rtwdf = Math.cos(2 * Math.PI / l2);
              var itwdf = Math.sin(2 * Math.PI / l2);
              for (var p2 = 0; p2 < N2; p2 += l2) {
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for (var j2 = 0; j2 < s2; j2++) {
                  var re2 = rtws[p2 + j2];
                  var ie2 = itws[p2 + j2];
                  var ro = rtws[p2 + j2 + s2];
                  var io = itws[p2 + j2 + s2];
                  var rx = rtwdf_ * ro - itwdf_ * io;
                  io = rtwdf_ * io + itwdf_ * ro;
                  ro = rx;
                  rtws[p2 + j2] = re2 + ro;
                  itws[p2 + j2] = ie2 + io;
                  rtws[p2 + j2 + s2] = re2 - ro;
                  itws[p2 + j2 + s2] = ie2 - io;
                  if (j2 !== l2) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                  }
                }
              }
            }
          };
          FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
            var N2 = Math.max(m2, n) | 1;
            var odd = N2 & 1;
            var i2 = 0;
            for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
              i2++;
            }
            return 1 << i2 + 1 + odd;
          };
          FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
            if (N2 <= 1)
              return;
            for (var i2 = 0; i2 < N2 / 2; i2++) {
              var t = rws[i2];
              rws[i2] = rws[N2 - i2 - 1];
              rws[N2 - i2 - 1] = t;
              t = iws[i2];
              iws[i2] = -iws[N2 - i2 - 1];
              iws[N2 - i2 - 1] = -t;
            }
          };
          FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
            var carry = 0;
            for (var i2 = 0; i2 < N2 / 2; i2++) {
              var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
              ws[i2] = w2 & 67108863;
              if (w2 < 67108864) {
                carry = 0;
              } else {
                carry = w2 / 67108864 | 0;
              }
            }
            return ws;
          };
          FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
            var carry = 0;
            for (var i2 = 0; i2 < len; i2++) {
              carry = carry + (ws[i2] | 0);
              rws[2 * i2] = carry & 8191;
              carry = carry >>> 13;
              rws[2 * i2 + 1] = carry & 8191;
              carry = carry >>> 13;
            }
            for (i2 = 2 * len; i2 < N2; ++i2) {
              rws[i2] = 0;
            }
            assert2(carry === 0);
            assert2((carry & ~8191) === 0);
          };
          FFTM.prototype.stub = function stub(N2) {
            var ph = new Array(N2);
            for (var i2 = 0; i2 < N2; i2++) {
              ph[i2] = 0;
            }
            return ph;
          };
          FFTM.prototype.mulp = function mulp(x2, y2, out) {
            var N2 = 2 * this.guessLen13b(x2.length, y2.length);
            var rbt = this.makeRBT(N2);
            var _2 = this.stub(N2);
            var rws = new Array(N2);
            var rwst = new Array(N2);
            var iwst = new Array(N2);
            var nrws = new Array(N2);
            var nrwst = new Array(N2);
            var niwst = new Array(N2);
            var rmws = out.words;
            rmws.length = N2;
            this.convert13b(x2.words, x2.length, rws, N2);
            this.convert13b(y2.words, y2.length, nrws, N2);
            this.transform(rws, _2, rwst, iwst, N2, rbt);
            this.transform(nrws, _2, nrwst, niwst, N2, rbt);
            for (var i2 = 0; i2 < N2; i2++) {
              var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
              iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
              rwst[i2] = rx;
            }
            this.conjugate(rwst, iwst, N2);
            this.transform(rwst, iwst, rmws, _2, N2, rbt);
            this.conjugate(rmws, _2, N2);
            this.normalize13b(rmws, N2);
            out.negative = x2.negative ^ y2.negative;
            out.length = x2.length + y2.length;
            return out._strip();
          };
          BN2.prototype.mul = function mul2(num) {
            var out = new BN2(null);
            out.words = new Array(this.length + num.length);
            return this.mulTo(num, out);
          };
          BN2.prototype.mulf = function mulf(num) {
            var out = new BN2(null);
            out.words = new Array(this.length + num.length);
            return jumboMulTo(this, num, out);
          };
          BN2.prototype.imul = function imul(num) {
            return this.clone().mulTo(num, this);
          };
          BN2.prototype.imuln = function imuln(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(typeof num === "number");
            assert2(num < 67108864);
            var carry = 0;
            for (var i2 = 0; i2 < this.length; i2++) {
              var w2 = (this.words[i2] | 0) * num;
              var lo = (w2 & 67108863) + (carry & 67108863);
              carry >>= 26;
              carry += w2 / 67108864 | 0;
              carry += lo >>> 26;
              this.words[i2] = lo & 67108863;
            }
            if (carry !== 0) {
              this.words[i2] = carry;
              this.length++;
            }
            return isNegNum ? this.ineg() : this;
          };
          BN2.prototype.muln = function muln(num) {
            return this.clone().imuln(num);
          };
          BN2.prototype.sqr = function sqr() {
            return this.mul(this);
          };
          BN2.prototype.isqr = function isqr() {
            return this.imul(this.clone());
          };
          BN2.prototype.pow = function pow2(num) {
            var w2 = toBitArray(num);
            if (w2.length === 0)
              return new BN2(1);
            var res = this;
            for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
              if (w2[i2] !== 0)
                break;
            }
            if (++i2 < w2.length) {
              for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
                if (w2[i2] === 0)
                  continue;
                res = res.mul(q2);
              }
            }
            return res;
          };
          BN2.prototype.iushln = function iushln(bits2) {
            assert2(typeof bits2 === "number" && bits2 >= 0);
            var r2 = bits2 % 26;
            var s2 = (bits2 - r2) / 26;
            var carryMask = 67108863 >>> 26 - r2 << 26 - r2;
            var i2;
            if (r2 !== 0) {
              var carry = 0;
              for (i2 = 0; i2 < this.length; i2++) {
                var newCarry = this.words[i2] & carryMask;
                var c2 = (this.words[i2] | 0) - newCarry << r2;
                this.words[i2] = c2 | carry;
                carry = newCarry >>> 26 - r2;
              }
              if (carry) {
                this.words[i2] = carry;
                this.length++;
              }
            }
            if (s2 !== 0) {
              for (i2 = this.length - 1; i2 >= 0; i2--) {
                this.words[i2 + s2] = this.words[i2];
              }
              for (i2 = 0; i2 < s2; i2++) {
                this.words[i2] = 0;
              }
              this.length += s2;
            }
            return this._strip();
          };
          BN2.prototype.ishln = function ishln(bits2) {
            assert2(this.negative === 0);
            return this.iushln(bits2);
          };
          BN2.prototype.iushrn = function iushrn(bits2, hint, extended) {
            assert2(typeof bits2 === "number" && bits2 >= 0);
            var h;
            if (hint) {
              h = (hint - hint % 26) / 26;
            } else {
              h = 0;
            }
            var r2 = bits2 % 26;
            var s2 = Math.min((bits2 - r2) / 26, this.length);
            var mask = 67108863 ^ 67108863 >>> r2 << r2;
            var maskedWords = extended;
            h -= s2;
            h = Math.max(0, h);
            if (maskedWords) {
              for (var i2 = 0; i2 < s2; i2++) {
                maskedWords.words[i2] = this.words[i2];
              }
              maskedWords.length = s2;
            }
            if (s2 === 0) {
            } else if (this.length > s2) {
              this.length -= s2;
              for (i2 = 0; i2 < this.length; i2++) {
                this.words[i2] = this.words[i2 + s2];
              }
            } else {
              this.words[0] = 0;
              this.length = 1;
            }
            var carry = 0;
            for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h); i2--) {
              var word = this.words[i2] | 0;
              this.words[i2] = carry << 26 - r2 | word >>> r2;
              carry = word & mask;
            }
            if (maskedWords && carry !== 0) {
              maskedWords.words[maskedWords.length++] = carry;
            }
            if (this.length === 0) {
              this.words[0] = 0;
              this.length = 1;
            }
            return this._strip();
          };
          BN2.prototype.ishrn = function ishrn(bits2, hint, extended) {
            assert2(this.negative === 0);
            return this.iushrn(bits2, hint, extended);
          };
          BN2.prototype.shln = function shln(bits2) {
            return this.clone().ishln(bits2);
          };
          BN2.prototype.ushln = function ushln(bits2) {
            return this.clone().iushln(bits2);
          };
          BN2.prototype.shrn = function shrn(bits2) {
            return this.clone().ishrn(bits2);
          };
          BN2.prototype.ushrn = function ushrn(bits2) {
            return this.clone().iushrn(bits2);
          };
          BN2.prototype.testn = function testn(bit) {
            assert2(typeof bit === "number" && bit >= 0);
            var r2 = bit % 26;
            var s2 = (bit - r2) / 26;
            var q2 = 1 << r2;
            if (this.length <= s2)
              return false;
            var w2 = this.words[s2];
            return !!(w2 & q2);
          };
          BN2.prototype.imaskn = function imaskn(bits2) {
            assert2(typeof bits2 === "number" && bits2 >= 0);
            var r2 = bits2 % 26;
            var s2 = (bits2 - r2) / 26;
            assert2(this.negative === 0, "imaskn works only with positive numbers");
            if (this.length <= s2) {
              return this;
            }
            if (r2 !== 0) {
              s2++;
            }
            this.length = Math.min(s2, this.length);
            if (r2 !== 0) {
              var mask = 67108863 ^ 67108863 >>> r2 << r2;
              this.words[this.length - 1] &= mask;
            }
            return this._strip();
          };
          BN2.prototype.maskn = function maskn(bits2) {
            return this.clone().imaskn(bits2);
          };
          BN2.prototype.iaddn = function iaddn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.isubn(-num);
            if (this.negative !== 0) {
              if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
              }
              this.negative = 0;
              this.isubn(num);
              this.negative = 1;
              return this;
            }
            return this._iaddn(num);
          };
          BN2.prototype._iaddn = function _iaddn(num) {
            this.words[0] += num;
            for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
              this.words[i2] -= 67108864;
              if (i2 === this.length - 1) {
                this.words[i2 + 1] = 1;
              } else {
                this.words[i2 + 1]++;
              }
            }
            this.length = Math.max(this.length, i2 + 1);
            return this;
          };
          BN2.prototype.isubn = function isubn(num) {
            assert2(typeof num === "number");
            assert2(num < 67108864);
            if (num < 0)
              return this.iaddn(-num);
            if (this.negative !== 0) {
              this.negative = 0;
              this.iaddn(num);
              this.negative = 1;
              return this;
            }
            this.words[0] -= num;
            if (this.length === 1 && this.words[0] < 0) {
              this.words[0] = -this.words[0];
              this.negative = 1;
            } else {
              for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
                this.words[i2] += 67108864;
                this.words[i2 + 1] -= 1;
              }
            }
            return this._strip();
          };
          BN2.prototype.addn = function addn(num) {
            return this.clone().iaddn(num);
          };
          BN2.prototype.subn = function subn(num) {
            return this.clone().isubn(num);
          };
          BN2.prototype.iabs = function iabs() {
            this.negative = 0;
            return this;
          };
          BN2.prototype.abs = function abs3() {
            return this.clone().iabs();
          };
          BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul2, shift) {
            var len = num.length + shift;
            var i2;
            this._expand(len);
            var w2;
            var carry = 0;
            for (i2 = 0; i2 < num.length; i2++) {
              w2 = (this.words[i2 + shift] | 0) + carry;
              var right = (num.words[i2] | 0) * mul2;
              w2 -= right & 67108863;
              carry = (w2 >> 26) - (right / 67108864 | 0);
              this.words[i2 + shift] = w2 & 67108863;
            }
            for (; i2 < this.length - shift; i2++) {
              w2 = (this.words[i2 + shift] | 0) + carry;
              carry = w2 >> 26;
              this.words[i2 + shift] = w2 & 67108863;
            }
            if (carry === 0)
              return this._strip();
            assert2(carry === -1);
            carry = 0;
            for (i2 = 0; i2 < this.length; i2++) {
              w2 = -(this.words[i2] | 0) + carry;
              carry = w2 >> 26;
              this.words[i2] = w2 & 67108863;
            }
            this.negative = 1;
            return this._strip();
          };
          BN2.prototype._wordDiv = function _wordDiv(num, mode) {
            var shift = this.length - num.length;
            var a2 = this.clone();
            var b2 = num;
            var bhi = b2.words[b2.length - 1] | 0;
            var bhiBits = this._countBits(bhi);
            shift = 26 - bhiBits;
            if (shift !== 0) {
              b2 = b2.ushln(shift);
              a2.iushln(shift);
              bhi = b2.words[b2.length - 1] | 0;
            }
            var m2 = a2.length - b2.length;
            var q2;
            if (mode !== "mod") {
              q2 = new BN2(null);
              q2.length = m2 + 1;
              q2.words = new Array(q2.length);
              for (var i2 = 0; i2 < q2.length; i2++) {
                q2.words[i2] = 0;
              }
            }
            var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
            if (diff.negative === 0) {
              a2 = diff;
              if (q2) {
                q2.words[m2] = 1;
              }
            }
            for (var j2 = m2 - 1; j2 >= 0; j2--) {
              var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
              qj = Math.min(qj / bhi | 0, 67108863);
              a2._ishlnsubmul(b2, qj, j2);
              while (a2.negative !== 0) {
                qj--;
                a2.negative = 0;
                a2._ishlnsubmul(b2, 1, j2);
                if (!a2.isZero()) {
                  a2.negative ^= 1;
                }
              }
              if (q2) {
                q2.words[j2] = qj;
              }
            }
            if (q2) {
              q2._strip();
            }
            a2._strip();
            if (mode !== "div" && shift !== 0) {
              a2.iushrn(shift);
            }
            return {
              div: q2 || null,
              mod: a2
            };
          };
          BN2.prototype.divmod = function divmod(num, mode, positive) {
            assert2(!num.isZero());
            if (this.isZero()) {
              return {
                div: new BN2(0),
                mod: new BN2(0)
              };
            }
            var div2, mod2, res;
            if (this.negative !== 0 && num.negative === 0) {
              res = this.neg().divmod(num, mode);
              if (mode !== "mod") {
                div2 = res.div.neg();
              }
              if (mode !== "div") {
                mod2 = res.mod.neg();
                if (positive && mod2.negative !== 0) {
                  mod2.iadd(num);
                }
              }
              return {
                div: div2,
                mod: mod2
              };
            }
            if (this.negative === 0 && num.negative !== 0) {
              res = this.divmod(num.neg(), mode);
              if (mode !== "mod") {
                div2 = res.div.neg();
              }
              return {
                div: div2,
                mod: res.mod
              };
            }
            if ((this.negative & num.negative) !== 0) {
              res = this.neg().divmod(num.neg(), mode);
              if (mode !== "div") {
                mod2 = res.mod.neg();
                if (positive && mod2.negative !== 0) {
                  mod2.isub(num);
                }
              }
              return {
                div: res.div,
                mod: mod2
              };
            }
            if (num.length > this.length || this.cmp(num) < 0) {
              return {
                div: new BN2(0),
                mod: this
              };
            }
            if (num.length === 1) {
              if (mode === "div") {
                return {
                  div: this.divn(num.words[0]),
                  mod: null
                };
              }
              if (mode === "mod") {
                return {
                  div: null,
                  mod: new BN2(this.modrn(num.words[0]))
                };
              }
              return {
                div: this.divn(num.words[0]),
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return this._wordDiv(num, mode);
          };
          BN2.prototype.div = function div2(num) {
            return this.divmod(num, "div", false).div;
          };
          BN2.prototype.mod = function mod2(num) {
            return this.divmod(num, "mod", false).mod;
          };
          BN2.prototype.umod = function umod(num) {
            return this.divmod(num, "mod", true).mod;
          };
          BN2.prototype.divRound = function divRound(num) {
            var dm = this.divmod(num);
            if (dm.mod.isZero())
              return dm.div;
            var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
            var half = num.ushrn(1);
            var r2 = num.andln(1);
            var cmp = mod2.cmp(half);
            if (cmp < 0 || r2 === 1 && cmp === 0)
              return dm.div;
            return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
          };
          BN2.prototype.modrn = function modrn(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(num <= 67108863);
            var p2 = (1 << 26) % num;
            var acc = 0;
            for (var i2 = this.length - 1; i2 >= 0; i2--) {
              acc = (p2 * acc + (this.words[i2] | 0)) % num;
            }
            return isNegNum ? -acc : acc;
          };
          BN2.prototype.modn = function modn(num) {
            return this.modrn(num);
          };
          BN2.prototype.idivn = function idivn(num) {
            var isNegNum = num < 0;
            if (isNegNum)
              num = -num;
            assert2(num <= 67108863);
            var carry = 0;
            for (var i2 = this.length - 1; i2 >= 0; i2--) {
              var w2 = (this.words[i2] | 0) + carry * 67108864;
              this.words[i2] = w2 / num | 0;
              carry = w2 % num;
            }
            this._strip();
            return isNegNum ? this.ineg() : this;
          };
          BN2.prototype.divn = function divn(num) {
            return this.clone().idivn(num);
          };
          BN2.prototype.egcd = function egcd(p2) {
            assert2(p2.negative === 0);
            assert2(!p2.isZero());
            var x2 = this;
            var y2 = p2.clone();
            if (x2.negative !== 0) {
              x2 = x2.umod(p2);
            } else {
              x2 = x2.clone();
            }
            var A2 = new BN2(1);
            var B2 = new BN2(0);
            var C2 = new BN2(0);
            var D2 = new BN2(1);
            var g2 = 0;
            while (x2.isEven() && y2.isEven()) {
              x2.iushrn(1);
              y2.iushrn(1);
              ++g2;
            }
            var yp = y2.clone();
            var xp = x2.clone();
            while (!x2.isZero()) {
              for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
                ;
              if (i2 > 0) {
                x2.iushrn(i2);
                while (i2-- > 0) {
                  if (A2.isOdd() || B2.isOdd()) {
                    A2.iadd(yp);
                    B2.isub(xp);
                  }
                  A2.iushrn(1);
                  B2.iushrn(1);
                }
              }
              for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
                ;
              if (j2 > 0) {
                y2.iushrn(j2);
                while (j2-- > 0) {
                  if (C2.isOdd() || D2.isOdd()) {
                    C2.iadd(yp);
                    D2.isub(xp);
                  }
                  C2.iushrn(1);
                  D2.iushrn(1);
                }
              }
              if (x2.cmp(y2) >= 0) {
                x2.isub(y2);
                A2.isub(C2);
                B2.isub(D2);
              } else {
                y2.isub(x2);
                C2.isub(A2);
                D2.isub(B2);
              }
            }
            return {
              a: C2,
              b: D2,
              gcd: y2.iushln(g2)
            };
          };
          BN2.prototype._invmp = function _invmp(p2) {
            assert2(p2.negative === 0);
            assert2(!p2.isZero());
            var a2 = this;
            var b2 = p2.clone();
            if (a2.negative !== 0) {
              a2 = a2.umod(p2);
            } else {
              a2 = a2.clone();
            }
            var x1 = new BN2(1);
            var x2 = new BN2(0);
            var delta = b2.clone();
            while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
              for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1)
                ;
              if (i2 > 0) {
                a2.iushrn(i2);
                while (i2-- > 0) {
                  if (x1.isOdd()) {
                    x1.iadd(delta);
                  }
                  x1.iushrn(1);
                }
              }
              for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1)
                ;
              if (j2 > 0) {
                b2.iushrn(j2);
                while (j2-- > 0) {
                  if (x2.isOdd()) {
                    x2.iadd(delta);
                  }
                  x2.iushrn(1);
                }
              }
              if (a2.cmp(b2) >= 0) {
                a2.isub(b2);
                x1.isub(x2);
              } else {
                b2.isub(a2);
                x2.isub(x1);
              }
            }
            var res;
            if (a2.cmpn(1) === 0) {
              res = x1;
            } else {
              res = x2;
            }
            if (res.cmpn(0) < 0) {
              res.iadd(p2);
            }
            return res;
          };
          BN2.prototype.gcd = function gcd(num) {
            if (this.isZero())
              return num.abs();
            if (num.isZero())
              return this.abs();
            var a2 = this.clone();
            var b2 = num.clone();
            a2.negative = 0;
            b2.negative = 0;
            for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
              a2.iushrn(1);
              b2.iushrn(1);
            }
            do {
              while (a2.isEven()) {
                a2.iushrn(1);
              }
              while (b2.isEven()) {
                b2.iushrn(1);
              }
              var r2 = a2.cmp(b2);
              if (r2 < 0) {
                var t = a2;
                a2 = b2;
                b2 = t;
              } else if (r2 === 0 || b2.cmpn(1) === 0) {
                break;
              }
              a2.isub(b2);
            } while (true);
            return b2.iushln(shift);
          };
          BN2.prototype.invm = function invm(num) {
            return this.egcd(num).a.umod(num);
          };
          BN2.prototype.isEven = function isEven2() {
            return (this.words[0] & 1) === 0;
          };
          BN2.prototype.isOdd = function isOdd2() {
            return (this.words[0] & 1) === 1;
          };
          BN2.prototype.andln = function andln(num) {
            return this.words[0] & num;
          };
          BN2.prototype.bincn = function bincn(bit) {
            assert2(typeof bit === "number");
            var r2 = bit % 26;
            var s2 = (bit - r2) / 26;
            var q2 = 1 << r2;
            if (this.length <= s2) {
              this._expand(s2 + 1);
              this.words[s2] |= q2;
              return this;
            }
            var carry = q2;
            for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
              var w2 = this.words[i2] | 0;
              w2 += carry;
              carry = w2 >>> 26;
              w2 &= 67108863;
              this.words[i2] = w2;
            }
            if (carry !== 0) {
              this.words[i2] = carry;
              this.length++;
            }
            return this;
          };
          BN2.prototype.isZero = function isZero2() {
            return this.length === 1 && this.words[0] === 0;
          };
          BN2.prototype.cmpn = function cmpn(num) {
            var negative = num < 0;
            if (this.negative !== 0 && !negative)
              return -1;
            if (this.negative === 0 && negative)
              return 1;
            this._strip();
            var res;
            if (this.length > 1) {
              res = 1;
            } else {
              if (negative) {
                num = -num;
              }
              assert2(num <= 67108863, "Number is too big");
              var w2 = this.words[0] | 0;
              res = w2 === num ? 0 : w2 < num ? -1 : 1;
            }
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN2.prototype.cmp = function cmp(num) {
            if (this.negative !== 0 && num.negative === 0)
              return -1;
            if (this.negative === 0 && num.negative !== 0)
              return 1;
            var res = this.ucmp(num);
            if (this.negative !== 0)
              return -res | 0;
            return res;
          };
          BN2.prototype.ucmp = function ucmp(num) {
            if (this.length > num.length)
              return 1;
            if (this.length < num.length)
              return -1;
            var res = 0;
            for (var i2 = this.length - 1; i2 >= 0; i2--) {
              var a2 = this.words[i2] | 0;
              var b2 = num.words[i2] | 0;
              if (a2 === b2)
                continue;
              if (a2 < b2) {
                res = -1;
              } else if (a2 > b2) {
                res = 1;
              }
              break;
            }
            return res;
          };
          BN2.prototype.gtn = function gtn(num) {
            return this.cmpn(num) === 1;
          };
          BN2.prototype.gt = function gt3(num) {
            return this.cmp(num) === 1;
          };
          BN2.prototype.gten = function gten(num) {
            return this.cmpn(num) >= 0;
          };
          BN2.prototype.gte = function gte(num) {
            return this.cmp(num) >= 0;
          };
          BN2.prototype.ltn = function ltn(num) {
            return this.cmpn(num) === -1;
          };
          BN2.prototype.lt = function lt3(num) {
            return this.cmp(num) === -1;
          };
          BN2.prototype.lten = function lten(num) {
            return this.cmpn(num) <= 0;
          };
          BN2.prototype.lte = function lte(num) {
            return this.cmp(num) <= 0;
          };
          BN2.prototype.eqn = function eqn(num) {
            return this.cmpn(num) === 0;
          };
          BN2.prototype.eq = function eq2(num) {
            return this.cmp(num) === 0;
          };
          BN2.red = function red(num) {
            return new Red(num);
          };
          BN2.prototype.toRed = function toRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            assert2(this.negative === 0, "red works only with positives");
            return ctx.convertTo(this)._forceRed(ctx);
          };
          BN2.prototype.fromRed = function fromRed() {
            assert2(this.red, "fromRed works only with numbers in reduction context");
            return this.red.convertFrom(this);
          };
          BN2.prototype._forceRed = function _forceRed(ctx) {
            this.red = ctx;
            return this;
          };
          BN2.prototype.forceRed = function forceRed(ctx) {
            assert2(!this.red, "Already a number in reduction context");
            return this._forceRed(ctx);
          };
          BN2.prototype.redAdd = function redAdd(num) {
            assert2(this.red, "redAdd works only with red numbers");
            return this.red.add(this, num);
          };
          BN2.prototype.redIAdd = function redIAdd(num) {
            assert2(this.red, "redIAdd works only with red numbers");
            return this.red.iadd(this, num);
          };
          BN2.prototype.redSub = function redSub(num) {
            assert2(this.red, "redSub works only with red numbers");
            return this.red.sub(this, num);
          };
          BN2.prototype.redISub = function redISub(num) {
            assert2(this.red, "redISub works only with red numbers");
            return this.red.isub(this, num);
          };
          BN2.prototype.redShl = function redShl(num) {
            assert2(this.red, "redShl works only with red numbers");
            return this.red.shl(this, num);
          };
          BN2.prototype.redMul = function redMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.mul(this, num);
          };
          BN2.prototype.redIMul = function redIMul(num) {
            assert2(this.red, "redMul works only with red numbers");
            this.red._verify2(this, num);
            return this.red.imul(this, num);
          };
          BN2.prototype.redSqr = function redSqr() {
            assert2(this.red, "redSqr works only with red numbers");
            this.red._verify1(this);
            return this.red.sqr(this);
          };
          BN2.prototype.redISqr = function redISqr() {
            assert2(this.red, "redISqr works only with red numbers");
            this.red._verify1(this);
            return this.red.isqr(this);
          };
          BN2.prototype.redSqrt = function redSqrt() {
            assert2(this.red, "redSqrt works only with red numbers");
            this.red._verify1(this);
            return this.red.sqrt(this);
          };
          BN2.prototype.redInvm = function redInvm() {
            assert2(this.red, "redInvm works only with red numbers");
            this.red._verify1(this);
            return this.red.invm(this);
          };
          BN2.prototype.redNeg = function redNeg() {
            assert2(this.red, "redNeg works only with red numbers");
            this.red._verify1(this);
            return this.red.neg(this);
          };
          BN2.prototype.redPow = function redPow(num) {
            assert2(this.red && !num.red, "redPow(normalNum)");
            this.red._verify1(this);
            return this.red.pow(this, num);
          };
          var primes = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
          };
          function MPrime(name, p2) {
            this.name = name;
            this.p = new BN2(p2, 16);
            this.n = this.p.bitLength();
            this.k = new BN2(1).iushln(this.n).isub(this.p);
            this.tmp = this._tmp();
          }
          MPrime.prototype._tmp = function _tmp() {
            var tmp = new BN2(null);
            tmp.words = new Array(Math.ceil(this.n / 13));
            return tmp;
          };
          MPrime.prototype.ireduce = function ireduce(num) {
            var r2 = num;
            var rlen;
            do {
              this.split(r2, this.tmp);
              r2 = this.imulK(r2);
              r2 = r2.iadd(this.tmp);
              rlen = r2.bitLength();
            } while (rlen > this.n);
            var cmp = rlen < this.n ? -1 : r2.ucmp(this.p);
            if (cmp === 0) {
              r2.words[0] = 0;
              r2.length = 1;
            } else if (cmp > 0) {
              r2.isub(this.p);
            } else {
              if (r2.strip !== void 0) {
                r2.strip();
              } else {
                r2._strip();
              }
            }
            return r2;
          };
          MPrime.prototype.split = function split(input, out) {
            input.iushrn(this.n, 0, out);
          };
          MPrime.prototype.imulK = function imulK(num) {
            return num.imul(this.k);
          };
          function K256() {
            MPrime.call(
              this,
              "k256",
              "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
            );
          }
          inherits(K256, MPrime);
          K256.prototype.split = function split(input, output) {
            var mask = 4194303;
            var outLen = Math.min(input.length, 9);
            for (var i2 = 0; i2 < outLen; i2++) {
              output.words[i2] = input.words[i2];
            }
            output.length = outLen;
            if (input.length <= 9) {
              input.words[0] = 0;
              input.length = 1;
              return;
            }
            var prev3 = input.words[9];
            output.words[output.length++] = prev3 & mask;
            for (i2 = 10; i2 < input.length; i2++) {
              var next2 = input.words[i2] | 0;
              input.words[i2 - 10] = (next2 & mask) << 4 | prev3 >>> 22;
              prev3 = next2;
            }
            prev3 >>>= 22;
            input.words[i2 - 10] = prev3;
            if (prev3 === 0 && input.length > 10) {
              input.length -= 10;
            } else {
              input.length -= 9;
            }
          };
          K256.prototype.imulK = function imulK(num) {
            num.words[num.length] = 0;
            num.words[num.length + 1] = 0;
            num.length += 2;
            var lo = 0;
            for (var i2 = 0; i2 < num.length; i2++) {
              var w2 = num.words[i2] | 0;
              lo += w2 * 977;
              num.words[i2] = lo & 67108863;
              lo = w2 * 64 + (lo / 67108864 | 0);
            }
            if (num.words[num.length - 1] === 0) {
              num.length--;
              if (num.words[num.length - 1] === 0) {
                num.length--;
              }
            }
            return num;
          };
          function P224() {
            MPrime.call(
              this,
              "p224",
              "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
            );
          }
          inherits(P224, MPrime);
          function P192() {
            MPrime.call(
              this,
              "p192",
              "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
            );
          }
          inherits(P192, MPrime);
          function P25519() {
            MPrime.call(
              this,
              "25519",
              "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
            );
          }
          inherits(P25519, MPrime);
          P25519.prototype.imulK = function imulK(num) {
            var carry = 0;
            for (var i2 = 0; i2 < num.length; i2++) {
              var hi = (num.words[i2] | 0) * 19 + carry;
              var lo = hi & 67108863;
              hi >>>= 26;
              num.words[i2] = lo;
              carry = hi;
            }
            if (carry !== 0) {
              num.words[num.length++] = carry;
            }
            return num;
          };
          BN2._prime = function prime(name) {
            if (primes[name])
              return primes[name];
            var prime2;
            if (name === "k256") {
              prime2 = new K256();
            } else if (name === "p224") {
              prime2 = new P224();
            } else if (name === "p192") {
              prime2 = new P192();
            } else if (name === "p25519") {
              prime2 = new P25519();
            } else {
              throw new Error("Unknown prime " + name);
            }
            primes[name] = prime2;
            return prime2;
          };
          function Red(m2) {
            if (typeof m2 === "string") {
              var prime = BN2._prime(m2);
              this.m = prime.p;
              this.prime = prime;
            } else {
              assert2(m2.gtn(1), "modulus must be greater than 1");
              this.m = m2;
              this.prime = null;
            }
          }
          Red.prototype._verify1 = function _verify1(a2) {
            assert2(a2.negative === 0, "red works only with positives");
            assert2(a2.red, "red works only with red numbers");
          };
          Red.prototype._verify2 = function _verify2(a2, b2) {
            assert2((a2.negative | b2.negative) === 0, "red works only with positives");
            assert2(
              a2.red && a2.red === b2.red,
              "red works only with red numbers"
            );
          };
          Red.prototype.imod = function imod(a2) {
            if (this.prime)
              return this.prime.ireduce(a2)._forceRed(this);
            move(a2, a2.umod(this.m)._forceRed(this));
            return a2;
          };
          Red.prototype.neg = function neg2(a2) {
            if (a2.isZero()) {
              return a2.clone();
            }
            return this.m.sub(a2)._forceRed(this);
          };
          Red.prototype.add = function add2(a2, b2) {
            this._verify2(a2, b2);
            var res = a2.add(b2);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.iadd = function iadd(a2, b2) {
            this._verify2(a2, b2);
            var res = a2.iadd(b2);
            if (res.cmp(this.m) >= 0) {
              res.isub(this.m);
            }
            return res;
          };
          Red.prototype.sub = function sub2(a2, b2) {
            this._verify2(a2, b2);
            var res = a2.sub(b2);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Red.prototype.isub = function isub(a2, b2) {
            this._verify2(a2, b2);
            var res = a2.isub(b2);
            if (res.cmpn(0) < 0) {
              res.iadd(this.m);
            }
            return res;
          };
          Red.prototype.shl = function shl2(a2, num) {
            this._verify1(a2);
            return this.imod(a2.ushln(num));
          };
          Red.prototype.imul = function imul(a2, b2) {
            this._verify2(a2, b2);
            return this.imod(a2.imul(b2));
          };
          Red.prototype.mul = function mul2(a2, b2) {
            this._verify2(a2, b2);
            return this.imod(a2.mul(b2));
          };
          Red.prototype.isqr = function isqr(a2) {
            return this.imul(a2, a2.clone());
          };
          Red.prototype.sqr = function sqr(a2) {
            return this.mul(a2, a2);
          };
          Red.prototype.sqrt = function sqrt(a2) {
            if (a2.isZero())
              return a2.clone();
            var mod3 = this.m.andln(3);
            assert2(mod3 % 2 === 1);
            if (mod3 === 3) {
              var pow2 = this.m.add(new BN2(1)).iushrn(2);
              return this.pow(a2, pow2);
            }
            var q2 = this.m.subn(1);
            var s2 = 0;
            while (!q2.isZero() && q2.andln(1) === 0) {
              s2++;
              q2.iushrn(1);
            }
            assert2(!q2.isZero());
            var one2 = new BN2(1).toRed(this);
            var nOne = one2.redNeg();
            var lpow = this.m.subn(1).iushrn(1);
            var z2 = this.m.bitLength();
            z2 = new BN2(2 * z2 * z2).toRed(this);
            while (this.pow(z2, lpow).cmp(nOne) !== 0) {
              z2.redIAdd(nOne);
            }
            var c2 = this.pow(z2, q2);
            var r2 = this.pow(a2, q2.addn(1).iushrn(1));
            var t = this.pow(a2, q2);
            var m2 = s2;
            while (t.cmp(one2) !== 0) {
              var tmp = t;
              for (var i2 = 0; tmp.cmp(one2) !== 0; i2++) {
                tmp = tmp.redSqr();
              }
              assert2(i2 < m2);
              var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
              r2 = r2.redMul(b2);
              c2 = b2.redSqr();
              t = t.redMul(c2);
              m2 = i2;
            }
            return r2;
          };
          Red.prototype.invm = function invm(a2) {
            var inv = a2._invmp(this.m);
            if (inv.negative !== 0) {
              inv.negative = 0;
              return this.imod(inv).redNeg();
            } else {
              return this.imod(inv);
            }
          };
          Red.prototype.pow = function pow2(a2, num) {
            if (num.isZero())
              return new BN2(1).toRed(this);
            if (num.cmpn(1) === 0)
              return a2.clone();
            var windowSize = 4;
            var wnd = new Array(1 << windowSize);
            wnd[0] = new BN2(1).toRed(this);
            wnd[1] = a2;
            for (var i2 = 2; i2 < wnd.length; i2++) {
              wnd[i2] = this.mul(wnd[i2 - 1], a2);
            }
            var res = wnd[0];
            var current = 0;
            var currentLen = 0;
            var start = num.bitLength() % 26;
            if (start === 0) {
              start = 26;
            }
            for (i2 = num.length - 1; i2 >= 0; i2--) {
              var word = num.words[i2];
              for (var j2 = start - 1; j2 >= 0; j2--) {
                var bit = word >> j2 & 1;
                if (res !== wnd[0]) {
                  res = this.sqr(res);
                }
                if (bit === 0 && current === 0) {
                  currentLen = 0;
                  continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0))
                  continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
              }
              start = 26;
            }
            return res;
          };
          Red.prototype.convertTo = function convertTo(num) {
            var r2 = num.umod(this.m);
            return r2 === num ? r2.clone() : r2;
          };
          Red.prototype.convertFrom = function convertFrom(num) {
            var res = num.clone();
            res.red = null;
            return res;
          };
          BN2.mont = function mont(num) {
            return new Mont(num);
          };
          function Mont(m2) {
            Red.call(this, m2);
            this.shift = this.m.bitLength();
            if (this.shift % 26 !== 0) {
              this.shift += 26 - this.shift % 26;
            }
            this.r = new BN2(1).iushln(this.shift);
            this.r2 = this.imod(this.r.sqr());
            this.rinv = this.r._invmp(this.m);
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
            this.minv = this.minv.umod(this.r);
            this.minv = this.r.sub(this.minv);
          }
          inherits(Mont, Red);
          Mont.prototype.convertTo = function convertTo(num) {
            return this.imod(num.ushln(this.shift));
          };
          Mont.prototype.convertFrom = function convertFrom(num) {
            var r2 = this.imod(num.mul(this.rinv));
            r2.red = null;
            return r2;
          };
          Mont.prototype.imul = function imul(a2, b2) {
            if (a2.isZero() || b2.isZero()) {
              a2.words[0] = 0;
              a2.length = 1;
              return a2;
            }
            var t = a2.imul(b2);
            var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u2 = t.isub(c2).iushrn(this.shift);
            var res = u2;
            if (u2.cmp(this.m) >= 0) {
              res = u2.isub(this.m);
            } else if (u2.cmpn(0) < 0) {
              res = u2.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.mul = function mul2(a2, b2) {
            if (a2.isZero() || b2.isZero())
              return new BN2(0)._forceRed(this);
            var t = a2.mul(b2);
            var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
            var u2 = t.isub(c2).iushrn(this.shift);
            var res = u2;
            if (u2.cmp(this.m) >= 0) {
              res = u2.isub(this.m);
            } else if (u2.cmpn(0) < 0) {
              res = u2.iadd(this.m);
            }
            return res._forceRed(this);
          };
          Mont.prototype.invm = function invm(a2) {
            var res = this.imod(a2._invmp(this.m).mul(this.r2));
            return res._forceRed(this);
          };
        })(typeof module2 === "undefined" || module2, exports2);
      }
    });
    var require_sha3 = __commonJS2({
      "../../node_modules/js-sha3/src/sha3.js"(exports2, module2) {
        "use strict";
        (function() {
          "use strict";
          var INPUT_ERROR = "input is invalid type";
          var FINALIZE_ERROR = "finalize already called";
          var WINDOW = typeof window === "object";
          var root = WINDOW ? window : {};
          if (root.JS_SHA3_NO_WINDOW) {
            WINDOW = false;
          }
          var WEB_WORKER = !WINDOW && typeof self === "object";
          var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
          if (NODE_JS) {
            root = global;
          } else if (WEB_WORKER) {
            root = self;
          }
          var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
          var AMD = typeof define === "function" && define.amd;
          var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
          var HEX_CHARS = "0123456789abcdef".split("");
          var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
          var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
          var KECCAK_PADDING = [1, 256, 65536, 16777216];
          var PADDING = [6, 1536, 393216, 100663296];
          var SHIFT = [0, 8, 16, 24];
          var RC = [
            1,
            0,
            32898,
            0,
            32906,
            2147483648,
            2147516416,
            2147483648,
            32907,
            0,
            2147483649,
            0,
            2147516545,
            2147483648,
            32777,
            2147483648,
            138,
            0,
            136,
            0,
            2147516425,
            0,
            2147483658,
            0,
            2147516555,
            0,
            139,
            2147483648,
            32905,
            2147483648,
            32771,
            2147483648,
            32770,
            2147483648,
            128,
            2147483648,
            32778,
            0,
            2147483658,
            2147483648,
            2147516545,
            2147483648,
            32896,
            2147483648,
            2147483649,
            0,
            2147516424,
            2147483648
          ];
          var BITS = [224, 256, 384, 512];
          var SHAKE_BITS = [128, 256];
          var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
          var CSHAKE_BYTEPAD = {
            "128": 168,
            "256": 136
          };
          if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
            Array.isArray = function(obj) {
              return Object.prototype.toString.call(obj) === "[object Array]";
            };
          }
          if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
            ArrayBuffer.isView = function(obj) {
              return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
            };
          }
          var createOutputMethod = function(bits22, padding, outputType) {
            return function(message) {
              return new Keccak(bits22, padding, bits22).update(message)[outputType]();
            };
          };
          var createShakeOutputMethod = function(bits22, padding, outputType) {
            return function(message, outputBits) {
              return new Keccak(bits22, padding, outputBits).update(message)[outputType]();
            };
          };
          var createCshakeOutputMethod = function(bits22, padding, outputType) {
            return function(message, outputBits, n, s2) {
              return methods["cshake" + bits22].update(message, outputBits, n, s2)[outputType]();
            };
          };
          var createKmacOutputMethod = function(bits22, padding, outputType) {
            return function(key, message, outputBits, s2) {
              return methods["kmac" + bits22].update(key, message, outputBits, s2)[outputType]();
            };
          };
          var createOutputMethods = function(method, createMethod2, bits22, padding) {
            for (var i22 = 0; i22 < OUTPUT_TYPES.length; ++i22) {
              var type = OUTPUT_TYPES[i22];
              method[type] = createMethod2(bits22, padding, type);
            }
            return method;
          };
          var createMethod = function(bits22, padding) {
            var method = createOutputMethod(bits22, padding, "hex");
            method.create = function() {
              return new Keccak(bits22, padding, bits22);
            };
            method.update = function(message) {
              return method.create().update(message);
            };
            return createOutputMethods(method, createOutputMethod, bits22, padding);
          };
          var createShakeMethod = function(bits22, padding) {
            var method = createShakeOutputMethod(bits22, padding, "hex");
            method.create = function(outputBits) {
              return new Keccak(bits22, padding, outputBits);
            };
            method.update = function(message, outputBits) {
              return method.create(outputBits).update(message);
            };
            return createOutputMethods(method, createShakeOutputMethod, bits22, padding);
          };
          var createCshakeMethod = function(bits22, padding) {
            var w2 = CSHAKE_BYTEPAD[bits22];
            var method = createCshakeOutputMethod(bits22, padding, "hex");
            method.create = function(outputBits, n, s2) {
              if (!n && !s2) {
                return methods["shake" + bits22].create(outputBits);
              } else {
                return new Keccak(bits22, padding, outputBits).bytepad([n, s2], w2);
              }
            };
            method.update = function(message, outputBits, n, s2) {
              return method.create(outputBits, n, s2).update(message);
            };
            return createOutputMethods(method, createCshakeOutputMethod, bits22, padding);
          };
          var createKmacMethod = function(bits22, padding) {
            var w2 = CSHAKE_BYTEPAD[bits22];
            var method = createKmacOutputMethod(bits22, padding, "hex");
            method.create = function(key, outputBits, s2) {
              return new Kmac(bits22, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
            };
            method.update = function(key, message, outputBits, s2) {
              return method.create(key, outputBits, s2).update(message);
            };
            return createOutputMethods(method, createKmacOutputMethod, bits22, padding);
          };
          var algorithms = [
            { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
            { name: "sha3", padding: PADDING, bits: BITS, createMethod },
            { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
            { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
            { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
          ];
          var methods = {}, methodNames = [];
          for (var i2 = 0; i2 < algorithms.length; ++i2) {
            var algorithm = algorithms[i2];
            var bits2 = algorithm.bits;
            for (var j2 = 0; j2 < bits2.length; ++j2) {
              var methodName = algorithm.name + "_" + bits2[j2];
              methodNames.push(methodName);
              methods[methodName] = algorithm.createMethod(bits2[j2], algorithm.padding);
              if (algorithm.name !== "sha3") {
                var newMethodName = algorithm.name + bits2[j2];
                methodNames.push(newMethodName);
                methods[newMethodName] = methods[methodName];
              }
            }
          }
          function Keccak(bits22, padding, outputBits) {
            this.blocks = [];
            this.s = [];
            this.padding = padding;
            this.outputBits = outputBits;
            this.reset = true;
            this.finalized = false;
            this.block = 0;
            this.start = 0;
            this.blockCount = 1600 - (bits22 << 1) >> 5;
            this.byteCount = this.blockCount << 2;
            this.outputBlocks = outputBits >> 5;
            this.extraBytes = (outputBits & 31) >> 3;
            for (var i22 = 0; i22 < 50; ++i22) {
              this.s[i22] = 0;
            }
          }
          Keccak.prototype.update = function(message) {
            if (this.finalized) {
              throw new Error(FINALIZE_ERROR);
            }
            var notString, type = typeof message;
            if (type !== "string") {
              if (type === "object") {
                if (message === null) {
                  throw new Error(INPUT_ERROR);
                } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                  message = new Uint8Array(message);
                } else if (!Array.isArray(message)) {
                  if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                    throw new Error(INPUT_ERROR);
                  }
                }
              } else {
                throw new Error(INPUT_ERROR);
              }
              notString = true;
            }
            var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i22, code;
            while (index < length2) {
              if (this.reset) {
                this.reset = false;
                blocks[0] = this.block;
                for (i22 = 1; i22 < blockCount + 1; ++i22) {
                  blocks[i22] = 0;
                }
              }
              if (notString) {
                for (i22 = this.start; index < length2 && i22 < byteCount; ++index) {
                  blocks[i22 >> 2] |= message[index] << SHIFT[i22++ & 3];
                }
              } else {
                for (i22 = this.start; index < length2 && i22 < byteCount; ++index) {
                  code = message.charCodeAt(index);
                  if (code < 128) {
                    blocks[i22 >> 2] |= code << SHIFT[i22++ & 3];
                  } else if (code < 2048) {
                    blocks[i22 >> 2] |= (192 | code >> 6) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
                  } else if (code < 55296 || code >= 57344) {
                    blocks[i22 >> 2] |= (224 | code >> 12) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
                  } else {
                    code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                    blocks[i22 >> 2] |= (240 | code >> 18) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i22++ & 3];
                    blocks[i22 >> 2] |= (128 | code & 63) << SHIFT[i22++ & 3];
                  }
                }
              }
              this.lastByteIndex = i22;
              if (i22 >= byteCount) {
                this.start = i22 - byteCount;
                this.block = blocks[blockCount];
                for (i22 = 0; i22 < blockCount; ++i22) {
                  s2[i22] ^= blocks[i22];
                }
                f2(s2);
                this.reset = true;
              } else {
                this.start = i22;
              }
            }
            return this;
          };
          Keccak.prototype.encode = function(x2, right) {
            var o2 = x2 & 255, n = 1;
            var bytes = [o2];
            x2 = x2 >> 8;
            o2 = x2 & 255;
            while (o2 > 0) {
              bytes.unshift(o2);
              x2 = x2 >> 8;
              o2 = x2 & 255;
              ++n;
            }
            if (right) {
              bytes.push(n);
            } else {
              bytes.unshift(n);
            }
            this.update(bytes);
            return bytes.length;
          };
          Keccak.prototype.encodeString = function(str) {
            var notString, type = typeof str;
            if (type !== "string") {
              if (type === "object") {
                if (str === null) {
                  throw new Error(INPUT_ERROR);
                } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                  str = new Uint8Array(str);
                } else if (!Array.isArray(str)) {
                  if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                    throw new Error(INPUT_ERROR);
                  }
                }
              } else {
                throw new Error(INPUT_ERROR);
              }
              notString = true;
            }
            var bytes = 0, length2 = str.length;
            if (notString) {
              bytes = length2;
            } else {
              for (var i22 = 0; i22 < str.length; ++i22) {
                var code = str.charCodeAt(i22);
                if (code < 128) {
                  bytes += 1;
                } else if (code < 2048) {
                  bytes += 2;
                } else if (code < 55296 || code >= 57344) {
                  bytes += 3;
                } else {
                  code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i22) & 1023);
                  bytes += 4;
                }
              }
            }
            bytes += this.encode(bytes * 8);
            this.update(str);
            return bytes;
          };
          Keccak.prototype.bytepad = function(strs, w2) {
            var bytes = this.encode(w2);
            for (var i22 = 0; i22 < strs.length; ++i22) {
              bytes += this.encodeString(strs[i22]);
            }
            var paddingBytes = w2 - bytes % w2;
            var zeros = [];
            zeros.length = paddingBytes;
            this.update(zeros);
            return this;
          };
          Keccak.prototype.finalize = function() {
            if (this.finalized) {
              return;
            }
            this.finalized = true;
            var blocks = this.blocks, i22 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
            blocks[i22 >> 2] |= this.padding[i22 & 3];
            if (this.lastByteIndex === this.byteCount) {
              blocks[0] = blocks[blockCount];
              for (i22 = 1; i22 < blockCount + 1; ++i22) {
                blocks[i22] = 0;
              }
            }
            blocks[blockCount - 1] |= 2147483648;
            for (i22 = 0; i22 < blockCount; ++i22) {
              s2[i22] ^= blocks[i22];
            }
            f2(s2);
          };
          Keccak.prototype.toString = Keccak.prototype.hex = function() {
            this.finalize();
            var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
            var hex2 = "", block;
            while (j22 < outputBlocks) {
              for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
                block = s2[i22];
                hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
              }
              if (j22 % blockCount === 0) {
                f2(s2);
                i22 = 0;
              }
            }
            if (extraBytes) {
              block = s2[i22];
              hex2 += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
              if (extraBytes > 1) {
                hex2 += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
              }
              if (extraBytes > 2) {
                hex2 += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
              }
            }
            return hex2;
          };
          Keccak.prototype.arrayBuffer = function() {
            this.finalize();
            var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
            var bytes = this.outputBits >> 3;
            var buffer;
            if (extraBytes) {
              buffer = new ArrayBuffer(outputBlocks + 1 << 2);
            } else {
              buffer = new ArrayBuffer(bytes);
            }
            var array = new Uint32Array(buffer);
            while (j22 < outputBlocks) {
              for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
                array[j22] = s2[i22];
              }
              if (j22 % blockCount === 0) {
                f2(s2);
              }
            }
            if (extraBytes) {
              array[i22] = s2[i22];
              buffer = buffer.slice(0, bytes);
            }
            return buffer;
          };
          Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
          Keccak.prototype.digest = Keccak.prototype.array = function() {
            this.finalize();
            var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i22 = 0, j22 = 0;
            var array = [], offset, block;
            while (j22 < outputBlocks) {
              for (i22 = 0; i22 < blockCount && j22 < outputBlocks; ++i22, ++j22) {
                offset = j22 << 2;
                block = s2[i22];
                array[offset] = block & 255;
                array[offset + 1] = block >> 8 & 255;
                array[offset + 2] = block >> 16 & 255;
                array[offset + 3] = block >> 24 & 255;
              }
              if (j22 % blockCount === 0) {
                f2(s2);
              }
            }
            if (extraBytes) {
              offset = j22 << 2;
              block = s2[i22];
              array[offset] = block & 255;
              if (extraBytes > 1) {
                array[offset + 1] = block >> 8 & 255;
              }
              if (extraBytes > 2) {
                array[offset + 2] = block >> 16 & 255;
              }
            }
            return array;
          };
          function Kmac(bits22, padding, outputBits) {
            Keccak.call(this, bits22, padding, outputBits);
          }
          Kmac.prototype = new Keccak();
          Kmac.prototype.finalize = function() {
            this.encode(this.outputBits, true);
            return Keccak.prototype.finalize.call(this);
          };
          var f2 = function(s2) {
            var h, l2, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
            for (n = 0; n < 48; n += 2) {
              c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
              c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
              c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
              c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
              c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
              c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
              c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
              c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
              c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
              c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
              h = c8 ^ (c2 << 1 | c3 >>> 31);
              l2 = c9 ^ (c3 << 1 | c2 >>> 31);
              s2[0] ^= h;
              s2[1] ^= l2;
              s2[10] ^= h;
              s2[11] ^= l2;
              s2[20] ^= h;
              s2[21] ^= l2;
              s2[30] ^= h;
              s2[31] ^= l2;
              s2[40] ^= h;
              s2[41] ^= l2;
              h = c0 ^ (c4 << 1 | c5 >>> 31);
              l2 = c1 ^ (c5 << 1 | c4 >>> 31);
              s2[2] ^= h;
              s2[3] ^= l2;
              s2[12] ^= h;
              s2[13] ^= l2;
              s2[22] ^= h;
              s2[23] ^= l2;
              s2[32] ^= h;
              s2[33] ^= l2;
              s2[42] ^= h;
              s2[43] ^= l2;
              h = c2 ^ (c6 << 1 | c7 >>> 31);
              l2 = c3 ^ (c7 << 1 | c6 >>> 31);
              s2[4] ^= h;
              s2[5] ^= l2;
              s2[14] ^= h;
              s2[15] ^= l2;
              s2[24] ^= h;
              s2[25] ^= l2;
              s2[34] ^= h;
              s2[35] ^= l2;
              s2[44] ^= h;
              s2[45] ^= l2;
              h = c4 ^ (c8 << 1 | c9 >>> 31);
              l2 = c5 ^ (c9 << 1 | c8 >>> 31);
              s2[6] ^= h;
              s2[7] ^= l2;
              s2[16] ^= h;
              s2[17] ^= l2;
              s2[26] ^= h;
              s2[27] ^= l2;
              s2[36] ^= h;
              s2[37] ^= l2;
              s2[46] ^= h;
              s2[47] ^= l2;
              h = c6 ^ (c0 << 1 | c1 >>> 31);
              l2 = c7 ^ (c1 << 1 | c0 >>> 31);
              s2[8] ^= h;
              s2[9] ^= l2;
              s2[18] ^= h;
              s2[19] ^= l2;
              s2[28] ^= h;
              s2[29] ^= l2;
              s2[38] ^= h;
              s2[39] ^= l2;
              s2[48] ^= h;
              s2[49] ^= l2;
              b0 = s2[0];
              b1 = s2[1];
              b32 = s2[11] << 4 | s2[10] >>> 28;
              b33 = s2[10] << 4 | s2[11] >>> 28;
              b14 = s2[20] << 3 | s2[21] >>> 29;
              b15 = s2[21] << 3 | s2[20] >>> 29;
              b46 = s2[31] << 9 | s2[30] >>> 23;
              b47 = s2[30] << 9 | s2[31] >>> 23;
              b28 = s2[40] << 18 | s2[41] >>> 14;
              b29 = s2[41] << 18 | s2[40] >>> 14;
              b20 = s2[2] << 1 | s2[3] >>> 31;
              b21 = s2[3] << 1 | s2[2] >>> 31;
              b2 = s2[13] << 12 | s2[12] >>> 20;
              b3 = s2[12] << 12 | s2[13] >>> 20;
              b34 = s2[22] << 10 | s2[23] >>> 22;
              b35 = s2[23] << 10 | s2[22] >>> 22;
              b16 = s2[33] << 13 | s2[32] >>> 19;
              b17 = s2[32] << 13 | s2[33] >>> 19;
              b48 = s2[42] << 2 | s2[43] >>> 30;
              b49 = s2[43] << 2 | s2[42] >>> 30;
              b40 = s2[5] << 30 | s2[4] >>> 2;
              b41 = s2[4] << 30 | s2[5] >>> 2;
              b22 = s2[14] << 6 | s2[15] >>> 26;
              b23 = s2[15] << 6 | s2[14] >>> 26;
              b4 = s2[25] << 11 | s2[24] >>> 21;
              b5 = s2[24] << 11 | s2[25] >>> 21;
              b36 = s2[34] << 15 | s2[35] >>> 17;
              b37 = s2[35] << 15 | s2[34] >>> 17;
              b18 = s2[45] << 29 | s2[44] >>> 3;
              b19 = s2[44] << 29 | s2[45] >>> 3;
              b10 = s2[6] << 28 | s2[7] >>> 4;
              b11 = s2[7] << 28 | s2[6] >>> 4;
              b42 = s2[17] << 23 | s2[16] >>> 9;
              b43 = s2[16] << 23 | s2[17] >>> 9;
              b24 = s2[26] << 25 | s2[27] >>> 7;
              b25 = s2[27] << 25 | s2[26] >>> 7;
              b6 = s2[36] << 21 | s2[37] >>> 11;
              b7 = s2[37] << 21 | s2[36] >>> 11;
              b38 = s2[47] << 24 | s2[46] >>> 8;
              b39 = s2[46] << 24 | s2[47] >>> 8;
              b30 = s2[8] << 27 | s2[9] >>> 5;
              b31 = s2[9] << 27 | s2[8] >>> 5;
              b12 = s2[18] << 20 | s2[19] >>> 12;
              b13 = s2[19] << 20 | s2[18] >>> 12;
              b44 = s2[29] << 7 | s2[28] >>> 25;
              b45 = s2[28] << 7 | s2[29] >>> 25;
              b26 = s2[38] << 8 | s2[39] >>> 24;
              b27 = s2[39] << 8 | s2[38] >>> 24;
              b8 = s2[48] << 14 | s2[49] >>> 18;
              b9 = s2[49] << 14 | s2[48] >>> 18;
              s2[0] = b0 ^ ~b2 & b4;
              s2[1] = b1 ^ ~b3 & b5;
              s2[10] = b10 ^ ~b12 & b14;
              s2[11] = b11 ^ ~b13 & b15;
              s2[20] = b20 ^ ~b22 & b24;
              s2[21] = b21 ^ ~b23 & b25;
              s2[30] = b30 ^ ~b32 & b34;
              s2[31] = b31 ^ ~b33 & b35;
              s2[40] = b40 ^ ~b42 & b44;
              s2[41] = b41 ^ ~b43 & b45;
              s2[2] = b2 ^ ~b4 & b6;
              s2[3] = b3 ^ ~b5 & b7;
              s2[12] = b12 ^ ~b14 & b16;
              s2[13] = b13 ^ ~b15 & b17;
              s2[22] = b22 ^ ~b24 & b26;
              s2[23] = b23 ^ ~b25 & b27;
              s2[32] = b32 ^ ~b34 & b36;
              s2[33] = b33 ^ ~b35 & b37;
              s2[42] = b42 ^ ~b44 & b46;
              s2[43] = b43 ^ ~b45 & b47;
              s2[4] = b4 ^ ~b6 & b8;
              s2[5] = b5 ^ ~b7 & b9;
              s2[14] = b14 ^ ~b16 & b18;
              s2[15] = b15 ^ ~b17 & b19;
              s2[24] = b24 ^ ~b26 & b28;
              s2[25] = b25 ^ ~b27 & b29;
              s2[34] = b34 ^ ~b36 & b38;
              s2[35] = b35 ^ ~b37 & b39;
              s2[44] = b44 ^ ~b46 & b48;
              s2[45] = b45 ^ ~b47 & b49;
              s2[6] = b6 ^ ~b8 & b0;
              s2[7] = b7 ^ ~b9 & b1;
              s2[16] = b16 ^ ~b18 & b10;
              s2[17] = b17 ^ ~b19 & b11;
              s2[26] = b26 ^ ~b28 & b20;
              s2[27] = b27 ^ ~b29 & b21;
              s2[36] = b36 ^ ~b38 & b30;
              s2[37] = b37 ^ ~b39 & b31;
              s2[46] = b46 ^ ~b48 & b40;
              s2[47] = b47 ^ ~b49 & b41;
              s2[8] = b8 ^ ~b0 & b2;
              s2[9] = b9 ^ ~b1 & b3;
              s2[18] = b18 ^ ~b10 & b12;
              s2[19] = b19 ^ ~b11 & b13;
              s2[28] = b28 ^ ~b20 & b22;
              s2[29] = b29 ^ ~b21 & b23;
              s2[38] = b38 ^ ~b30 & b32;
              s2[39] = b39 ^ ~b31 & b33;
              s2[48] = b48 ^ ~b40 & b42;
              s2[49] = b49 ^ ~b41 & b43;
              s2[0] ^= RC[n];
              s2[1] ^= RC[n + 1];
            }
          };
          if (COMMON_JS) {
            module2.exports = methods;
          } else {
            for (i2 = 0; i2 < methodNames.length; ++i2) {
              root[methodNames[i2]] = methods[methodNames[i2]];
            }
            if (AMD) {
              define(function() {
                return methods;
              });
            }
          }
        })();
      }
    });
    var src_exports = {};
    __export2(src_exports, {
      AnonAadhaarCore: () => AnonAadhaarCore,
      AnonAadhaarCorePackage: () => AnonAadhaarCorePackage,
      AnonAadhaarTypeName: () => AnonAadhaarTypeName,
      ArtifactsOrigin: () => ArtifactsOrigin,
      CIRCOM_FIELD_P: () => CIRCOM_FIELD_P,
      IdFields: () => IdFields,
      ProverState: () => ProverState,
      artifactUrls: () => artifactUrls,
      compressByteArray: () => compressByteArray,
      convertBigIntToByteArray: () => convertBigIntToByteArray,
      convertByteArrayToBigInt: () => convertByteArrayToBigInt,
      convertRevealBigIntToString: () => convertRevealBigIntToString,
      createCustomV2TestData: () => createCustomV2TestData,
      dateToUnixTimestamp: () => dateToUnixTimestamp,
      decompressByteArray: () => decompressByteArray,
      deserialize: () => deserialize,
      extractFieldByIndex: () => extractFieldByIndex,
      extractPhoto: () => extractPhoto,
      fetchPublicKey: () => fetchPublicKey,
      fieldsLabel: () => fieldsLabel,
      generateArgs: () => generateArgs,
      getDisplayOptions: () => getDisplayOptions,
      getEndIndex: () => getEndIndex,
      getRandomBytes: () => getRandomBytes3,
      handleError: () => handleError,
      hash: () => hash2,
      init: () => init,
      packGroth16Proof: () => packGroth16Proof,
      productionPublicKeyHash: () => productionPublicKeyHash,
      prove: () => prove,
      rawDataToCompressedQR: () => rawDataToCompressedQR,
      readData: () => readData,
      replaceBytesBetween: () => replaceBytesBetween,
      retrieveFileExtension: () => retrieveFileExtension,
      returnFullId: () => returnFullId,
      returnNewDateString: () => returnNewDateString,
      searchZkeyChunks: () => searchZkeyChunks,
      serialize: () => serialize2,
      splitToWords: () => splitToWords,
      testCertificateUrl: () => testCertificateUrl,
      testPublicKeyHash: () => testPublicKeyHash,
      timestampToUTCUnix: () => timestampToUTCUnix,
      verify: () => verify2
    });
    module.exports = __toCommonJS2(src_exports);
    var AnonAadhaarTypeName = "anon-aadhaar";
    var ArtifactsOrigin = ((ArtifactsOrigin2) => {
      ArtifactsOrigin2[ArtifactsOrigin2["server"] = 0] = "server";
      ArtifactsOrigin2[ArtifactsOrigin2["local"] = 1] = "local";
      ArtifactsOrigin2[ArtifactsOrigin2["chunked"] = 2] = "chunked";
      return ArtifactsOrigin2;
    })(ArtifactsOrigin || {});
    var ProverState = ((ProverState3) => {
      ProverState3["Initializing"] = "initializing";
      ProverState3["FetchingWasm"] = "fetching-wasm";
      ProverState3["FetchingZkey"] = "fetching-zkey";
      ProverState3["Proving"] = "proving";
      ProverState3["Completed"] = "completed";
      ProverState3["Error"] = "error";
      return ProverState3;
    })(ProverState || {});
    var fieldsLabel = [
      { key: "revealAgeAbove18", label: "Age Above 18" },
      { key: "revealGender", label: "Gender" },
      { key: "revealPinCode", label: "PIN Code" },
      { key: "revealState", label: "State" }
    ];
    var import_uuid = require_commonjs_browser();
    var import_snarkjs2 = (init_browser_esm2(), __toCommonJS(browser_esm_exports));
    var import_json_bigint = __toESM2(require_json_bigint());
    var import_snarkjs = (init_browser_esm2(), __toCommonJS(browser_esm_exports));
    var import_localforage = __toESM2(require_localforage());
    var storageService = {
      setItem(key, value) {
        return __async(this, null, function* () {
          return yield import_localforage.default.setItem(key, value);
        });
      },
      getItem(key) {
        return __async(this, null, function* () {
          return yield import_localforage.default.getItem(key);
        });
      }
    };
    var import_pako = __toESM2(require_pako());
    var handleError = (error, defaultMessage) => {
      if (error instanceof Error)
        return error;
      let stringified = defaultMessage;
      try {
        stringified = JSON.stringify(error);
      } catch (e2) {
      }
      const err = new Error(
        `This value was thrown as is, not through an Error: ${stringified}`
      );
      return err;
    };
    function splitToWords(number, wordsize, numberElement) {
      let t = number;
      const words = [];
      for (let i2 = BigInt(0); i2 < numberElement; ++i2) {
        const baseTwo = BigInt(2);
        words.push(`${t % BigInt(Math.pow(Number(baseTwo), Number(wordsize)))}`);
        t = BigInt(t / BigInt(Math.pow(Number(BigInt(2)), Number(wordsize))));
      }
      if (!(t == BigInt(0))) {
        throw `Number ${number} does not fit in ${(wordsize * numberElement).toString()} bits`;
      }
      return words;
    }
    function packGroth16Proof(groth16Proof) {
      return [
        groth16Proof.pi_a[0],
        groth16Proof.pi_a[1],
        groth16Proof.pi_b[0][1],
        groth16Proof.pi_b[0][0],
        groth16Proof.pi_b[1][1],
        groth16Proof.pi_b[1][0],
        groth16Proof.pi_c[0],
        groth16Proof.pi_c[1]
      ];
    }
    var fetchPublicKey = (certUrl) => __async(void 0, null, function* () {
      try {
        const response = yield fetch(
          `https://nodejs-serverless-function-express-eight-iota.vercel.app/api/get-public-key?url=${certUrl}`
        );
        if (!response.ok) {
          throw new Error(`Failed to fetch public key from server`);
        }
        const publicKeyData = yield response.json();
        return publicKeyData.publicKey || null;
      } catch (error) {
        console.error("Error fetching public key:", error);
        return null;
      }
    });
    function convertBigIntToByteArray(bigInt) {
      const byteLength2 = Math.max(1, Math.ceil(bigInt.toString(2).length / 8));
      const result = new Uint8Array(byteLength2);
      let i2 = 0;
      while (bigInt > 0) {
        result[i2] = Number(bigInt % BigInt(256));
        bigInt = bigInt / BigInt(256);
        i2 += 1;
      }
      return result.reverse();
    }
    function convertRevealBigIntToString(input) {
      if (typeof input === "string")
        input = BigInt(input);
      let result = "";
      while (input > 0) {
        result += String.fromCharCode(Number(input % BigInt(256)));
        input = input / BigInt(256);
      }
      return result;
    }
    function decompressByteArray(byteArray) {
      const decompressedArray = import_pako.default.inflate(byteArray);
      return decompressedArray;
    }
    var IdFields = ((IdFields2) => {
      IdFields2[IdFields2["Email_mobile_present_bit_indicator_value"] = 0] = "Email_mobile_present_bit_indicator_value";
      IdFields2[IdFields2["ReferenceId"] = 1] = "ReferenceId";
      IdFields2[IdFields2["Name"] = 2] = "Name";
      IdFields2[IdFields2["DOB"] = 3] = "DOB";
      IdFields2[IdFields2["Gender"] = 4] = "Gender";
      IdFields2[IdFields2["CareOf"] = 5] = "CareOf";
      IdFields2[IdFields2["District"] = 6] = "District";
      IdFields2[IdFields2["Landmark"] = 7] = "Landmark";
      IdFields2[IdFields2["House"] = 8] = "House";
      IdFields2[IdFields2["Location"] = 9] = "Location";
      IdFields2[IdFields2["PinCode"] = 10] = "PinCode";
      IdFields2[IdFields2["PostOffice"] = 11] = "PostOffice";
      IdFields2[IdFields2["State"] = 12] = "State";
      IdFields2[IdFields2["Street"] = 13] = "Street";
      IdFields2[IdFields2["SubDistrict"] = 14] = "SubDistrict";
      IdFields2[IdFields2["VTC"] = 15] = "VTC";
      IdFields2[IdFields2["PhoneNumberLast4"] = 16] = "PhoneNumberLast4";
      return IdFields2;
    })(IdFields || {});
    function readData(data, index) {
      let count = 0;
      let start = 0;
      let end = data.indexOf(255, start);
      while (count != index) {
        start = end + 1;
        end = data.indexOf(255, start);
        count++;
      }
      return data.slice(start, end);
    }
    function extractPhoto(qrDataPadded, dataLength) {
      let begin = 0;
      for (let i2 = 0; i2 < 18; ++i2) {
        begin = qrDataPadded.indexOf(255, begin + 1);
      }
      return {
        begin,
        dataLength,
        bytes: qrDataPadded.slice(begin + 1, dataLength)
      };
    }
    var searchZkeyChunks = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (zkeyPath, storageService2 = storageService) {
      const filePromises = [];
      for (let i2 = 0; i2 < 10; i2++) {
        const fileName = `circuit_final_${i2}.zkey`;
        const item = yield storageService2.getItem(fileName);
        if (item) {
          continue;
        }
        filePromises.push(
          downloadAndStoreCompressedZkeyChunks(
            zkeyPath,
            i2,
            fileName,
            storageService2
          )
        );
      }
      yield Promise.all(filePromises);
    });
    var downloadAndStoreCompressedZkeyChunks = (_0, _1, _2, ..._3) => __async(void 0, [_0, _1, _2, ..._3], function* (zkeyPath, index, fileName, storageService2 = storageService) {
      try {
        const response = yield fetch(zkeyPath + `/circuit_final_${index}.gz`);
        if (!response.ok)
          throw Error("Error while fetching compressed chunked zkey");
        const compressedChunk = yield response.arrayBuffer();
        const uncompressedChunk = import_pako.default.ungzip(compressedChunk);
        yield storageService2.setItem(fileName, uncompressedChunk);
      } catch (e2) {
        handleError(e2, "Error while dowloading the zkey chunks");
      }
    });
    var retrieveFileExtension = (str) => {
      const parsedUrl = new URL(str);
      const fileExtension = parsedUrl.pathname.substring(
        parsedUrl.pathname.lastIndexOf(".") + 1
      );
      return fileExtension;
    };
    function getRandomBytes3(length2) {
      const array = new Uint8Array(length2);
      for (let i2 = 0; i2 < length2; i2++) {
        array[i2] = Math.floor(Math.random() * 256);
      }
      return array;
    }
    var loadZkeyChunks = (_0, ..._1) => __async(void 0, [_0, ..._1], function* (zkeyUrl, storageService2 = storageService) {
      try {
        yield searchZkeyChunks(zkeyUrl, storageService2);
      } catch (e2) {
        handleError(e2, "Error while searching for the zkey chunks");
      }
      const buffers = [];
      try {
        for (let i2 = 0; i2 < 10; i2++) {
          const fileName = `circuit_final_${i2}.zkey`;
          const item = yield storageService2.getItem(fileName);
          if (!item)
            throw Error(`${fileName} missing in LocalForage!`);
          buffers.push(item);
        }
      } catch (e2) {
        handleError(e2, "Error while retrieving zkey chunks from localforage");
      }
      const totalLength = buffers.reduce((acc, val) => acc + val.length, 0);
      const zkey2 = new Uint8Array(totalLength);
      let offset = 0;
      for (const array of buffers) {
        zkey2.set(array, offset);
        offset += array.length;
      }
      return zkey2;
    });
    function fetchKey(keyURL, maxRetries = 3) {
      return __async(this, null, function* () {
        let attempts = 0;
        while (attempts < maxRetries) {
          try {
            const response = yield fetch(keyURL);
            if (!response.ok) {
              throw new Error(
                `Error while fetching ${retrieveFileExtension(
                  keyURL
                )} artifacts from prover: ${response.statusText}`
              );
            }
            const data = yield response.arrayBuffer();
            return data;
          } catch (error) {
            attempts++;
            if (attempts >= maxRetries) {
              throw error;
            }
            yield new Promise((resolve) => setTimeout(resolve, 1e3 * attempts));
          }
        }
        return keyURL;
      });
    }
    var KeyPath = class {
      constructor(keyURL, ArtifactsOrigin2) {
        this.keyURL = keyURL;
        this.artifactsOrigin = ArtifactsOrigin2;
      }
      getKey() {
        return __async(this, null, function* () {
          switch (this.artifactsOrigin) {
            case 1:
              return this.keyURL;
            case 0:
              return yield fetchKey(this.keyURL);
            case 2:
              return yield loadZkeyChunks(this.keyURL);
          }
        });
      }
    };
    var AnonAadhaarProver = class {
      constructor(wasmURL, zkey2, proverType) {
        this.wasm = new KeyPath(
          wasmURL,
          proverType === 2 ? 0 : proverType
        );
        this.zkey = new KeyPath(zkey2, proverType);
        this.proverType = proverType;
      }
      proving(witness, updateState) {
        return __async(this, null, function* () {
          let wasmBuffer;
          let zkeyBuffer;
          switch (this.proverType) {
            case 1:
              if (updateState)
                updateState(
                  "fetching-wasm"
                  /* FetchingWasm */
                );
              wasmBuffer = yield this.wasm.getKey();
              if (updateState)
                updateState(
                  "fetching-zkey"
                  /* FetchingZkey */
                );
              zkeyBuffer = yield this.zkey.getKey();
              break;
            case 0:
              if (updateState)
                updateState(
                  "fetching-wasm"
                  /* FetchingWasm */
                );
              wasmBuffer = new Uint8Array(yield this.wasm.getKey());
              if (updateState)
                updateState(
                  "fetching-zkey"
                  /* FetchingZkey */
                );
              zkeyBuffer = new Uint8Array(yield this.zkey.getKey());
              break;
            case 2:
              if (updateState)
                updateState(
                  "fetching-wasm"
                  /* FetchingWasm */
                );
              wasmBuffer = new Uint8Array(yield this.wasm.getKey());
              if (updateState)
                updateState(
                  "fetching-zkey"
                  /* FetchingZkey */
                );
              zkeyBuffer = yield this.zkey.getKey();
              break;
          }
          const input = {
            qrDataPadded: witness.qrDataPadded.value,
            qrDataPaddedLength: witness.qrDataPaddedLength.value,
            delimiterIndices: witness.delimiterIndices.value,
            signature: witness.signature.value,
            pubKey: witness.pubKey.value,
            nullifierSeed: witness.nullifierSeed.value,
            signalHash: witness.signalHash.value,
            revealAgeAbove18: witness.revealAgeAbove18.value,
            revealGender: witness.revealGender.value,
            revealPinCode: witness.revealPinCode.value,
            revealState: witness.revealState.value
          };
          if (updateState)
            updateState(
              "proving"
              /* Proving */
            );
          let result;
          try {
            result = yield import_snarkjs.groth16.fullProve(input, wasmBuffer, zkeyBuffer);
          } catch (e2) {
            console.error(e2);
            if (updateState)
              updateState(
                "error"
                /* Error */
              );
            throw new Error("[AnonAAdhaarProver]: Error while generating the proof");
          }
          const proof = result.proof;
          const publicSignals = result.publicSignals;
          if (updateState)
            updateState(
              "completed"
              /* Completed */
            );
          return {
            groth16Proof: proof,
            pubkeyHash: publicSignals[0],
            timestamp: publicSignals[2],
            nullifierSeed: witness.nullifierSeed.value,
            nullifier: publicSignals[1],
            signalHash: witness.signalHash.value,
            ageAbove18: publicSignals[3],
            gender: publicSignals[4],
            pincode: publicSignals[5],
            state: publicSignals[6]
          };
        });
      }
    };
    var artifactUrls = {
      V1: {
        wasm: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/aadhaar-verifier.wasm",
        zkey: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/circuit_final.zkey",
        vk: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/vkey.json",
        chunked: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v1.0.0/chunked_zkey"
      },
      v2: {
        wasm: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/aadhaar-verifier.wasm",
        zkey: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/circuit_final.zkey",
        vk: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/vkey.json",
        chunked: "https://anon-aadhaar-artifacts.s3.eu-central-1.amazonaws.com/v2.0.0/chunked_zkey"
      }
      // test: {
      //   wasm: BaseUrlArtifacts.Test + Artifacts.WASM_URL,
      //   zkey: BaseUrlArtifacts.Test + Artifacts.ZKEY_URL,
      //   vk: BaseUrlArtifacts.Test + Artifacts.VK_URL,
      //   chunked: BaseUrlArtifacts.Test + Artifacts.ZKEY_CHUNKS,
      // },
      // staging: {
      //   wasm: BaseUrlArtifacts.Test + Artifacts.WASM_URL,
      //   zkey: BaseUrlArtifacts.Staging + Artifacts.ZKEY_CHUNKS,
      //   vk: BaseUrlArtifacts.Test + Artifacts.VK_URL,
      // },
    };
    var testCertificateUrl = "https://anon-aadhaar.s3.ap-south-1.amazonaws.com/testCertificate.pem";
    var CIRCOM_FIELD_P = BigInt(
      "21888242871839275222246405745257275088548364400416034343698204186575808495617"
    );
    var productionPublicKeyHash = "18063425702624337643644061197836918910810808173893535653269228433734128853484";
    var testPublicKeyHash = "15134874015316324267425466444584014077184337590635665158241104437045239495873";
    var AnonAadhaarCore = class {
      constructor(id, claim, proof) {
        this.type = AnonAadhaarTypeName;
        this.id = id;
        this.claim = claim;
        this.proof = proof;
      }
    };
    var initArgs = void 0;
    function init(args) {
      return __async(this, null, function* () {
        initArgs = args;
      });
    }
    function prove(args, updateState) {
      return __async(this, null, function* () {
        if (!initArgs) {
          throw new Error(
            "cannot make Anon Aadhaar proof: init has not been called yet"
          );
        }
        if (!args.pubKey.value) {
          throw new Error("Invalid pubKey argument");
        }
        if (!args.signalHash.value) {
          throw new Error("Invalid signalHash argument");
        }
        if (!args.revealAgeAbove18.value) {
          throw new Error("Invalid revealAgeAbove18 argument");
        }
        const id = (0, import_uuid.v4)();
        const prover = new AnonAadhaarProver(
          initArgs.wasmURL,
          initArgs.zkeyURL,
          initArgs.artifactsOrigin
        );
        const anonAadhaarProof = yield prover.proving(args, updateState);
        const anonAadhaarClaim = {
          pubKey: args.pubKey.value,
          signalHash: args.signalHash.value,
          ageAbove18: args.revealAgeAbove18.value === "1" ? anonAadhaarProof.ageAbove18 === "1" : null,
          gender: convertRevealBigIntToString(anonAadhaarProof.gender) || null,
          pincode: anonAadhaarProof.pincode === "0" ? null : anonAadhaarProof.pincode,
          state: convertRevealBigIntToString(anonAadhaarProof.state) || null
        };
        return new AnonAadhaarCore(id, anonAadhaarClaim, anonAadhaarProof);
      });
    }
    function getVerifyKey() {
      return __async(this, null, function* () {
        let vk;
        if (!initArgs) {
          throw new Error(
            "cannot make Anon Aadhaar proof: init has not been called yet"
          );
        }
        if (initArgs.artifactsOrigin === 1) {
          vk = __require(initArgs.vkeyURL);
        } else {
          const response = yield fetch(initArgs.vkeyURL);
          if (!response.ok) {
            throw new Error(`Failed to fetch the verify key from server`);
          }
          vk = yield response.json();
        }
        return vk;
      });
    }
    function verify2(pcd, useTestAadhaar) {
      return __async(this, null, function* () {
        let pubkeyHash = productionPublicKeyHash;
        if (useTestAadhaar) {
          pubkeyHash = testPublicKeyHash;
        }
        if (pcd.proof.pubkeyHash !== pubkeyHash) {
          throw new Error("VerificationError: public key mismatch.");
        }
        const vk = yield getVerifyKey();
        return import_snarkjs2.groth16.verify(
          vk,
          [
            pcd.proof.pubkeyHash,
            pcd.proof.nullifier,
            pcd.proof.timestamp,
            pcd.proof.ageAbove18,
            pcd.proof.gender,
            pcd.proof.pincode,
            pcd.proof.state,
            pcd.proof.nullifierSeed,
            pcd.proof.signalHash
          ],
          pcd.proof.groth16Proof
        );
      });
    }
    function serialize2(pcd) {
      return Promise.resolve({
        type: AnonAadhaarTypeName,
        pcd: (0, import_json_bigint.default)().stringify({
          type: pcd.type,
          id: pcd.id,
          claim: pcd.claim,
          proof: pcd.proof
        })
      });
    }
    function deserialize(serialized) {
      return __async(this, null, function* () {
        return (0, import_json_bigint.default)().parse(serialized);
      });
    }
    function getDisplayOptions(pcd) {
      return {
        header: "Anon Aadhaar Signature",
        displayName: "pcd-" + pcd.type
      };
    }
    var AnonAadhaarCorePackage = {
      name: AnonAadhaarTypeName,
      getDisplayOptions,
      prove,
      init,
      verify: verify2,
      serialize: serialize2,
      deserialize
    };
    var import_binary_format = require_binary_format();
    var import_sha_utils = require_sha_utils();
    var import_buffer = (init_dist(), __toCommonJS(dist_exports));
    var import_node_forge = __toESM2(require_lib3());
    var import_pcd_types = require_dist4();
    var import_bn = __toESM2(require_bn());
    var version = "logger/5.7.0";
    var _permanentCensorErrors = false;
    var _censorErrors = false;
    var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
    var _logLevel = LogLevels["default"];
    var _globalLogger = null;
    function _checkNormalize() {
      try {
        const missing = [];
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
          try {
            if ("test".normalize(form) !== "test") {
              throw new Error("bad normalize");
            }
            ;
          } catch (error) {
            missing.push(form);
          }
        });
        if (missing.length) {
          throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
          throw new Error("broken implementation");
        }
      } catch (error) {
        return error.message;
      }
      return null;
    }
    var _normalizeError = _checkNormalize();
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2["DEBUG"] = "DEBUG";
      LogLevel2["INFO"] = "INFO";
      LogLevel2["WARNING"] = "WARNING";
      LogLevel2["ERROR"] = "ERROR";
      LogLevel2["OFF"] = "OFF";
    })(LogLevel || (LogLevel = {}));
    var ErrorCode;
    (function(ErrorCode2) {
      ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
      ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
      ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
      ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
      ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
      ErrorCode2["TIMEOUT"] = "TIMEOUT";
      ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
      ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
      ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
      ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
      ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
      ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
      ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
      ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
      ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
      ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
      ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
      ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
      ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
    })(ErrorCode || (ErrorCode = {}));
    var HEX = "0123456789abcdef";
    var Logger = class _Logger {
      constructor(version4) {
        Object.defineProperty(this, "version", {
          enumerable: true,
          value: version4,
          writable: false
        });
      }
      _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
          this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
          return;
        }
        console.log.apply(console, args);
      }
      debug(...args) {
        this._log(_Logger.levels.DEBUG, args);
      }
      info(...args) {
        this._log(_Logger.levels.INFO, args);
      }
      warn(...args) {
        this._log(_Logger.levels.WARNING, args);
      }
      makeError(message, code, params) {
        if (_censorErrors) {
          return this.makeError("censored error", code, {});
        }
        if (!code) {
          code = _Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
          params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
          const value = params[key];
          try {
            if (value instanceof Uint8Array) {
              let hex2 = "";
              for (let i2 = 0; i2 < value.length; i2++) {
                hex2 += HEX[value[i2] >> 4];
                hex2 += HEX[value[i2] & 15];
              }
              messageDetails.push(key + "=Uint8Array(0x" + hex2 + ")");
            } else {
              messageDetails.push(key + "=" + JSON.stringify(value));
            }
          } catch (error2) {
            messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
          }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
          case ErrorCode.NUMERIC_FAULT: {
            url = "NUMERIC_FAULT";
            const fault = message;
            switch (fault) {
              case "overflow":
              case "underflow":
              case "division-by-zero":
                url += "-" + fault;
                break;
              case "negative-power":
              case "negative-width":
                url += "-unsupported";
                break;
              case "unbound-bitwise-result":
                url += "-unbound-result";
                break;
            }
            break;
          }
          case ErrorCode.CALL_EXCEPTION:
          case ErrorCode.INSUFFICIENT_FUNDS:
          case ErrorCode.MISSING_NEW:
          case ErrorCode.NONCE_EXPIRED:
          case ErrorCode.REPLACEMENT_UNDERPRICED:
          case ErrorCode.TRANSACTION_REPLACED:
          case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
            url = code;
            break;
        }
        if (url) {
          message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
          message += " (" + messageDetails.join(", ") + ")";
        }
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
          error[key] = params[key];
        });
        return error;
      }
      throwError(message, code, params) {
        throw this.makeError(message, code, params);
      }
      throwArgumentError(message, name, value) {
        return this.throwError(message, _Logger.errors.INVALID_ARGUMENT, {
          argument: name,
          value
        });
      }
      assert(condition, message, code, params) {
        if (!!condition) {
          return;
        }
        this.throwError(message, code, params);
      }
      assertArgument(condition, message, name, value) {
        if (!!condition) {
          return;
        }
        this.throwArgumentError(message, name, value);
      }
      checkNormalize(message) {
        if (message == null) {
          message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
          this.throwError("platform missing String.prototype.normalize", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
          });
        }
      }
      checkSafeUint53(value, message) {
        if (typeof value !== "number") {
          return;
        }
        if (message == null) {
          message = "value not safe";
        }
        if (value < 0 || value >= 9007199254740991) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value
          });
        }
        if (value % 1) {
          this.throwError(message, _Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value
          });
        }
      }
      checkArgumentCount(count, expectedCount, message) {
        if (message) {
          message = ": " + message;
        } else {
          message = "";
        }
        if (count < expectedCount) {
          this.throwError("missing argument" + message, _Logger.errors.MISSING_ARGUMENT, {
            count,
            expectedCount
          });
        }
        if (count > expectedCount) {
          this.throwError("too many arguments" + message, _Logger.errors.UNEXPECTED_ARGUMENT, {
            count,
            expectedCount
          });
        }
      }
      checkNew(target, kind) {
        if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      checkAbstract(target, kind) {
        if (target === kind) {
          this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", _Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        } else if (target === Object || target == null) {
          this.throwError("missing new", _Logger.errors.MISSING_NEW, { name: kind.name });
        }
      }
      static globalLogger() {
        if (!_globalLogger) {
          _globalLogger = new _Logger(version);
        }
        return _globalLogger;
      }
      static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
          this.globalLogger().throwError("cannot permanently disable censorship", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        if (_permanentCensorErrors) {
          if (!censorship) {
            return;
          }
          this.globalLogger().throwError("error censorship permanent", _Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
      }
      static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
          _Logger.globalLogger().warn("invalid log level - " + logLevel);
          return;
        }
        _logLevel = level;
      }
      static from(version4) {
        return new _Logger(version4);
      }
    };
    Logger.errors = ErrorCode;
    Logger.levels = LogLevel;
    var version2 = "bytes/5.7.0";
    var logger = new Logger(version2);
    function isHexable(value) {
      return !!value.toHexString;
    }
    function addSlice(array) {
      if (array.slice) {
        return array;
      }
      array.slice = function() {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
      };
      return array;
    }
    function isInteger(value) {
      return typeof value === "number" && value == value && value % 1 === 0;
    }
    function isBytes(value) {
      if (value == null) {
        return false;
      }
      if (value.constructor === Uint8Array) {
        return true;
      }
      if (typeof value === "string") {
        return false;
      }
      if (!isInteger(value.length) || value.length < 0) {
        return false;
      }
      for (let i2 = 0; i2 < value.length; i2++) {
        const v2 = value[i2];
        if (!isInteger(v2) || v2 < 0 || v2 >= 256) {
          return false;
        }
      }
      return true;
    }
    function arrayify(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
          result.unshift(value & 255);
          value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
          result.push(0);
        }
        return addSlice(new Uint8Array(result));
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        value = value.toHexString();
      }
      if (isHexString(value)) {
        let hex2 = value.substring(2);
        if (hex2.length % 2) {
          if (options.hexPad === "left") {
            hex2 = "0" + hex2;
          } else if (options.hexPad === "right") {
            hex2 += "0";
          } else {
            logger.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        const result = [];
        for (let i2 = 0; i2 < hex2.length; i2 += 2) {
          result.push(parseInt(hex2.substring(i2, i2 + 2), 16));
        }
        return addSlice(new Uint8Array(result));
      }
      if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
      }
      return logger.throwArgumentError("invalid arrayify value", "value", value);
    }
    function zeroPad(value, length2) {
      value = arrayify(value);
      if (value.length > length2) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
      }
      const result = new Uint8Array(length2);
      result.set(value, length2 - value.length);
      return addSlice(result);
    }
    function isHexString(value, length2) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (length2 && value.length !== 2 + 2 * length2) {
        return false;
      }
      return true;
    }
    var HexCharacters = "0123456789abcdef";
    function hexlify(value, options) {
      if (!options) {
        options = {};
      }
      if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex2 = "";
        while (value) {
          hex2 = HexCharacters[value & 15] + hex2;
          value = Math.floor(value / 16);
        }
        if (hex2.length) {
          if (hex2.length % 2) {
            hex2 = "0" + hex2;
          }
          return "0x" + hex2;
        }
        return "0x00";
      }
      if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
          return "0x0" + value;
        }
        return "0x" + value;
      }
      if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (isHexable(value)) {
        return value.toHexString();
      }
      if (isHexString(value)) {
        if (value.length % 2) {
          if (options.hexPad === "left") {
            value = "0x0" + value.substring(2);
          } else if (options.hexPad === "right") {
            value += "0";
          } else {
            logger.throwArgumentError("hex data is odd-length", "value", value);
          }
        }
        return value.toLowerCase();
      }
      if (isBytes(value)) {
        let result = "0x";
        for (let i2 = 0; i2 < value.length; i2++) {
          let v2 = value[i2];
          result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
        }
        return result;
      }
      return logger.throwArgumentError("invalid hexlify value", "value", value);
    }
    var version3 = "bignumber/5.7.0";
    var BN = import_bn.default.BN;
    var logger2 = new Logger(version3);
    var _constructorGuard = {};
    var MAX_SAFE = 9007199254740991;
    var _warnedToStringRadix = false;
    var BigNumber = class _BigNumber {
      constructor(constructorGuard, hex2) {
        if (constructorGuard !== _constructorGuard) {
          logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          });
        }
        this._hex = hex2;
        this._isBigNumber = true;
        Object.freeze(this);
      }
      fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
      }
      toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
      }
      abs() {
        if (this._hex[0] === "-") {
          return _BigNumber.from(this._hex.substring(1));
        }
        return this;
      }
      add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
      }
      sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
      }
      div(other) {
        const o2 = _BigNumber.from(other);
        if (o2.isZero()) {
          throwFault("division-by-zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
      }
      mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
      }
      mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("division-by-zero", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
      }
      pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
          throwFault("negative-power", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
      }
      and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "and");
        }
        return toBigNumber(toBN(this).and(value));
      }
      or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "or");
        }
        return toBigNumber(toBN(this).or(value));
      }
      xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
          throwFault("unbound-bitwise-result", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
      }
      mask(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
      }
      shl(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
      }
      shr(value) {
        if (this.isNegative() || value < 0) {
          throwFault("negative-width", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
      }
      eq(other) {
        return toBN(this).eq(toBN(other));
      }
      lt(other) {
        return toBN(this).lt(toBN(other));
      }
      lte(other) {
        return toBN(this).lte(toBN(other));
      }
      gt(other) {
        return toBN(this).gt(toBN(other));
      }
      gte(other) {
        return toBN(this).gte(toBN(other));
      }
      isNegative() {
        return this._hex[0] === "-";
      }
      isZero() {
        return toBN(this).isZero();
      }
      toNumber() {
        try {
          return toBN(this).toNumber();
        } catch (error) {
          throwFault("overflow", "toNumber", this.toString());
        }
        return null;
      }
      toBigInt() {
        try {
          return BigInt(this.toString());
        } catch (e2) {
        }
        return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
          value: this.toString()
        });
      }
      toString() {
        if (arguments.length > 0) {
          if (arguments[0] === 10) {
            if (!_warnedToStringRadix) {
              _warnedToStringRadix = true;
              logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
            }
          } else if (arguments[0] === 16) {
            logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
          } else {
            logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
          }
        }
        return toBN(this).toString(10);
      }
      toHexString() {
        return this._hex;
      }
      toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
      }
      static from(value) {
        if (value instanceof _BigNumber) {
          return value;
        }
        if (typeof value === "string") {
          if (value.match(/^-?0x[0-9a-f]+$/i)) {
            return new _BigNumber(_constructorGuard, toHex(value));
          }
          if (value.match(/^-?[0-9]+$/)) {
            return new _BigNumber(_constructorGuard, toHex(new BN(value)));
          }
          return logger2.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
          if (value % 1) {
            throwFault("underflow", "BigNumber.from", value);
          }
          if (value >= MAX_SAFE || value <= -MAX_SAFE) {
            throwFault("overflow", "BigNumber.from", value);
          }
          return _BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") {
          return _BigNumber.from(anyValue.toString());
        }
        if (isBytes(anyValue)) {
          return _BigNumber.from(hexlify(anyValue));
        }
        if (anyValue) {
          if (anyValue.toHexString) {
            const hex2 = anyValue.toHexString();
            if (typeof hex2 === "string") {
              return _BigNumber.from(hex2);
            }
          } else {
            let hex2 = anyValue._hex;
            if (hex2 == null && anyValue.type === "BigNumber") {
              hex2 = anyValue.hex;
            }
            if (typeof hex2 === "string") {
              if (isHexString(hex2) || hex2[0] === "-" && isHexString(hex2.substring(1))) {
                return _BigNumber.from(hex2);
              }
            }
          }
        }
        return logger2.throwArgumentError("invalid BigNumber value", "value", value);
      }
      static isBigNumber(value) {
        return !!(value && value._isBigNumber);
      }
    };
    function toHex(value) {
      if (typeof value !== "string") {
        return toHex(value.toString(16));
      }
      if (value[0] === "-") {
        value = value.substring(1);
        if (value[0] === "-") {
          logger2.throwArgumentError("invalid hex", "value", value);
        }
        value = toHex(value);
        if (value === "0x00") {
          return value;
        }
        return "-" + value;
      }
      if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }
      if (value === "0x") {
        return "0x00";
      }
      if (value.length % 2) {
        value = "0x0" + value.substring(2);
      }
      while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
      }
      return value;
    }
    function toBigNumber(value) {
      return BigNumber.from(toHex(value));
    }
    function toBN(value) {
      const hex2 = BigNumber.from(value).toHexString();
      if (hex2[0] === "-") {
        return new BN("-" + hex2.substring(3), 16);
      }
      return new BN(hex2.substring(2), 16);
    }
    function throwFault(fault, operation, value) {
      const params = { fault, operation };
      if (value != null) {
        params.value = value;
      }
      return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
    }
    var import_js_sha3 = __toESM2(require_sha3());
    function keccak2562(data) {
      return "0x" + import_js_sha3.default.keccak_256(arrayify(data));
    }
    function hash2(message) {
      message = BigNumber.from(message).toTwos(256).toHexString();
      message = zeroPad(message, 32);
      return (BigInt(keccak2562(message)) >> BigInt(3)).toString();
    }
    var generateArgs = (_0) => __async(void 0, [_0], function* ({
      qrData,
      certificateFile,
      nullifierSeed,
      fieldsToRevealArray,
      signal
    }) {
      const bigIntData = BigInt(qrData);
      const byteArray = convertBigIntToByteArray(bigIntData);
      const decompressedByteArray = decompressByteArray(byteArray);
      const signature = decompressedByteArray.slice(
        decompressedByteArray.length - 256,
        decompressedByteArray.length
      );
      const signedData = decompressedByteArray.slice(
        0,
        decompressedByteArray.length - 256
      );
      const RSAPublicKey = import_node_forge.pki.certificateFromPem(certificateFile).publicKey;
      const publicKey = RSAPublicKey.n.toString(16);
      const pubKeyBigInt = BigInt("0x" + publicKey);
      const signatureBigint = BigInt(
        "0x" + (0, import_binary_format.bufferToHex)(import_buffer.Buffer.from(signature)).toString()
      );
      const [paddedMessage, messageLength] = (0, import_sha_utils.sha256Pad)(signedData, 512 * 3);
      const delimiterIndices = [];
      for (let i2 = 0; i2 < paddedMessage.length; i2++) {
        if (paddedMessage[i2] === 255) {
          delimiterIndices.push(i2);
        }
        if (delimiterIndices.length === 18) {
          break;
        }
      }
      if (!fieldsToRevealArray)
        fieldsToRevealArray = [];
      const fieldsToReveal = {
        revealAgeAbove18: fieldsToRevealArray.includes("revealAgeAbove18"),
        revealGender: fieldsToRevealArray.includes("revealGender"),
        revealPinCode: fieldsToRevealArray.includes("revealPinCode"),
        revealState: fieldsToRevealArray.includes("revealState")
      };
      const nullifierSeedBigInt = BigInt(nullifierSeed);
      if (nullifierSeedBigInt > CIRCOM_FIELD_P) {
        throw new Error("Nullifier seed is larger than the max field size");
      }
      const signalHash = signal ? hash2(signal) : hash2(1);
      const anonAadhaarArgs = {
        qrDataPadded: {
          argumentType: import_pcd_types.ArgumentTypeName.StringArray,
          value: (0, import_binary_format.Uint8ArrayToCharArray)(paddedMessage)
        },
        qrDataPaddedLength: {
          argumentType: import_pcd_types.ArgumentTypeName.Number,
          value: messageLength.toString()
        },
        delimiterIndices: {
          argumentType: import_pcd_types.ArgumentTypeName.StringArray,
          value: delimiterIndices.map((elem) => elem.toString())
        },
        signature: {
          argumentType: import_pcd_types.ArgumentTypeName.StringArray,
          value: splitToWords(signatureBigint, BigInt(121), BigInt(17))
        },
        pubKey: {
          argumentType: import_pcd_types.ArgumentTypeName.StringArray,
          value: splitToWords(pubKeyBigInt, BigInt(121), BigInt(17))
        },
        nullifierSeed: {
          argumentType: import_pcd_types.ArgumentTypeName.String,
          value: nullifierSeedBigInt.toString()
        },
        signalHash: {
          argumentType: import_pcd_types.ArgumentTypeName.String,
          value: signalHash
        },
        revealAgeAbove18: {
          argumentType: import_pcd_types.ArgumentTypeName.Number,
          value: fieldsToReveal.revealAgeAbove18 ? "1" : "0"
        },
        revealGender: {
          argumentType: import_pcd_types.ArgumentTypeName.Number,
          value: fieldsToReveal.revealGender ? "1" : "0"
        },
        revealPinCode: {
          argumentType: import_pcd_types.ArgumentTypeName.Number,
          value: fieldsToReveal.revealPinCode ? "1" : "0"
        },
        revealState: {
          argumentType: import_pcd_types.ArgumentTypeName.Number,
          value: fieldsToReveal.revealState ? "1" : "0"
        }
      };
      return anonAadhaarArgs;
    });
    var import_pako2 = __toESM2(require_pako());
    var createCustomV2TestData = ({
      signedData,
      dob,
      pincode,
      gender,
      state,
      photo
    }) => {
      const allDataParsed = [];
      const delimiterIndices = [];
      let countDelimiter = 0;
      let temp = [];
      for (let i2 = 0; i2 < signedData.length; i2++) {
        if (countDelimiter < 16) {
          if (signedData[i2] !== 255) {
            temp.push(signedData[i2]);
          } else {
            countDelimiter += 1;
            allDataParsed.push(temp);
            delimiterIndices.push(i2);
            temp = [];
          }
        } else {
          break;
        }
      }
      const newDateString = returnNewDateString();
      const newTimestamp = new TextEncoder().encode(newDateString);
      const signedDataWithNewTimestamp = replaceBytesBetween(
        signedData,
        newTimestamp,
        6,
        5 + newTimestamp.length
      );
      let modifiedSignedData = signedDataWithNewTimestamp;
      if (dob) {
        const newDOB = new TextEncoder().encode(dob);
        modifiedSignedData = replaceBytesBetween(
          modifiedSignedData,
          newDOB,
          delimiterIndices[3 - 1] + 1,
          delimiterIndices[3 - 1] + allDataParsed[
            3
            /* DOB */
          ].length
        );
      }
      if (gender) {
        const newGender = new TextEncoder().encode(gender);
        modifiedSignedData = replaceBytesBetween(
          modifiedSignedData,
          newGender,
          delimiterIndices[4 - 1] + 1,
          delimiterIndices[4 - 1] + allDataParsed[
            4
            /* Gender */
          ].length
        );
      }
      if (pincode) {
        const newPincode = new TextEncoder().encode(pincode);
        modifiedSignedData = replaceBytesBetween(
          modifiedSignedData,
          newPincode,
          delimiterIndices[10 - 1] + 1,
          delimiterIndices[10 - 1] + allDataParsed[
            10
            /* PinCode */
          ].length
        );
      }
      if (state) {
        const newState = new TextEncoder().encode(state);
        modifiedSignedData = replaceBytesBetween(
          modifiedSignedData,
          newState,
          delimiterIndices[12 - 1] + 1,
          delimiterIndices[12 - 1] + allDataParsed[
            12
            /* State */
          ].length
        );
      }
      if (photo) {
        const { begin, dataLength } = extractPhoto(
          Array.from(modifiedSignedData),
          modifiedSignedData.length
        );
        const photoLength = dataLength - begin;
        modifiedSignedData = replaceBytesBetween(
          modifiedSignedData,
          getRandomBytes3(photoLength - 1),
          begin + 1,
          begin + photoLength - 1
        );
      }
      const versionSpecifier = new Uint8Array([86, 50, 255]);
      const number1234 = new Uint8Array([49, 50, 51, 52, 255]);
      const beforeInsertion = new Uint8Array(
        modifiedSignedData.slice(0, getEndIndex(modifiedSignedData))
      );
      const afterInsertion = new Uint8Array(
        modifiedSignedData.slice(getEndIndex(modifiedSignedData))
      );
      const newData = new Uint8Array(
        versionSpecifier.length + beforeInsertion.length + number1234.length + afterInsertion.length
      );
      newData.set(versionSpecifier, 0);
      newData.set(beforeInsertion, versionSpecifier.length);
      newData.set(number1234, versionSpecifier.length + beforeInsertion.length);
      newData.set(
        afterInsertion,
        versionSpecifier.length + beforeInsertion.length + number1234.length
      );
      return newData;
    };
    function timestampToUTCUnix(rawData) {
      const extractedArray = new Uint8Array(10);
      for (let i2 = 0; i2 < 10; i2++) {
        extractedArray[i2] = rawData[i2 + 9];
      }
      const timestampString = Buffer.from(extractedArray).toString();
      const result = `${timestampString.slice(0, 4)}-${timestampString.slice(
        4,
        6
      )}-${timestampString.slice(6, 8)}T${timestampString.slice(8, 10)}:00:00.000Z`;
      const dateObj = new Date(result);
      dateObj.setUTCHours(dateObj.getUTCHours() - 5);
      dateObj.setUTCMinutes(dateObj.getUTCMinutes() - 30);
      return Math.floor(dateObj.getTime() / 1e3);
    }
    function dateToUnixTimestamp(dateStr) {
      const parts = dateStr.split("-");
      const day = parseInt(parts[0], 10);
      const month = parseInt(parts[1], 10) - 1;
      const year = parseInt(parts[2], 10);
      const date = new Date(Date.UTC(year, month, day, 0, 0, 0, 0));
      const unixTimestamp = date.getTime() / 1e3;
      return unixTimestamp + 19800;
    }
    function returnFullId(signedData) {
      const allDataParsed = [];
      let countDelimiter = 0;
      let temp = [];
      for (let i2 = 0; i2 < signedData.length; i2++) {
        if (countDelimiter < 18) {
          if (signedData[i2] !== 255) {
            temp.push(signedData[i2]);
          } else {
            countDelimiter += 1;
            allDataParsed.push(temp);
            temp = [];
          }
        }
      }
      const ID = {};
      for (let i2 = 0; i2 < allDataParsed.length; i2++) {
        let result = "";
        for (let j2 = 0; j2 < allDataParsed[i2].length; j2++) {
          result += String.fromCharCode(allDataParsed[i2][j2]);
        }
        ID[IdFields[i2 - 1]] = result;
      }
      return ID;
    }
    function extractFieldByIndex(data, index) {
      let start = -1;
      let end = data.length;
      let fieldIndex = -1;
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data[i2] === 255) {
          fieldIndex++;
          if (fieldIndex === index) {
            start = i2;
          } else if (fieldIndex === index + 1) {
            end = i2;
            break;
          }
        }
      }
      if (start !== -1 && start < end) {
        return data.slice(start, end);
      }
      return new Uint8Array();
    }
    function compressByteArray(byteArray) {
      const compressedArray = import_pako2.default.deflate(byteArray);
      return new Uint8Array(compressedArray);
    }
    function getEndIndex(byteArray) {
      let countDelimiter = 0;
      let endIndex = 0;
      for (let i2 = 0; i2 < byteArray.length; i2++) {
        if (countDelimiter < 16) {
          if (byteArray[i2] !== 255) {
            continue;
          } else {
            countDelimiter += 1;
          }
        } else {
          endIndex = i2;
          break;
        }
      }
      return endIndex;
    }
    function replaceBytesBetween(arr, replaceWith, start, end) {
      if (start < 0 || end >= arr.length || start > end) {
        console.error("Invalid start or end index.");
        return arr;
      }
      const before = arr.subarray(0, start);
      const after = arr.subarray(end + 1);
      const result = new Uint8Array(
        before.length + replaceWith.length + after.length
      );
      result.set(before, 0);
      result.set(replaceWith, before.length);
      result.set(after, before.length + replaceWith.length);
      return result;
    }
    function returnNewDateString() {
      const newDate = /* @__PURE__ */ new Date();
      const offsetHours = 5;
      const offsetMinutes = 30;
      newDate.setUTCHours(newDate.getUTCHours() + offsetHours);
      newDate.setUTCMinutes(newDate.getUTCMinutes() + offsetMinutes);
      return newDate.getUTCFullYear().toString() + (newDate.getUTCMonth() + 1).toString().padStart(2, "0") + newDate.getUTCDate().toString().padStart(2, "0") + newDate.getUTCHours().toString().padStart(2, "0") + newDate.getUTCMinutes().toString().padStart(2, "0") + newDate.getUTCSeconds().toString().padStart(2, "0") + newDate.getUTCMilliseconds().toString().padStart(3, "0");
    }
    function convertByteArrayToBigInt(byteArray) {
      let result = BigInt(0);
      for (let i2 = 0; i2 < byteArray.length; i2++) {
        result = result * BigInt(256) + BigInt(byteArray[i2]);
      }
      return result;
    }
    var rawDataToCompressedQR = (data) => {
      const compressedDataBytes = compressByteArray(data);
      const compressedBigInt = convertByteArrayToBigInt(compressedDataBytes);
      return compressedBigInt;
    };
  }
});

// node_modules/jsqr/dist/jsQR.js
var require_jsQR = __commonJS({
  "node_modules/jsqr/dist/jsQR.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["jsQR"] = factory();
      else
        root["jsQR"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 3);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix = (
              /** @class */
              function() {
                function BitMatrix2(data, width) {
                  this.width = width;
                  this.height = data.length / width;
                  this.data = data;
                }
                BitMatrix2.createEmpty = function(width, height) {
                  return new BitMatrix2(new Uint8ClampedArray(width * height), width);
                };
                BitMatrix2.prototype.get = function(x2, y2) {
                  if (x2 < 0 || x2 >= this.width || y2 < 0 || y2 >= this.height) {
                    return false;
                  }
                  return !!this.data[y2 * this.width + x2];
                };
                BitMatrix2.prototype.set = function(x2, y2, v2) {
                  this.data[y2 * this.width + x2] = v2 ? 1 : 0;
                };
                BitMatrix2.prototype.setRegion = function(left, top, width, height, v2) {
                  for (var y2 = top; y2 < top + height; y2++) {
                    for (var x2 = left; x2 < left + width; x2++) {
                      this.set(x2, y2, !!v2);
                    }
                  }
                };
                return BitMatrix2;
              }()
            );
            exports2.BitMatrix = BitMatrix;
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGFPoly_1 = __webpack_require__(2);
            function addOrSubtractGF(a2, b2) {
              return a2 ^ b2;
            }
            exports2.addOrSubtractGF = addOrSubtractGF;
            var GenericGF = (
              /** @class */
              function() {
                function GenericGF2(primitive, size, genBase) {
                  this.primitive = primitive;
                  this.size = size;
                  this.generatorBase = genBase;
                  this.expTable = new Array(this.size);
                  this.logTable = new Array(this.size);
                  var x2 = 1;
                  for (var i2 = 0; i2 < this.size; i2++) {
                    this.expTable[i2] = x2;
                    x2 = x2 * 2;
                    if (x2 >= this.size) {
                      x2 = (x2 ^ this.primitive) & this.size - 1;
                    }
                  }
                  for (var i2 = 0; i2 < this.size - 1; i2++) {
                    this.logTable[this.expTable[i2]] = i2;
                  }
                  this.zero = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([0]));
                  this.one = new GenericGFPoly_1.default(this, Uint8ClampedArray.from([1]));
                }
                GenericGF2.prototype.multiply = function(a2, b2) {
                  if (a2 === 0 || b2 === 0) {
                    return 0;
                  }
                  return this.expTable[(this.logTable[a2] + this.logTable[b2]) % (this.size - 1)];
                };
                GenericGF2.prototype.inverse = function(a2) {
                  if (a2 === 0) {
                    throw new Error("Can't invert 0");
                  }
                  return this.expTable[this.size - this.logTable[a2] - 1];
                };
                GenericGF2.prototype.buildMonomial = function(degree, coefficient) {
                  if (degree < 0) {
                    throw new Error("Invalid monomial degree less than 0");
                  }
                  if (coefficient === 0) {
                    return this.zero;
                  }
                  var coefficients = new Uint8ClampedArray(degree + 1);
                  coefficients[0] = coefficient;
                  return new GenericGFPoly_1.default(this, coefficients);
                };
                GenericGF2.prototype.log = function(a2) {
                  if (a2 === 0) {
                    throw new Error("Can't take log(0)");
                  }
                  return this.logTable[a2];
                };
                GenericGF2.prototype.exp = function(a2) {
                  return this.expTable[a2];
                };
                return GenericGF2;
              }()
            );
            exports2.default = GenericGF;
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGF_1 = __webpack_require__(1);
            var GenericGFPoly = (
              /** @class */
              function() {
                function GenericGFPoly2(field, coefficients) {
                  if (coefficients.length === 0) {
                    throw new Error("No coefficients.");
                  }
                  this.field = field;
                  var coefficientsLength = coefficients.length;
                  if (coefficientsLength > 1 && coefficients[0] === 0) {
                    var firstNonZero = 1;
                    while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                      firstNonZero++;
                    }
                    if (firstNonZero === coefficientsLength) {
                      this.coefficients = field.zero.coefficients;
                    } else {
                      this.coefficients = new Uint8ClampedArray(coefficientsLength - firstNonZero);
                      for (var i2 = 0; i2 < this.coefficients.length; i2++) {
                        this.coefficients[i2] = coefficients[firstNonZero + i2];
                      }
                    }
                  } else {
                    this.coefficients = coefficients;
                  }
                }
                GenericGFPoly2.prototype.degree = function() {
                  return this.coefficients.length - 1;
                };
                GenericGFPoly2.prototype.isZero = function() {
                  return this.coefficients[0] === 0;
                };
                GenericGFPoly2.prototype.getCoefficient = function(degree) {
                  return this.coefficients[this.coefficients.length - 1 - degree];
                };
                GenericGFPoly2.prototype.addOrSubtract = function(other) {
                  var _a;
                  if (this.isZero()) {
                    return other;
                  }
                  if (other.isZero()) {
                    return this;
                  }
                  var smallerCoefficients = this.coefficients;
                  var largerCoefficients = other.coefficients;
                  if (smallerCoefficients.length > largerCoefficients.length) {
                    _a = [largerCoefficients, smallerCoefficients], smallerCoefficients = _a[0], largerCoefficients = _a[1];
                  }
                  var sumDiff = new Uint8ClampedArray(largerCoefficients.length);
                  var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
                  for (var i2 = 0; i2 < lengthDiff; i2++) {
                    sumDiff[i2] = largerCoefficients[i2];
                  }
                  for (var i2 = lengthDiff; i2 < largerCoefficients.length; i2++) {
                    sumDiff[i2] = GenericGF_1.addOrSubtractGF(smallerCoefficients[i2 - lengthDiff], largerCoefficients[i2]);
                  }
                  return new GenericGFPoly2(this.field, sumDiff);
                };
                GenericGFPoly2.prototype.multiply = function(scalar) {
                  if (scalar === 0) {
                    return this.field.zero;
                  }
                  if (scalar === 1) {
                    return this;
                  }
                  var size = this.coefficients.length;
                  var product = new Uint8ClampedArray(size);
                  for (var i2 = 0; i2 < size; i2++) {
                    product[i2] = this.field.multiply(this.coefficients[i2], scalar);
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.multiplyPoly = function(other) {
                  if (this.isZero() || other.isZero()) {
                    return this.field.zero;
                  }
                  var aCoefficients = this.coefficients;
                  var aLength = aCoefficients.length;
                  var bCoefficients = other.coefficients;
                  var bLength = bCoefficients.length;
                  var product = new Uint8ClampedArray(aLength + bLength - 1);
                  for (var i2 = 0; i2 < aLength; i2++) {
                    var aCoeff = aCoefficients[i2];
                    for (var j2 = 0; j2 < bLength; j2++) {
                      product[i2 + j2] = GenericGF_1.addOrSubtractGF(product[i2 + j2], this.field.multiply(aCoeff, bCoefficients[j2]));
                    }
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.multiplyByMonomial = function(degree, coefficient) {
                  if (degree < 0) {
                    throw new Error("Invalid degree less than 0");
                  }
                  if (coefficient === 0) {
                    return this.field.zero;
                  }
                  var size = this.coefficients.length;
                  var product = new Uint8ClampedArray(size + degree);
                  for (var i2 = 0; i2 < size; i2++) {
                    product[i2] = this.field.multiply(this.coefficients[i2], coefficient);
                  }
                  return new GenericGFPoly2(this.field, product);
                };
                GenericGFPoly2.prototype.evaluateAt = function(a2) {
                  var result = 0;
                  if (a2 === 0) {
                    return this.getCoefficient(0);
                  }
                  var size = this.coefficients.length;
                  if (a2 === 1) {
                    this.coefficients.forEach(function(coefficient) {
                      result = GenericGF_1.addOrSubtractGF(result, coefficient);
                    });
                    return result;
                  }
                  result = this.coefficients[0];
                  for (var i2 = 1; i2 < size; i2++) {
                    result = GenericGF_1.addOrSubtractGF(this.field.multiply(a2, result), this.coefficients[i2]);
                  }
                  return result;
                };
                return GenericGFPoly2;
              }()
            );
            exports2.default = GenericGFPoly;
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var binarizer_1 = __webpack_require__(4);
            var decoder_1 = __webpack_require__(5);
            var extractor_1 = __webpack_require__(11);
            var locator_1 = __webpack_require__(12);
            function scan(matrix) {
              var locations = locator_1.locate(matrix);
              if (!locations) {
                return null;
              }
              for (var _i = 0, locations_1 = locations; _i < locations_1.length; _i++) {
                var location_1 = locations_1[_i];
                var extracted = extractor_1.extract(matrix, location_1);
                var decoded = decoder_1.decode(extracted.matrix);
                if (decoded) {
                  return {
                    binaryData: decoded.bytes,
                    data: decoded.text,
                    chunks: decoded.chunks,
                    version: decoded.version,
                    location: {
                      topRightCorner: extracted.mappingFunction(location_1.dimension, 0),
                      topLeftCorner: extracted.mappingFunction(0, 0),
                      bottomRightCorner: extracted.mappingFunction(location_1.dimension, location_1.dimension),
                      bottomLeftCorner: extracted.mappingFunction(0, location_1.dimension),
                      topRightFinderPattern: location_1.topRight,
                      topLeftFinderPattern: location_1.topLeft,
                      bottomLeftFinderPattern: location_1.bottomLeft,
                      bottomRightAlignmentPattern: location_1.alignmentPattern
                    }
                  };
                }
              }
              return null;
            }
            var defaultOptions = {
              inversionAttempts: "attemptBoth"
            };
            function jsQR(data, width, height, providedOptions) {
              if (providedOptions === void 0) {
                providedOptions = {};
              }
              var options = defaultOptions;
              Object.keys(options || {}).forEach(function(opt) {
                options[opt] = providedOptions[opt] || options[opt];
              });
              var shouldInvert = options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst";
              var tryInvertedFirst = options.inversionAttempts === "onlyInvert" || options.inversionAttempts === "invertFirst";
              var _a = binarizer_1.binarize(data, width, height, shouldInvert), binarized = _a.binarized, inverted = _a.inverted;
              var result = scan(tryInvertedFirst ? inverted : binarized);
              if (!result && (options.inversionAttempts === "attemptBoth" || options.inversionAttempts === "invertFirst")) {
                result = scan(tryInvertedFirst ? binarized : inverted);
              }
              return result;
            }
            jsQR.default = jsQR;
            exports2.default = jsQR;
          },
          /* 4 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            var REGION_SIZE = 8;
            var MIN_DYNAMIC_RANGE = 24;
            function numBetween(value, min, max) {
              return value < min ? min : value > max ? max : value;
            }
            var Matrix = (
              /** @class */
              function() {
                function Matrix2(width, height) {
                  this.width = width;
                  this.data = new Uint8ClampedArray(width * height);
                }
                Matrix2.prototype.get = function(x2, y2) {
                  return this.data[y2 * this.width + x2];
                };
                Matrix2.prototype.set = function(x2, y2, value) {
                  this.data[y2 * this.width + x2] = value;
                };
                return Matrix2;
              }()
            );
            function binarize(data, width, height, returnInverted) {
              if (data.length !== width * height * 4) {
                throw new Error("Malformed data passed to binarizer.");
              }
              var greyscalePixels = new Matrix(width, height);
              for (var x2 = 0; x2 < width; x2++) {
                for (var y2 = 0; y2 < height; y2++) {
                  var r2 = data[(y2 * width + x2) * 4 + 0];
                  var g2 = data[(y2 * width + x2) * 4 + 1];
                  var b2 = data[(y2 * width + x2) * 4 + 2];
                  greyscalePixels.set(x2, y2, 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2);
                }
              }
              var horizontalRegionCount = Math.ceil(width / REGION_SIZE);
              var verticalRegionCount = Math.ceil(height / REGION_SIZE);
              var blackPoints = new Matrix(horizontalRegionCount, verticalRegionCount);
              for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
                for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
                  var sum = 0;
                  var min = Infinity;
                  var max = 0;
                  for (var y2 = 0; y2 < REGION_SIZE; y2++) {
                    for (var x2 = 0; x2 < REGION_SIZE; x2++) {
                      var pixelLumosity = greyscalePixels.get(hortizontalRegion * REGION_SIZE + x2, verticalRegion * REGION_SIZE + y2);
                      sum += pixelLumosity;
                      min = Math.min(min, pixelLumosity);
                      max = Math.max(max, pixelLumosity);
                    }
                  }
                  var average = sum / Math.pow(REGION_SIZE, 2);
                  if (max - min <= MIN_DYNAMIC_RANGE) {
                    average = min / 2;
                    if (verticalRegion > 0 && hortizontalRegion > 0) {
                      var averageNeighborBlackPoint = (blackPoints.get(hortizontalRegion, verticalRegion - 1) + 2 * blackPoints.get(hortizontalRegion - 1, verticalRegion) + blackPoints.get(hortizontalRegion - 1, verticalRegion - 1)) / 4;
                      if (min < averageNeighborBlackPoint) {
                        average = averageNeighborBlackPoint;
                      }
                    }
                  }
                  blackPoints.set(hortizontalRegion, verticalRegion, average);
                }
              }
              var binarized = BitMatrix_1.BitMatrix.createEmpty(width, height);
              var inverted = null;
              if (returnInverted) {
                inverted = BitMatrix_1.BitMatrix.createEmpty(width, height);
              }
              for (var verticalRegion = 0; verticalRegion < verticalRegionCount; verticalRegion++) {
                for (var hortizontalRegion = 0; hortizontalRegion < horizontalRegionCount; hortizontalRegion++) {
                  var left = numBetween(hortizontalRegion, 2, horizontalRegionCount - 3);
                  var top_1 = numBetween(verticalRegion, 2, verticalRegionCount - 3);
                  var sum = 0;
                  for (var xRegion = -2; xRegion <= 2; xRegion++) {
                    for (var yRegion = -2; yRegion <= 2; yRegion++) {
                      sum += blackPoints.get(left + xRegion, top_1 + yRegion);
                    }
                  }
                  var threshold = sum / 25;
                  for (var xRegion = 0; xRegion < REGION_SIZE; xRegion++) {
                    for (var yRegion = 0; yRegion < REGION_SIZE; yRegion++) {
                      var x2 = hortizontalRegion * REGION_SIZE + xRegion;
                      var y2 = verticalRegion * REGION_SIZE + yRegion;
                      var lum = greyscalePixels.get(x2, y2);
                      binarized.set(x2, y2, lum <= threshold);
                      if (returnInverted) {
                        inverted.set(x2, y2, !(lum <= threshold));
                      }
                    }
                  }
                }
              }
              if (returnInverted) {
                return { binarized, inverted };
              }
              return { binarized };
            }
            exports2.binarize = binarize;
          },
          /* 5 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            var decodeData_1 = __webpack_require__(6);
            var reedsolomon_1 = __webpack_require__(9);
            var version_1 = __webpack_require__(10);
            function numBitsDiffering(x2, y2) {
              var z2 = x2 ^ y2;
              var bitCount = 0;
              while (z2) {
                bitCount++;
                z2 &= z2 - 1;
              }
              return bitCount;
            }
            function pushBit(bit, byte) {
              return byte << 1 | bit;
            }
            var FORMAT_INFO_TABLE = [
              { bits: 21522, formatInfo: { errorCorrectionLevel: 1, dataMask: 0 } },
              { bits: 20773, formatInfo: { errorCorrectionLevel: 1, dataMask: 1 } },
              { bits: 24188, formatInfo: { errorCorrectionLevel: 1, dataMask: 2 } },
              { bits: 23371, formatInfo: { errorCorrectionLevel: 1, dataMask: 3 } },
              { bits: 17913, formatInfo: { errorCorrectionLevel: 1, dataMask: 4 } },
              { bits: 16590, formatInfo: { errorCorrectionLevel: 1, dataMask: 5 } },
              { bits: 20375, formatInfo: { errorCorrectionLevel: 1, dataMask: 6 } },
              { bits: 19104, formatInfo: { errorCorrectionLevel: 1, dataMask: 7 } },
              { bits: 30660, formatInfo: { errorCorrectionLevel: 0, dataMask: 0 } },
              { bits: 29427, formatInfo: { errorCorrectionLevel: 0, dataMask: 1 } },
              { bits: 32170, formatInfo: { errorCorrectionLevel: 0, dataMask: 2 } },
              { bits: 30877, formatInfo: { errorCorrectionLevel: 0, dataMask: 3 } },
              { bits: 26159, formatInfo: { errorCorrectionLevel: 0, dataMask: 4 } },
              { bits: 25368, formatInfo: { errorCorrectionLevel: 0, dataMask: 5 } },
              { bits: 27713, formatInfo: { errorCorrectionLevel: 0, dataMask: 6 } },
              { bits: 26998, formatInfo: { errorCorrectionLevel: 0, dataMask: 7 } },
              { bits: 5769, formatInfo: { errorCorrectionLevel: 3, dataMask: 0 } },
              { bits: 5054, formatInfo: { errorCorrectionLevel: 3, dataMask: 1 } },
              { bits: 7399, formatInfo: { errorCorrectionLevel: 3, dataMask: 2 } },
              { bits: 6608, formatInfo: { errorCorrectionLevel: 3, dataMask: 3 } },
              { bits: 1890, formatInfo: { errorCorrectionLevel: 3, dataMask: 4 } },
              { bits: 597, formatInfo: { errorCorrectionLevel: 3, dataMask: 5 } },
              { bits: 3340, formatInfo: { errorCorrectionLevel: 3, dataMask: 6 } },
              { bits: 2107, formatInfo: { errorCorrectionLevel: 3, dataMask: 7 } },
              { bits: 13663, formatInfo: { errorCorrectionLevel: 2, dataMask: 0 } },
              { bits: 12392, formatInfo: { errorCorrectionLevel: 2, dataMask: 1 } },
              { bits: 16177, formatInfo: { errorCorrectionLevel: 2, dataMask: 2 } },
              { bits: 14854, formatInfo: { errorCorrectionLevel: 2, dataMask: 3 } },
              { bits: 9396, formatInfo: { errorCorrectionLevel: 2, dataMask: 4 } },
              { bits: 8579, formatInfo: { errorCorrectionLevel: 2, dataMask: 5 } },
              { bits: 11994, formatInfo: { errorCorrectionLevel: 2, dataMask: 6 } },
              { bits: 11245, formatInfo: { errorCorrectionLevel: 2, dataMask: 7 } }
            ];
            var DATA_MASKS = [
              function(p2) {
                return (p2.y + p2.x) % 2 === 0;
              },
              function(p2) {
                return p2.y % 2 === 0;
              },
              function(p2) {
                return p2.x % 3 === 0;
              },
              function(p2) {
                return (p2.y + p2.x) % 3 === 0;
              },
              function(p2) {
                return (Math.floor(p2.y / 2) + Math.floor(p2.x / 3)) % 2 === 0;
              },
              function(p2) {
                return p2.x * p2.y % 2 + p2.x * p2.y % 3 === 0;
              },
              function(p2) {
                return (p2.y * p2.x % 2 + p2.y * p2.x % 3) % 2 === 0;
              },
              function(p2) {
                return ((p2.y + p2.x) % 2 + p2.y * p2.x % 3) % 2 === 0;
              }
            ];
            function buildFunctionPatternMask(version) {
              var dimension = 17 + 4 * version.versionNumber;
              var matrix = BitMatrix_1.BitMatrix.createEmpty(dimension, dimension);
              matrix.setRegion(0, 0, 9, 9, true);
              matrix.setRegion(dimension - 8, 0, 8, 9, true);
              matrix.setRegion(0, dimension - 8, 9, 8, true);
              for (var _i = 0, _a = version.alignmentPatternCenters; _i < _a.length; _i++) {
                var x2 = _a[_i];
                for (var _b = 0, _c = version.alignmentPatternCenters; _b < _c.length; _b++) {
                  var y2 = _c[_b];
                  if (!(x2 === 6 && y2 === 6 || x2 === 6 && y2 === dimension - 7 || x2 === dimension - 7 && y2 === 6)) {
                    matrix.setRegion(x2 - 2, y2 - 2, 5, 5, true);
                  }
                }
              }
              matrix.setRegion(6, 9, 1, dimension - 17, true);
              matrix.setRegion(9, 6, dimension - 17, 1, true);
              if (version.versionNumber > 6) {
                matrix.setRegion(dimension - 11, 0, 3, 6, true);
                matrix.setRegion(0, dimension - 11, 6, 3, true);
              }
              return matrix;
            }
            function readCodewords(matrix, version, formatInfo) {
              var dataMask = DATA_MASKS[formatInfo.dataMask];
              var dimension = matrix.height;
              var functionPatternMask = buildFunctionPatternMask(version);
              var codewords = [];
              var currentByte = 0;
              var bitsRead = 0;
              var readingUp = true;
              for (var columnIndex = dimension - 1; columnIndex > 0; columnIndex -= 2) {
                if (columnIndex === 6) {
                  columnIndex--;
                }
                for (var i2 = 0; i2 < dimension; i2++) {
                  var y2 = readingUp ? dimension - 1 - i2 : i2;
                  for (var columnOffset = 0; columnOffset < 2; columnOffset++) {
                    var x2 = columnIndex - columnOffset;
                    if (!functionPatternMask.get(x2, y2)) {
                      bitsRead++;
                      var bit = matrix.get(x2, y2);
                      if (dataMask({ y: y2, x: x2 })) {
                        bit = !bit;
                      }
                      currentByte = pushBit(bit, currentByte);
                      if (bitsRead === 8) {
                        codewords.push(currentByte);
                        bitsRead = 0;
                        currentByte = 0;
                      }
                    }
                  }
                }
                readingUp = !readingUp;
              }
              return codewords;
            }
            function readVersion(matrix) {
              var dimension = matrix.height;
              var provisionalVersion = Math.floor((dimension - 17) / 4);
              if (provisionalVersion <= 6) {
                return version_1.VERSIONS[provisionalVersion - 1];
              }
              var topRightVersionBits = 0;
              for (var y2 = 5; y2 >= 0; y2--) {
                for (var x2 = dimension - 9; x2 >= dimension - 11; x2--) {
                  topRightVersionBits = pushBit(matrix.get(x2, y2), topRightVersionBits);
                }
              }
              var bottomLeftVersionBits = 0;
              for (var x2 = 5; x2 >= 0; x2--) {
                for (var y2 = dimension - 9; y2 >= dimension - 11; y2--) {
                  bottomLeftVersionBits = pushBit(matrix.get(x2, y2), bottomLeftVersionBits);
                }
              }
              var bestDifference = Infinity;
              var bestVersion;
              for (var _i = 0, VERSIONS_1 = version_1.VERSIONS; _i < VERSIONS_1.length; _i++) {
                var version = VERSIONS_1[_i];
                if (version.infoBits === topRightVersionBits || version.infoBits === bottomLeftVersionBits) {
                  return version;
                }
                var difference = numBitsDiffering(topRightVersionBits, version.infoBits);
                if (difference < bestDifference) {
                  bestVersion = version;
                  bestDifference = difference;
                }
                difference = numBitsDiffering(bottomLeftVersionBits, version.infoBits);
                if (difference < bestDifference) {
                  bestVersion = version;
                  bestDifference = difference;
                }
              }
              if (bestDifference <= 3) {
                return bestVersion;
              }
            }
            function readFormatInformation(matrix) {
              var topLeftFormatInfoBits = 0;
              for (var x2 = 0; x2 <= 8; x2++) {
                if (x2 !== 6) {
                  topLeftFormatInfoBits = pushBit(matrix.get(x2, 8), topLeftFormatInfoBits);
                }
              }
              for (var y2 = 7; y2 >= 0; y2--) {
                if (y2 !== 6) {
                  topLeftFormatInfoBits = pushBit(matrix.get(8, y2), topLeftFormatInfoBits);
                }
              }
              var dimension = matrix.height;
              var topRightBottomRightFormatInfoBits = 0;
              for (var y2 = dimension - 1; y2 >= dimension - 7; y2--) {
                topRightBottomRightFormatInfoBits = pushBit(matrix.get(8, y2), topRightBottomRightFormatInfoBits);
              }
              for (var x2 = dimension - 8; x2 < dimension; x2++) {
                topRightBottomRightFormatInfoBits = pushBit(matrix.get(x2, 8), topRightBottomRightFormatInfoBits);
              }
              var bestDifference = Infinity;
              var bestFormatInfo = null;
              for (var _i = 0, FORMAT_INFO_TABLE_1 = FORMAT_INFO_TABLE; _i < FORMAT_INFO_TABLE_1.length; _i++) {
                var _a = FORMAT_INFO_TABLE_1[_i], bits2 = _a.bits, formatInfo = _a.formatInfo;
                if (bits2 === topLeftFormatInfoBits || bits2 === topRightBottomRightFormatInfoBits) {
                  return formatInfo;
                }
                var difference = numBitsDiffering(topLeftFormatInfoBits, bits2);
                if (difference < bestDifference) {
                  bestFormatInfo = formatInfo;
                  bestDifference = difference;
                }
                if (topLeftFormatInfoBits !== topRightBottomRightFormatInfoBits) {
                  difference = numBitsDiffering(topRightBottomRightFormatInfoBits, bits2);
                  if (difference < bestDifference) {
                    bestFormatInfo = formatInfo;
                    bestDifference = difference;
                  }
                }
              }
              if (bestDifference <= 3) {
                return bestFormatInfo;
              }
              return null;
            }
            function getDataBlocks(codewords, version, ecLevel) {
              var ecInfo = version.errorCorrectionLevels[ecLevel];
              var dataBlocks = [];
              var totalCodewords = 0;
              ecInfo.ecBlocks.forEach(function(block) {
                for (var i3 = 0; i3 < block.numBlocks; i3++) {
                  dataBlocks.push({ numDataCodewords: block.dataCodewordsPerBlock, codewords: [] });
                  totalCodewords += block.dataCodewordsPerBlock + ecInfo.ecCodewordsPerBlock;
                }
              });
              if (codewords.length < totalCodewords) {
                return null;
              }
              codewords = codewords.slice(0, totalCodewords);
              var shortBlockSize = ecInfo.ecBlocks[0].dataCodewordsPerBlock;
              for (var i2 = 0; i2 < shortBlockSize; i2++) {
                for (var _i = 0, dataBlocks_1 = dataBlocks; _i < dataBlocks_1.length; _i++) {
                  var dataBlock = dataBlocks_1[_i];
                  dataBlock.codewords.push(codewords.shift());
                }
              }
              if (ecInfo.ecBlocks.length > 1) {
                var smallBlockCount = ecInfo.ecBlocks[0].numBlocks;
                var largeBlockCount = ecInfo.ecBlocks[1].numBlocks;
                for (var i2 = 0; i2 < largeBlockCount; i2++) {
                  dataBlocks[smallBlockCount + i2].codewords.push(codewords.shift());
                }
              }
              while (codewords.length > 0) {
                for (var _a = 0, dataBlocks_2 = dataBlocks; _a < dataBlocks_2.length; _a++) {
                  var dataBlock = dataBlocks_2[_a];
                  dataBlock.codewords.push(codewords.shift());
                }
              }
              return dataBlocks;
            }
            function decodeMatrix(matrix) {
              var version = readVersion(matrix);
              if (!version) {
                return null;
              }
              var formatInfo = readFormatInformation(matrix);
              if (!formatInfo) {
                return null;
              }
              var codewords = readCodewords(matrix, version, formatInfo);
              var dataBlocks = getDataBlocks(codewords, version, formatInfo.errorCorrectionLevel);
              if (!dataBlocks) {
                return null;
              }
              var totalBytes = dataBlocks.reduce(function(a2, b2) {
                return a2 + b2.numDataCodewords;
              }, 0);
              var resultBytes = new Uint8ClampedArray(totalBytes);
              var resultIndex = 0;
              for (var _i = 0, dataBlocks_3 = dataBlocks; _i < dataBlocks_3.length; _i++) {
                var dataBlock = dataBlocks_3[_i];
                var correctedBytes = reedsolomon_1.decode(dataBlock.codewords, dataBlock.codewords.length - dataBlock.numDataCodewords);
                if (!correctedBytes) {
                  return null;
                }
                for (var i2 = 0; i2 < dataBlock.numDataCodewords; i2++) {
                  resultBytes[resultIndex++] = correctedBytes[i2];
                }
              }
              try {
                return decodeData_1.decode(resultBytes, version.versionNumber);
              } catch (_a) {
                return null;
              }
            }
            function decode(matrix) {
              if (matrix == null) {
                return null;
              }
              var result = decodeMatrix(matrix);
              if (result) {
                return result;
              }
              for (var x2 = 0; x2 < matrix.width; x2++) {
                for (var y2 = x2 + 1; y2 < matrix.height; y2++) {
                  if (matrix.get(x2, y2) !== matrix.get(y2, x2)) {
                    matrix.set(x2, y2, !matrix.get(x2, y2));
                    matrix.set(y2, x2, !matrix.get(y2, x2));
                  }
                }
              }
              return decodeMatrix(matrix);
            }
            exports2.decode = decode;
          },
          /* 6 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitStream_1 = __webpack_require__(7);
            var shiftJISTable_1 = __webpack_require__(8);
            var Mode;
            (function(Mode2) {
              Mode2["Numeric"] = "numeric";
              Mode2["Alphanumeric"] = "alphanumeric";
              Mode2["Byte"] = "byte";
              Mode2["Kanji"] = "kanji";
              Mode2["ECI"] = "eci";
            })(Mode = exports2.Mode || (exports2.Mode = {}));
            var ModeByte;
            (function(ModeByte2) {
              ModeByte2[ModeByte2["Terminator"] = 0] = "Terminator";
              ModeByte2[ModeByte2["Numeric"] = 1] = "Numeric";
              ModeByte2[ModeByte2["Alphanumeric"] = 2] = "Alphanumeric";
              ModeByte2[ModeByte2["Byte"] = 4] = "Byte";
              ModeByte2[ModeByte2["Kanji"] = 8] = "Kanji";
              ModeByte2[ModeByte2["ECI"] = 7] = "ECI";
            })(ModeByte || (ModeByte = {}));
            function decodeNumeric(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [10, 12, 14][size];
              var length2 = stream.readBits(characterCountSize);
              while (length2 >= 3) {
                var num = stream.readBits(10);
                if (num >= 1e3) {
                  throw new Error("Invalid numeric value above 999");
                }
                var a2 = Math.floor(num / 100);
                var b2 = Math.floor(num / 10) % 10;
                var c2 = num % 10;
                bytes.push(48 + a2, 48 + b2, 48 + c2);
                text += a2.toString() + b2.toString() + c2.toString();
                length2 -= 3;
              }
              if (length2 === 2) {
                var num = stream.readBits(7);
                if (num >= 100) {
                  throw new Error("Invalid numeric value above 99");
                }
                var a2 = Math.floor(num / 10);
                var b2 = num % 10;
                bytes.push(48 + a2, 48 + b2);
                text += a2.toString() + b2.toString();
              } else if (length2 === 1) {
                var num = stream.readBits(4);
                if (num >= 10) {
                  throw new Error("Invalid numeric value above 9");
                }
                bytes.push(48 + num);
                text += num.toString();
              }
              return { bytes, text };
            }
            var AlphanumericCharacterCodes = [
              "0",
              "1",
              "2",
              "3",
              "4",
              "5",
              "6",
              "7",
              "8",
              "9",
              "A",
              "B",
              "C",
              "D",
              "E",
              "F",
              "G",
              "H",
              "I",
              "J",
              "K",
              "L",
              "M",
              "N",
              "O",
              "P",
              "Q",
              "R",
              "S",
              "T",
              "U",
              "V",
              "W",
              "X",
              "Y",
              "Z",
              " ",
              "$",
              "%",
              "*",
              "+",
              "-",
              ".",
              "/",
              ":"
            ];
            function decodeAlphanumeric(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [9, 11, 13][size];
              var length2 = stream.readBits(characterCountSize);
              while (length2 >= 2) {
                var v2 = stream.readBits(11);
                var a2 = Math.floor(v2 / 45);
                var b2 = v2 % 45;
                bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0), AlphanumericCharacterCodes[b2].charCodeAt(0));
                text += AlphanumericCharacterCodes[a2] + AlphanumericCharacterCodes[b2];
                length2 -= 2;
              }
              if (length2 === 1) {
                var a2 = stream.readBits(6);
                bytes.push(AlphanumericCharacterCodes[a2].charCodeAt(0));
                text += AlphanumericCharacterCodes[a2];
              }
              return { bytes, text };
            }
            function decodeByte(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [8, 16, 16][size];
              var length2 = stream.readBits(characterCountSize);
              for (var i2 = 0; i2 < length2; i2++) {
                var b2 = stream.readBits(8);
                bytes.push(b2);
              }
              try {
                text += decodeURIComponent(bytes.map(function(b3) {
                  return "%" + ("0" + b3.toString(16)).substr(-2);
                }).join(""));
              } catch (_a) {
              }
              return { bytes, text };
            }
            function decodeKanji(stream, size) {
              var bytes = [];
              var text = "";
              var characterCountSize = [8, 10, 12][size];
              var length2 = stream.readBits(characterCountSize);
              for (var i2 = 0; i2 < length2; i2++) {
                var k2 = stream.readBits(13);
                var c2 = Math.floor(k2 / 192) << 8 | k2 % 192;
                if (c2 < 7936) {
                  c2 += 33088;
                } else {
                  c2 += 49472;
                }
                bytes.push(c2 >> 8, c2 & 255);
                text += String.fromCharCode(shiftJISTable_1.shiftJISTable[c2]);
              }
              return { bytes, text };
            }
            function decode(data, version) {
              var _a, _b, _c, _d;
              var stream = new BitStream_1.BitStream(data);
              var size = version <= 9 ? 0 : version <= 26 ? 1 : 2;
              var result = {
                text: "",
                bytes: [],
                chunks: [],
                version
              };
              while (stream.available() >= 4) {
                var mode = stream.readBits(4);
                if (mode === ModeByte.Terminator) {
                  return result;
                } else if (mode === ModeByte.ECI) {
                  if (stream.readBits(1) === 0) {
                    result.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(7)
                    });
                  } else if (stream.readBits(1) === 0) {
                    result.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(14)
                    });
                  } else if (stream.readBits(1) === 0) {
                    result.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: stream.readBits(21)
                    });
                  } else {
                    result.chunks.push({
                      type: Mode.ECI,
                      assignmentNumber: -1
                    });
                  }
                } else if (mode === ModeByte.Numeric) {
                  var numericResult = decodeNumeric(stream, size);
                  result.text += numericResult.text;
                  (_a = result.bytes).push.apply(_a, numericResult.bytes);
                  result.chunks.push({
                    type: Mode.Numeric,
                    text: numericResult.text
                  });
                } else if (mode === ModeByte.Alphanumeric) {
                  var alphanumericResult = decodeAlphanumeric(stream, size);
                  result.text += alphanumericResult.text;
                  (_b = result.bytes).push.apply(_b, alphanumericResult.bytes);
                  result.chunks.push({
                    type: Mode.Alphanumeric,
                    text: alphanumericResult.text
                  });
                } else if (mode === ModeByte.Byte) {
                  var byteResult = decodeByte(stream, size);
                  result.text += byteResult.text;
                  (_c = result.bytes).push.apply(_c, byteResult.bytes);
                  result.chunks.push({
                    type: Mode.Byte,
                    bytes: byteResult.bytes,
                    text: byteResult.text
                  });
                } else if (mode === ModeByte.Kanji) {
                  var kanjiResult = decodeKanji(stream, size);
                  result.text += kanjiResult.text;
                  (_d = result.bytes).push.apply(_d, kanjiResult.bytes);
                  result.chunks.push({
                    type: Mode.Kanji,
                    bytes: kanjiResult.bytes,
                    text: kanjiResult.text
                  });
                }
              }
              if (stream.available() === 0 || stream.readBits(stream.available()) === 0) {
                return result;
              }
            }
            exports2.decode = decode;
          },
          /* 7 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitStream = (
              /** @class */
              function() {
                function BitStream2(bytes) {
                  this.byteOffset = 0;
                  this.bitOffset = 0;
                  this.bytes = bytes;
                }
                BitStream2.prototype.readBits = function(numBits) {
                  if (numBits < 1 || numBits > 32 || numBits > this.available()) {
                    throw new Error("Cannot read " + numBits.toString() + " bits");
                  }
                  var result = 0;
                  if (this.bitOffset > 0) {
                    var bitsLeft = 8 - this.bitOffset;
                    var toRead = numBits < bitsLeft ? numBits : bitsLeft;
                    var bitsToNotRead = bitsLeft - toRead;
                    var mask = 255 >> 8 - toRead << bitsToNotRead;
                    result = (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                    numBits -= toRead;
                    this.bitOffset += toRead;
                    if (this.bitOffset === 8) {
                      this.bitOffset = 0;
                      this.byteOffset++;
                    }
                  }
                  if (numBits > 0) {
                    while (numBits >= 8) {
                      result = result << 8 | this.bytes[this.byteOffset] & 255;
                      this.byteOffset++;
                      numBits -= 8;
                    }
                    if (numBits > 0) {
                      var bitsToNotRead = 8 - numBits;
                      var mask = 255 >> bitsToNotRead << bitsToNotRead;
                      result = result << numBits | (this.bytes[this.byteOffset] & mask) >> bitsToNotRead;
                      this.bitOffset += numBits;
                    }
                  }
                  return result;
                };
                BitStream2.prototype.available = function() {
                  return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
                };
                return BitStream2;
              }()
            );
            exports2.BitStream = BitStream;
          },
          /* 8 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.shiftJISTable = {
              32: 32,
              33: 33,
              34: 34,
              35: 35,
              36: 36,
              37: 37,
              38: 38,
              39: 39,
              40: 40,
              41: 41,
              42: 42,
              43: 43,
              44: 44,
              45: 45,
              46: 46,
              47: 47,
              48: 48,
              49: 49,
              50: 50,
              51: 51,
              52: 52,
              53: 53,
              54: 54,
              55: 55,
              56: 56,
              57: 57,
              58: 58,
              59: 59,
              60: 60,
              61: 61,
              62: 62,
              63: 63,
              64: 64,
              65: 65,
              66: 66,
              67: 67,
              68: 68,
              69: 69,
              70: 70,
              71: 71,
              72: 72,
              73: 73,
              74: 74,
              75: 75,
              76: 76,
              77: 77,
              78: 78,
              79: 79,
              80: 80,
              81: 81,
              82: 82,
              83: 83,
              84: 84,
              85: 85,
              86: 86,
              87: 87,
              88: 88,
              89: 89,
              90: 90,
              91: 91,
              92: 165,
              93: 93,
              94: 94,
              95: 95,
              96: 96,
              97: 97,
              98: 98,
              99: 99,
              100: 100,
              101: 101,
              102: 102,
              103: 103,
              104: 104,
              105: 105,
              106: 106,
              107: 107,
              108: 108,
              109: 109,
              110: 110,
              111: 111,
              112: 112,
              113: 113,
              114: 114,
              115: 115,
              116: 116,
              117: 117,
              118: 118,
              119: 119,
              120: 120,
              121: 121,
              122: 122,
              123: 123,
              124: 124,
              125: 125,
              126: 8254,
              33088: 12288,
              33089: 12289,
              33090: 12290,
              33091: 65292,
              33092: 65294,
              33093: 12539,
              33094: 65306,
              33095: 65307,
              33096: 65311,
              33097: 65281,
              33098: 12443,
              33099: 12444,
              33100: 180,
              33101: 65344,
              33102: 168,
              33103: 65342,
              33104: 65507,
              33105: 65343,
              33106: 12541,
              33107: 12542,
              33108: 12445,
              33109: 12446,
              33110: 12291,
              33111: 20189,
              33112: 12293,
              33113: 12294,
              33114: 12295,
              33115: 12540,
              33116: 8213,
              33117: 8208,
              33118: 65295,
              33119: 92,
              33120: 12316,
              33121: 8214,
              33122: 65372,
              33123: 8230,
              33124: 8229,
              33125: 8216,
              33126: 8217,
              33127: 8220,
              33128: 8221,
              33129: 65288,
              33130: 65289,
              33131: 12308,
              33132: 12309,
              33133: 65339,
              33134: 65341,
              33135: 65371,
              33136: 65373,
              33137: 12296,
              33138: 12297,
              33139: 12298,
              33140: 12299,
              33141: 12300,
              33142: 12301,
              33143: 12302,
              33144: 12303,
              33145: 12304,
              33146: 12305,
              33147: 65291,
              33148: 8722,
              33149: 177,
              33150: 215,
              33152: 247,
              33153: 65309,
              33154: 8800,
              33155: 65308,
              33156: 65310,
              33157: 8806,
              33158: 8807,
              33159: 8734,
              33160: 8756,
              33161: 9794,
              33162: 9792,
              33163: 176,
              33164: 8242,
              33165: 8243,
              33166: 8451,
              33167: 65509,
              33168: 65284,
              33169: 162,
              33170: 163,
              33171: 65285,
              33172: 65283,
              33173: 65286,
              33174: 65290,
              33175: 65312,
              33176: 167,
              33177: 9734,
              33178: 9733,
              33179: 9675,
              33180: 9679,
              33181: 9678,
              33182: 9671,
              33183: 9670,
              33184: 9633,
              33185: 9632,
              33186: 9651,
              33187: 9650,
              33188: 9661,
              33189: 9660,
              33190: 8251,
              33191: 12306,
              33192: 8594,
              33193: 8592,
              33194: 8593,
              33195: 8595,
              33196: 12307,
              33208: 8712,
              33209: 8715,
              33210: 8838,
              33211: 8839,
              33212: 8834,
              33213: 8835,
              33214: 8746,
              33215: 8745,
              33224: 8743,
              33225: 8744,
              33226: 172,
              33227: 8658,
              33228: 8660,
              33229: 8704,
              33230: 8707,
              33242: 8736,
              33243: 8869,
              33244: 8978,
              33245: 8706,
              33246: 8711,
              33247: 8801,
              33248: 8786,
              33249: 8810,
              33250: 8811,
              33251: 8730,
              33252: 8765,
              33253: 8733,
              33254: 8757,
              33255: 8747,
              33256: 8748,
              33264: 8491,
              33265: 8240,
              33266: 9839,
              33267: 9837,
              33268: 9834,
              33269: 8224,
              33270: 8225,
              33271: 182,
              33276: 9711,
              33359: 65296,
              33360: 65297,
              33361: 65298,
              33362: 65299,
              33363: 65300,
              33364: 65301,
              33365: 65302,
              33366: 65303,
              33367: 65304,
              33368: 65305,
              33376: 65313,
              33377: 65314,
              33378: 65315,
              33379: 65316,
              33380: 65317,
              33381: 65318,
              33382: 65319,
              33383: 65320,
              33384: 65321,
              33385: 65322,
              33386: 65323,
              33387: 65324,
              33388: 65325,
              33389: 65326,
              33390: 65327,
              33391: 65328,
              33392: 65329,
              33393: 65330,
              33394: 65331,
              33395: 65332,
              33396: 65333,
              33397: 65334,
              33398: 65335,
              33399: 65336,
              33400: 65337,
              33401: 65338,
              33409: 65345,
              33410: 65346,
              33411: 65347,
              33412: 65348,
              33413: 65349,
              33414: 65350,
              33415: 65351,
              33416: 65352,
              33417: 65353,
              33418: 65354,
              33419: 65355,
              33420: 65356,
              33421: 65357,
              33422: 65358,
              33423: 65359,
              33424: 65360,
              33425: 65361,
              33426: 65362,
              33427: 65363,
              33428: 65364,
              33429: 65365,
              33430: 65366,
              33431: 65367,
              33432: 65368,
              33433: 65369,
              33434: 65370,
              33439: 12353,
              33440: 12354,
              33441: 12355,
              33442: 12356,
              33443: 12357,
              33444: 12358,
              33445: 12359,
              33446: 12360,
              33447: 12361,
              33448: 12362,
              33449: 12363,
              33450: 12364,
              33451: 12365,
              33452: 12366,
              33453: 12367,
              33454: 12368,
              33455: 12369,
              33456: 12370,
              33457: 12371,
              33458: 12372,
              33459: 12373,
              33460: 12374,
              33461: 12375,
              33462: 12376,
              33463: 12377,
              33464: 12378,
              33465: 12379,
              33466: 12380,
              33467: 12381,
              33468: 12382,
              33469: 12383,
              33470: 12384,
              33471: 12385,
              33472: 12386,
              33473: 12387,
              33474: 12388,
              33475: 12389,
              33476: 12390,
              33477: 12391,
              33478: 12392,
              33479: 12393,
              33480: 12394,
              33481: 12395,
              33482: 12396,
              33483: 12397,
              33484: 12398,
              33485: 12399,
              33486: 12400,
              33487: 12401,
              33488: 12402,
              33489: 12403,
              33490: 12404,
              33491: 12405,
              33492: 12406,
              33493: 12407,
              33494: 12408,
              33495: 12409,
              33496: 12410,
              33497: 12411,
              33498: 12412,
              33499: 12413,
              33500: 12414,
              33501: 12415,
              33502: 12416,
              33503: 12417,
              33504: 12418,
              33505: 12419,
              33506: 12420,
              33507: 12421,
              33508: 12422,
              33509: 12423,
              33510: 12424,
              33511: 12425,
              33512: 12426,
              33513: 12427,
              33514: 12428,
              33515: 12429,
              33516: 12430,
              33517: 12431,
              33518: 12432,
              33519: 12433,
              33520: 12434,
              33521: 12435,
              33600: 12449,
              33601: 12450,
              33602: 12451,
              33603: 12452,
              33604: 12453,
              33605: 12454,
              33606: 12455,
              33607: 12456,
              33608: 12457,
              33609: 12458,
              33610: 12459,
              33611: 12460,
              33612: 12461,
              33613: 12462,
              33614: 12463,
              33615: 12464,
              33616: 12465,
              33617: 12466,
              33618: 12467,
              33619: 12468,
              33620: 12469,
              33621: 12470,
              33622: 12471,
              33623: 12472,
              33624: 12473,
              33625: 12474,
              33626: 12475,
              33627: 12476,
              33628: 12477,
              33629: 12478,
              33630: 12479,
              33631: 12480,
              33632: 12481,
              33633: 12482,
              33634: 12483,
              33635: 12484,
              33636: 12485,
              33637: 12486,
              33638: 12487,
              33639: 12488,
              33640: 12489,
              33641: 12490,
              33642: 12491,
              33643: 12492,
              33644: 12493,
              33645: 12494,
              33646: 12495,
              33647: 12496,
              33648: 12497,
              33649: 12498,
              33650: 12499,
              33651: 12500,
              33652: 12501,
              33653: 12502,
              33654: 12503,
              33655: 12504,
              33656: 12505,
              33657: 12506,
              33658: 12507,
              33659: 12508,
              33660: 12509,
              33661: 12510,
              33662: 12511,
              33664: 12512,
              33665: 12513,
              33666: 12514,
              33667: 12515,
              33668: 12516,
              33669: 12517,
              33670: 12518,
              33671: 12519,
              33672: 12520,
              33673: 12521,
              33674: 12522,
              33675: 12523,
              33676: 12524,
              33677: 12525,
              33678: 12526,
              33679: 12527,
              33680: 12528,
              33681: 12529,
              33682: 12530,
              33683: 12531,
              33684: 12532,
              33685: 12533,
              33686: 12534,
              33695: 913,
              33696: 914,
              33697: 915,
              33698: 916,
              33699: 917,
              33700: 918,
              33701: 919,
              33702: 920,
              33703: 921,
              33704: 922,
              33705: 923,
              33706: 924,
              33707: 925,
              33708: 926,
              33709: 927,
              33710: 928,
              33711: 929,
              33712: 931,
              33713: 932,
              33714: 933,
              33715: 934,
              33716: 935,
              33717: 936,
              33718: 937,
              33727: 945,
              33728: 946,
              33729: 947,
              33730: 948,
              33731: 949,
              33732: 950,
              33733: 951,
              33734: 952,
              33735: 953,
              33736: 954,
              33737: 955,
              33738: 956,
              33739: 957,
              33740: 958,
              33741: 959,
              33742: 960,
              33743: 961,
              33744: 963,
              33745: 964,
              33746: 965,
              33747: 966,
              33748: 967,
              33749: 968,
              33750: 969,
              33856: 1040,
              33857: 1041,
              33858: 1042,
              33859: 1043,
              33860: 1044,
              33861: 1045,
              33862: 1025,
              33863: 1046,
              33864: 1047,
              33865: 1048,
              33866: 1049,
              33867: 1050,
              33868: 1051,
              33869: 1052,
              33870: 1053,
              33871: 1054,
              33872: 1055,
              33873: 1056,
              33874: 1057,
              33875: 1058,
              33876: 1059,
              33877: 1060,
              33878: 1061,
              33879: 1062,
              33880: 1063,
              33881: 1064,
              33882: 1065,
              33883: 1066,
              33884: 1067,
              33885: 1068,
              33886: 1069,
              33887: 1070,
              33888: 1071,
              33904: 1072,
              33905: 1073,
              33906: 1074,
              33907: 1075,
              33908: 1076,
              33909: 1077,
              33910: 1105,
              33911: 1078,
              33912: 1079,
              33913: 1080,
              33914: 1081,
              33915: 1082,
              33916: 1083,
              33917: 1084,
              33918: 1085,
              33920: 1086,
              33921: 1087,
              33922: 1088,
              33923: 1089,
              33924: 1090,
              33925: 1091,
              33926: 1092,
              33927: 1093,
              33928: 1094,
              33929: 1095,
              33930: 1096,
              33931: 1097,
              33932: 1098,
              33933: 1099,
              33934: 1100,
              33935: 1101,
              33936: 1102,
              33937: 1103,
              33951: 9472,
              33952: 9474,
              33953: 9484,
              33954: 9488,
              33955: 9496,
              33956: 9492,
              33957: 9500,
              33958: 9516,
              33959: 9508,
              33960: 9524,
              33961: 9532,
              33962: 9473,
              33963: 9475,
              33964: 9487,
              33965: 9491,
              33966: 9499,
              33967: 9495,
              33968: 9507,
              33969: 9523,
              33970: 9515,
              33971: 9531,
              33972: 9547,
              33973: 9504,
              33974: 9519,
              33975: 9512,
              33976: 9527,
              33977: 9535,
              33978: 9501,
              33979: 9520,
              33980: 9509,
              33981: 9528,
              33982: 9538,
              34975: 20124,
              34976: 21782,
              34977: 23043,
              34978: 38463,
              34979: 21696,
              34980: 24859,
              34981: 25384,
              34982: 23030,
              34983: 36898,
              34984: 33909,
              34985: 33564,
              34986: 31312,
              34987: 24746,
              34988: 25569,
              34989: 28197,
              34990: 26093,
              34991: 33894,
              34992: 33446,
              34993: 39925,
              34994: 26771,
              34995: 22311,
              34996: 26017,
              34997: 25201,
              34998: 23451,
              34999: 22992,
              35e3: 34427,
              35001: 39156,
              35002: 32098,
              35003: 32190,
              35004: 39822,
              35005: 25110,
              35006: 31903,
              35007: 34999,
              35008: 23433,
              35009: 24245,
              35010: 25353,
              35011: 26263,
              35012: 26696,
              35013: 38343,
              35014: 38797,
              35015: 26447,
              35016: 20197,
              35017: 20234,
              35018: 20301,
              35019: 20381,
              35020: 20553,
              35021: 22258,
              35022: 22839,
              35023: 22996,
              35024: 23041,
              35025: 23561,
              35026: 24799,
              35027: 24847,
              35028: 24944,
              35029: 26131,
              35030: 26885,
              35031: 28858,
              35032: 30031,
              35033: 30064,
              35034: 31227,
              35035: 32173,
              35036: 32239,
              35037: 32963,
              35038: 33806,
              35039: 34915,
              35040: 35586,
              35041: 36949,
              35042: 36986,
              35043: 21307,
              35044: 20117,
              35045: 20133,
              35046: 22495,
              35047: 32946,
              35048: 37057,
              35049: 30959,
              35050: 19968,
              35051: 22769,
              35052: 28322,
              35053: 36920,
              35054: 31282,
              35055: 33576,
              35056: 33419,
              35057: 39983,
              35058: 20801,
              35059: 21360,
              35060: 21693,
              35061: 21729,
              35062: 22240,
              35063: 23035,
              35064: 24341,
              35065: 39154,
              35066: 28139,
              35067: 32996,
              35068: 34093,
              35136: 38498,
              35137: 38512,
              35138: 38560,
              35139: 38907,
              35140: 21515,
              35141: 21491,
              35142: 23431,
              35143: 28879,
              35144: 32701,
              35145: 36802,
              35146: 38632,
              35147: 21359,
              35148: 40284,
              35149: 31418,
              35150: 19985,
              35151: 30867,
              35152: 33276,
              35153: 28198,
              35154: 22040,
              35155: 21764,
              35156: 27421,
              35157: 34074,
              35158: 39995,
              35159: 23013,
              35160: 21417,
              35161: 28006,
              35162: 29916,
              35163: 38287,
              35164: 22082,
              35165: 20113,
              35166: 36939,
              35167: 38642,
              35168: 33615,
              35169: 39180,
              35170: 21473,
              35171: 21942,
              35172: 23344,
              35173: 24433,
              35174: 26144,
              35175: 26355,
              35176: 26628,
              35177: 27704,
              35178: 27891,
              35179: 27945,
              35180: 29787,
              35181: 30408,
              35182: 31310,
              35183: 38964,
              35184: 33521,
              35185: 34907,
              35186: 35424,
              35187: 37613,
              35188: 28082,
              35189: 30123,
              35190: 30410,
              35191: 39365,
              35192: 24742,
              35193: 35585,
              35194: 36234,
              35195: 38322,
              35196: 27022,
              35197: 21421,
              35198: 20870,
              35200: 22290,
              35201: 22576,
              35202: 22852,
              35203: 23476,
              35204: 24310,
              35205: 24616,
              35206: 25513,
              35207: 25588,
              35208: 27839,
              35209: 28436,
              35210: 28814,
              35211: 28948,
              35212: 29017,
              35213: 29141,
              35214: 29503,
              35215: 32257,
              35216: 33398,
              35217: 33489,
              35218: 34199,
              35219: 36960,
              35220: 37467,
              35221: 40219,
              35222: 22633,
              35223: 26044,
              35224: 27738,
              35225: 29989,
              35226: 20985,
              35227: 22830,
              35228: 22885,
              35229: 24448,
              35230: 24540,
              35231: 25276,
              35232: 26106,
              35233: 27178,
              35234: 27431,
              35235: 27572,
              35236: 29579,
              35237: 32705,
              35238: 35158,
              35239: 40236,
              35240: 40206,
              35241: 40644,
              35242: 23713,
              35243: 27798,
              35244: 33659,
              35245: 20740,
              35246: 23627,
              35247: 25014,
              35248: 33222,
              35249: 26742,
              35250: 29281,
              35251: 20057,
              35252: 20474,
              35253: 21368,
              35254: 24681,
              35255: 28201,
              35256: 31311,
              35257: 38899,
              35258: 19979,
              35259: 21270,
              35260: 20206,
              35261: 20309,
              35262: 20285,
              35263: 20385,
              35264: 20339,
              35265: 21152,
              35266: 21487,
              35267: 22025,
              35268: 22799,
              35269: 23233,
              35270: 23478,
              35271: 23521,
              35272: 31185,
              35273: 26247,
              35274: 26524,
              35275: 26550,
              35276: 27468,
              35277: 27827,
              35278: 28779,
              35279: 29634,
              35280: 31117,
              35281: 31166,
              35282: 31292,
              35283: 31623,
              35284: 33457,
              35285: 33499,
              35286: 33540,
              35287: 33655,
              35288: 33775,
              35289: 33747,
              35290: 34662,
              35291: 35506,
              35292: 22057,
              35293: 36008,
              35294: 36838,
              35295: 36942,
              35296: 38686,
              35297: 34442,
              35298: 20420,
              35299: 23784,
              35300: 25105,
              35301: 29273,
              35302: 30011,
              35303: 33253,
              35304: 33469,
              35305: 34558,
              35306: 36032,
              35307: 38597,
              35308: 39187,
              35309: 39381,
              35310: 20171,
              35311: 20250,
              35312: 35299,
              35313: 22238,
              35314: 22602,
              35315: 22730,
              35316: 24315,
              35317: 24555,
              35318: 24618,
              35319: 24724,
              35320: 24674,
              35321: 25040,
              35322: 25106,
              35323: 25296,
              35324: 25913,
              35392: 39745,
              35393: 26214,
              35394: 26800,
              35395: 28023,
              35396: 28784,
              35397: 30028,
              35398: 30342,
              35399: 32117,
              35400: 33445,
              35401: 34809,
              35402: 38283,
              35403: 38542,
              35404: 35997,
              35405: 20977,
              35406: 21182,
              35407: 22806,
              35408: 21683,
              35409: 23475,
              35410: 23830,
              35411: 24936,
              35412: 27010,
              35413: 28079,
              35414: 30861,
              35415: 33995,
              35416: 34903,
              35417: 35442,
              35418: 37799,
              35419: 39608,
              35420: 28012,
              35421: 39336,
              35422: 34521,
              35423: 22435,
              35424: 26623,
              35425: 34510,
              35426: 37390,
              35427: 21123,
              35428: 22151,
              35429: 21508,
              35430: 24275,
              35431: 25313,
              35432: 25785,
              35433: 26684,
              35434: 26680,
              35435: 27579,
              35436: 29554,
              35437: 30906,
              35438: 31339,
              35439: 35226,
              35440: 35282,
              35441: 36203,
              35442: 36611,
              35443: 37101,
              35444: 38307,
              35445: 38548,
              35446: 38761,
              35447: 23398,
              35448: 23731,
              35449: 27005,
              35450: 38989,
              35451: 38990,
              35452: 25499,
              35453: 31520,
              35454: 27179,
              35456: 27263,
              35457: 26806,
              35458: 39949,
              35459: 28511,
              35460: 21106,
              35461: 21917,
              35462: 24688,
              35463: 25324,
              35464: 27963,
              35465: 28167,
              35466: 28369,
              35467: 33883,
              35468: 35088,
              35469: 36676,
              35470: 19988,
              35471: 39993,
              35472: 21494,
              35473: 26907,
              35474: 27194,
              35475: 38788,
              35476: 26666,
              35477: 20828,
              35478: 31427,
              35479: 33970,
              35480: 37340,
              35481: 37772,
              35482: 22107,
              35483: 40232,
              35484: 26658,
              35485: 33541,
              35486: 33841,
              35487: 31909,
              35488: 21e3,
              35489: 33477,
              35490: 29926,
              35491: 20094,
              35492: 20355,
              35493: 20896,
              35494: 23506,
              35495: 21002,
              35496: 21208,
              35497: 21223,
              35498: 24059,
              35499: 21914,
              35500: 22570,
              35501: 23014,
              35502: 23436,
              35503: 23448,
              35504: 23515,
              35505: 24178,
              35506: 24185,
              35507: 24739,
              35508: 24863,
              35509: 24931,
              35510: 25022,
              35511: 25563,
              35512: 25954,
              35513: 26577,
              35514: 26707,
              35515: 26874,
              35516: 27454,
              35517: 27475,
              35518: 27735,
              35519: 28450,
              35520: 28567,
              35521: 28485,
              35522: 29872,
              35523: 29976,
              35524: 30435,
              35525: 30475,
              35526: 31487,
              35527: 31649,
              35528: 31777,
              35529: 32233,
              35530: 32566,
              35531: 32752,
              35532: 32925,
              35533: 33382,
              35534: 33694,
              35535: 35251,
              35536: 35532,
              35537: 36011,
              35538: 36996,
              35539: 37969,
              35540: 38291,
              35541: 38289,
              35542: 38306,
              35543: 38501,
              35544: 38867,
              35545: 39208,
              35546: 33304,
              35547: 20024,
              35548: 21547,
              35549: 23736,
              35550: 24012,
              35551: 29609,
              35552: 30284,
              35553: 30524,
              35554: 23721,
              35555: 32747,
              35556: 36107,
              35557: 38593,
              35558: 38929,
              35559: 38996,
              35560: 39e3,
              35561: 20225,
              35562: 20238,
              35563: 21361,
              35564: 21916,
              35565: 22120,
              35566: 22522,
              35567: 22855,
              35568: 23305,
              35569: 23492,
              35570: 23696,
              35571: 24076,
              35572: 24190,
              35573: 24524,
              35574: 25582,
              35575: 26426,
              35576: 26071,
              35577: 26082,
              35578: 26399,
              35579: 26827,
              35580: 26820,
              35648: 27231,
              35649: 24112,
              35650: 27589,
              35651: 27671,
              35652: 27773,
              35653: 30079,
              35654: 31048,
              35655: 23395,
              35656: 31232,
              35657: 32e3,
              35658: 24509,
              35659: 35215,
              35660: 35352,
              35661: 36020,
              35662: 36215,
              35663: 36556,
              35664: 36637,
              35665: 39138,
              35666: 39438,
              35667: 39740,
              35668: 20096,
              35669: 20605,
              35670: 20736,
              35671: 22931,
              35672: 23452,
              35673: 25135,
              35674: 25216,
              35675: 25836,
              35676: 27450,
              35677: 29344,
              35678: 30097,
              35679: 31047,
              35680: 32681,
              35681: 34811,
              35682: 35516,
              35683: 35696,
              35684: 25516,
              35685: 33738,
              35686: 38816,
              35687: 21513,
              35688: 21507,
              35689: 21931,
              35690: 26708,
              35691: 27224,
              35692: 35440,
              35693: 30759,
              35694: 26485,
              35695: 40653,
              35696: 21364,
              35697: 23458,
              35698: 33050,
              35699: 34384,
              35700: 36870,
              35701: 19992,
              35702: 20037,
              35703: 20167,
              35704: 20241,
              35705: 21450,
              35706: 21560,
              35707: 23470,
              35708: 24339,
              35709: 24613,
              35710: 25937,
              35712: 26429,
              35713: 27714,
              35714: 27762,
              35715: 27875,
              35716: 28792,
              35717: 29699,
              35718: 31350,
              35719: 31406,
              35720: 31496,
              35721: 32026,
              35722: 31998,
              35723: 32102,
              35724: 26087,
              35725: 29275,
              35726: 21435,
              35727: 23621,
              35728: 24040,
              35729: 25298,
              35730: 25312,
              35731: 25369,
              35732: 28192,
              35733: 34394,
              35734: 35377,
              35735: 36317,
              35736: 37624,
              35737: 28417,
              35738: 31142,
              35739: 39770,
              35740: 20136,
              35741: 20139,
              35742: 20140,
              35743: 20379,
              35744: 20384,
              35745: 20689,
              35746: 20807,
              35747: 31478,
              35748: 20849,
              35749: 20982,
              35750: 21332,
              35751: 21281,
              35752: 21375,
              35753: 21483,
              35754: 21932,
              35755: 22659,
              35756: 23777,
              35757: 24375,
              35758: 24394,
              35759: 24623,
              35760: 24656,
              35761: 24685,
              35762: 25375,
              35763: 25945,
              35764: 27211,
              35765: 27841,
              35766: 29378,
              35767: 29421,
              35768: 30703,
              35769: 33016,
              35770: 33029,
              35771: 33288,
              35772: 34126,
              35773: 37111,
              35774: 37857,
              35775: 38911,
              35776: 39255,
              35777: 39514,
              35778: 20208,
              35779: 20957,
              35780: 23597,
              35781: 26241,
              35782: 26989,
              35783: 23616,
              35784: 26354,
              35785: 26997,
              35786: 29577,
              35787: 26704,
              35788: 31873,
              35789: 20677,
              35790: 21220,
              35791: 22343,
              35792: 24062,
              35793: 37670,
              35794: 26020,
              35795: 27427,
              35796: 27453,
              35797: 29748,
              35798: 31105,
              35799: 31165,
              35800: 31563,
              35801: 32202,
              35802: 33465,
              35803: 33740,
              35804: 34943,
              35805: 35167,
              35806: 35641,
              35807: 36817,
              35808: 37329,
              35809: 21535,
              35810: 37504,
              35811: 20061,
              35812: 20534,
              35813: 21477,
              35814: 21306,
              35815: 29399,
              35816: 29590,
              35817: 30697,
              35818: 33510,
              35819: 36527,
              35820: 39366,
              35821: 39368,
              35822: 39378,
              35823: 20855,
              35824: 24858,
              35825: 34398,
              35826: 21936,
              35827: 31354,
              35828: 20598,
              35829: 23507,
              35830: 36935,
              35831: 38533,
              35832: 20018,
              35833: 27355,
              35834: 37351,
              35835: 23633,
              35836: 23624,
              35904: 25496,
              35905: 31391,
              35906: 27795,
              35907: 38772,
              35908: 36705,
              35909: 31402,
              35910: 29066,
              35911: 38536,
              35912: 31874,
              35913: 26647,
              35914: 32368,
              35915: 26705,
              35916: 37740,
              35917: 21234,
              35918: 21531,
              35919: 34219,
              35920: 35347,
              35921: 32676,
              35922: 36557,
              35923: 37089,
              35924: 21350,
              35925: 34952,
              35926: 31041,
              35927: 20418,
              35928: 20670,
              35929: 21009,
              35930: 20804,
              35931: 21843,
              35932: 22317,
              35933: 29674,
              35934: 22411,
              35935: 22865,
              35936: 24418,
              35937: 24452,
              35938: 24693,
              35939: 24950,
              35940: 24935,
              35941: 25001,
              35942: 25522,
              35943: 25658,
              35944: 25964,
              35945: 26223,
              35946: 26690,
              35947: 28179,
              35948: 30054,
              35949: 31293,
              35950: 31995,
              35951: 32076,
              35952: 32153,
              35953: 32331,
              35954: 32619,
              35955: 33550,
              35956: 33610,
              35957: 34509,
              35958: 35336,
              35959: 35427,
              35960: 35686,
              35961: 36605,
              35962: 38938,
              35963: 40335,
              35964: 33464,
              35965: 36814,
              35966: 39912,
              35968: 21127,
              35969: 25119,
              35970: 25731,
              35971: 28608,
              35972: 38553,
              35973: 26689,
              35974: 20625,
              35975: 27424,
              35976: 27770,
              35977: 28500,
              35978: 31348,
              35979: 32080,
              35980: 34880,
              35981: 35363,
              35982: 26376,
              35983: 20214,
              35984: 20537,
              35985: 20518,
              35986: 20581,
              35987: 20860,
              35988: 21048,
              35989: 21091,
              35990: 21927,
              35991: 22287,
              35992: 22533,
              35993: 23244,
              35994: 24314,
              35995: 25010,
              35996: 25080,
              35997: 25331,
              35998: 25458,
              35999: 26908,
              36e3: 27177,
              36001: 29309,
              36002: 29356,
              36003: 29486,
              36004: 30740,
              36005: 30831,
              36006: 32121,
              36007: 30476,
              36008: 32937,
              36009: 35211,
              36010: 35609,
              36011: 36066,
              36012: 36562,
              36013: 36963,
              36014: 37749,
              36015: 38522,
              36016: 38997,
              36017: 39443,
              36018: 40568,
              36019: 20803,
              36020: 21407,
              36021: 21427,
              36022: 24187,
              36023: 24358,
              36024: 28187,
              36025: 28304,
              36026: 29572,
              36027: 29694,
              36028: 32067,
              36029: 33335,
              36030: 35328,
              36031: 35578,
              36032: 38480,
              36033: 20046,
              36034: 20491,
              36035: 21476,
              36036: 21628,
              36037: 22266,
              36038: 22993,
              36039: 23396,
              36040: 24049,
              36041: 24235,
              36042: 24359,
              36043: 25144,
              36044: 25925,
              36045: 26543,
              36046: 28246,
              36047: 29392,
              36048: 31946,
              36049: 34996,
              36050: 32929,
              36051: 32993,
              36052: 33776,
              36053: 34382,
              36054: 35463,
              36055: 36328,
              36056: 37431,
              36057: 38599,
              36058: 39015,
              36059: 40723,
              36060: 20116,
              36061: 20114,
              36062: 20237,
              36063: 21320,
              36064: 21577,
              36065: 21566,
              36066: 23087,
              36067: 24460,
              36068: 24481,
              36069: 24735,
              36070: 26791,
              36071: 27278,
              36072: 29786,
              36073: 30849,
              36074: 35486,
              36075: 35492,
              36076: 35703,
              36077: 37264,
              36078: 20062,
              36079: 39881,
              36080: 20132,
              36081: 20348,
              36082: 20399,
              36083: 20505,
              36084: 20502,
              36085: 20809,
              36086: 20844,
              36087: 21151,
              36088: 21177,
              36089: 21246,
              36090: 21402,
              36091: 21475,
              36092: 21521,
              36160: 21518,
              36161: 21897,
              36162: 22353,
              36163: 22434,
              36164: 22909,
              36165: 23380,
              36166: 23389,
              36167: 23439,
              36168: 24037,
              36169: 24039,
              36170: 24055,
              36171: 24184,
              36172: 24195,
              36173: 24218,
              36174: 24247,
              36175: 24344,
              36176: 24658,
              36177: 24908,
              36178: 25239,
              36179: 25304,
              36180: 25511,
              36181: 25915,
              36182: 26114,
              36183: 26179,
              36184: 26356,
              36185: 26477,
              36186: 26657,
              36187: 26775,
              36188: 27083,
              36189: 27743,
              36190: 27946,
              36191: 28009,
              36192: 28207,
              36193: 28317,
              36194: 30002,
              36195: 30343,
              36196: 30828,
              36197: 31295,
              36198: 31968,
              36199: 32005,
              36200: 32024,
              36201: 32094,
              36202: 32177,
              36203: 32789,
              36204: 32771,
              36205: 32943,
              36206: 32945,
              36207: 33108,
              36208: 33167,
              36209: 33322,
              36210: 33618,
              36211: 34892,
              36212: 34913,
              36213: 35611,
              36214: 36002,
              36215: 36092,
              36216: 37066,
              36217: 37237,
              36218: 37489,
              36219: 30783,
              36220: 37628,
              36221: 38308,
              36222: 38477,
              36224: 38917,
              36225: 39321,
              36226: 39640,
              36227: 40251,
              36228: 21083,
              36229: 21163,
              36230: 21495,
              36231: 21512,
              36232: 22741,
              36233: 25335,
              36234: 28640,
              36235: 35946,
              36236: 36703,
              36237: 40633,
              36238: 20811,
              36239: 21051,
              36240: 21578,
              36241: 22269,
              36242: 31296,
              36243: 37239,
              36244: 40288,
              36245: 40658,
              36246: 29508,
              36247: 28425,
              36248: 33136,
              36249: 29969,
              36250: 24573,
              36251: 24794,
              36252: 39592,
              36253: 29403,
              36254: 36796,
              36255: 27492,
              36256: 38915,
              36257: 20170,
              36258: 22256,
              36259: 22372,
              36260: 22718,
              36261: 23130,
              36262: 24680,
              36263: 25031,
              36264: 26127,
              36265: 26118,
              36266: 26681,
              36267: 26801,
              36268: 28151,
              36269: 30165,
              36270: 32058,
              36271: 33390,
              36272: 39746,
              36273: 20123,
              36274: 20304,
              36275: 21449,
              36276: 21766,
              36277: 23919,
              36278: 24038,
              36279: 24046,
              36280: 26619,
              36281: 27801,
              36282: 29811,
              36283: 30722,
              36284: 35408,
              36285: 37782,
              36286: 35039,
              36287: 22352,
              36288: 24231,
              36289: 25387,
              36290: 20661,
              36291: 20652,
              36292: 20877,
              36293: 26368,
              36294: 21705,
              36295: 22622,
              36296: 22971,
              36297: 23472,
              36298: 24425,
              36299: 25165,
              36300: 25505,
              36301: 26685,
              36302: 27507,
              36303: 28168,
              36304: 28797,
              36305: 37319,
              36306: 29312,
              36307: 30741,
              36308: 30758,
              36309: 31085,
              36310: 25998,
              36311: 32048,
              36312: 33756,
              36313: 35009,
              36314: 36617,
              36315: 38555,
              36316: 21092,
              36317: 22312,
              36318: 26448,
              36319: 32618,
              36320: 36001,
              36321: 20916,
              36322: 22338,
              36323: 38442,
              36324: 22586,
              36325: 27018,
              36326: 32948,
              36327: 21682,
              36328: 23822,
              36329: 22524,
              36330: 30869,
              36331: 40442,
              36332: 20316,
              36333: 21066,
              36334: 21643,
              36335: 25662,
              36336: 26152,
              36337: 26388,
              36338: 26613,
              36339: 31364,
              36340: 31574,
              36341: 32034,
              36342: 37679,
              36343: 26716,
              36344: 39853,
              36345: 31545,
              36346: 21273,
              36347: 20874,
              36348: 21047,
              36416: 23519,
              36417: 25334,
              36418: 25774,
              36419: 25830,
              36420: 26413,
              36421: 27578,
              36422: 34217,
              36423: 38609,
              36424: 30352,
              36425: 39894,
              36426: 25420,
              36427: 37638,
              36428: 39851,
              36429: 30399,
              36430: 26194,
              36431: 19977,
              36432: 20632,
              36433: 21442,
              36434: 23665,
              36435: 24808,
              36436: 25746,
              36437: 25955,
              36438: 26719,
              36439: 29158,
              36440: 29642,
              36441: 29987,
              36442: 31639,
              36443: 32386,
              36444: 34453,
              36445: 35715,
              36446: 36059,
              36447: 37240,
              36448: 39184,
              36449: 26028,
              36450: 26283,
              36451: 27531,
              36452: 20181,
              36453: 20180,
              36454: 20282,
              36455: 20351,
              36456: 21050,
              36457: 21496,
              36458: 21490,
              36459: 21987,
              36460: 22235,
              36461: 22763,
              36462: 22987,
              36463: 22985,
              36464: 23039,
              36465: 23376,
              36466: 23629,
              36467: 24066,
              36468: 24107,
              36469: 24535,
              36470: 24605,
              36471: 25351,
              36472: 25903,
              36473: 23388,
              36474: 26031,
              36475: 26045,
              36476: 26088,
              36477: 26525,
              36478: 27490,
              36480: 27515,
              36481: 27663,
              36482: 29509,
              36483: 31049,
              36484: 31169,
              36485: 31992,
              36486: 32025,
              36487: 32043,
              36488: 32930,
              36489: 33026,
              36490: 33267,
              36491: 35222,
              36492: 35422,
              36493: 35433,
              36494: 35430,
              36495: 35468,
              36496: 35566,
              36497: 36039,
              36498: 36060,
              36499: 38604,
              36500: 39164,
              36501: 27503,
              36502: 20107,
              36503: 20284,
              36504: 20365,
              36505: 20816,
              36506: 23383,
              36507: 23546,
              36508: 24904,
              36509: 25345,
              36510: 26178,
              36511: 27425,
              36512: 28363,
              36513: 27835,
              36514: 29246,
              36515: 29885,
              36516: 30164,
              36517: 30913,
              36518: 31034,
              36519: 32780,
              36520: 32819,
              36521: 33258,
              36522: 33940,
              36523: 36766,
              36524: 27728,
              36525: 40575,
              36526: 24335,
              36527: 35672,
              36528: 40235,
              36529: 31482,
              36530: 36600,
              36531: 23437,
              36532: 38635,
              36533: 19971,
              36534: 21489,
              36535: 22519,
              36536: 22833,
              36537: 23241,
              36538: 23460,
              36539: 24713,
              36540: 28287,
              36541: 28422,
              36542: 30142,
              36543: 36074,
              36544: 23455,
              36545: 34048,
              36546: 31712,
              36547: 20594,
              36548: 26612,
              36549: 33437,
              36550: 23649,
              36551: 34122,
              36552: 32286,
              36553: 33294,
              36554: 20889,
              36555: 23556,
              36556: 25448,
              36557: 36198,
              36558: 26012,
              36559: 29038,
              36560: 31038,
              36561: 32023,
              36562: 32773,
              36563: 35613,
              36564: 36554,
              36565: 36974,
              36566: 34503,
              36567: 37034,
              36568: 20511,
              36569: 21242,
              36570: 23610,
              36571: 26451,
              36572: 28796,
              36573: 29237,
              36574: 37196,
              36575: 37320,
              36576: 37675,
              36577: 33509,
              36578: 23490,
              36579: 24369,
              36580: 24825,
              36581: 20027,
              36582: 21462,
              36583: 23432,
              36584: 25163,
              36585: 26417,
              36586: 27530,
              36587: 29417,
              36588: 29664,
              36589: 31278,
              36590: 33131,
              36591: 36259,
              36592: 37202,
              36593: 39318,
              36594: 20754,
              36595: 21463,
              36596: 21610,
              36597: 23551,
              36598: 25480,
              36599: 27193,
              36600: 32172,
              36601: 38656,
              36602: 22234,
              36603: 21454,
              36604: 21608,
              36672: 23447,
              36673: 23601,
              36674: 24030,
              36675: 20462,
              36676: 24833,
              36677: 25342,
              36678: 27954,
              36679: 31168,
              36680: 31179,
              36681: 32066,
              36682: 32333,
              36683: 32722,
              36684: 33261,
              36685: 33311,
              36686: 33936,
              36687: 34886,
              36688: 35186,
              36689: 35728,
              36690: 36468,
              36691: 36655,
              36692: 36913,
              36693: 37195,
              36694: 37228,
              36695: 38598,
              36696: 37276,
              36697: 20160,
              36698: 20303,
              36699: 20805,
              36700: 21313,
              36701: 24467,
              36702: 25102,
              36703: 26580,
              36704: 27713,
              36705: 28171,
              36706: 29539,
              36707: 32294,
              36708: 37325,
              36709: 37507,
              36710: 21460,
              36711: 22809,
              36712: 23487,
              36713: 28113,
              36714: 31069,
              36715: 32302,
              36716: 31899,
              36717: 22654,
              36718: 29087,
              36719: 20986,
              36720: 34899,
              36721: 36848,
              36722: 20426,
              36723: 23803,
              36724: 26149,
              36725: 30636,
              36726: 31459,
              36727: 33308,
              36728: 39423,
              36729: 20934,
              36730: 24490,
              36731: 26092,
              36732: 26991,
              36733: 27529,
              36734: 28147,
              36736: 28310,
              36737: 28516,
              36738: 30462,
              36739: 32020,
              36740: 24033,
              36741: 36981,
              36742: 37255,
              36743: 38918,
              36744: 20966,
              36745: 21021,
              36746: 25152,
              36747: 26257,
              36748: 26329,
              36749: 28186,
              36750: 24246,
              36751: 32210,
              36752: 32626,
              36753: 26360,
              36754: 34223,
              36755: 34295,
              36756: 35576,
              36757: 21161,
              36758: 21465,
              36759: 22899,
              36760: 24207,
              36761: 24464,
              36762: 24661,
              36763: 37604,
              36764: 38500,
              36765: 20663,
              36766: 20767,
              36767: 21213,
              36768: 21280,
              36769: 21319,
              36770: 21484,
              36771: 21736,
              36772: 21830,
              36773: 21809,
              36774: 22039,
              36775: 22888,
              36776: 22974,
              36777: 23100,
              36778: 23477,
              36779: 23558,
              36780: 23567,
              36781: 23569,
              36782: 23578,
              36783: 24196,
              36784: 24202,
              36785: 24288,
              36786: 24432,
              36787: 25215,
              36788: 25220,
              36789: 25307,
              36790: 25484,
              36791: 25463,
              36792: 26119,
              36793: 26124,
              36794: 26157,
              36795: 26230,
              36796: 26494,
              36797: 26786,
              36798: 27167,
              36799: 27189,
              36800: 27836,
              36801: 28040,
              36802: 28169,
              36803: 28248,
              36804: 28988,
              36805: 28966,
              36806: 29031,
              36807: 30151,
              36808: 30465,
              36809: 30813,
              36810: 30977,
              36811: 31077,
              36812: 31216,
              36813: 31456,
              36814: 31505,
              36815: 31911,
              36816: 32057,
              36817: 32918,
              36818: 33750,
              36819: 33931,
              36820: 34121,
              36821: 34909,
              36822: 35059,
              36823: 35359,
              36824: 35388,
              36825: 35412,
              36826: 35443,
              36827: 35937,
              36828: 36062,
              36829: 37284,
              36830: 37478,
              36831: 37758,
              36832: 37912,
              36833: 38556,
              36834: 38808,
              36835: 19978,
              36836: 19976,
              36837: 19998,
              36838: 20055,
              36839: 20887,
              36840: 21104,
              36841: 22478,
              36842: 22580,
              36843: 22732,
              36844: 23330,
              36845: 24120,
              36846: 24773,
              36847: 25854,
              36848: 26465,
              36849: 26454,
              36850: 27972,
              36851: 29366,
              36852: 30067,
              36853: 31331,
              36854: 33976,
              36855: 35698,
              36856: 37304,
              36857: 37664,
              36858: 22065,
              36859: 22516,
              36860: 39166,
              36928: 25325,
              36929: 26893,
              36930: 27542,
              36931: 29165,
              36932: 32340,
              36933: 32887,
              36934: 33394,
              36935: 35302,
              36936: 39135,
              36937: 34645,
              36938: 36785,
              36939: 23611,
              36940: 20280,
              36941: 20449,
              36942: 20405,
              36943: 21767,
              36944: 23072,
              36945: 23517,
              36946: 23529,
              36947: 24515,
              36948: 24910,
              36949: 25391,
              36950: 26032,
              36951: 26187,
              36952: 26862,
              36953: 27035,
              36954: 28024,
              36955: 28145,
              36956: 30003,
              36957: 30137,
              36958: 30495,
              36959: 31070,
              36960: 31206,
              36961: 32051,
              36962: 33251,
              36963: 33455,
              36964: 34218,
              36965: 35242,
              36966: 35386,
              36967: 36523,
              36968: 36763,
              36969: 36914,
              36970: 37341,
              36971: 38663,
              36972: 20154,
              36973: 20161,
              36974: 20995,
              36975: 22645,
              36976: 22764,
              36977: 23563,
              36978: 29978,
              36979: 23613,
              36980: 33102,
              36981: 35338,
              36982: 36805,
              36983: 38499,
              36984: 38765,
              36985: 31525,
              36986: 35535,
              36987: 38920,
              36988: 37218,
              36989: 22259,
              36990: 21416,
              36992: 36887,
              36993: 21561,
              36994: 22402,
              36995: 24101,
              36996: 25512,
              36997: 27700,
              36998: 28810,
              36999: 30561,
              37e3: 31883,
              37001: 32736,
              37002: 34928,
              37003: 36930,
              37004: 37204,
              37005: 37648,
              37006: 37656,
              37007: 38543,
              37008: 29790,
              37009: 39620,
              37010: 23815,
              37011: 23913,
              37012: 25968,
              37013: 26530,
              37014: 36264,
              37015: 38619,
              37016: 25454,
              37017: 26441,
              37018: 26905,
              37019: 33733,
              37020: 38935,
              37021: 38592,
              37022: 35070,
              37023: 28548,
              37024: 25722,
              37025: 23544,
              37026: 19990,
              37027: 28716,
              37028: 30045,
              37029: 26159,
              37030: 20932,
              37031: 21046,
              37032: 21218,
              37033: 22995,
              37034: 24449,
              37035: 24615,
              37036: 25104,
              37037: 25919,
              37038: 25972,
              37039: 26143,
              37040: 26228,
              37041: 26866,
              37042: 26646,
              37043: 27491,
              37044: 28165,
              37045: 29298,
              37046: 29983,
              37047: 30427,
              37048: 31934,
              37049: 32854,
              37050: 22768,
              37051: 35069,
              37052: 35199,
              37053: 35488,
              37054: 35475,
              37055: 35531,
              37056: 36893,
              37057: 37266,
              37058: 38738,
              37059: 38745,
              37060: 25993,
              37061: 31246,
              37062: 33030,
              37063: 38587,
              37064: 24109,
              37065: 24796,
              37066: 25114,
              37067: 26021,
              37068: 26132,
              37069: 26512,
              37070: 30707,
              37071: 31309,
              37072: 31821,
              37073: 32318,
              37074: 33034,
              37075: 36012,
              37076: 36196,
              37077: 36321,
              37078: 36447,
              37079: 30889,
              37080: 20999,
              37081: 25305,
              37082: 25509,
              37083: 25666,
              37084: 25240,
              37085: 35373,
              37086: 31363,
              37087: 31680,
              37088: 35500,
              37089: 38634,
              37090: 32118,
              37091: 33292,
              37092: 34633,
              37093: 20185,
              37094: 20808,
              37095: 21315,
              37096: 21344,
              37097: 23459,
              37098: 23554,
              37099: 23574,
              37100: 24029,
              37101: 25126,
              37102: 25159,
              37103: 25776,
              37104: 26643,
              37105: 26676,
              37106: 27849,
              37107: 27973,
              37108: 27927,
              37109: 26579,
              37110: 28508,
              37111: 29006,
              37112: 29053,
              37113: 26059,
              37114: 31359,
              37115: 31661,
              37116: 32218,
              37184: 32330,
              37185: 32680,
              37186: 33146,
              37187: 33307,
              37188: 33337,
              37189: 34214,
              37190: 35438,
              37191: 36046,
              37192: 36341,
              37193: 36984,
              37194: 36983,
              37195: 37549,
              37196: 37521,
              37197: 38275,
              37198: 39854,
              37199: 21069,
              37200: 21892,
              37201: 28472,
              37202: 28982,
              37203: 20840,
              37204: 31109,
              37205: 32341,
              37206: 33203,
              37207: 31950,
              37208: 22092,
              37209: 22609,
              37210: 23720,
              37211: 25514,
              37212: 26366,
              37213: 26365,
              37214: 26970,
              37215: 29401,
              37216: 30095,
              37217: 30094,
              37218: 30990,
              37219: 31062,
              37220: 31199,
              37221: 31895,
              37222: 32032,
              37223: 32068,
              37224: 34311,
              37225: 35380,
              37226: 38459,
              37227: 36961,
              37228: 40736,
              37229: 20711,
              37230: 21109,
              37231: 21452,
              37232: 21474,
              37233: 20489,
              37234: 21930,
              37235: 22766,
              37236: 22863,
              37237: 29245,
              37238: 23435,
              37239: 23652,
              37240: 21277,
              37241: 24803,
              37242: 24819,
              37243: 25436,
              37244: 25475,
              37245: 25407,
              37246: 25531,
              37248: 25805,
              37249: 26089,
              37250: 26361,
              37251: 24035,
              37252: 27085,
              37253: 27133,
              37254: 28437,
              37255: 29157,
              37256: 20105,
              37257: 30185,
              37258: 30456,
              37259: 31379,
              37260: 31967,
              37261: 32207,
              37262: 32156,
              37263: 32865,
              37264: 33609,
              37265: 33624,
              37266: 33900,
              37267: 33980,
              37268: 34299,
              37269: 35013,
              37270: 36208,
              37271: 36865,
              37272: 36973,
              37273: 37783,
              37274: 38684,
              37275: 39442,
              37276: 20687,
              37277: 22679,
              37278: 24974,
              37279: 33235,
              37280: 34101,
              37281: 36104,
              37282: 36896,
              37283: 20419,
              37284: 20596,
              37285: 21063,
              37286: 21363,
              37287: 24687,
              37288: 25417,
              37289: 26463,
              37290: 28204,
              37291: 36275,
              37292: 36895,
              37293: 20439,
              37294: 23646,
              37295: 36042,
              37296: 26063,
              37297: 32154,
              37298: 21330,
              37299: 34966,
              37300: 20854,
              37301: 25539,
              37302: 23384,
              37303: 23403,
              37304: 23562,
              37305: 25613,
              37306: 26449,
              37307: 36956,
              37308: 20182,
              37309: 22810,
              37310: 22826,
              37311: 27760,
              37312: 35409,
              37313: 21822,
              37314: 22549,
              37315: 22949,
              37316: 24816,
              37317: 25171,
              37318: 26561,
              37319: 33333,
              37320: 26965,
              37321: 38464,
              37322: 39364,
              37323: 39464,
              37324: 20307,
              37325: 22534,
              37326: 23550,
              37327: 32784,
              37328: 23729,
              37329: 24111,
              37330: 24453,
              37331: 24608,
              37332: 24907,
              37333: 25140,
              37334: 26367,
              37335: 27888,
              37336: 28382,
              37337: 32974,
              37338: 33151,
              37339: 33492,
              37340: 34955,
              37341: 36024,
              37342: 36864,
              37343: 36910,
              37344: 38538,
              37345: 40667,
              37346: 39899,
              37347: 20195,
              37348: 21488,
              37349: 22823,
              37350: 31532,
              37351: 37261,
              37352: 38988,
              37353: 40441,
              37354: 28381,
              37355: 28711,
              37356: 21331,
              37357: 21828,
              37358: 23429,
              37359: 25176,
              37360: 25246,
              37361: 25299,
              37362: 27810,
              37363: 28655,
              37364: 29730,
              37365: 35351,
              37366: 37944,
              37367: 28609,
              37368: 35582,
              37369: 33592,
              37370: 20967,
              37371: 34552,
              37372: 21482,
              37440: 21481,
              37441: 20294,
              37442: 36948,
              37443: 36784,
              37444: 22890,
              37445: 33073,
              37446: 24061,
              37447: 31466,
              37448: 36799,
              37449: 26842,
              37450: 35895,
              37451: 29432,
              37452: 40008,
              37453: 27197,
              37454: 35504,
              37455: 20025,
              37456: 21336,
              37457: 22022,
              37458: 22374,
              37459: 25285,
              37460: 25506,
              37461: 26086,
              37462: 27470,
              37463: 28129,
              37464: 28251,
              37465: 28845,
              37466: 30701,
              37467: 31471,
              37468: 31658,
              37469: 32187,
              37470: 32829,
              37471: 32966,
              37472: 34507,
              37473: 35477,
              37474: 37723,
              37475: 22243,
              37476: 22727,
              37477: 24382,
              37478: 26029,
              37479: 26262,
              37480: 27264,
              37481: 27573,
              37482: 30007,
              37483: 35527,
              37484: 20516,
              37485: 30693,
              37486: 22320,
              37487: 24347,
              37488: 24677,
              37489: 26234,
              37490: 27744,
              37491: 30196,
              37492: 31258,
              37493: 32622,
              37494: 33268,
              37495: 34584,
              37496: 36933,
              37497: 39347,
              37498: 31689,
              37499: 30044,
              37500: 31481,
              37501: 31569,
              37502: 33988,
              37504: 36880,
              37505: 31209,
              37506: 31378,
              37507: 33590,
              37508: 23265,
              37509: 30528,
              37510: 20013,
              37511: 20210,
              37512: 23449,
              37513: 24544,
              37514: 25277,
              37515: 26172,
              37516: 26609,
              37517: 27880,
              37518: 34411,
              37519: 34935,
              37520: 35387,
              37521: 37198,
              37522: 37619,
              37523: 39376,
              37524: 27159,
              37525: 28710,
              37526: 29482,
              37527: 33511,
              37528: 33879,
              37529: 36015,
              37530: 19969,
              37531: 20806,
              37532: 20939,
              37533: 21899,
              37534: 23541,
              37535: 24086,
              37536: 24115,
              37537: 24193,
              37538: 24340,
              37539: 24373,
              37540: 24427,
              37541: 24500,
              37542: 25074,
              37543: 25361,
              37544: 26274,
              37545: 26397,
              37546: 28526,
              37547: 29266,
              37548: 30010,
              37549: 30522,
              37550: 32884,
              37551: 33081,
              37552: 33144,
              37553: 34678,
              37554: 35519,
              37555: 35548,
              37556: 36229,
              37557: 36339,
              37558: 37530,
              37559: 38263,
              37560: 38914,
              37561: 40165,
              37562: 21189,
              37563: 25431,
              37564: 30452,
              37565: 26389,
              37566: 27784,
              37567: 29645,
              37568: 36035,
              37569: 37806,
              37570: 38515,
              37571: 27941,
              37572: 22684,
              37573: 26894,
              37574: 27084,
              37575: 36861,
              37576: 37786,
              37577: 30171,
              37578: 36890,
              37579: 22618,
              37580: 26626,
              37581: 25524,
              37582: 27131,
              37583: 20291,
              37584: 28460,
              37585: 26584,
              37586: 36795,
              37587: 34086,
              37588: 32180,
              37589: 37716,
              37590: 26943,
              37591: 28528,
              37592: 22378,
              37593: 22775,
              37594: 23340,
              37595: 32044,
              37596: 29226,
              37597: 21514,
              37598: 37347,
              37599: 40372,
              37600: 20141,
              37601: 20302,
              37602: 20572,
              37603: 20597,
              37604: 21059,
              37605: 35998,
              37606: 21576,
              37607: 22564,
              37608: 23450,
              37609: 24093,
              37610: 24213,
              37611: 24237,
              37612: 24311,
              37613: 24351,
              37614: 24716,
              37615: 25269,
              37616: 25402,
              37617: 25552,
              37618: 26799,
              37619: 27712,
              37620: 30855,
              37621: 31118,
              37622: 31243,
              37623: 32224,
              37624: 33351,
              37625: 35330,
              37626: 35558,
              37627: 36420,
              37628: 36883,
              37696: 37048,
              37697: 37165,
              37698: 37336,
              37699: 40718,
              37700: 27877,
              37701: 25688,
              37702: 25826,
              37703: 25973,
              37704: 28404,
              37705: 30340,
              37706: 31515,
              37707: 36969,
              37708: 37841,
              37709: 28346,
              37710: 21746,
              37711: 24505,
              37712: 25764,
              37713: 36685,
              37714: 36845,
              37715: 37444,
              37716: 20856,
              37717: 22635,
              37718: 22825,
              37719: 23637,
              37720: 24215,
              37721: 28155,
              37722: 32399,
              37723: 29980,
              37724: 36028,
              37725: 36578,
              37726: 39003,
              37727: 28857,
              37728: 20253,
              37729: 27583,
              37730: 28593,
              37731: 3e4,
              37732: 38651,
              37733: 20814,
              37734: 21520,
              37735: 22581,
              37736: 22615,
              37737: 22956,
              37738: 23648,
              37739: 24466,
              37740: 26007,
              37741: 26460,
              37742: 28193,
              37743: 30331,
              37744: 33759,
              37745: 36077,
              37746: 36884,
              37747: 37117,
              37748: 37709,
              37749: 30757,
              37750: 30778,
              37751: 21162,
              37752: 24230,
              37753: 22303,
              37754: 22900,
              37755: 24594,
              37756: 20498,
              37757: 20826,
              37758: 20908,
              37760: 20941,
              37761: 20992,
              37762: 21776,
              37763: 22612,
              37764: 22616,
              37765: 22871,
              37766: 23445,
              37767: 23798,
              37768: 23947,
              37769: 24764,
              37770: 25237,
              37771: 25645,
              37772: 26481,
              37773: 26691,
              37774: 26812,
              37775: 26847,
              37776: 30423,
              37777: 28120,
              37778: 28271,
              37779: 28059,
              37780: 28783,
              37781: 29128,
              37782: 24403,
              37783: 30168,
              37784: 31095,
              37785: 31561,
              37786: 31572,
              37787: 31570,
              37788: 31958,
              37789: 32113,
              37790: 21040,
              37791: 33891,
              37792: 34153,
              37793: 34276,
              37794: 35342,
              37795: 35588,
              37796: 35910,
              37797: 36367,
              37798: 36867,
              37799: 36879,
              37800: 37913,
              37801: 38518,
              37802: 38957,
              37803: 39472,
              37804: 38360,
              37805: 20685,
              37806: 21205,
              37807: 21516,
              37808: 22530,
              37809: 23566,
              37810: 24999,
              37811: 25758,
              37812: 27934,
              37813: 30643,
              37814: 31461,
              37815: 33012,
              37816: 33796,
              37817: 36947,
              37818: 37509,
              37819: 23776,
              37820: 40199,
              37821: 21311,
              37822: 24471,
              37823: 24499,
              37824: 28060,
              37825: 29305,
              37826: 30563,
              37827: 31167,
              37828: 31716,
              37829: 27602,
              37830: 29420,
              37831: 35501,
              37832: 26627,
              37833: 27233,
              37834: 20984,
              37835: 31361,
              37836: 26932,
              37837: 23626,
              37838: 40182,
              37839: 33515,
              37840: 23493,
              37841: 37193,
              37842: 28702,
              37843: 22136,
              37844: 23663,
              37845: 24775,
              37846: 25958,
              37847: 27788,
              37848: 35930,
              37849: 36929,
              37850: 38931,
              37851: 21585,
              37852: 26311,
              37853: 37389,
              37854: 22856,
              37855: 37027,
              37856: 20869,
              37857: 20045,
              37858: 20970,
              37859: 34201,
              37860: 35598,
              37861: 28760,
              37862: 25466,
              37863: 37707,
              37864: 26978,
              37865: 39348,
              37866: 32260,
              37867: 30071,
              37868: 21335,
              37869: 26976,
              37870: 36575,
              37871: 38627,
              37872: 27741,
              37873: 20108,
              37874: 23612,
              37875: 24336,
              37876: 36841,
              37877: 21250,
              37878: 36049,
              37879: 32905,
              37880: 34425,
              37881: 24319,
              37882: 26085,
              37883: 20083,
              37884: 20837,
              37952: 22914,
              37953: 23615,
              37954: 38894,
              37955: 20219,
              37956: 22922,
              37957: 24525,
              37958: 35469,
              37959: 28641,
              37960: 31152,
              37961: 31074,
              37962: 23527,
              37963: 33905,
              37964: 29483,
              37965: 29105,
              37966: 24180,
              37967: 24565,
              37968: 25467,
              37969: 25754,
              37970: 29123,
              37971: 31896,
              37972: 20035,
              37973: 24316,
              37974: 20043,
              37975: 22492,
              37976: 22178,
              37977: 24745,
              37978: 28611,
              37979: 32013,
              37980: 33021,
              37981: 33075,
              37982: 33215,
              37983: 36786,
              37984: 35223,
              37985: 34468,
              37986: 24052,
              37987: 25226,
              37988: 25773,
              37989: 35207,
              37990: 26487,
              37991: 27874,
              37992: 27966,
              37993: 29750,
              37994: 30772,
              37995: 23110,
              37996: 32629,
              37997: 33453,
              37998: 39340,
              37999: 20467,
              38e3: 24259,
              38001: 25309,
              38002: 25490,
              38003: 25943,
              38004: 26479,
              38005: 30403,
              38006: 29260,
              38007: 32972,
              38008: 32954,
              38009: 36649,
              38010: 37197,
              38011: 20493,
              38012: 22521,
              38013: 23186,
              38014: 26757,
              38016: 26995,
              38017: 29028,
              38018: 29437,
              38019: 36023,
              38020: 22770,
              38021: 36064,
              38022: 38506,
              38023: 36889,
              38024: 34687,
              38025: 31204,
              38026: 30695,
              38027: 33833,
              38028: 20271,
              38029: 21093,
              38030: 21338,
              38031: 25293,
              38032: 26575,
              38033: 27850,
              38034: 30333,
              38035: 31636,
              38036: 31893,
              38037: 33334,
              38038: 34180,
              38039: 36843,
              38040: 26333,
              38041: 28448,
              38042: 29190,
              38043: 32283,
              38044: 33707,
              38045: 39361,
              38046: 40614,
              38047: 20989,
              38048: 31665,
              38049: 30834,
              38050: 31672,
              38051: 32903,
              38052: 31560,
              38053: 27368,
              38054: 24161,
              38055: 32908,
              38056: 30033,
              38057: 30048,
              38058: 20843,
              38059: 37474,
              38060: 28300,
              38061: 30330,
              38062: 37271,
              38063: 39658,
              38064: 20240,
              38065: 32624,
              38066: 25244,
              38067: 31567,
              38068: 38309,
              38069: 40169,
              38070: 22138,
              38071: 22617,
              38072: 34532,
              38073: 38588,
              38074: 20276,
              38075: 21028,
              38076: 21322,
              38077: 21453,
              38078: 21467,
              38079: 24070,
              38080: 25644,
              38081: 26001,
              38082: 26495,
              38083: 27710,
              38084: 27726,
              38085: 29256,
              38086: 29359,
              38087: 29677,
              38088: 30036,
              38089: 32321,
              38090: 33324,
              38091: 34281,
              38092: 36009,
              38093: 31684,
              38094: 37318,
              38095: 29033,
              38096: 38930,
              38097: 39151,
              38098: 25405,
              38099: 26217,
              38100: 30058,
              38101: 30436,
              38102: 30928,
              38103: 34115,
              38104: 34542,
              38105: 21290,
              38106: 21329,
              38107: 21542,
              38108: 22915,
              38109: 24199,
              38110: 24444,
              38111: 24754,
              38112: 25161,
              38113: 25209,
              38114: 25259,
              38115: 26e3,
              38116: 27604,
              38117: 27852,
              38118: 30130,
              38119: 30382,
              38120: 30865,
              38121: 31192,
              38122: 32203,
              38123: 32631,
              38124: 32933,
              38125: 34987,
              38126: 35513,
              38127: 36027,
              38128: 36991,
              38129: 38750,
              38130: 39131,
              38131: 27147,
              38132: 31800,
              38133: 20633,
              38134: 23614,
              38135: 24494,
              38136: 26503,
              38137: 27608,
              38138: 29749,
              38139: 30473,
              38140: 32654,
              38208: 40763,
              38209: 26570,
              38210: 31255,
              38211: 21305,
              38212: 30091,
              38213: 39661,
              38214: 24422,
              38215: 33181,
              38216: 33777,
              38217: 32920,
              38218: 24380,
              38219: 24517,
              38220: 30050,
              38221: 31558,
              38222: 36924,
              38223: 26727,
              38224: 23019,
              38225: 23195,
              38226: 32016,
              38227: 30334,
              38228: 35628,
              38229: 20469,
              38230: 24426,
              38231: 27161,
              38232: 27703,
              38233: 28418,
              38234: 29922,
              38235: 31080,
              38236: 34920,
              38237: 35413,
              38238: 35961,
              38239: 24287,
              38240: 25551,
              38241: 30149,
              38242: 31186,
              38243: 33495,
              38244: 37672,
              38245: 37618,
              38246: 33948,
              38247: 34541,
              38248: 39981,
              38249: 21697,
              38250: 24428,
              38251: 25996,
              38252: 27996,
              38253: 28693,
              38254: 36007,
              38255: 36051,
              38256: 38971,
              38257: 25935,
              38258: 29942,
              38259: 19981,
              38260: 20184,
              38261: 22496,
              38262: 22827,
              38263: 23142,
              38264: 23500,
              38265: 20904,
              38266: 24067,
              38267: 24220,
              38268: 24598,
              38269: 25206,
              38270: 25975,
              38272: 26023,
              38273: 26222,
              38274: 28014,
              38275: 29238,
              38276: 31526,
              38277: 33104,
              38278: 33178,
              38279: 33433,
              38280: 35676,
              38281: 36e3,
              38282: 36070,
              38283: 36212,
              38284: 38428,
              38285: 38468,
              38286: 20398,
              38287: 25771,
              38288: 27494,
              38289: 33310,
              38290: 33889,
              38291: 34154,
              38292: 37096,
              38293: 23553,
              38294: 26963,
              38295: 39080,
              38296: 33914,
              38297: 34135,
              38298: 20239,
              38299: 21103,
              38300: 24489,
              38301: 24133,
              38302: 26381,
              38303: 31119,
              38304: 33145,
              38305: 35079,
              38306: 35206,
              38307: 28149,
              38308: 24343,
              38309: 25173,
              38310: 27832,
              38311: 20175,
              38312: 29289,
              38313: 39826,
              38314: 20998,
              38315: 21563,
              38316: 22132,
              38317: 22707,
              38318: 24996,
              38319: 25198,
              38320: 28954,
              38321: 22894,
              38322: 31881,
              38323: 31966,
              38324: 32027,
              38325: 38640,
              38326: 25991,
              38327: 32862,
              38328: 19993,
              38329: 20341,
              38330: 20853,
              38331: 22592,
              38332: 24163,
              38333: 24179,
              38334: 24330,
              38335: 26564,
              38336: 20006,
              38337: 34109,
              38338: 38281,
              38339: 38491,
              38340: 31859,
              38341: 38913,
              38342: 20731,
              38343: 22721,
              38344: 30294,
              38345: 30887,
              38346: 21029,
              38347: 30629,
              38348: 34065,
              38349: 31622,
              38350: 20559,
              38351: 22793,
              38352: 29255,
              38353: 31687,
              38354: 32232,
              38355: 36794,
              38356: 36820,
              38357: 36941,
              38358: 20415,
              38359: 21193,
              38360: 23081,
              38361: 24321,
              38362: 38829,
              38363: 20445,
              38364: 33303,
              38365: 37610,
              38366: 22275,
              38367: 25429,
              38368: 27497,
              38369: 29995,
              38370: 35036,
              38371: 36628,
              38372: 31298,
              38373: 21215,
              38374: 22675,
              38375: 24917,
              38376: 25098,
              38377: 26286,
              38378: 27597,
              38379: 31807,
              38380: 33769,
              38381: 20515,
              38382: 20472,
              38383: 21253,
              38384: 21574,
              38385: 22577,
              38386: 22857,
              38387: 23453,
              38388: 23792,
              38389: 23791,
              38390: 23849,
              38391: 24214,
              38392: 25265,
              38393: 25447,
              38394: 25918,
              38395: 26041,
              38396: 26379,
              38464: 27861,
              38465: 27873,
              38466: 28921,
              38467: 30770,
              38468: 32299,
              38469: 32990,
              38470: 33459,
              38471: 33804,
              38472: 34028,
              38473: 34562,
              38474: 35090,
              38475: 35370,
              38476: 35914,
              38477: 37030,
              38478: 37586,
              38479: 39165,
              38480: 40179,
              38481: 40300,
              38482: 20047,
              38483: 20129,
              38484: 20621,
              38485: 21078,
              38486: 22346,
              38487: 22952,
              38488: 24125,
              38489: 24536,
              38490: 24537,
              38491: 25151,
              38492: 26292,
              38493: 26395,
              38494: 26576,
              38495: 26834,
              38496: 20882,
              38497: 32033,
              38498: 32938,
              38499: 33192,
              38500: 35584,
              38501: 35980,
              38502: 36031,
              38503: 37502,
              38504: 38450,
              38505: 21536,
              38506: 38956,
              38507: 21271,
              38508: 20693,
              38509: 21340,
              38510: 22696,
              38511: 25778,
              38512: 26420,
              38513: 29287,
              38514: 30566,
              38515: 31302,
              38516: 37350,
              38517: 21187,
              38518: 27809,
              38519: 27526,
              38520: 22528,
              38521: 24140,
              38522: 22868,
              38523: 26412,
              38524: 32763,
              38525: 20961,
              38526: 30406,
              38528: 25705,
              38529: 30952,
              38530: 39764,
              38531: 40635,
              38532: 22475,
              38533: 22969,
              38534: 26151,
              38535: 26522,
              38536: 27598,
              38537: 21737,
              38538: 27097,
              38539: 24149,
              38540: 33180,
              38541: 26517,
              38542: 39850,
              38543: 26622,
              38544: 40018,
              38545: 26717,
              38546: 20134,
              38547: 20451,
              38548: 21448,
              38549: 25273,
              38550: 26411,
              38551: 27819,
              38552: 36804,
              38553: 20397,
              38554: 32365,
              38555: 40639,
              38556: 19975,
              38557: 24930,
              38558: 28288,
              38559: 28459,
              38560: 34067,
              38561: 21619,
              38562: 26410,
              38563: 39749,
              38564: 24051,
              38565: 31637,
              38566: 23724,
              38567: 23494,
              38568: 34588,
              38569: 28234,
              38570: 34001,
              38571: 31252,
              38572: 33032,
              38573: 22937,
              38574: 31885,
              38575: 27665,
              38576: 30496,
              38577: 21209,
              38578: 22818,
              38579: 28961,
              38580: 29279,
              38581: 30683,
              38582: 38695,
              38583: 40289,
              38584: 26891,
              38585: 23167,
              38586: 23064,
              38587: 20901,
              38588: 21517,
              38589: 21629,
              38590: 26126,
              38591: 30431,
              38592: 36855,
              38593: 37528,
              38594: 40180,
              38595: 23018,
              38596: 29277,
              38597: 28357,
              38598: 20813,
              38599: 26825,
              38600: 32191,
              38601: 32236,
              38602: 38754,
              38603: 40634,
              38604: 25720,
              38605: 27169,
              38606: 33538,
              38607: 22916,
              38608: 23391,
              38609: 27611,
              38610: 29467,
              38611: 30450,
              38612: 32178,
              38613: 32791,
              38614: 33945,
              38615: 20786,
              38616: 26408,
              38617: 40665,
              38618: 30446,
              38619: 26466,
              38620: 21247,
              38621: 39173,
              38622: 23588,
              38623: 25147,
              38624: 31870,
              38625: 36016,
              38626: 21839,
              38627: 24758,
              38628: 32011,
              38629: 38272,
              38630: 21249,
              38631: 20063,
              38632: 20918,
              38633: 22812,
              38634: 29242,
              38635: 32822,
              38636: 37326,
              38637: 24357,
              38638: 30690,
              38639: 21380,
              38640: 24441,
              38641: 32004,
              38642: 34220,
              38643: 35379,
              38644: 36493,
              38645: 38742,
              38646: 26611,
              38647: 34222,
              38648: 37971,
              38649: 24841,
              38650: 24840,
              38651: 27833,
              38652: 30290,
              38720: 35565,
              38721: 36664,
              38722: 21807,
              38723: 20305,
              38724: 20778,
              38725: 21191,
              38726: 21451,
              38727: 23461,
              38728: 24189,
              38729: 24736,
              38730: 24962,
              38731: 25558,
              38732: 26377,
              38733: 26586,
              38734: 28263,
              38735: 28044,
              38736: 29494,
              38737: 29495,
              38738: 30001,
              38739: 31056,
              38740: 35029,
              38741: 35480,
              38742: 36938,
              38743: 37009,
              38744: 37109,
              38745: 38596,
              38746: 34701,
              38747: 22805,
              38748: 20104,
              38749: 20313,
              38750: 19982,
              38751: 35465,
              38752: 36671,
              38753: 38928,
              38754: 20653,
              38755: 24188,
              38756: 22934,
              38757: 23481,
              38758: 24248,
              38759: 25562,
              38760: 25594,
              38761: 25793,
              38762: 26332,
              38763: 26954,
              38764: 27096,
              38765: 27915,
              38766: 28342,
              38767: 29076,
              38768: 29992,
              38769: 31407,
              38770: 32650,
              38771: 32768,
              38772: 33865,
              38773: 33993,
              38774: 35201,
              38775: 35617,
              38776: 36362,
              38777: 36965,
              38778: 38525,
              38779: 39178,
              38780: 24958,
              38781: 25233,
              38782: 27442,
              38784: 27779,
              38785: 28020,
              38786: 32716,
              38787: 32764,
              38788: 28096,
              38789: 32645,
              38790: 34746,
              38791: 35064,
              38792: 26469,
              38793: 33713,
              38794: 38972,
              38795: 38647,
              38796: 27931,
              38797: 32097,
              38798: 33853,
              38799: 37226,
              38800: 20081,
              38801: 21365,
              38802: 23888,
              38803: 27396,
              38804: 28651,
              38805: 34253,
              38806: 34349,
              38807: 35239,
              38808: 21033,
              38809: 21519,
              38810: 23653,
              38811: 26446,
              38812: 26792,
              38813: 29702,
              38814: 29827,
              38815: 30178,
              38816: 35023,
              38817: 35041,
              38818: 37324,
              38819: 38626,
              38820: 38520,
              38821: 24459,
              38822: 29575,
              38823: 31435,
              38824: 33870,
              38825: 25504,
              38826: 30053,
              38827: 21129,
              38828: 27969,
              38829: 28316,
              38830: 29705,
              38831: 30041,
              38832: 30827,
              38833: 31890,
              38834: 38534,
              38835: 31452,
              38836: 40845,
              38837: 20406,
              38838: 24942,
              38839: 26053,
              38840: 34396,
              38841: 20102,
              38842: 20142,
              38843: 20698,
              38844: 20001,
              38845: 20940,
              38846: 23534,
              38847: 26009,
              38848: 26753,
              38849: 28092,
              38850: 29471,
              38851: 30274,
              38852: 30637,
              38853: 31260,
              38854: 31975,
              38855: 33391,
              38856: 35538,
              38857: 36988,
              38858: 37327,
              38859: 38517,
              38860: 38936,
              38861: 21147,
              38862: 32209,
              38863: 20523,
              38864: 21400,
              38865: 26519,
              38866: 28107,
              38867: 29136,
              38868: 29747,
              38869: 33256,
              38870: 36650,
              38871: 38563,
              38872: 40023,
              38873: 40607,
              38874: 29792,
              38875: 22593,
              38876: 28057,
              38877: 32047,
              38878: 39006,
              38879: 20196,
              38880: 20278,
              38881: 20363,
              38882: 20919,
              38883: 21169,
              38884: 23994,
              38885: 24604,
              38886: 29618,
              38887: 31036,
              38888: 33491,
              38889: 37428,
              38890: 38583,
              38891: 38646,
              38892: 38666,
              38893: 40599,
              38894: 40802,
              38895: 26278,
              38896: 27508,
              38897: 21015,
              38898: 21155,
              38899: 28872,
              38900: 35010,
              38901: 24265,
              38902: 24651,
              38903: 24976,
              38904: 28451,
              38905: 29001,
              38906: 31806,
              38907: 32244,
              38908: 32879,
              38976: 34030,
              38977: 36899,
              38978: 37676,
              38979: 21570,
              38980: 39791,
              38981: 27347,
              38982: 28809,
              38983: 36034,
              38984: 36335,
              38985: 38706,
              38986: 21172,
              38987: 23105,
              38988: 24266,
              38989: 24324,
              38990: 26391,
              38991: 27004,
              38992: 27028,
              38993: 28010,
              38994: 28431,
              38995: 29282,
              38996: 29436,
              38997: 31725,
              38998: 32769,
              38999: 32894,
              39e3: 34635,
              39001: 37070,
              39002: 20845,
              39003: 40595,
              39004: 31108,
              39005: 32907,
              39006: 37682,
              39007: 35542,
              39008: 20525,
              39009: 21644,
              39010: 35441,
              39011: 27498,
              39012: 36036,
              39013: 33031,
              39014: 24785,
              39015: 26528,
              39016: 40434,
              39017: 20121,
              39018: 20120,
              39019: 39952,
              39020: 35435,
              39021: 34241,
              39022: 34152,
              39023: 26880,
              39024: 28286,
              39025: 30871,
              39026: 33109,
              39071: 24332,
              39072: 19984,
              39073: 19989,
              39074: 20010,
              39075: 20017,
              39076: 20022,
              39077: 20028,
              39078: 20031,
              39079: 20034,
              39080: 20054,
              39081: 20056,
              39082: 20098,
              39083: 20101,
              39084: 35947,
              39085: 20106,
              39086: 33298,
              39087: 24333,
              39088: 20110,
              39089: 20126,
              39090: 20127,
              39091: 20128,
              39092: 20130,
              39093: 20144,
              39094: 20147,
              39095: 20150,
              39096: 20174,
              39097: 20173,
              39098: 20164,
              39099: 20166,
              39100: 20162,
              39101: 20183,
              39102: 20190,
              39103: 20205,
              39104: 20191,
              39105: 20215,
              39106: 20233,
              39107: 20314,
              39108: 20272,
              39109: 20315,
              39110: 20317,
              39111: 20311,
              39112: 20295,
              39113: 20342,
              39114: 20360,
              39115: 20367,
              39116: 20376,
              39117: 20347,
              39118: 20329,
              39119: 20336,
              39120: 20369,
              39121: 20335,
              39122: 20358,
              39123: 20374,
              39124: 20760,
              39125: 20436,
              39126: 20447,
              39127: 20430,
              39128: 20440,
              39129: 20443,
              39130: 20433,
              39131: 20442,
              39132: 20432,
              39133: 20452,
              39134: 20453,
              39135: 20506,
              39136: 20520,
              39137: 20500,
              39138: 20522,
              39139: 20517,
              39140: 20485,
              39141: 20252,
              39142: 20470,
              39143: 20513,
              39144: 20521,
              39145: 20524,
              39146: 20478,
              39147: 20463,
              39148: 20497,
              39149: 20486,
              39150: 20547,
              39151: 20551,
              39152: 26371,
              39153: 20565,
              39154: 20560,
              39155: 20552,
              39156: 20570,
              39157: 20566,
              39158: 20588,
              39159: 20600,
              39160: 20608,
              39161: 20634,
              39162: 20613,
              39163: 20660,
              39164: 20658,
              39232: 20681,
              39233: 20682,
              39234: 20659,
              39235: 20674,
              39236: 20694,
              39237: 20702,
              39238: 20709,
              39239: 20717,
              39240: 20707,
              39241: 20718,
              39242: 20729,
              39243: 20725,
              39244: 20745,
              39245: 20737,
              39246: 20738,
              39247: 20758,
              39248: 20757,
              39249: 20756,
              39250: 20762,
              39251: 20769,
              39252: 20794,
              39253: 20791,
              39254: 20796,
              39255: 20795,
              39256: 20799,
              39257: 20800,
              39258: 20818,
              39259: 20812,
              39260: 20820,
              39261: 20834,
              39262: 31480,
              39263: 20841,
              39264: 20842,
              39265: 20846,
              39266: 20864,
              39267: 20866,
              39268: 22232,
              39269: 20876,
              39270: 20873,
              39271: 20879,
              39272: 20881,
              39273: 20883,
              39274: 20885,
              39275: 20886,
              39276: 20900,
              39277: 20902,
              39278: 20898,
              39279: 20905,
              39280: 20906,
              39281: 20907,
              39282: 20915,
              39283: 20913,
              39284: 20914,
              39285: 20912,
              39286: 20917,
              39287: 20925,
              39288: 20933,
              39289: 20937,
              39290: 20955,
              39291: 20960,
              39292: 34389,
              39293: 20969,
              39294: 20973,
              39296: 20976,
              39297: 20981,
              39298: 20990,
              39299: 20996,
              39300: 21003,
              39301: 21012,
              39302: 21006,
              39303: 21031,
              39304: 21034,
              39305: 21038,
              39306: 21043,
              39307: 21049,
              39308: 21071,
              39309: 21060,
              39310: 21067,
              39311: 21068,
              39312: 21086,
              39313: 21076,
              39314: 21098,
              39315: 21108,
              39316: 21097,
              39317: 21107,
              39318: 21119,
              39319: 21117,
              39320: 21133,
              39321: 21140,
              39322: 21138,
              39323: 21105,
              39324: 21128,
              39325: 21137,
              39326: 36776,
              39327: 36775,
              39328: 21164,
              39329: 21165,
              39330: 21180,
              39331: 21173,
              39332: 21185,
              39333: 21197,
              39334: 21207,
              39335: 21214,
              39336: 21219,
              39337: 21222,
              39338: 39149,
              39339: 21216,
              39340: 21235,
              39341: 21237,
              39342: 21240,
              39343: 21241,
              39344: 21254,
              39345: 21256,
              39346: 30008,
              39347: 21261,
              39348: 21264,
              39349: 21263,
              39350: 21269,
              39351: 21274,
              39352: 21283,
              39353: 21295,
              39354: 21297,
              39355: 21299,
              39356: 21304,
              39357: 21312,
              39358: 21318,
              39359: 21317,
              39360: 19991,
              39361: 21321,
              39362: 21325,
              39363: 20950,
              39364: 21342,
              39365: 21353,
              39366: 21358,
              39367: 22808,
              39368: 21371,
              39369: 21367,
              39370: 21378,
              39371: 21398,
              39372: 21408,
              39373: 21414,
              39374: 21413,
              39375: 21422,
              39376: 21424,
              39377: 21430,
              39378: 21443,
              39379: 31762,
              39380: 38617,
              39381: 21471,
              39382: 26364,
              39383: 29166,
              39384: 21486,
              39385: 21480,
              39386: 21485,
              39387: 21498,
              39388: 21505,
              39389: 21565,
              39390: 21568,
              39391: 21548,
              39392: 21549,
              39393: 21564,
              39394: 21550,
              39395: 21558,
              39396: 21545,
              39397: 21533,
              39398: 21582,
              39399: 21647,
              39400: 21621,
              39401: 21646,
              39402: 21599,
              39403: 21617,
              39404: 21623,
              39405: 21616,
              39406: 21650,
              39407: 21627,
              39408: 21632,
              39409: 21622,
              39410: 21636,
              39411: 21648,
              39412: 21638,
              39413: 21703,
              39414: 21666,
              39415: 21688,
              39416: 21669,
              39417: 21676,
              39418: 21700,
              39419: 21704,
              39420: 21672,
              39488: 21675,
              39489: 21698,
              39490: 21668,
              39491: 21694,
              39492: 21692,
              39493: 21720,
              39494: 21733,
              39495: 21734,
              39496: 21775,
              39497: 21780,
              39498: 21757,
              39499: 21742,
              39500: 21741,
              39501: 21754,
              39502: 21730,
              39503: 21817,
              39504: 21824,
              39505: 21859,
              39506: 21836,
              39507: 21806,
              39508: 21852,
              39509: 21829,
              39510: 21846,
              39511: 21847,
              39512: 21816,
              39513: 21811,
              39514: 21853,
              39515: 21913,
              39516: 21888,
              39517: 21679,
              39518: 21898,
              39519: 21919,
              39520: 21883,
              39521: 21886,
              39522: 21912,
              39523: 21918,
              39524: 21934,
              39525: 21884,
              39526: 21891,
              39527: 21929,
              39528: 21895,
              39529: 21928,
              39530: 21978,
              39531: 21957,
              39532: 21983,
              39533: 21956,
              39534: 21980,
              39535: 21988,
              39536: 21972,
              39537: 22036,
              39538: 22007,
              39539: 22038,
              39540: 22014,
              39541: 22013,
              39542: 22043,
              39543: 22009,
              39544: 22094,
              39545: 22096,
              39546: 29151,
              39547: 22068,
              39548: 22070,
              39549: 22066,
              39550: 22072,
              39552: 22123,
              39553: 22116,
              39554: 22063,
              39555: 22124,
              39556: 22122,
              39557: 22150,
              39558: 22144,
              39559: 22154,
              39560: 22176,
              39561: 22164,
              39562: 22159,
              39563: 22181,
              39564: 22190,
              39565: 22198,
              39566: 22196,
              39567: 22210,
              39568: 22204,
              39569: 22209,
              39570: 22211,
              39571: 22208,
              39572: 22216,
              39573: 22222,
              39574: 22225,
              39575: 22227,
              39576: 22231,
              39577: 22254,
              39578: 22265,
              39579: 22272,
              39580: 22271,
              39581: 22276,
              39582: 22281,
              39583: 22280,
              39584: 22283,
              39585: 22285,
              39586: 22291,
              39587: 22296,
              39588: 22294,
              39589: 21959,
              39590: 22300,
              39591: 22310,
              39592: 22327,
              39593: 22328,
              39594: 22350,
              39595: 22331,
              39596: 22336,
              39597: 22351,
              39598: 22377,
              39599: 22464,
              39600: 22408,
              39601: 22369,
              39602: 22399,
              39603: 22409,
              39604: 22419,
              39605: 22432,
              39606: 22451,
              39607: 22436,
              39608: 22442,
              39609: 22448,
              39610: 22467,
              39611: 22470,
              39612: 22484,
              39613: 22482,
              39614: 22483,
              39615: 22538,
              39616: 22486,
              39617: 22499,
              39618: 22539,
              39619: 22553,
              39620: 22557,
              39621: 22642,
              39622: 22561,
              39623: 22626,
              39624: 22603,
              39625: 22640,
              39626: 27584,
              39627: 22610,
              39628: 22589,
              39629: 22649,
              39630: 22661,
              39631: 22713,
              39632: 22687,
              39633: 22699,
              39634: 22714,
              39635: 22750,
              39636: 22715,
              39637: 22712,
              39638: 22702,
              39639: 22725,
              39640: 22739,
              39641: 22737,
              39642: 22743,
              39643: 22745,
              39644: 22744,
              39645: 22757,
              39646: 22748,
              39647: 22756,
              39648: 22751,
              39649: 22767,
              39650: 22778,
              39651: 22777,
              39652: 22779,
              39653: 22780,
              39654: 22781,
              39655: 22786,
              39656: 22794,
              39657: 22800,
              39658: 22811,
              39659: 26790,
              39660: 22821,
              39661: 22828,
              39662: 22829,
              39663: 22834,
              39664: 22840,
              39665: 22846,
              39666: 31442,
              39667: 22869,
              39668: 22864,
              39669: 22862,
              39670: 22874,
              39671: 22872,
              39672: 22882,
              39673: 22880,
              39674: 22887,
              39675: 22892,
              39676: 22889,
              39744: 22904,
              39745: 22913,
              39746: 22941,
              39747: 20318,
              39748: 20395,
              39749: 22947,
              39750: 22962,
              39751: 22982,
              39752: 23016,
              39753: 23004,
              39754: 22925,
              39755: 23001,
              39756: 23002,
              39757: 23077,
              39758: 23071,
              39759: 23057,
              39760: 23068,
              39761: 23049,
              39762: 23066,
              39763: 23104,
              39764: 23148,
              39765: 23113,
              39766: 23093,
              39767: 23094,
              39768: 23138,
              39769: 23146,
              39770: 23194,
              39771: 23228,
              39772: 23230,
              39773: 23243,
              39774: 23234,
              39775: 23229,
              39776: 23267,
              39777: 23255,
              39778: 23270,
              39779: 23273,
              39780: 23254,
              39781: 23290,
              39782: 23291,
              39783: 23308,
              39784: 23307,
              39785: 23318,
              39786: 23346,
              39787: 23248,
              39788: 23338,
              39789: 23350,
              39790: 23358,
              39791: 23363,
              39792: 23365,
              39793: 23360,
              39794: 23377,
              39795: 23381,
              39796: 23386,
              39797: 23387,
              39798: 23397,
              39799: 23401,
              39800: 23408,
              39801: 23411,
              39802: 23413,
              39803: 23416,
              39804: 25992,
              39805: 23418,
              39806: 23424,
              39808: 23427,
              39809: 23462,
              39810: 23480,
              39811: 23491,
              39812: 23495,
              39813: 23497,
              39814: 23508,
              39815: 23504,
              39816: 23524,
              39817: 23526,
              39818: 23522,
              39819: 23518,
              39820: 23525,
              39821: 23531,
              39822: 23536,
              39823: 23542,
              39824: 23539,
              39825: 23557,
              39826: 23559,
              39827: 23560,
              39828: 23565,
              39829: 23571,
              39830: 23584,
              39831: 23586,
              39832: 23592,
              39833: 23608,
              39834: 23609,
              39835: 23617,
              39836: 23622,
              39837: 23630,
              39838: 23635,
              39839: 23632,
              39840: 23631,
              39841: 23409,
              39842: 23660,
              39843: 23662,
              39844: 20066,
              39845: 23670,
              39846: 23673,
              39847: 23692,
              39848: 23697,
              39849: 23700,
              39850: 22939,
              39851: 23723,
              39852: 23739,
              39853: 23734,
              39854: 23740,
              39855: 23735,
              39856: 23749,
              39857: 23742,
              39858: 23751,
              39859: 23769,
              39860: 23785,
              39861: 23805,
              39862: 23802,
              39863: 23789,
              39864: 23948,
              39865: 23786,
              39866: 23819,
              39867: 23829,
              39868: 23831,
              39869: 23900,
              39870: 23839,
              39871: 23835,
              39872: 23825,
              39873: 23828,
              39874: 23842,
              39875: 23834,
              39876: 23833,
              39877: 23832,
              39878: 23884,
              39879: 23890,
              39880: 23886,
              39881: 23883,
              39882: 23916,
              39883: 23923,
              39884: 23926,
              39885: 23943,
              39886: 23940,
              39887: 23938,
              39888: 23970,
              39889: 23965,
              39890: 23980,
              39891: 23982,
              39892: 23997,
              39893: 23952,
              39894: 23991,
              39895: 23996,
              39896: 24009,
              39897: 24013,
              39898: 24019,
              39899: 24018,
              39900: 24022,
              39901: 24027,
              39902: 24043,
              39903: 24050,
              39904: 24053,
              39905: 24075,
              39906: 24090,
              39907: 24089,
              39908: 24081,
              39909: 24091,
              39910: 24118,
              39911: 24119,
              39912: 24132,
              39913: 24131,
              39914: 24128,
              39915: 24142,
              39916: 24151,
              39917: 24148,
              39918: 24159,
              39919: 24162,
              39920: 24164,
              39921: 24135,
              39922: 24181,
              39923: 24182,
              39924: 24186,
              39925: 40636,
              39926: 24191,
              39927: 24224,
              39928: 24257,
              39929: 24258,
              39930: 24264,
              39931: 24272,
              39932: 24271,
              4e4: 24278,
              40001: 24291,
              40002: 24285,
              40003: 24282,
              40004: 24283,
              40005: 24290,
              40006: 24289,
              40007: 24296,
              40008: 24297,
              40009: 24300,
              40010: 24305,
              40011: 24307,
              40012: 24304,
              40013: 24308,
              40014: 24312,
              40015: 24318,
              40016: 24323,
              40017: 24329,
              40018: 24413,
              40019: 24412,
              40020: 24331,
              40021: 24337,
              40022: 24342,
              40023: 24361,
              40024: 24365,
              40025: 24376,
              40026: 24385,
              40027: 24392,
              40028: 24396,
              40029: 24398,
              40030: 24367,
              40031: 24401,
              40032: 24406,
              40033: 24407,
              40034: 24409,
              40035: 24417,
              40036: 24429,
              40037: 24435,
              40038: 24439,
              40039: 24451,
              40040: 24450,
              40041: 24447,
              40042: 24458,
              40043: 24456,
              40044: 24465,
              40045: 24455,
              40046: 24478,
              40047: 24473,
              40048: 24472,
              40049: 24480,
              40050: 24488,
              40051: 24493,
              40052: 24508,
              40053: 24534,
              40054: 24571,
              40055: 24548,
              40056: 24568,
              40057: 24561,
              40058: 24541,
              40059: 24755,
              40060: 24575,
              40061: 24609,
              40062: 24672,
              40064: 24601,
              40065: 24592,
              40066: 24617,
              40067: 24590,
              40068: 24625,
              40069: 24603,
              40070: 24597,
              40071: 24619,
              40072: 24614,
              40073: 24591,
              40074: 24634,
              40075: 24666,
              40076: 24641,
              40077: 24682,
              40078: 24695,
              40079: 24671,
              40080: 24650,
              40081: 24646,
              40082: 24653,
              40083: 24675,
              40084: 24643,
              40085: 24676,
              40086: 24642,
              40087: 24684,
              40088: 24683,
              40089: 24665,
              40090: 24705,
              40091: 24717,
              40092: 24807,
              40093: 24707,
              40094: 24730,
              40095: 24708,
              40096: 24731,
              40097: 24726,
              40098: 24727,
              40099: 24722,
              40100: 24743,
              40101: 24715,
              40102: 24801,
              40103: 24760,
              40104: 24800,
              40105: 24787,
              40106: 24756,
              40107: 24560,
              40108: 24765,
              40109: 24774,
              40110: 24757,
              40111: 24792,
              40112: 24909,
              40113: 24853,
              40114: 24838,
              40115: 24822,
              40116: 24823,
              40117: 24832,
              40118: 24820,
              40119: 24826,
              40120: 24835,
              40121: 24865,
              40122: 24827,
              40123: 24817,
              40124: 24845,
              40125: 24846,
              40126: 24903,
              40127: 24894,
              40128: 24872,
              40129: 24871,
              40130: 24906,
              40131: 24895,
              40132: 24892,
              40133: 24876,
              40134: 24884,
              40135: 24893,
              40136: 24898,
              40137: 24900,
              40138: 24947,
              40139: 24951,
              40140: 24920,
              40141: 24921,
              40142: 24922,
              40143: 24939,
              40144: 24948,
              40145: 24943,
              40146: 24933,
              40147: 24945,
              40148: 24927,
              40149: 24925,
              40150: 24915,
              40151: 24949,
              40152: 24985,
              40153: 24982,
              40154: 24967,
              40155: 25004,
              40156: 24980,
              40157: 24986,
              40158: 24970,
              40159: 24977,
              40160: 25003,
              40161: 25006,
              40162: 25036,
              40163: 25034,
              40164: 25033,
              40165: 25079,
              40166: 25032,
              40167: 25027,
              40168: 25030,
              40169: 25018,
              40170: 25035,
              40171: 32633,
              40172: 25037,
              40173: 25062,
              40174: 25059,
              40175: 25078,
              40176: 25082,
              40177: 25076,
              40178: 25087,
              40179: 25085,
              40180: 25084,
              40181: 25086,
              40182: 25088,
              40183: 25096,
              40184: 25097,
              40185: 25101,
              40186: 25100,
              40187: 25108,
              40188: 25115,
              40256: 25118,
              40257: 25121,
              40258: 25130,
              40259: 25134,
              40260: 25136,
              40261: 25138,
              40262: 25139,
              40263: 25153,
              40264: 25166,
              40265: 25182,
              40266: 25187,
              40267: 25179,
              40268: 25184,
              40269: 25192,
              40270: 25212,
              40271: 25218,
              40272: 25225,
              40273: 25214,
              40274: 25234,
              40275: 25235,
              40276: 25238,
              40277: 25300,
              40278: 25219,
              40279: 25236,
              40280: 25303,
              40281: 25297,
              40282: 25275,
              40283: 25295,
              40284: 25343,
              40285: 25286,
              40286: 25812,
              40287: 25288,
              40288: 25308,
              40289: 25292,
              40290: 25290,
              40291: 25282,
              40292: 25287,
              40293: 25243,
              40294: 25289,
              40295: 25356,
              40296: 25326,
              40297: 25329,
              40298: 25383,
              40299: 25346,
              40300: 25352,
              40301: 25327,
              40302: 25333,
              40303: 25424,
              40304: 25406,
              40305: 25421,
              40306: 25628,
              40307: 25423,
              40308: 25494,
              40309: 25486,
              40310: 25472,
              40311: 25515,
              40312: 25462,
              40313: 25507,
              40314: 25487,
              40315: 25481,
              40316: 25503,
              40317: 25525,
              40318: 25451,
              40320: 25449,
              40321: 25534,
              40322: 25577,
              40323: 25536,
              40324: 25542,
              40325: 25571,
              40326: 25545,
              40327: 25554,
              40328: 25590,
              40329: 25540,
              40330: 25622,
              40331: 25652,
              40332: 25606,
              40333: 25619,
              40334: 25638,
              40335: 25654,
              40336: 25885,
              40337: 25623,
              40338: 25640,
              40339: 25615,
              40340: 25703,
              40341: 25711,
              40342: 25718,
              40343: 25678,
              40344: 25898,
              40345: 25749,
              40346: 25747,
              40347: 25765,
              40348: 25769,
              40349: 25736,
              40350: 25788,
              40351: 25818,
              40352: 25810,
              40353: 25797,
              40354: 25799,
              40355: 25787,
              40356: 25816,
              40357: 25794,
              40358: 25841,
              40359: 25831,
              40360: 33289,
              40361: 25824,
              40362: 25825,
              40363: 25260,
              40364: 25827,
              40365: 25839,
              40366: 25900,
              40367: 25846,
              40368: 25844,
              40369: 25842,
              40370: 25850,
              40371: 25856,
              40372: 25853,
              40373: 25880,
              40374: 25884,
              40375: 25861,
              40376: 25892,
              40377: 25891,
              40378: 25899,
              40379: 25908,
              40380: 25909,
              40381: 25911,
              40382: 25910,
              40383: 25912,
              40384: 30027,
              40385: 25928,
              40386: 25942,
              40387: 25941,
              40388: 25933,
              40389: 25944,
              40390: 25950,
              40391: 25949,
              40392: 25970,
              40393: 25976,
              40394: 25986,
              40395: 25987,
              40396: 35722,
              40397: 26011,
              40398: 26015,
              40399: 26027,
              40400: 26039,
              40401: 26051,
              40402: 26054,
              40403: 26049,
              40404: 26052,
              40405: 26060,
              40406: 26066,
              40407: 26075,
              40408: 26073,
              40409: 26080,
              40410: 26081,
              40411: 26097,
              40412: 26482,
              40413: 26122,
              40414: 26115,
              40415: 26107,
              40416: 26483,
              40417: 26165,
              40418: 26166,
              40419: 26164,
              40420: 26140,
              40421: 26191,
              40422: 26180,
              40423: 26185,
              40424: 26177,
              40425: 26206,
              40426: 26205,
              40427: 26212,
              40428: 26215,
              40429: 26216,
              40430: 26207,
              40431: 26210,
              40432: 26224,
              40433: 26243,
              40434: 26248,
              40435: 26254,
              40436: 26249,
              40437: 26244,
              40438: 26264,
              40439: 26269,
              40440: 26305,
              40441: 26297,
              40442: 26313,
              40443: 26302,
              40444: 26300,
              40512: 26308,
              40513: 26296,
              40514: 26326,
              40515: 26330,
              40516: 26336,
              40517: 26175,
              40518: 26342,
              40519: 26345,
              40520: 26352,
              40521: 26357,
              40522: 26359,
              40523: 26383,
              40524: 26390,
              40525: 26398,
              40526: 26406,
              40527: 26407,
              40528: 38712,
              40529: 26414,
              40530: 26431,
              40531: 26422,
              40532: 26433,
              40533: 26424,
              40534: 26423,
              40535: 26438,
              40536: 26462,
              40537: 26464,
              40538: 26457,
              40539: 26467,
              40540: 26468,
              40541: 26505,
              40542: 26480,
              40543: 26537,
              40544: 26492,
              40545: 26474,
              40546: 26508,
              40547: 26507,
              40548: 26534,
              40549: 26529,
              40550: 26501,
              40551: 26551,
              40552: 26607,
              40553: 26548,
              40554: 26604,
              40555: 26547,
              40556: 26601,
              40557: 26552,
              40558: 26596,
              40559: 26590,
              40560: 26589,
              40561: 26594,
              40562: 26606,
              40563: 26553,
              40564: 26574,
              40565: 26566,
              40566: 26599,
              40567: 27292,
              40568: 26654,
              40569: 26694,
              40570: 26665,
              40571: 26688,
              40572: 26701,
              40573: 26674,
              40574: 26702,
              40576: 26803,
              40577: 26667,
              40578: 26713,
              40579: 26723,
              40580: 26743,
              40581: 26751,
              40582: 26783,
              40583: 26767,
              40584: 26797,
              40585: 26772,
              40586: 26781,
              40587: 26779,
              40588: 26755,
              40589: 27310,
              40590: 26809,
              40591: 26740,
              40592: 26805,
              40593: 26784,
              40594: 26810,
              40595: 26895,
              40596: 26765,
              40597: 26750,
              40598: 26881,
              40599: 26826,
              40600: 26888,
              40601: 26840,
              40602: 26914,
              40603: 26918,
              40604: 26849,
              40605: 26892,
              40606: 26829,
              40607: 26836,
              40608: 26855,
              40609: 26837,
              40610: 26934,
              40611: 26898,
              40612: 26884,
              40613: 26839,
              40614: 26851,
              40615: 26917,
              40616: 26873,
              40617: 26848,
              40618: 26863,
              40619: 26920,
              40620: 26922,
              40621: 26906,
              40622: 26915,
              40623: 26913,
              40624: 26822,
              40625: 27001,
              40626: 26999,
              40627: 26972,
              40628: 27e3,
              40629: 26987,
              40630: 26964,
              40631: 27006,
              40632: 26990,
              40633: 26937,
              40634: 26996,
              40635: 26941,
              40636: 26969,
              40637: 26928,
              40638: 26977,
              40639: 26974,
              40640: 26973,
              40641: 27009,
              40642: 26986,
              40643: 27058,
              40644: 27054,
              40645: 27088,
              40646: 27071,
              40647: 27073,
              40648: 27091,
              40649: 27070,
              40650: 27086,
              40651: 23528,
              40652: 27082,
              40653: 27101,
              40654: 27067,
              40655: 27075,
              40656: 27047,
              40657: 27182,
              40658: 27025,
              40659: 27040,
              40660: 27036,
              40661: 27029,
              40662: 27060,
              40663: 27102,
              40664: 27112,
              40665: 27138,
              40666: 27163,
              40667: 27135,
              40668: 27402,
              40669: 27129,
              40670: 27122,
              40671: 27111,
              40672: 27141,
              40673: 27057,
              40674: 27166,
              40675: 27117,
              40676: 27156,
              40677: 27115,
              40678: 27146,
              40679: 27154,
              40680: 27329,
              40681: 27171,
              40682: 27155,
              40683: 27204,
              40684: 27148,
              40685: 27250,
              40686: 27190,
              40687: 27256,
              40688: 27207,
              40689: 27234,
              40690: 27225,
              40691: 27238,
              40692: 27208,
              40693: 27192,
              40694: 27170,
              40695: 27280,
              40696: 27277,
              40697: 27296,
              40698: 27268,
              40699: 27298,
              40700: 27299,
              40768: 27287,
              40769: 34327,
              40770: 27323,
              40771: 27331,
              40772: 27330,
              40773: 27320,
              40774: 27315,
              40775: 27308,
              40776: 27358,
              40777: 27345,
              40778: 27359,
              40779: 27306,
              40780: 27354,
              40781: 27370,
              40782: 27387,
              40783: 27397,
              40784: 34326,
              40785: 27386,
              40786: 27410,
              40787: 27414,
              40788: 39729,
              40789: 27423,
              40790: 27448,
              40791: 27447,
              40792: 30428,
              40793: 27449,
              40794: 39150,
              40795: 27463,
              40796: 27459,
              40797: 27465,
              40798: 27472,
              40799: 27481,
              40800: 27476,
              40801: 27483,
              40802: 27487,
              40803: 27489,
              40804: 27512,
              40805: 27513,
              40806: 27519,
              40807: 27520,
              40808: 27524,
              40809: 27523,
              40810: 27533,
              40811: 27544,
              40812: 27541,
              40813: 27550,
              40814: 27556,
              40815: 27562,
              40816: 27563,
              40817: 27567,
              40818: 27570,
              40819: 27569,
              40820: 27571,
              40821: 27575,
              40822: 27580,
              40823: 27590,
              40824: 27595,
              40825: 27603,
              40826: 27615,
              40827: 27628,
              40828: 27627,
              40829: 27635,
              40830: 27631,
              40832: 40638,
              40833: 27656,
              40834: 27667,
              40835: 27668,
              40836: 27675,
              40837: 27684,
              40838: 27683,
              40839: 27742,
              40840: 27733,
              40841: 27746,
              40842: 27754,
              40843: 27778,
              40844: 27789,
              40845: 27802,
              40846: 27777,
              40847: 27803,
              40848: 27774,
              40849: 27752,
              40850: 27763,
              40851: 27794,
              40852: 27792,
              40853: 27844,
              40854: 27889,
              40855: 27859,
              40856: 27837,
              40857: 27863,
              40858: 27845,
              40859: 27869,
              40860: 27822,
              40861: 27825,
              40862: 27838,
              40863: 27834,
              40864: 27867,
              40865: 27887,
              40866: 27865,
              40867: 27882,
              40868: 27935,
              40869: 34893,
              40870: 27958,
              40871: 27947,
              40872: 27965,
              40873: 27960,
              40874: 27929,
              40875: 27957,
              40876: 27955,
              40877: 27922,
              40878: 27916,
              40879: 28003,
              40880: 28051,
              40881: 28004,
              40882: 27994,
              40883: 28025,
              40884: 27993,
              40885: 28046,
              40886: 28053,
              40887: 28644,
              40888: 28037,
              40889: 28153,
              40890: 28181,
              40891: 28170,
              40892: 28085,
              40893: 28103,
              40894: 28134,
              40895: 28088,
              40896: 28102,
              40897: 28140,
              40898: 28126,
              40899: 28108,
              40900: 28136,
              40901: 28114,
              40902: 28101,
              40903: 28154,
              40904: 28121,
              40905: 28132,
              40906: 28117,
              40907: 28138,
              40908: 28142,
              40909: 28205,
              40910: 28270,
              40911: 28206,
              40912: 28185,
              40913: 28274,
              40914: 28255,
              40915: 28222,
              40916: 28195,
              40917: 28267,
              40918: 28203,
              40919: 28278,
              40920: 28237,
              40921: 28191,
              40922: 28227,
              40923: 28218,
              40924: 28238,
              40925: 28196,
              40926: 28415,
              40927: 28189,
              40928: 28216,
              40929: 28290,
              40930: 28330,
              40931: 28312,
              40932: 28361,
              40933: 28343,
              40934: 28371,
              40935: 28349,
              40936: 28335,
              40937: 28356,
              40938: 28338,
              40939: 28372,
              40940: 28373,
              40941: 28303,
              40942: 28325,
              40943: 28354,
              40944: 28319,
              40945: 28481,
              40946: 28433,
              40947: 28748,
              40948: 28396,
              40949: 28408,
              40950: 28414,
              40951: 28479,
              40952: 28402,
              40953: 28465,
              40954: 28399,
              40955: 28466,
              40956: 28364,
              161: 65377,
              162: 65378,
              163: 65379,
              164: 65380,
              165: 65381,
              166: 65382,
              167: 65383,
              168: 65384,
              169: 65385,
              170: 65386,
              171: 65387,
              172: 65388,
              173: 65389,
              174: 65390,
              175: 65391,
              176: 65392,
              177: 65393,
              178: 65394,
              179: 65395,
              180: 65396,
              181: 65397,
              182: 65398,
              183: 65399,
              184: 65400,
              185: 65401,
              186: 65402,
              187: 65403,
              188: 65404,
              189: 65405,
              190: 65406,
              191: 65407,
              192: 65408,
              193: 65409,
              194: 65410,
              195: 65411,
              196: 65412,
              197: 65413,
              198: 65414,
              199: 65415,
              200: 65416,
              201: 65417,
              202: 65418,
              203: 65419,
              204: 65420,
              205: 65421,
              206: 65422,
              207: 65423,
              208: 65424,
              209: 65425,
              210: 65426,
              211: 65427,
              212: 65428,
              213: 65429,
              214: 65430,
              215: 65431,
              216: 65432,
              217: 65433,
              218: 65434,
              219: 65435,
              220: 65436,
              221: 65437,
              222: 65438,
              223: 65439,
              57408: 28478,
              57409: 28435,
              57410: 28407,
              57411: 28550,
              57412: 28538,
              57413: 28536,
              57414: 28545,
              57415: 28544,
              57416: 28527,
              57417: 28507,
              57418: 28659,
              57419: 28525,
              57420: 28546,
              57421: 28540,
              57422: 28504,
              57423: 28558,
              57424: 28561,
              57425: 28610,
              57426: 28518,
              57427: 28595,
              57428: 28579,
              57429: 28577,
              57430: 28580,
              57431: 28601,
              57432: 28614,
              57433: 28586,
              57434: 28639,
              57435: 28629,
              57436: 28652,
              57437: 28628,
              57438: 28632,
              57439: 28657,
              57440: 28654,
              57441: 28635,
              57442: 28681,
              57443: 28683,
              57444: 28666,
              57445: 28689,
              57446: 28673,
              57447: 28687,
              57448: 28670,
              57449: 28699,
              57450: 28698,
              57451: 28532,
              57452: 28701,
              57453: 28696,
              57454: 28703,
              57455: 28720,
              57456: 28734,
              57457: 28722,
              57458: 28753,
              57459: 28771,
              57460: 28825,
              57461: 28818,
              57462: 28847,
              57463: 28913,
              57464: 28844,
              57465: 28856,
              57466: 28851,
              57467: 28846,
              57468: 28895,
              57469: 28875,
              57470: 28893,
              57472: 28889,
              57473: 28937,
              57474: 28925,
              57475: 28956,
              57476: 28953,
              57477: 29029,
              57478: 29013,
              57479: 29064,
              57480: 29030,
              57481: 29026,
              57482: 29004,
              57483: 29014,
              57484: 29036,
              57485: 29071,
              57486: 29179,
              57487: 29060,
              57488: 29077,
              57489: 29096,
              57490: 29100,
              57491: 29143,
              57492: 29113,
              57493: 29118,
              57494: 29138,
              57495: 29129,
              57496: 29140,
              57497: 29134,
              57498: 29152,
              57499: 29164,
              57500: 29159,
              57501: 29173,
              57502: 29180,
              57503: 29177,
              57504: 29183,
              57505: 29197,
              57506: 29200,
              57507: 29211,
              57508: 29224,
              57509: 29229,
              57510: 29228,
              57511: 29232,
              57512: 29234,
              57513: 29243,
              57514: 29244,
              57515: 29247,
              57516: 29248,
              57517: 29254,
              57518: 29259,
              57519: 29272,
              57520: 29300,
              57521: 29310,
              57522: 29314,
              57523: 29313,
              57524: 29319,
              57525: 29330,
              57526: 29334,
              57527: 29346,
              57528: 29351,
              57529: 29369,
              57530: 29362,
              57531: 29379,
              57532: 29382,
              57533: 29380,
              57534: 29390,
              57535: 29394,
              57536: 29410,
              57537: 29408,
              57538: 29409,
              57539: 29433,
              57540: 29431,
              57541: 20495,
              57542: 29463,
              57543: 29450,
              57544: 29468,
              57545: 29462,
              57546: 29469,
              57547: 29492,
              57548: 29487,
              57549: 29481,
              57550: 29477,
              57551: 29502,
              57552: 29518,
              57553: 29519,
              57554: 40664,
              57555: 29527,
              57556: 29546,
              57557: 29544,
              57558: 29552,
              57559: 29560,
              57560: 29557,
              57561: 29563,
              57562: 29562,
              57563: 29640,
              57564: 29619,
              57565: 29646,
              57566: 29627,
              57567: 29632,
              57568: 29669,
              57569: 29678,
              57570: 29662,
              57571: 29858,
              57572: 29701,
              57573: 29807,
              57574: 29733,
              57575: 29688,
              57576: 29746,
              57577: 29754,
              57578: 29781,
              57579: 29759,
              57580: 29791,
              57581: 29785,
              57582: 29761,
              57583: 29788,
              57584: 29801,
              57585: 29808,
              57586: 29795,
              57587: 29802,
              57588: 29814,
              57589: 29822,
              57590: 29835,
              57591: 29854,
              57592: 29863,
              57593: 29898,
              57594: 29903,
              57595: 29908,
              57596: 29681,
              57664: 29920,
              57665: 29923,
              57666: 29927,
              57667: 29929,
              57668: 29934,
              57669: 29938,
              57670: 29936,
              57671: 29937,
              57672: 29944,
              57673: 29943,
              57674: 29956,
              57675: 29955,
              57676: 29957,
              57677: 29964,
              57678: 29966,
              57679: 29965,
              57680: 29973,
              57681: 29971,
              57682: 29982,
              57683: 29990,
              57684: 29996,
              57685: 30012,
              57686: 30020,
              57687: 30029,
              57688: 30026,
              57689: 30025,
              57690: 30043,
              57691: 30022,
              57692: 30042,
              57693: 30057,
              57694: 30052,
              57695: 30055,
              57696: 30059,
              57697: 30061,
              57698: 30072,
              57699: 30070,
              57700: 30086,
              57701: 30087,
              57702: 30068,
              57703: 30090,
              57704: 30089,
              57705: 30082,
              57706: 30100,
              57707: 30106,
              57708: 30109,
              57709: 30117,
              57710: 30115,
              57711: 30146,
              57712: 30131,
              57713: 30147,
              57714: 30133,
              57715: 30141,
              57716: 30136,
              57717: 30140,
              57718: 30129,
              57719: 30157,
              57720: 30154,
              57721: 30162,
              57722: 30169,
              57723: 30179,
              57724: 30174,
              57725: 30206,
              57726: 30207,
              57728: 30204,
              57729: 30209,
              57730: 30192,
              57731: 30202,
              57732: 30194,
              57733: 30195,
              57734: 30219,
              57735: 30221,
              57736: 30217,
              57737: 30239,
              57738: 30247,
              57739: 30240,
              57740: 30241,
              57741: 30242,
              57742: 30244,
              57743: 30260,
              57744: 30256,
              57745: 30267,
              57746: 30279,
              57747: 30280,
              57748: 30278,
              57749: 30300,
              57750: 30296,
              57751: 30305,
              57752: 30306,
              57753: 30312,
              57754: 30313,
              57755: 30314,
              57756: 30311,
              57757: 30316,
              57758: 30320,
              57759: 30322,
              57760: 30326,
              57761: 30328,
              57762: 30332,
              57763: 30336,
              57764: 30339,
              57765: 30344,
              57766: 30347,
              57767: 30350,
              57768: 30358,
              57769: 30355,
              57770: 30361,
              57771: 30362,
              57772: 30384,
              57773: 30388,
              57774: 30392,
              57775: 30393,
              57776: 30394,
              57777: 30402,
              57778: 30413,
              57779: 30422,
              57780: 30418,
              57781: 30430,
              57782: 30433,
              57783: 30437,
              57784: 30439,
              57785: 30442,
              57786: 34351,
              57787: 30459,
              57788: 30472,
              57789: 30471,
              57790: 30468,
              57791: 30505,
              57792: 30500,
              57793: 30494,
              57794: 30501,
              57795: 30502,
              57796: 30491,
              57797: 30519,
              57798: 30520,
              57799: 30535,
              57800: 30554,
              57801: 30568,
              57802: 30571,
              57803: 30555,
              57804: 30565,
              57805: 30591,
              57806: 30590,
              57807: 30585,
              57808: 30606,
              57809: 30603,
              57810: 30609,
              57811: 30624,
              57812: 30622,
              57813: 30640,
              57814: 30646,
              57815: 30649,
              57816: 30655,
              57817: 30652,
              57818: 30653,
              57819: 30651,
              57820: 30663,
              57821: 30669,
              57822: 30679,
              57823: 30682,
              57824: 30684,
              57825: 30691,
              57826: 30702,
              57827: 30716,
              57828: 30732,
              57829: 30738,
              57830: 31014,
              57831: 30752,
              57832: 31018,
              57833: 30789,
              57834: 30862,
              57835: 30836,
              57836: 30854,
              57837: 30844,
              57838: 30874,
              57839: 30860,
              57840: 30883,
              57841: 30901,
              57842: 30890,
              57843: 30895,
              57844: 30929,
              57845: 30918,
              57846: 30923,
              57847: 30932,
              57848: 30910,
              57849: 30908,
              57850: 30917,
              57851: 30922,
              57852: 30956,
              57920: 30951,
              57921: 30938,
              57922: 30973,
              57923: 30964,
              57924: 30983,
              57925: 30994,
              57926: 30993,
              57927: 31001,
              57928: 31020,
              57929: 31019,
              57930: 31040,
              57931: 31072,
              57932: 31063,
              57933: 31071,
              57934: 31066,
              57935: 31061,
              57936: 31059,
              57937: 31098,
              57938: 31103,
              57939: 31114,
              57940: 31133,
              57941: 31143,
              57942: 40779,
              57943: 31146,
              57944: 31150,
              57945: 31155,
              57946: 31161,
              57947: 31162,
              57948: 31177,
              57949: 31189,
              57950: 31207,
              57951: 31212,
              57952: 31201,
              57953: 31203,
              57954: 31240,
              57955: 31245,
              57956: 31256,
              57957: 31257,
              57958: 31264,
              57959: 31263,
              57960: 31104,
              57961: 31281,
              57962: 31291,
              57963: 31294,
              57964: 31287,
              57965: 31299,
              57966: 31319,
              57967: 31305,
              57968: 31329,
              57969: 31330,
              57970: 31337,
              57971: 40861,
              57972: 31344,
              57973: 31353,
              57974: 31357,
              57975: 31368,
              57976: 31383,
              57977: 31381,
              57978: 31384,
              57979: 31382,
              57980: 31401,
              57981: 31432,
              57982: 31408,
              57984: 31414,
              57985: 31429,
              57986: 31428,
              57987: 31423,
              57988: 36995,
              57989: 31431,
              57990: 31434,
              57991: 31437,
              57992: 31439,
              57993: 31445,
              57994: 31443,
              57995: 31449,
              57996: 31450,
              57997: 31453,
              57998: 31457,
              57999: 31458,
              58e3: 31462,
              58001: 31469,
              58002: 31472,
              58003: 31490,
              58004: 31503,
              58005: 31498,
              58006: 31494,
              58007: 31539,
              58008: 31512,
              58009: 31513,
              58010: 31518,
              58011: 31541,
              58012: 31528,
              58013: 31542,
              58014: 31568,
              58015: 31610,
              58016: 31492,
              58017: 31565,
              58018: 31499,
              58019: 31564,
              58020: 31557,
              58021: 31605,
              58022: 31589,
              58023: 31604,
              58024: 31591,
              58025: 31600,
              58026: 31601,
              58027: 31596,
              58028: 31598,
              58029: 31645,
              58030: 31640,
              58031: 31647,
              58032: 31629,
              58033: 31644,
              58034: 31642,
              58035: 31627,
              58036: 31634,
              58037: 31631,
              58038: 31581,
              58039: 31641,
              58040: 31691,
              58041: 31681,
              58042: 31692,
              58043: 31695,
              58044: 31668,
              58045: 31686,
              58046: 31709,
              58047: 31721,
              58048: 31761,
              58049: 31764,
              58050: 31718,
              58051: 31717,
              58052: 31840,
              58053: 31744,
              58054: 31751,
              58055: 31763,
              58056: 31731,
              58057: 31735,
              58058: 31767,
              58059: 31757,
              58060: 31734,
              58061: 31779,
              58062: 31783,
              58063: 31786,
              58064: 31775,
              58065: 31799,
              58066: 31787,
              58067: 31805,
              58068: 31820,
              58069: 31811,
              58070: 31828,
              58071: 31823,
              58072: 31808,
              58073: 31824,
              58074: 31832,
              58075: 31839,
              58076: 31844,
              58077: 31830,
              58078: 31845,
              58079: 31852,
              58080: 31861,
              58081: 31875,
              58082: 31888,
              58083: 31908,
              58084: 31917,
              58085: 31906,
              58086: 31915,
              58087: 31905,
              58088: 31912,
              58089: 31923,
              58090: 31922,
              58091: 31921,
              58092: 31918,
              58093: 31929,
              58094: 31933,
              58095: 31936,
              58096: 31941,
              58097: 31938,
              58098: 31960,
              58099: 31954,
              58100: 31964,
              58101: 31970,
              58102: 39739,
              58103: 31983,
              58104: 31986,
              58105: 31988,
              58106: 31990,
              58107: 31994,
              58108: 32006,
              58176: 32002,
              58177: 32028,
              58178: 32021,
              58179: 32010,
              58180: 32069,
              58181: 32075,
              58182: 32046,
              58183: 32050,
              58184: 32063,
              58185: 32053,
              58186: 32070,
              58187: 32115,
              58188: 32086,
              58189: 32078,
              58190: 32114,
              58191: 32104,
              58192: 32110,
              58193: 32079,
              58194: 32099,
              58195: 32147,
              58196: 32137,
              58197: 32091,
              58198: 32143,
              58199: 32125,
              58200: 32155,
              58201: 32186,
              58202: 32174,
              58203: 32163,
              58204: 32181,
              58205: 32199,
              58206: 32189,
              58207: 32171,
              58208: 32317,
              58209: 32162,
              58210: 32175,
              58211: 32220,
              58212: 32184,
              58213: 32159,
              58214: 32176,
              58215: 32216,
              58216: 32221,
              58217: 32228,
              58218: 32222,
              58219: 32251,
              58220: 32242,
              58221: 32225,
              58222: 32261,
              58223: 32266,
              58224: 32291,
              58225: 32289,
              58226: 32274,
              58227: 32305,
              58228: 32287,
              58229: 32265,
              58230: 32267,
              58231: 32290,
              58232: 32326,
              58233: 32358,
              58234: 32315,
              58235: 32309,
              58236: 32313,
              58237: 32323,
              58238: 32311,
              58240: 32306,
              58241: 32314,
              58242: 32359,
              58243: 32349,
              58244: 32342,
              58245: 32350,
              58246: 32345,
              58247: 32346,
              58248: 32377,
              58249: 32362,
              58250: 32361,
              58251: 32380,
              58252: 32379,
              58253: 32387,
              58254: 32213,
              58255: 32381,
              58256: 36782,
              58257: 32383,
              58258: 32392,
              58259: 32393,
              58260: 32396,
              58261: 32402,
              58262: 32400,
              58263: 32403,
              58264: 32404,
              58265: 32406,
              58266: 32398,
              58267: 32411,
              58268: 32412,
              58269: 32568,
              58270: 32570,
              58271: 32581,
              58272: 32588,
              58273: 32589,
              58274: 32590,
              58275: 32592,
              58276: 32593,
              58277: 32597,
              58278: 32596,
              58279: 32600,
              58280: 32607,
              58281: 32608,
              58282: 32616,
              58283: 32617,
              58284: 32615,
              58285: 32632,
              58286: 32642,
              58287: 32646,
              58288: 32643,
              58289: 32648,
              58290: 32647,
              58291: 32652,
              58292: 32660,
              58293: 32670,
              58294: 32669,
              58295: 32666,
              58296: 32675,
              58297: 32687,
              58298: 32690,
              58299: 32697,
              58300: 32686,
              58301: 32694,
              58302: 32696,
              58303: 35697,
              58304: 32709,
              58305: 32710,
              58306: 32714,
              58307: 32725,
              58308: 32724,
              58309: 32737,
              58310: 32742,
              58311: 32745,
              58312: 32755,
              58313: 32761,
              58314: 39132,
              58315: 32774,
              58316: 32772,
              58317: 32779,
              58318: 32786,
              58319: 32792,
              58320: 32793,
              58321: 32796,
              58322: 32801,
              58323: 32808,
              58324: 32831,
              58325: 32827,
              58326: 32842,
              58327: 32838,
              58328: 32850,
              58329: 32856,
              58330: 32858,
              58331: 32863,
              58332: 32866,
              58333: 32872,
              58334: 32883,
              58335: 32882,
              58336: 32880,
              58337: 32886,
              58338: 32889,
              58339: 32893,
              58340: 32895,
              58341: 32900,
              58342: 32902,
              58343: 32901,
              58344: 32923,
              58345: 32915,
              58346: 32922,
              58347: 32941,
              58348: 20880,
              58349: 32940,
              58350: 32987,
              58351: 32997,
              58352: 32985,
              58353: 32989,
              58354: 32964,
              58355: 32986,
              58356: 32982,
              58357: 33033,
              58358: 33007,
              58359: 33009,
              58360: 33051,
              58361: 33065,
              58362: 33059,
              58363: 33071,
              58364: 33099,
              58432: 38539,
              58433: 33094,
              58434: 33086,
              58435: 33107,
              58436: 33105,
              58437: 33020,
              58438: 33137,
              58439: 33134,
              58440: 33125,
              58441: 33126,
              58442: 33140,
              58443: 33155,
              58444: 33160,
              58445: 33162,
              58446: 33152,
              58447: 33154,
              58448: 33184,
              58449: 33173,
              58450: 33188,
              58451: 33187,
              58452: 33119,
              58453: 33171,
              58454: 33193,
              58455: 33200,
              58456: 33205,
              58457: 33214,
              58458: 33208,
              58459: 33213,
              58460: 33216,
              58461: 33218,
              58462: 33210,
              58463: 33225,
              58464: 33229,
              58465: 33233,
              58466: 33241,
              58467: 33240,
              58468: 33224,
              58469: 33242,
              58470: 33247,
              58471: 33248,
              58472: 33255,
              58473: 33274,
              58474: 33275,
              58475: 33278,
              58476: 33281,
              58477: 33282,
              58478: 33285,
              58479: 33287,
              58480: 33290,
              58481: 33293,
              58482: 33296,
              58483: 33302,
              58484: 33321,
              58485: 33323,
              58486: 33336,
              58487: 33331,
              58488: 33344,
              58489: 33369,
              58490: 33368,
              58491: 33373,
              58492: 33370,
              58493: 33375,
              58494: 33380,
              58496: 33378,
              58497: 33384,
              58498: 33386,
              58499: 33387,
              58500: 33326,
              58501: 33393,
              58502: 33399,
              58503: 33400,
              58504: 33406,
              58505: 33421,
              58506: 33426,
              58507: 33451,
              58508: 33439,
              58509: 33467,
              58510: 33452,
              58511: 33505,
              58512: 33507,
              58513: 33503,
              58514: 33490,
              58515: 33524,
              58516: 33523,
              58517: 33530,
              58518: 33683,
              58519: 33539,
              58520: 33531,
              58521: 33529,
              58522: 33502,
              58523: 33542,
              58524: 33500,
              58525: 33545,
              58526: 33497,
              58527: 33589,
              58528: 33588,
              58529: 33558,
              58530: 33586,
              58531: 33585,
              58532: 33600,
              58533: 33593,
              58534: 33616,
              58535: 33605,
              58536: 33583,
              58537: 33579,
              58538: 33559,
              58539: 33560,
              58540: 33669,
              58541: 33690,
              58542: 33706,
              58543: 33695,
              58544: 33698,
              58545: 33686,
              58546: 33571,
              58547: 33678,
              58548: 33671,
              58549: 33674,
              58550: 33660,
              58551: 33717,
              58552: 33651,
              58553: 33653,
              58554: 33696,
              58555: 33673,
              58556: 33704,
              58557: 33780,
              58558: 33811,
              58559: 33771,
              58560: 33742,
              58561: 33789,
              58562: 33795,
              58563: 33752,
              58564: 33803,
              58565: 33729,
              58566: 33783,
              58567: 33799,
              58568: 33760,
              58569: 33778,
              58570: 33805,
              58571: 33826,
              58572: 33824,
              58573: 33725,
              58574: 33848,
              58575: 34054,
              58576: 33787,
              58577: 33901,
              58578: 33834,
              58579: 33852,
              58580: 34138,
              58581: 33924,
              58582: 33911,
              58583: 33899,
              58584: 33965,
              58585: 33902,
              58586: 33922,
              58587: 33897,
              58588: 33862,
              58589: 33836,
              58590: 33903,
              58591: 33913,
              58592: 33845,
              58593: 33994,
              58594: 33890,
              58595: 33977,
              58596: 33983,
              58597: 33951,
              58598: 34009,
              58599: 33997,
              58600: 33979,
              58601: 34010,
              58602: 34e3,
              58603: 33985,
              58604: 33990,
              58605: 34006,
              58606: 33953,
              58607: 34081,
              58608: 34047,
              58609: 34036,
              58610: 34071,
              58611: 34072,
              58612: 34092,
              58613: 34079,
              58614: 34069,
              58615: 34068,
              58616: 34044,
              58617: 34112,
              58618: 34147,
              58619: 34136,
              58620: 34120,
              58688: 34113,
              58689: 34306,
              58690: 34123,
              58691: 34133,
              58692: 34176,
              58693: 34212,
              58694: 34184,
              58695: 34193,
              58696: 34186,
              58697: 34216,
              58698: 34157,
              58699: 34196,
              58700: 34203,
              58701: 34282,
              58702: 34183,
              58703: 34204,
              58704: 34167,
              58705: 34174,
              58706: 34192,
              58707: 34249,
              58708: 34234,
              58709: 34255,
              58710: 34233,
              58711: 34256,
              58712: 34261,
              58713: 34269,
              58714: 34277,
              58715: 34268,
              58716: 34297,
              58717: 34314,
              58718: 34323,
              58719: 34315,
              58720: 34302,
              58721: 34298,
              58722: 34310,
              58723: 34338,
              58724: 34330,
              58725: 34352,
              58726: 34367,
              58727: 34381,
              58728: 20053,
              58729: 34388,
              58730: 34399,
              58731: 34407,
              58732: 34417,
              58733: 34451,
              58734: 34467,
              58735: 34473,
              58736: 34474,
              58737: 34443,
              58738: 34444,
              58739: 34486,
              58740: 34479,
              58741: 34500,
              58742: 34502,
              58743: 34480,
              58744: 34505,
              58745: 34851,
              58746: 34475,
              58747: 34516,
              58748: 34526,
              58749: 34537,
              58750: 34540,
              58752: 34527,
              58753: 34523,
              58754: 34543,
              58755: 34578,
              58756: 34566,
              58757: 34568,
              58758: 34560,
              58759: 34563,
              58760: 34555,
              58761: 34577,
              58762: 34569,
              58763: 34573,
              58764: 34553,
              58765: 34570,
              58766: 34612,
              58767: 34623,
              58768: 34615,
              58769: 34619,
              58770: 34597,
              58771: 34601,
              58772: 34586,
              58773: 34656,
              58774: 34655,
              58775: 34680,
              58776: 34636,
              58777: 34638,
              58778: 34676,
              58779: 34647,
              58780: 34664,
              58781: 34670,
              58782: 34649,
              58783: 34643,
              58784: 34659,
              58785: 34666,
              58786: 34821,
              58787: 34722,
              58788: 34719,
              58789: 34690,
              58790: 34735,
              58791: 34763,
              58792: 34749,
              58793: 34752,
              58794: 34768,
              58795: 38614,
              58796: 34731,
              58797: 34756,
              58798: 34739,
              58799: 34759,
              58800: 34758,
              58801: 34747,
              58802: 34799,
              58803: 34802,
              58804: 34784,
              58805: 34831,
              58806: 34829,
              58807: 34814,
              58808: 34806,
              58809: 34807,
              58810: 34830,
              58811: 34770,
              58812: 34833,
              58813: 34838,
              58814: 34837,
              58815: 34850,
              58816: 34849,
              58817: 34865,
              58818: 34870,
              58819: 34873,
              58820: 34855,
              58821: 34875,
              58822: 34884,
              58823: 34882,
              58824: 34898,
              58825: 34905,
              58826: 34910,
              58827: 34914,
              58828: 34923,
              58829: 34945,
              58830: 34942,
              58831: 34974,
              58832: 34933,
              58833: 34941,
              58834: 34997,
              58835: 34930,
              58836: 34946,
              58837: 34967,
              58838: 34962,
              58839: 34990,
              58840: 34969,
              58841: 34978,
              58842: 34957,
              58843: 34980,
              58844: 34992,
              58845: 35007,
              58846: 34993,
              58847: 35011,
              58848: 35012,
              58849: 35028,
              58850: 35032,
              58851: 35033,
              58852: 35037,
              58853: 35065,
              58854: 35074,
              58855: 35068,
              58856: 35060,
              58857: 35048,
              58858: 35058,
              58859: 35076,
              58860: 35084,
              58861: 35082,
              58862: 35091,
              58863: 35139,
              58864: 35102,
              58865: 35109,
              58866: 35114,
              58867: 35115,
              58868: 35137,
              58869: 35140,
              58870: 35131,
              58871: 35126,
              58872: 35128,
              58873: 35148,
              58874: 35101,
              58875: 35168,
              58876: 35166,
              58944: 35174,
              58945: 35172,
              58946: 35181,
              58947: 35178,
              58948: 35183,
              58949: 35188,
              58950: 35191,
              58951: 35198,
              58952: 35203,
              58953: 35208,
              58954: 35210,
              58955: 35219,
              58956: 35224,
              58957: 35233,
              58958: 35241,
              58959: 35238,
              58960: 35244,
              58961: 35247,
              58962: 35250,
              58963: 35258,
              58964: 35261,
              58965: 35263,
              58966: 35264,
              58967: 35290,
              58968: 35292,
              58969: 35293,
              58970: 35303,
              58971: 35316,
              58972: 35320,
              58973: 35331,
              58974: 35350,
              58975: 35344,
              58976: 35340,
              58977: 35355,
              58978: 35357,
              58979: 35365,
              58980: 35382,
              58981: 35393,
              58982: 35419,
              58983: 35410,
              58984: 35398,
              58985: 35400,
              58986: 35452,
              58987: 35437,
              58988: 35436,
              58989: 35426,
              58990: 35461,
              58991: 35458,
              58992: 35460,
              58993: 35496,
              58994: 35489,
              58995: 35473,
              58996: 35493,
              58997: 35494,
              58998: 35482,
              58999: 35491,
              59e3: 35524,
              59001: 35533,
              59002: 35522,
              59003: 35546,
              59004: 35563,
              59005: 35571,
              59006: 35559,
              59008: 35556,
              59009: 35569,
              59010: 35604,
              59011: 35552,
              59012: 35554,
              59013: 35575,
              59014: 35550,
              59015: 35547,
              59016: 35596,
              59017: 35591,
              59018: 35610,
              59019: 35553,
              59020: 35606,
              59021: 35600,
              59022: 35607,
              59023: 35616,
              59024: 35635,
              59025: 38827,
              59026: 35622,
              59027: 35627,
              59028: 35646,
              59029: 35624,
              59030: 35649,
              59031: 35660,
              59032: 35663,
              59033: 35662,
              59034: 35657,
              59035: 35670,
              59036: 35675,
              59037: 35674,
              59038: 35691,
              59039: 35679,
              59040: 35692,
              59041: 35695,
              59042: 35700,
              59043: 35709,
              59044: 35712,
              59045: 35724,
              59046: 35726,
              59047: 35730,
              59048: 35731,
              59049: 35734,
              59050: 35737,
              59051: 35738,
              59052: 35898,
              59053: 35905,
              59054: 35903,
              59055: 35912,
              59056: 35916,
              59057: 35918,
              59058: 35920,
              59059: 35925,
              59060: 35938,
              59061: 35948,
              59062: 35960,
              59063: 35962,
              59064: 35970,
              59065: 35977,
              59066: 35973,
              59067: 35978,
              59068: 35981,
              59069: 35982,
              59070: 35988,
              59071: 35964,
              59072: 35992,
              59073: 25117,
              59074: 36013,
              59075: 36010,
              59076: 36029,
              59077: 36018,
              59078: 36019,
              59079: 36014,
              59080: 36022,
              59081: 36040,
              59082: 36033,
              59083: 36068,
              59084: 36067,
              59085: 36058,
              59086: 36093,
              59087: 36090,
              59088: 36091,
              59089: 36100,
              59090: 36101,
              59091: 36106,
              59092: 36103,
              59093: 36111,
              59094: 36109,
              59095: 36112,
              59096: 40782,
              59097: 36115,
              59098: 36045,
              59099: 36116,
              59100: 36118,
              59101: 36199,
              59102: 36205,
              59103: 36209,
              59104: 36211,
              59105: 36225,
              59106: 36249,
              59107: 36290,
              59108: 36286,
              59109: 36282,
              59110: 36303,
              59111: 36314,
              59112: 36310,
              59113: 36300,
              59114: 36315,
              59115: 36299,
              59116: 36330,
              59117: 36331,
              59118: 36319,
              59119: 36323,
              59120: 36348,
              59121: 36360,
              59122: 36361,
              59123: 36351,
              59124: 36381,
              59125: 36382,
              59126: 36368,
              59127: 36383,
              59128: 36418,
              59129: 36405,
              59130: 36400,
              59131: 36404,
              59132: 36426,
              59200: 36423,
              59201: 36425,
              59202: 36428,
              59203: 36432,
              59204: 36424,
              59205: 36441,
              59206: 36452,
              59207: 36448,
              59208: 36394,
              59209: 36451,
              59210: 36437,
              59211: 36470,
              59212: 36466,
              59213: 36476,
              59214: 36481,
              59215: 36487,
              59216: 36485,
              59217: 36484,
              59218: 36491,
              59219: 36490,
              59220: 36499,
              59221: 36497,
              59222: 36500,
              59223: 36505,
              59224: 36522,
              59225: 36513,
              59226: 36524,
              59227: 36528,
              59228: 36550,
              59229: 36529,
              59230: 36542,
              59231: 36549,
              59232: 36552,
              59233: 36555,
              59234: 36571,
              59235: 36579,
              59236: 36604,
              59237: 36603,
              59238: 36587,
              59239: 36606,
              59240: 36618,
              59241: 36613,
              59242: 36629,
              59243: 36626,
              59244: 36633,
              59245: 36627,
              59246: 36636,
              59247: 36639,
              59248: 36635,
              59249: 36620,
              59250: 36646,
              59251: 36659,
              59252: 36667,
              59253: 36665,
              59254: 36677,
              59255: 36674,
              59256: 36670,
              59257: 36684,
              59258: 36681,
              59259: 36678,
              59260: 36686,
              59261: 36695,
              59262: 36700,
              59264: 36706,
              59265: 36707,
              59266: 36708,
              59267: 36764,
              59268: 36767,
              59269: 36771,
              59270: 36781,
              59271: 36783,
              59272: 36791,
              59273: 36826,
              59274: 36837,
              59275: 36834,
              59276: 36842,
              59277: 36847,
              59278: 36999,
              59279: 36852,
              59280: 36869,
              59281: 36857,
              59282: 36858,
              59283: 36881,
              59284: 36885,
              59285: 36897,
              59286: 36877,
              59287: 36894,
              59288: 36886,
              59289: 36875,
              59290: 36903,
              59291: 36918,
              59292: 36917,
              59293: 36921,
              59294: 36856,
              59295: 36943,
              59296: 36944,
              59297: 36945,
              59298: 36946,
              59299: 36878,
              59300: 36937,
              59301: 36926,
              59302: 36950,
              59303: 36952,
              59304: 36958,
              59305: 36968,
              59306: 36975,
              59307: 36982,
              59308: 38568,
              59309: 36978,
              59310: 36994,
              59311: 36989,
              59312: 36993,
              59313: 36992,
              59314: 37002,
              59315: 37001,
              59316: 37007,
              59317: 37032,
              59318: 37039,
              59319: 37041,
              59320: 37045,
              59321: 37090,
              59322: 37092,
              59323: 25160,
              59324: 37083,
              59325: 37122,
              59326: 37138,
              59327: 37145,
              59328: 37170,
              59329: 37168,
              59330: 37194,
              59331: 37206,
              59332: 37208,
              59333: 37219,
              59334: 37221,
              59335: 37225,
              59336: 37235,
              59337: 37234,
              59338: 37259,
              59339: 37257,
              59340: 37250,
              59341: 37282,
              59342: 37291,
              59343: 37295,
              59344: 37290,
              59345: 37301,
              59346: 37300,
              59347: 37306,
              59348: 37312,
              59349: 37313,
              59350: 37321,
              59351: 37323,
              59352: 37328,
              59353: 37334,
              59354: 37343,
              59355: 37345,
              59356: 37339,
              59357: 37372,
              59358: 37365,
              59359: 37366,
              59360: 37406,
              59361: 37375,
              59362: 37396,
              59363: 37420,
              59364: 37397,
              59365: 37393,
              59366: 37470,
              59367: 37463,
              59368: 37445,
              59369: 37449,
              59370: 37476,
              59371: 37448,
              59372: 37525,
              59373: 37439,
              59374: 37451,
              59375: 37456,
              59376: 37532,
              59377: 37526,
              59378: 37523,
              59379: 37531,
              59380: 37466,
              59381: 37583,
              59382: 37561,
              59383: 37559,
              59384: 37609,
              59385: 37647,
              59386: 37626,
              59387: 37700,
              59388: 37678,
              59456: 37657,
              59457: 37666,
              59458: 37658,
              59459: 37667,
              59460: 37690,
              59461: 37685,
              59462: 37691,
              59463: 37724,
              59464: 37728,
              59465: 37756,
              59466: 37742,
              59467: 37718,
              59468: 37808,
              59469: 37804,
              59470: 37805,
              59471: 37780,
              59472: 37817,
              59473: 37846,
              59474: 37847,
              59475: 37864,
              59476: 37861,
              59477: 37848,
              59478: 37827,
              59479: 37853,
              59480: 37840,
              59481: 37832,
              59482: 37860,
              59483: 37914,
              59484: 37908,
              59485: 37907,
              59486: 37891,
              59487: 37895,
              59488: 37904,
              59489: 37942,
              59490: 37931,
              59491: 37941,
              59492: 37921,
              59493: 37946,
              59494: 37953,
              59495: 37970,
              59496: 37956,
              59497: 37979,
              59498: 37984,
              59499: 37986,
              59500: 37982,
              59501: 37994,
              59502: 37417,
              59503: 38e3,
              59504: 38005,
              59505: 38007,
              59506: 38013,
              59507: 37978,
              59508: 38012,
              59509: 38014,
              59510: 38017,
              59511: 38015,
              59512: 38274,
              59513: 38279,
              59514: 38282,
              59515: 38292,
              59516: 38294,
              59517: 38296,
              59518: 38297,
              59520: 38304,
              59521: 38312,
              59522: 38311,
              59523: 38317,
              59524: 38332,
              59525: 38331,
              59526: 38329,
              59527: 38334,
              59528: 38346,
              59529: 28662,
              59530: 38339,
              59531: 38349,
              59532: 38348,
              59533: 38357,
              59534: 38356,
              59535: 38358,
              59536: 38364,
              59537: 38369,
              59538: 38373,
              59539: 38370,
              59540: 38433,
              59541: 38440,
              59542: 38446,
              59543: 38447,
              59544: 38466,
              59545: 38476,
              59546: 38479,
              59547: 38475,
              59548: 38519,
              59549: 38492,
              59550: 38494,
              59551: 38493,
              59552: 38495,
              59553: 38502,
              59554: 38514,
              59555: 38508,
              59556: 38541,
              59557: 38552,
              59558: 38549,
              59559: 38551,
              59560: 38570,
              59561: 38567,
              59562: 38577,
              59563: 38578,
              59564: 38576,
              59565: 38580,
              59566: 38582,
              59567: 38584,
              59568: 38585,
              59569: 38606,
              59570: 38603,
              59571: 38601,
              59572: 38605,
              59573: 35149,
              59574: 38620,
              59575: 38669,
              59576: 38613,
              59577: 38649,
              59578: 38660,
              59579: 38662,
              59580: 38664,
              59581: 38675,
              59582: 38670,
              59583: 38673,
              59584: 38671,
              59585: 38678,
              59586: 38681,
              59587: 38692,
              59588: 38698,
              59589: 38704,
              59590: 38713,
              59591: 38717,
              59592: 38718,
              59593: 38724,
              59594: 38726,
              59595: 38728,
              59596: 38722,
              59597: 38729,
              59598: 38748,
              59599: 38752,
              59600: 38756,
              59601: 38758,
              59602: 38760,
              59603: 21202,
              59604: 38763,
              59605: 38769,
              59606: 38777,
              59607: 38789,
              59608: 38780,
              59609: 38785,
              59610: 38778,
              59611: 38790,
              59612: 38795,
              59613: 38799,
              59614: 38800,
              59615: 38812,
              59616: 38824,
              59617: 38822,
              59618: 38819,
              59619: 38835,
              59620: 38836,
              59621: 38851,
              59622: 38854,
              59623: 38856,
              59624: 38859,
              59625: 38876,
              59626: 38893,
              59627: 40783,
              59628: 38898,
              59629: 31455,
              59630: 38902,
              59631: 38901,
              59632: 38927,
              59633: 38924,
              59634: 38968,
              59635: 38948,
              59636: 38945,
              59637: 38967,
              59638: 38973,
              59639: 38982,
              59640: 38991,
              59641: 38987,
              59642: 39019,
              59643: 39023,
              59644: 39024,
              59712: 39025,
              59713: 39028,
              59714: 39027,
              59715: 39082,
              59716: 39087,
              59717: 39089,
              59718: 39094,
              59719: 39108,
              59720: 39107,
              59721: 39110,
              59722: 39145,
              59723: 39147,
              59724: 39171,
              59725: 39177,
              59726: 39186,
              59727: 39188,
              59728: 39192,
              59729: 39201,
              59730: 39197,
              59731: 39198,
              59732: 39204,
              59733: 39200,
              59734: 39212,
              59735: 39214,
              59736: 39229,
              59737: 39230,
              59738: 39234,
              59739: 39241,
              59740: 39237,
              59741: 39248,
              59742: 39243,
              59743: 39249,
              59744: 39250,
              59745: 39244,
              59746: 39253,
              59747: 39319,
              59748: 39320,
              59749: 39333,
              59750: 39341,
              59751: 39342,
              59752: 39356,
              59753: 39391,
              59754: 39387,
              59755: 39389,
              59756: 39384,
              59757: 39377,
              59758: 39405,
              59759: 39406,
              59760: 39409,
              59761: 39410,
              59762: 39419,
              59763: 39416,
              59764: 39425,
              59765: 39439,
              59766: 39429,
              59767: 39394,
              59768: 39449,
              59769: 39467,
              59770: 39479,
              59771: 39493,
              59772: 39490,
              59773: 39488,
              59774: 39491,
              59776: 39486,
              59777: 39509,
              59778: 39501,
              59779: 39515,
              59780: 39511,
              59781: 39519,
              59782: 39522,
              59783: 39525,
              59784: 39524,
              59785: 39529,
              59786: 39531,
              59787: 39530,
              59788: 39597,
              59789: 39600,
              59790: 39612,
              59791: 39616,
              59792: 39631,
              59793: 39633,
              59794: 39635,
              59795: 39636,
              59796: 39646,
              59797: 39647,
              59798: 39650,
              59799: 39651,
              59800: 39654,
              59801: 39663,
              59802: 39659,
              59803: 39662,
              59804: 39668,
              59805: 39665,
              59806: 39671,
              59807: 39675,
              59808: 39686,
              59809: 39704,
              59810: 39706,
              59811: 39711,
              59812: 39714,
              59813: 39715,
              59814: 39717,
              59815: 39719,
              59816: 39720,
              59817: 39721,
              59818: 39722,
              59819: 39726,
              59820: 39727,
              59821: 39730,
              59822: 39748,
              59823: 39747,
              59824: 39759,
              59825: 39757,
              59826: 39758,
              59827: 39761,
              59828: 39768,
              59829: 39796,
              59830: 39827,
              59831: 39811,
              59832: 39825,
              59833: 39830,
              59834: 39831,
              59835: 39839,
              59836: 39840,
              59837: 39848,
              59838: 39860,
              59839: 39872,
              59840: 39882,
              59841: 39865,
              59842: 39878,
              59843: 39887,
              59844: 39889,
              59845: 39890,
              59846: 39907,
              59847: 39906,
              59848: 39908,
              59849: 39892,
              59850: 39905,
              59851: 39994,
              59852: 39922,
              59853: 39921,
              59854: 39920,
              59855: 39957,
              59856: 39956,
              59857: 39945,
              59858: 39955,
              59859: 39948,
              59860: 39942,
              59861: 39944,
              59862: 39954,
              59863: 39946,
              59864: 39940,
              59865: 39982,
              59866: 39963,
              59867: 39973,
              59868: 39972,
              59869: 39969,
              59870: 39984,
              59871: 40007,
              59872: 39986,
              59873: 40006,
              59874: 39998,
              59875: 40026,
              59876: 40032,
              59877: 40039,
              59878: 40054,
              59879: 40056,
              59880: 40167,
              59881: 40172,
              59882: 40176,
              59883: 40201,
              59884: 40200,
              59885: 40171,
              59886: 40195,
              59887: 40198,
              59888: 40234,
              59889: 40230,
              59890: 40367,
              59891: 40227,
              59892: 40223,
              59893: 40260,
              59894: 40213,
              59895: 40210,
              59896: 40257,
              59897: 40255,
              59898: 40254,
              59899: 40262,
              59900: 40264,
              59968: 40285,
              59969: 40286,
              59970: 40292,
              59971: 40273,
              59972: 40272,
              59973: 40281,
              59974: 40306,
              59975: 40329,
              59976: 40327,
              59977: 40363,
              59978: 40303,
              59979: 40314,
              59980: 40346,
              59981: 40356,
              59982: 40361,
              59983: 40370,
              59984: 40388,
              59985: 40385,
              59986: 40379,
              59987: 40376,
              59988: 40378,
              59989: 40390,
              59990: 40399,
              59991: 40386,
              59992: 40409,
              59993: 40403,
              59994: 40440,
              59995: 40422,
              59996: 40429,
              59997: 40431,
              59998: 40445,
              59999: 40474,
              6e4: 40475,
              60001: 40478,
              60002: 40565,
              60003: 40569,
              60004: 40573,
              60005: 40577,
              60006: 40584,
              60007: 40587,
              60008: 40588,
              60009: 40594,
              60010: 40597,
              60011: 40593,
              60012: 40605,
              60013: 40613,
              60014: 40617,
              60015: 40632,
              60016: 40618,
              60017: 40621,
              60018: 38753,
              60019: 40652,
              60020: 40654,
              60021: 40655,
              60022: 40656,
              60023: 40660,
              60024: 40668,
              60025: 40670,
              60026: 40669,
              60027: 40672,
              60028: 40677,
              60029: 40680,
              60030: 40687,
              60032: 40692,
              60033: 40694,
              60034: 40695,
              60035: 40697,
              60036: 40699,
              60037: 40700,
              60038: 40701,
              60039: 40711,
              60040: 40712,
              60041: 30391,
              60042: 40725,
              60043: 40737,
              60044: 40748,
              60045: 40766,
              60046: 40778,
              60047: 40786,
              60048: 40788,
              60049: 40803,
              60050: 40799,
              60051: 40800,
              60052: 40801,
              60053: 40806,
              60054: 40807,
              60055: 40812,
              60056: 40810,
              60057: 40823,
              60058: 40818,
              60059: 40822,
              60060: 40853,
              60061: 40860,
              60062: 40864,
              60063: 22575,
              60064: 27079,
              60065: 36953,
              60066: 29796,
              60067: 20956,
              60068: 29081
            };
          },
          /* 9 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var GenericGF_1 = __webpack_require__(1);
            var GenericGFPoly_1 = __webpack_require__(2);
            function runEuclideanAlgorithm(field, a2, b2, R2) {
              var _a;
              if (a2.degree() < b2.degree()) {
                _a = [b2, a2], a2 = _a[0], b2 = _a[1];
              }
              var rLast = a2;
              var r2 = b2;
              var tLast = field.zero;
              var t = field.one;
              while (r2.degree() >= R2 / 2) {
                var rLastLast = rLast;
                var tLastLast = tLast;
                rLast = r2;
                tLast = t;
                if (rLast.isZero()) {
                  return null;
                }
                r2 = rLastLast;
                var q2 = field.zero;
                var denominatorLeadingTerm = rLast.getCoefficient(rLast.degree());
                var dltInverse = field.inverse(denominatorLeadingTerm);
                while (r2.degree() >= rLast.degree() && !r2.isZero()) {
                  var degreeDiff = r2.degree() - rLast.degree();
                  var scale = field.multiply(r2.getCoefficient(r2.degree()), dltInverse);
                  q2 = q2.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                  r2 = r2.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
                }
                t = q2.multiplyPoly(tLast).addOrSubtract(tLastLast);
                if (r2.degree() >= rLast.degree()) {
                  return null;
                }
              }
              var sigmaTildeAtZero = t.getCoefficient(0);
              if (sigmaTildeAtZero === 0) {
                return null;
              }
              var inverse = field.inverse(sigmaTildeAtZero);
              return [t.multiply(inverse), r2.multiply(inverse)];
            }
            function findErrorLocations(field, errorLocator) {
              var numErrors = errorLocator.degree();
              if (numErrors === 1) {
                return [errorLocator.getCoefficient(1)];
              }
              var result = new Array(numErrors);
              var errorCount = 0;
              for (var i2 = 1; i2 < field.size && errorCount < numErrors; i2++) {
                if (errorLocator.evaluateAt(i2) === 0) {
                  result[errorCount] = field.inverse(i2);
                  errorCount++;
                }
              }
              if (errorCount !== numErrors) {
                return null;
              }
              return result;
            }
            function findErrorMagnitudes(field, errorEvaluator, errorLocations) {
              var s2 = errorLocations.length;
              var result = new Array(s2);
              for (var i2 = 0; i2 < s2; i2++) {
                var xiInverse = field.inverse(errorLocations[i2]);
                var denominator = 1;
                for (var j2 = 0; j2 < s2; j2++) {
                  if (i2 !== j2) {
                    denominator = field.multiply(denominator, GenericGF_1.addOrSubtractGF(1, field.multiply(errorLocations[j2], xiInverse)));
                  }
                }
                result[i2] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
                if (field.generatorBase !== 0) {
                  result[i2] = field.multiply(result[i2], xiInverse);
                }
              }
              return result;
            }
            function decode(bytes, twoS) {
              var outputBytes = new Uint8ClampedArray(bytes.length);
              outputBytes.set(bytes);
              var field = new GenericGF_1.default(285, 256, 0);
              var poly = new GenericGFPoly_1.default(field, outputBytes);
              var syndromeCoefficients = new Uint8ClampedArray(twoS);
              var error = false;
              for (var s2 = 0; s2 < twoS; s2++) {
                var evaluation = poly.evaluateAt(field.exp(s2 + field.generatorBase));
                syndromeCoefficients[syndromeCoefficients.length - 1 - s2] = evaluation;
                if (evaluation !== 0) {
                  error = true;
                }
              }
              if (!error) {
                return outputBytes;
              }
              var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
              var sigmaOmega = runEuclideanAlgorithm(field, field.buildMonomial(twoS, 1), syndrome, twoS);
              if (sigmaOmega === null) {
                return null;
              }
              var errorLocations = findErrorLocations(field, sigmaOmega[0]);
              if (errorLocations == null) {
                return null;
              }
              var errorMagnitudes = findErrorMagnitudes(field, sigmaOmega[1], errorLocations);
              for (var i2 = 0; i2 < errorLocations.length; i2++) {
                var position2 = outputBytes.length - 1 - field.log(errorLocations[i2]);
                if (position2 < 0) {
                  return null;
                }
                outputBytes[position2] = GenericGF_1.addOrSubtractGF(outputBytes[position2], errorMagnitudes[i2]);
              }
              return outputBytes;
            }
            exports2.decode = decode;
          },
          /* 10 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            exports2.VERSIONS = [
              {
                infoBits: null,
                versionNumber: 1,
                alignmentPatternCenters: [],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 7,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 19 }]
                  },
                  {
                    ecCodewordsPerBlock: 10,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
                  },
                  {
                    ecCodewordsPerBlock: 13,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 13 }]
                  },
                  {
                    ecCodewordsPerBlock: 17,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 9 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 2,
                alignmentPatternCenters: [6, 18],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 10,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 34 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 28 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 22 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 16 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 3,
                alignmentPatternCenters: [6, 22],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 15,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 55 }]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 44 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 17 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 13 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 4,
                alignmentPatternCenters: [6, 26],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 80 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 32 }]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 24 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 9 }]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 5,
                alignmentPatternCenters: [6, 30],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 1, dataCodewordsPerBlock: 108 }]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 43 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 15 },
                      { numBlocks: 2, dataCodewordsPerBlock: 16 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 11 },
                      { numBlocks: 2, dataCodewordsPerBlock: 12 }
                    ]
                  }
                ]
              },
              {
                infoBits: null,
                versionNumber: 6,
                alignmentPatternCenters: [6, 34],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 68 }]
                  },
                  {
                    ecCodewordsPerBlock: 16,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 27 }]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 19 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 15 }]
                  }
                ]
              },
              {
                infoBits: 31892,
                versionNumber: 7,
                alignmentPatternCenters: [6, 22, 38],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 78 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 31 }]
                  },
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 4, dataCodewordsPerBlock: 15 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 13 },
                      { numBlocks: 1, dataCodewordsPerBlock: 14 }
                    ]
                  }
                ]
              },
              {
                infoBits: 34236,
                versionNumber: 8,
                alignmentPatternCenters: [6, 24, 42],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 97 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 38 },
                      { numBlocks: 2, dataCodewordsPerBlock: 39 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 18 },
                      { numBlocks: 2, dataCodewordsPerBlock: 19 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 14 },
                      { numBlocks: 2, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 39577,
                versionNumber: 9,
                alignmentPatternCenters: [6, 26, 46],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [{ numBlocks: 2, dataCodewordsPerBlock: 116 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 36 },
                      { numBlocks: 2, dataCodewordsPerBlock: 37 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 16 },
                      { numBlocks: 4, dataCodewordsPerBlock: 17 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 12 },
                      { numBlocks: 4, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 42195,
                versionNumber: 10,
                alignmentPatternCenters: [6, 28, 50],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 18,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 68 },
                      { numBlocks: 2, dataCodewordsPerBlock: 69 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 43 },
                      { numBlocks: 1, dataCodewordsPerBlock: 44 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 19 },
                      { numBlocks: 2, dataCodewordsPerBlock: 20 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 15 },
                      { numBlocks: 2, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 48118,
                versionNumber: 11,
                alignmentPatternCenters: [6, 30, 54],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 81 }]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 50 },
                      { numBlocks: 4, dataCodewordsPerBlock: 51 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 22 },
                      { numBlocks: 4, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 12 },
                      { numBlocks: 8, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 51042,
                versionNumber: 12,
                alignmentPatternCenters: [6, 32, 58],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 92 },
                      { numBlocks: 2, dataCodewordsPerBlock: 93 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 36 },
                      { numBlocks: 2, dataCodewordsPerBlock: 37 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 20 },
                      { numBlocks: 6, dataCodewordsPerBlock: 21 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 14 },
                      { numBlocks: 4, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 55367,
                versionNumber: 13,
                alignmentPatternCenters: [6, 34, 62],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 4, dataCodewordsPerBlock: 107 }]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 37 },
                      { numBlocks: 1, dataCodewordsPerBlock: 38 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 20 },
                      { numBlocks: 4, dataCodewordsPerBlock: 21 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 11 },
                      { numBlocks: 4, dataCodewordsPerBlock: 12 }
                    ]
                  }
                ]
              },
              {
                infoBits: 58893,
                versionNumber: 14,
                alignmentPatternCenters: [6, 26, 46, 66],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 115 },
                      { numBlocks: 1, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 40 },
                      { numBlocks: 5, dataCodewordsPerBlock: 41 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 20,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 16 },
                      { numBlocks: 5, dataCodewordsPerBlock: 17 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 12 },
                      { numBlocks: 5, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 63784,
                versionNumber: 15,
                alignmentPatternCenters: [6, 26, 48, 70],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 22,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 87 },
                      { numBlocks: 1, dataCodewordsPerBlock: 88 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 41 },
                      { numBlocks: 5, dataCodewordsPerBlock: 42 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 24 },
                      { numBlocks: 7, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 12 },
                      { numBlocks: 7, dataCodewordsPerBlock: 13 }
                    ]
                  }
                ]
              },
              {
                infoBits: 68472,
                versionNumber: 16,
                alignmentPatternCenters: [6, 26, 50, 74],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 98 },
                      { numBlocks: 1, dataCodewordsPerBlock: 99 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 45 },
                      { numBlocks: 3, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 19 },
                      { numBlocks: 2, dataCodewordsPerBlock: 20 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 15 },
                      { numBlocks: 13, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 70749,
                versionNumber: 17,
                alignmentPatternCenters: [6, 30, 54, 78],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 107 },
                      { numBlocks: 5, dataCodewordsPerBlock: 108 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 46 },
                      { numBlocks: 1, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 22 },
                      { numBlocks: 15, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 17, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 76311,
                versionNumber: 18,
                alignmentPatternCenters: [6, 30, 56, 82],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 120 },
                      { numBlocks: 1, dataCodewordsPerBlock: 121 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 9, dataCodewordsPerBlock: 43 },
                      { numBlocks: 4, dataCodewordsPerBlock: 44 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 22 },
                      { numBlocks: 1, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 14 },
                      { numBlocks: 19, dataCodewordsPerBlock: 15 }
                    ]
                  }
                ]
              },
              {
                infoBits: 79154,
                versionNumber: 19,
                alignmentPatternCenters: [6, 30, 58, 86],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 113 },
                      { numBlocks: 4, dataCodewordsPerBlock: 114 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 44 },
                      { numBlocks: 11, dataCodewordsPerBlock: 45 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 21 },
                      { numBlocks: 4, dataCodewordsPerBlock: 22 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 9, dataCodewordsPerBlock: 13 },
                      { numBlocks: 16, dataCodewordsPerBlock: 14 }
                    ]
                  }
                ]
              },
              {
                infoBits: 84390,
                versionNumber: 20,
                alignmentPatternCenters: [6, 34, 62, 90],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 107 },
                      { numBlocks: 5, dataCodewordsPerBlock: 108 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 41 },
                      { numBlocks: 13, dataCodewordsPerBlock: 42 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 24 },
                      { numBlocks: 5, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 15 },
                      { numBlocks: 10, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 87683,
                versionNumber: 21,
                alignmentPatternCenters: [6, 28, 50, 72, 94],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 116 },
                      { numBlocks: 4, dataCodewordsPerBlock: 117 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 42 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 22 },
                      { numBlocks: 6, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 16 },
                      { numBlocks: 6, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 92361,
                versionNumber: 22,
                alignmentPatternCenters: [6, 26, 50, 74, 98],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 111 },
                      { numBlocks: 7, dataCodewordsPerBlock: 112 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 46 }]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 24 },
                      { numBlocks: 16, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 24,
                    ecBlocks: [{ numBlocks: 34, dataCodewordsPerBlock: 13 }]
                  }
                ]
              },
              {
                infoBits: 96236,
                versionNumber: 23,
                alignmentPatternCenters: [6, 30, 54, 74, 102],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 121 },
                      { numBlocks: 5, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 47 },
                      { numBlocks: 14, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 16, dataCodewordsPerBlock: 15 },
                      { numBlocks: 14, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 102084,
                versionNumber: 24,
                alignmentPatternCenters: [6, 28, 54, 80, 106],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 117 },
                      { numBlocks: 4, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 45 },
                      { numBlocks: 14, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 24 },
                      { numBlocks: 16, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 30, dataCodewordsPerBlock: 16 },
                      { numBlocks: 2, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 102881,
                versionNumber: 25,
                alignmentPatternCenters: [6, 32, 58, 84, 110],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 26,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 106 },
                      { numBlocks: 4, dataCodewordsPerBlock: 107 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 47 },
                      { numBlocks: 13, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 24 },
                      { numBlocks: 22, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 15 },
                      { numBlocks: 13, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 110507,
                versionNumber: 26,
                alignmentPatternCenters: [6, 30, 58, 86, 114],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 114 },
                      { numBlocks: 2, dataCodewordsPerBlock: 115 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 46 },
                      { numBlocks: 4, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 28, dataCodewordsPerBlock: 22 },
                      { numBlocks: 6, dataCodewordsPerBlock: 23 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 33, dataCodewordsPerBlock: 16 },
                      { numBlocks: 4, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 110734,
                versionNumber: 27,
                alignmentPatternCenters: [6, 34, 62, 90, 118],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 122 },
                      { numBlocks: 4, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 45 },
                      { numBlocks: 3, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 8, dataCodewordsPerBlock: 23 },
                      { numBlocks: 26, dataCodewordsPerBlock: 24 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 15 },
                      { numBlocks: 28, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 117786,
                versionNumber: 28,
                alignmentPatternCenters: [6, 26, 50, 74, 98, 122],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 117 },
                      { numBlocks: 10, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 3, dataCodewordsPerBlock: 45 },
                      { numBlocks: 23, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 24 },
                      { numBlocks: 31, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 15 },
                      { numBlocks: 31, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 119615,
                versionNumber: 29,
                alignmentPatternCenters: [6, 30, 54, 78, 102, 126],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 7, dataCodewordsPerBlock: 116 },
                      { numBlocks: 7, dataCodewordsPerBlock: 117 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 21, dataCodewordsPerBlock: 45 },
                      { numBlocks: 7, dataCodewordsPerBlock: 46 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 1, dataCodewordsPerBlock: 23 },
                      { numBlocks: 37, dataCodewordsPerBlock: 24 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 15 },
                      { numBlocks: 26, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 126325,
                versionNumber: 30,
                alignmentPatternCenters: [6, 26, 52, 78, 104, 130],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 5, dataCodewordsPerBlock: 115 },
                      { numBlocks: 10, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 47 },
                      { numBlocks: 10, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 15, dataCodewordsPerBlock: 24 },
                      { numBlocks: 25, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 23, dataCodewordsPerBlock: 15 },
                      { numBlocks: 25, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 127568,
                versionNumber: 31,
                alignmentPatternCenters: [6, 30, 56, 82, 108, 134],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 115 },
                      { numBlocks: 3, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 46 },
                      { numBlocks: 29, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 42, dataCodewordsPerBlock: 24 },
                      { numBlocks: 1, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 23, dataCodewordsPerBlock: 15 },
                      { numBlocks: 28, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 133589,
                versionNumber: 32,
                alignmentPatternCenters: [6, 34, 60, 86, 112, 138],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [{ numBlocks: 17, dataCodewordsPerBlock: 115 }]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 46 },
                      { numBlocks: 23, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 24 },
                      { numBlocks: 35, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 15 },
                      { numBlocks: 35, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 136944,
                versionNumber: 33,
                alignmentPatternCenters: [6, 30, 58, 86, 114, 142],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 115 },
                      { numBlocks: 1, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 14, dataCodewordsPerBlock: 46 },
                      { numBlocks: 21, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 29, dataCodewordsPerBlock: 24 },
                      { numBlocks: 19, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 11, dataCodewordsPerBlock: 15 },
                      { numBlocks: 46, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 141498,
                versionNumber: 34,
                alignmentPatternCenters: [6, 34, 62, 90, 118, 146],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 115 },
                      { numBlocks: 6, dataCodewordsPerBlock: 116 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 14, dataCodewordsPerBlock: 46 },
                      { numBlocks: 23, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 44, dataCodewordsPerBlock: 24 },
                      { numBlocks: 7, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 59, dataCodewordsPerBlock: 16 },
                      { numBlocks: 1, dataCodewordsPerBlock: 17 }
                    ]
                  }
                ]
              },
              {
                infoBits: 145311,
                versionNumber: 35,
                alignmentPatternCenters: [6, 30, 54, 78, 102, 126, 150],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 121 },
                      { numBlocks: 7, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 12, dataCodewordsPerBlock: 47 },
                      { numBlocks: 26, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 39, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 22, dataCodewordsPerBlock: 15 },
                      { numBlocks: 41, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 150283,
                versionNumber: 36,
                alignmentPatternCenters: [6, 24, 50, 76, 102, 128, 154],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 121 },
                      { numBlocks: 14, dataCodewordsPerBlock: 122 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 6, dataCodewordsPerBlock: 47 },
                      { numBlocks: 34, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 46, dataCodewordsPerBlock: 24 },
                      { numBlocks: 10, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 2, dataCodewordsPerBlock: 15 },
                      { numBlocks: 64, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 152622,
                versionNumber: 37,
                alignmentPatternCenters: [6, 28, 54, 80, 106, 132, 158],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 17, dataCodewordsPerBlock: 122 },
                      { numBlocks: 4, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 29, dataCodewordsPerBlock: 46 },
                      { numBlocks: 14, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 49, dataCodewordsPerBlock: 24 },
                      { numBlocks: 10, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 24, dataCodewordsPerBlock: 15 },
                      { numBlocks: 46, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 158308,
                versionNumber: 38,
                alignmentPatternCenters: [6, 32, 58, 84, 110, 136, 162],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 4, dataCodewordsPerBlock: 122 },
                      { numBlocks: 18, dataCodewordsPerBlock: 123 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 13, dataCodewordsPerBlock: 46 },
                      { numBlocks: 32, dataCodewordsPerBlock: 47 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 48, dataCodewordsPerBlock: 24 },
                      { numBlocks: 14, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 42, dataCodewordsPerBlock: 15 },
                      { numBlocks: 32, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 161089,
                versionNumber: 39,
                alignmentPatternCenters: [6, 26, 54, 82, 110, 138, 166],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 20, dataCodewordsPerBlock: 117 },
                      { numBlocks: 4, dataCodewordsPerBlock: 118 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 40, dataCodewordsPerBlock: 47 },
                      { numBlocks: 7, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 43, dataCodewordsPerBlock: 24 },
                      { numBlocks: 22, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 10, dataCodewordsPerBlock: 15 },
                      { numBlocks: 67, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              },
              {
                infoBits: 167017,
                versionNumber: 40,
                alignmentPatternCenters: [6, 30, 58, 86, 114, 142, 170],
                errorCorrectionLevels: [
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 19, dataCodewordsPerBlock: 118 },
                      { numBlocks: 6, dataCodewordsPerBlock: 119 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 28,
                    ecBlocks: [
                      { numBlocks: 18, dataCodewordsPerBlock: 47 },
                      { numBlocks: 31, dataCodewordsPerBlock: 48 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 34, dataCodewordsPerBlock: 24 },
                      { numBlocks: 34, dataCodewordsPerBlock: 25 }
                    ]
                  },
                  {
                    ecCodewordsPerBlock: 30,
                    ecBlocks: [
                      { numBlocks: 20, dataCodewordsPerBlock: 15 },
                      { numBlocks: 61, dataCodewordsPerBlock: 16 }
                    ]
                  }
                ]
              }
            ];
          },
          /* 11 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BitMatrix_1 = __webpack_require__(0);
            function squareToQuadrilateral(p1, p2, p3, p4) {
              var dx3 = p1.x - p2.x + p3.x - p4.x;
              var dy3 = p1.y - p2.y + p3.y - p4.y;
              if (dx3 === 0 && dy3 === 0) {
                return {
                  a11: p2.x - p1.x,
                  a12: p2.y - p1.y,
                  a13: 0,
                  a21: p3.x - p2.x,
                  a22: p3.y - p2.y,
                  a23: 0,
                  a31: p1.x,
                  a32: p1.y,
                  a33: 1
                };
              } else {
                var dx1 = p2.x - p3.x;
                var dx2 = p4.x - p3.x;
                var dy1 = p2.y - p3.y;
                var dy2 = p4.y - p3.y;
                var denominator = dx1 * dy2 - dx2 * dy1;
                var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
                var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
                return {
                  a11: p2.x - p1.x + a13 * p2.x,
                  a12: p2.y - p1.y + a13 * p2.y,
                  a13,
                  a21: p4.x - p1.x + a23 * p4.x,
                  a22: p4.y - p1.y + a23 * p4.y,
                  a23,
                  a31: p1.x,
                  a32: p1.y,
                  a33: 1
                };
              }
            }
            function quadrilateralToSquare(p1, p2, p3, p4) {
              var sToQ = squareToQuadrilateral(p1, p2, p3, p4);
              return {
                a11: sToQ.a22 * sToQ.a33 - sToQ.a23 * sToQ.a32,
                a12: sToQ.a13 * sToQ.a32 - sToQ.a12 * sToQ.a33,
                a13: sToQ.a12 * sToQ.a23 - sToQ.a13 * sToQ.a22,
                a21: sToQ.a23 * sToQ.a31 - sToQ.a21 * sToQ.a33,
                a22: sToQ.a11 * sToQ.a33 - sToQ.a13 * sToQ.a31,
                a23: sToQ.a13 * sToQ.a21 - sToQ.a11 * sToQ.a23,
                a31: sToQ.a21 * sToQ.a32 - sToQ.a22 * sToQ.a31,
                a32: sToQ.a12 * sToQ.a31 - sToQ.a11 * sToQ.a32,
                a33: sToQ.a11 * sToQ.a22 - sToQ.a12 * sToQ.a21
              };
            }
            function times(a2, b2) {
              return {
                a11: a2.a11 * b2.a11 + a2.a21 * b2.a12 + a2.a31 * b2.a13,
                a12: a2.a12 * b2.a11 + a2.a22 * b2.a12 + a2.a32 * b2.a13,
                a13: a2.a13 * b2.a11 + a2.a23 * b2.a12 + a2.a33 * b2.a13,
                a21: a2.a11 * b2.a21 + a2.a21 * b2.a22 + a2.a31 * b2.a23,
                a22: a2.a12 * b2.a21 + a2.a22 * b2.a22 + a2.a32 * b2.a23,
                a23: a2.a13 * b2.a21 + a2.a23 * b2.a22 + a2.a33 * b2.a23,
                a31: a2.a11 * b2.a31 + a2.a21 * b2.a32 + a2.a31 * b2.a33,
                a32: a2.a12 * b2.a31 + a2.a22 * b2.a32 + a2.a32 * b2.a33,
                a33: a2.a13 * b2.a31 + a2.a23 * b2.a32 + a2.a33 * b2.a33
              };
            }
            function extract(image, location) {
              var qToS = quadrilateralToSquare({ x: 3.5, y: 3.5 }, { x: location.dimension - 3.5, y: 3.5 }, { x: location.dimension - 6.5, y: location.dimension - 6.5 }, { x: 3.5, y: location.dimension - 3.5 });
              var sToQ = squareToQuadrilateral(location.topLeft, location.topRight, location.alignmentPattern, location.bottomLeft);
              var transform = times(sToQ, qToS);
              var matrix = BitMatrix_1.BitMatrix.createEmpty(location.dimension, location.dimension);
              var mappingFunction = function(x3, y3) {
                var denominator = transform.a13 * x3 + transform.a23 * y3 + transform.a33;
                return {
                  x: (transform.a11 * x3 + transform.a21 * y3 + transform.a31) / denominator,
                  y: (transform.a12 * x3 + transform.a22 * y3 + transform.a32) / denominator
                };
              };
              for (var y2 = 0; y2 < location.dimension; y2++) {
                for (var x2 = 0; x2 < location.dimension; x2++) {
                  var xValue = x2 + 0.5;
                  var yValue = y2 + 0.5;
                  var sourcePixel = mappingFunction(xValue, yValue);
                  matrix.set(x2, y2, image.get(Math.floor(sourcePixel.x), Math.floor(sourcePixel.y)));
                }
              }
              return {
                matrix,
                mappingFunction
              };
            }
            exports2.extract = extract;
          },
          /* 12 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var MAX_FINDERPATTERNS_TO_SEARCH = 4;
            var MIN_QUAD_RATIO = 0.5;
            var MAX_QUAD_RATIO = 1.5;
            var distance = function(a2, b2) {
              return Math.sqrt(Math.pow(b2.x - a2.x, 2) + Math.pow(b2.y - a2.y, 2));
            };
            function sum(values) {
              return values.reduce(function(a2, b2) {
                return a2 + b2;
              });
            }
            function reorderFinderPatterns(pattern1, pattern2, pattern3) {
              var _a, _b, _c, _d;
              var oneTwoDistance = distance(pattern1, pattern2);
              var twoThreeDistance = distance(pattern2, pattern3);
              var oneThreeDistance = distance(pattern1, pattern3);
              var bottomLeft;
              var topLeft;
              var topRight;
              if (twoThreeDistance >= oneTwoDistance && twoThreeDistance >= oneThreeDistance) {
                _a = [pattern2, pattern1, pattern3], bottomLeft = _a[0], topLeft = _a[1], topRight = _a[2];
              } else if (oneThreeDistance >= twoThreeDistance && oneThreeDistance >= oneTwoDistance) {
                _b = [pattern1, pattern2, pattern3], bottomLeft = _b[0], topLeft = _b[1], topRight = _b[2];
              } else {
                _c = [pattern1, pattern3, pattern2], bottomLeft = _c[0], topLeft = _c[1], topRight = _c[2];
              }
              if ((topRight.x - topLeft.x) * (bottomLeft.y - topLeft.y) - (topRight.y - topLeft.y) * (bottomLeft.x - topLeft.x) < 0) {
                _d = [topRight, bottomLeft], bottomLeft = _d[0], topRight = _d[1];
              }
              return { bottomLeft, topLeft, topRight };
            }
            function computeDimension(topLeft, topRight, bottomLeft, matrix) {
              var moduleSize = (sum(countBlackWhiteRun(topLeft, bottomLeft, matrix, 5)) / 7 + // Divide by 7 since the ratio is 1:1:3:1:1
              sum(countBlackWhiteRun(topLeft, topRight, matrix, 5)) / 7 + sum(countBlackWhiteRun(bottomLeft, topLeft, matrix, 5)) / 7 + sum(countBlackWhiteRun(topRight, topLeft, matrix, 5)) / 7) / 4;
              if (moduleSize < 1) {
                throw new Error("Invalid module size");
              }
              var topDimension = Math.round(distance(topLeft, topRight) / moduleSize);
              var sideDimension = Math.round(distance(topLeft, bottomLeft) / moduleSize);
              var dimension = Math.floor((topDimension + sideDimension) / 2) + 7;
              switch (dimension % 4) {
                case 0:
                  dimension++;
                  break;
                case 2:
                  dimension--;
                  break;
              }
              return { dimension, moduleSize };
            }
            function countBlackWhiteRunTowardsPoint(origin, end, matrix, length2) {
              var switchPoints = [{ x: Math.floor(origin.x), y: Math.floor(origin.y) }];
              var steep = Math.abs(end.y - origin.y) > Math.abs(end.x - origin.x);
              var fromX;
              var fromY;
              var toX;
              var toY;
              if (steep) {
                fromX = Math.floor(origin.y);
                fromY = Math.floor(origin.x);
                toX = Math.floor(end.y);
                toY = Math.floor(end.x);
              } else {
                fromX = Math.floor(origin.x);
                fromY = Math.floor(origin.y);
                toX = Math.floor(end.x);
                toY = Math.floor(end.y);
              }
              var dx = Math.abs(toX - fromX);
              var dy = Math.abs(toY - fromY);
              var error = Math.floor(-dx / 2);
              var xStep = fromX < toX ? 1 : -1;
              var yStep = fromY < toY ? 1 : -1;
              var currentPixel = true;
              for (var x2 = fromX, y2 = fromY; x2 !== toX + xStep; x2 += xStep) {
                var realX = steep ? y2 : x2;
                var realY = steep ? x2 : y2;
                if (matrix.get(realX, realY) !== currentPixel) {
                  currentPixel = !currentPixel;
                  switchPoints.push({ x: realX, y: realY });
                  if (switchPoints.length === length2 + 1) {
                    break;
                  }
                }
                error += dy;
                if (error > 0) {
                  if (y2 === toY) {
                    break;
                  }
                  y2 += yStep;
                  error -= dx;
                }
              }
              var distances = [];
              for (var i2 = 0; i2 < length2; i2++) {
                if (switchPoints[i2] && switchPoints[i2 + 1]) {
                  distances.push(distance(switchPoints[i2], switchPoints[i2 + 1]));
                } else {
                  distances.push(0);
                }
              }
              return distances;
            }
            function countBlackWhiteRun(origin, end, matrix, length2) {
              var _a;
              var rise = end.y - origin.y;
              var run = end.x - origin.x;
              var towardsEnd = countBlackWhiteRunTowardsPoint(origin, end, matrix, Math.ceil(length2 / 2));
              var awayFromEnd = countBlackWhiteRunTowardsPoint(origin, { x: origin.x - run, y: origin.y - rise }, matrix, Math.ceil(length2 / 2));
              var middleValue = towardsEnd.shift() + awayFromEnd.shift() - 1;
              return (_a = awayFromEnd.concat(middleValue)).concat.apply(_a, towardsEnd);
            }
            function scoreBlackWhiteRun(sequence, ratios) {
              var averageSize = sum(sequence) / sum(ratios);
              var error = 0;
              ratios.forEach(function(ratio, i2) {
                error += Math.pow(sequence[i2] - ratio * averageSize, 2);
              });
              return { averageSize, error };
            }
            function scorePattern(point, ratios, matrix) {
              try {
                var horizontalRun = countBlackWhiteRun(point, { x: -1, y: point.y }, matrix, ratios.length);
                var verticalRun = countBlackWhiteRun(point, { x: point.x, y: -1 }, matrix, ratios.length);
                var topLeftPoint = {
                  x: Math.max(0, point.x - point.y) - 1,
                  y: Math.max(0, point.y - point.x) - 1
                };
                var topLeftBottomRightRun = countBlackWhiteRun(point, topLeftPoint, matrix, ratios.length);
                var bottomLeftPoint = {
                  x: Math.min(matrix.width, point.x + point.y) + 1,
                  y: Math.min(matrix.height, point.y + point.x) + 1
                };
                var bottomLeftTopRightRun = countBlackWhiteRun(point, bottomLeftPoint, matrix, ratios.length);
                var horzError = scoreBlackWhiteRun(horizontalRun, ratios);
                var vertError = scoreBlackWhiteRun(verticalRun, ratios);
                var diagDownError = scoreBlackWhiteRun(topLeftBottomRightRun, ratios);
                var diagUpError = scoreBlackWhiteRun(bottomLeftTopRightRun, ratios);
                var ratioError = Math.sqrt(horzError.error * horzError.error + vertError.error * vertError.error + diagDownError.error * diagDownError.error + diagUpError.error * diagUpError.error);
                var avgSize = (horzError.averageSize + vertError.averageSize + diagDownError.averageSize + diagUpError.averageSize) / 4;
                var sizeError = (Math.pow(horzError.averageSize - avgSize, 2) + Math.pow(vertError.averageSize - avgSize, 2) + Math.pow(diagDownError.averageSize - avgSize, 2) + Math.pow(diagUpError.averageSize - avgSize, 2)) / avgSize;
                return ratioError + sizeError;
              } catch (_a) {
                return Infinity;
              }
            }
            function recenterLocation(matrix, p2) {
              var leftX = Math.round(p2.x);
              while (matrix.get(leftX, Math.round(p2.y))) {
                leftX--;
              }
              var rightX = Math.round(p2.x);
              while (matrix.get(rightX, Math.round(p2.y))) {
                rightX++;
              }
              var x2 = (leftX + rightX) / 2;
              var topY = Math.round(p2.y);
              while (matrix.get(Math.round(x2), topY)) {
                topY--;
              }
              var bottomY = Math.round(p2.y);
              while (matrix.get(Math.round(x2), bottomY)) {
                bottomY++;
              }
              var y2 = (topY + bottomY) / 2;
              return { x: x2, y: y2 };
            }
            function locate(matrix) {
              var finderPatternQuads = [];
              var activeFinderPatternQuads = [];
              var alignmentPatternQuads = [];
              var activeAlignmentPatternQuads = [];
              var _loop_1 = function(y3) {
                var length_1 = 0;
                var lastBit = false;
                var scans = [0, 0, 0, 0, 0];
                var _loop_2 = function(x3) {
                  var v2 = matrix.get(x3, y3);
                  if (v2 === lastBit) {
                    length_1++;
                  } else {
                    scans = [scans[1], scans[2], scans[3], scans[4], length_1];
                    length_1 = 1;
                    lastBit = v2;
                    var averageFinderPatternBlocksize = sum(scans) / 7;
                    var validFinderPattern = Math.abs(scans[0] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[1] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[2] - 3 * averageFinderPatternBlocksize) < 3 * averageFinderPatternBlocksize && Math.abs(scans[3] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && Math.abs(scans[4] - averageFinderPatternBlocksize) < averageFinderPatternBlocksize && !v2;
                    var averageAlignmentPatternBlocksize = sum(scans.slice(-3)) / 3;
                    var validAlignmentPattern = Math.abs(scans[2] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[3] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && Math.abs(scans[4] - averageAlignmentPatternBlocksize) < averageAlignmentPatternBlocksize && v2;
                    if (validFinderPattern) {
                      var endX_1 = x3 - scans[3] - scans[4];
                      var startX_1 = endX_1 - scans[2];
                      var line2 = { startX: startX_1, endX: endX_1, y: y3 };
                      var matchingQuads = activeFinderPatternQuads.filter(function(q2) {
                        return startX_1 >= q2.bottom.startX && startX_1 <= q2.bottom.endX || endX_1 >= q2.bottom.startX && startX_1 <= q2.bottom.endX || startX_1 <= q2.bottom.startX && endX_1 >= q2.bottom.endX && (scans[2] / (q2.bottom.endX - q2.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q2.bottom.endX - q2.bottom.startX) > MIN_QUAD_RATIO);
                      });
                      if (matchingQuads.length > 0) {
                        matchingQuads[0].bottom = line2;
                      } else {
                        activeFinderPatternQuads.push({ top: line2, bottom: line2 });
                      }
                    }
                    if (validAlignmentPattern) {
                      var endX_2 = x3 - scans[4];
                      var startX_2 = endX_2 - scans[3];
                      var line2 = { startX: startX_2, y: y3, endX: endX_2 };
                      var matchingQuads = activeAlignmentPatternQuads.filter(function(q2) {
                        return startX_2 >= q2.bottom.startX && startX_2 <= q2.bottom.endX || endX_2 >= q2.bottom.startX && startX_2 <= q2.bottom.endX || startX_2 <= q2.bottom.startX && endX_2 >= q2.bottom.endX && (scans[2] / (q2.bottom.endX - q2.bottom.startX) < MAX_QUAD_RATIO && scans[2] / (q2.bottom.endX - q2.bottom.startX) > MIN_QUAD_RATIO);
                      });
                      if (matchingQuads.length > 0) {
                        matchingQuads[0].bottom = line2;
                      } else {
                        activeAlignmentPatternQuads.push({ top: line2, bottom: line2 });
                      }
                    }
                  }
                };
                for (var x2 = -1; x2 <= matrix.width; x2++) {
                  _loop_2(x2);
                }
                finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q2) {
                  return q2.bottom.y !== y3 && q2.bottom.y - q2.top.y >= 2;
                }));
                activeFinderPatternQuads = activeFinderPatternQuads.filter(function(q2) {
                  return q2.bottom.y === y3;
                });
                alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads.filter(function(q2) {
                  return q2.bottom.y !== y3;
                }));
                activeAlignmentPatternQuads = activeAlignmentPatternQuads.filter(function(q2) {
                  return q2.bottom.y === y3;
                });
              };
              for (var y2 = 0; y2 <= matrix.height; y2++) {
                _loop_1(y2);
              }
              finderPatternQuads.push.apply(finderPatternQuads, activeFinderPatternQuads.filter(function(q2) {
                return q2.bottom.y - q2.top.y >= 2;
              }));
              alignmentPatternQuads.push.apply(alignmentPatternQuads, activeAlignmentPatternQuads);
              var finderPatternGroups = finderPatternQuads.filter(function(q2) {
                return q2.bottom.y - q2.top.y >= 2;
              }).map(function(q2) {
                var x2 = (q2.top.startX + q2.top.endX + q2.bottom.startX + q2.bottom.endX) / 4;
                var y3 = (q2.top.y + q2.bottom.y + 1) / 2;
                if (!matrix.get(Math.round(x2), Math.round(y3))) {
                  return;
                }
                var lengths = [q2.top.endX - q2.top.startX, q2.bottom.endX - q2.bottom.startX, q2.bottom.y - q2.top.y + 1];
                var size = sum(lengths) / lengths.length;
                var score = scorePattern({ x: Math.round(x2), y: Math.round(y3) }, [1, 1, 3, 1, 1], matrix);
                return { score, x: x2, y: y3, size };
              }).filter(function(q2) {
                return !!q2;
              }).sort(function(a2, b2) {
                return a2.score - b2.score;
              }).map(function(point, i2, finderPatterns) {
                if (i2 > MAX_FINDERPATTERNS_TO_SEARCH) {
                  return null;
                }
                var otherPoints = finderPatterns.filter(function(p2, ii) {
                  return i2 !== ii;
                }).map(function(p2) {
                  return { x: p2.x, y: p2.y, score: p2.score + Math.pow(p2.size - point.size, 2) / point.size, size: p2.size };
                }).sort(function(a2, b2) {
                  return a2.score - b2.score;
                });
                if (otherPoints.length < 2) {
                  return null;
                }
                var score = point.score + otherPoints[0].score + otherPoints[1].score;
                return { points: [point].concat(otherPoints.slice(0, 2)), score };
              }).filter(function(q2) {
                return !!q2;
              }).sort(function(a2, b2) {
                return a2.score - b2.score;
              });
              if (finderPatternGroups.length === 0) {
                return null;
              }
              var _a = reorderFinderPatterns(finderPatternGroups[0].points[0], finderPatternGroups[0].points[1], finderPatternGroups[0].points[2]), topRight = _a.topRight, topLeft = _a.topLeft, bottomLeft = _a.bottomLeft;
              var alignment = findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft);
              var result = [];
              if (alignment) {
                result.push({
                  alignmentPattern: { x: alignment.alignmentPattern.x, y: alignment.alignmentPattern.y },
                  bottomLeft: { x: bottomLeft.x, y: bottomLeft.y },
                  dimension: alignment.dimension,
                  topLeft: { x: topLeft.x, y: topLeft.y },
                  topRight: { x: topRight.x, y: topRight.y }
                });
              }
              var midTopRight = recenterLocation(matrix, topRight);
              var midTopLeft = recenterLocation(matrix, topLeft);
              var midBottomLeft = recenterLocation(matrix, bottomLeft);
              var centeredAlignment = findAlignmentPattern(matrix, alignmentPatternQuads, midTopRight, midTopLeft, midBottomLeft);
              if (centeredAlignment) {
                result.push({
                  alignmentPattern: { x: centeredAlignment.alignmentPattern.x, y: centeredAlignment.alignmentPattern.y },
                  bottomLeft: { x: midBottomLeft.x, y: midBottomLeft.y },
                  topLeft: { x: midTopLeft.x, y: midTopLeft.y },
                  topRight: { x: midTopRight.x, y: midTopRight.y },
                  dimension: centeredAlignment.dimension
                });
              }
              if (result.length === 0) {
                return null;
              }
              return result;
            }
            exports2.locate = locate;
            function findAlignmentPattern(matrix, alignmentPatternQuads, topRight, topLeft, bottomLeft) {
              var _a;
              var dimension;
              var moduleSize;
              try {
                _a = computeDimension(topLeft, topRight, bottomLeft, matrix), dimension = _a.dimension, moduleSize = _a.moduleSize;
              } catch (e2) {
                return null;
              }
              var bottomRightFinderPattern = {
                x: topRight.x - topLeft.x + bottomLeft.x,
                y: topRight.y - topLeft.y + bottomLeft.y
              };
              var modulesBetweenFinderPatterns = (distance(topLeft, bottomLeft) + distance(topLeft, topRight)) / 2 / moduleSize;
              var correctionToTopLeft = 1 - 3 / modulesBetweenFinderPatterns;
              var expectedAlignmentPattern = {
                x: topLeft.x + correctionToTopLeft * (bottomRightFinderPattern.x - topLeft.x),
                y: topLeft.y + correctionToTopLeft * (bottomRightFinderPattern.y - topLeft.y)
              };
              var alignmentPatterns = alignmentPatternQuads.map(function(q2) {
                var x2 = (q2.top.startX + q2.top.endX + q2.bottom.startX + q2.bottom.endX) / 4;
                var y2 = (q2.top.y + q2.bottom.y + 1) / 2;
                if (!matrix.get(Math.floor(x2), Math.floor(y2))) {
                  return;
                }
                var lengths = [q2.top.endX - q2.top.startX, q2.bottom.endX - q2.bottom.startX, q2.bottom.y - q2.top.y + 1];
                var size = sum(lengths) / lengths.length;
                var sizeScore = scorePattern({ x: Math.floor(x2), y: Math.floor(y2) }, [1, 1, 1], matrix);
                var score = sizeScore + distance({ x: x2, y: y2 }, expectedAlignmentPattern);
                return { x: x2, y: y2, score };
              }).filter(function(v2) {
                return !!v2;
              }).sort(function(a2, b2) {
                return a2.score - b2.score;
              });
              var alignmentPattern = modulesBetweenFinderPatterns >= 15 && alignmentPatterns.length ? alignmentPatterns[0] : expectedAlignmentPattern;
              return { alignmentPattern, dimension };
            }
          }
          /******/
        ])["default"]
      );
    });
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var api = {};
    module.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet2, maxline) {
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet2);
      } else {
        var i2 = 0;
        var base = alphabet2.length;
        var first = alphabet2.charAt(0);
        var digits = [0];
        for (i2 = 0; i2 < input.length; ++i2) {
          for (var j2 = 0, carry = input[i2]; j2 < digits.length; ++j2) {
            carry += digits[j2] << 8;
            digits[j2] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i2 = 0; input[i2] === 0 && i2 < input.length - 1; ++i2) {
          output += first;
        }
        for (i2 = digits.length - 1; i2 >= 0; --i2) {
          output += alphabet2[digits[i2]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet2) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet2 !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet2];
      if (!table) {
        table = _reverseAlphabets[alphabet2] = [];
        for (var i2 = 0; i2 < alphabet2.length; ++i2) {
          table[alphabet2.charCodeAt(i2)] = i2;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet2.length;
      var first = alphabet2.charAt(0);
      var bytes = [0];
      for (var i2 = 0; i2 < input.length; i2++) {
        var value = table[input.charCodeAt(i2)];
        if (value === void 0) {
          return;
        }
        for (var j2 = 0, carry = value; j2 < bytes.length; ++j2) {
          carry += bytes[j2] * base;
          bytes[j2] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k2 = 0; input[k2] === first && k2 < input.length - 1; ++k2) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet2) {
      var i2 = 0;
      var base = alphabet2.length;
      var first = alphabet2.charAt(0);
      var digits = [0];
      for (i2 = 0; i2 < input.length(); ++i2) {
        for (var j2 = 0, carry = input.at(i2); j2 < digits.length; ++j2) {
          carry += digits[j2] << 8;
          digits[j2] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i2 = 0; input.at(i2) === 0 && i2 < input.length() - 1; ++i2) {
        output += first;
      }
      for (i2 = digits.length - 1; i2 >= 0; --i2) {
        output += alphabet2[digits[i2]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy2 = callbacks.slice();
            callbacks.length = 0;
            copy2.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div2 = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy2 = callbacks.slice();
          callbacks.length = 0;
          copy2.forEach(function(callback) {
            callback();
          });
        }).observe(div2, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div2.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x2) {
      return Object.prototype.toString.call(x2) === "[object Array]";
    };
    util.isArrayBuffer = function(x2) {
      return typeof ArrayBuffer !== "undefined" && x2 instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x2) {
      return x2 && util.isArrayBuffer(x2.buffer) && x2.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util.isArrayBuffer(b2) || util.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e2) {
            for (var i2 = 0; i2 < arr.length; ++i2) {
              this.putByte(arr[i2]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x2) {
      this._constructedStringLength += x2;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b2, n) {
      b2 = String.fromCharCode(b2);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b2;
        }
        n >>>= 1;
        if (n > 0) {
          b2 += b2;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i2) {
      return this.putBytes(
        String.fromCharCode(i2 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      var bytes = "";
      do {
        n -= 8;
        bytes += String.fromCharCode(i2 >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i2, n) {
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x2 = this.getInt(n);
      var max = 2 << n - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i2) {
      return this.data.charCodeAt(this.read + i2);
    };
    util.ByteStringBuffer.prototype.setAt = function(i2, b2) {
      this.data = this.data.substr(0, this.read + i2) + String.fromCharCode(b2) + this.data.substr(this.read + i2 + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c2 = util.createBuffer(this.data);
      c2.read = this.read;
      return c2;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.length; ++i2) {
        var b2 = this.data.charCodeAt(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b2);
      var isArrayBufferView = util.isArrayBufferView(b2);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b2, n) {
      this.accommodate(n);
      for (var i2 = 0; i2 < n; ++i2) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i2) {
      this.accommodate(3);
      this.data.setInt16(this.write, i2 >> 8 & 65535);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i2) {
      this.accommodate(2);
      this.data.setInt16(this.write, i2, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i2) {
      this.accommodate(3);
      this.data.setInt8(this.write, i2 >> 16 & 255);
      this.data.setInt16(this.write, i2 >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i2) {
      this.accommodate(4);
      this.data.setInt32(this.write, i2, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i2 >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i2, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i2 < 0) {
        i2 += 2 << n - 1;
      }
      return this.putInt(i2, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x2 = this.getInt(n);
      var max = 2 << n - 2;
      if (x2 >= max) {
        x2 -= max << 1;
      }
      return x2;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i2) {
      return this.data.getUint8(this.read + i2);
    };
    util.DataBuffer.prototype.setAt = function(i2, b2) {
      this.data.setUint8(i2, b2);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i2 = this.read; i2 < this.data.byteLength; ++i2) {
        var b2 = this.data.getUint8(i2);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c2, n) {
      var s2 = "";
      while (n > 0) {
        if (n & 1) {
          s2 += c2;
        }
        n >>>= 1;
        if (n > 0) {
          c2 += c2;
        }
      }
      return s2;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b2 = "";
      var t = "";
      var i2 = 0;
      var c2 = 0;
      for (; n > 0; --n, ++i2) {
        b2 = s1.charCodeAt(i2) ^ s2.charCodeAt(i2);
        if (c2 >= 10) {
          s3 += t;
          t = "";
          c2 = 0;
        }
        t += String.fromCharCode(b2);
        ++c2;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex2) {
      var rval = "";
      var i2 = 0;
      if (hex2.length & true) {
        i2 = 1;
        rval += String.fromCharCode(parseInt(hex2[0], 16));
      }
      for (; i2 < hex2.length; i2 += 2) {
        rval += String.fromCharCode(parseInt(hex2.substr(i2, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i2) {
      return String.fromCharCode(i2 >> 24 & 255) + String.fromCharCode(i2 >> 16 & 255) + String.fromCharCode(i2 >> 8 & 255) + String.fromCharCode(i2 & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line2 = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.length) {
        chr1 = input.charCodeAt(i2++);
        chr2 = input.charCodeAt(i2++);
        chr3 = input.charCodeAt(i2++);
        line2 += _base64.charAt(chr1 >> 2);
        line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line2 += "==";
        } else {
          line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line2.length > maxline) {
          output += line2.substr(0, maxline) + "\r\n";
          line2 = line2.substr(maxline);
        }
      }
      output += line2;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i2 = 0;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex2, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex2.length / 2));
      }
      offset = offset || 0;
      var i2 = 0, j2 = offset;
      if (hex2.length & 1) {
        i2 = 1;
        out[j2++] = parseInt(hex2[0], 16);
      }
      for (; i2 < hex2.length; i2 += 2) {
        out[j2++] = parseInt(hex2.substr(i2, 2), 16);
      }
      return output ? j2 - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line2 = "";
      var output = "";
      var chr1, chr2, chr3;
      var i2 = 0;
      while (i2 < input.byteLength) {
        chr1 = input[i2++];
        chr2 = input[i2++];
        chr3 = input[i2++];
        line2 += _base64.charAt(chr1 >> 2);
        line2 += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line2 += "==";
        } else {
          line2 += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line2 += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line2.length > maxline) {
          output += line2.substr(0, maxline) + "\r\n";
          line2 = line2.substr(maxline);
        }
      }
      output += line2;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i2 = 0, j2 = offset;
      while (i2 < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i2++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i2++) - 43];
        out[j2++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j2++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j2 - offset : out.subarray(0, j2);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        out[j2++] = str.charCodeAt(i2);
      }
      return output ? j2 - offset : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j2 = offset;
      var k2 = offset;
      for (var i2 = 0; i2 < str.length; ++i2) {
        view[k2++] = str.charCodeAt(i2);
        j2 += 2;
      }
      return output ? j2 - offset : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location) {
      var rval = null;
      if (typeof location === "undefined") {
        location = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location) {
        type = location[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location) {
      _callStorageFunction(_setItem, arguments, location);
    };
    util.getItem = function(api, id, key, location) {
      return _callStorageFunction(_getItem, arguments, location);
    };
    util.removeItem = function(api, id, key, location) {
      _callStorageFunction(_removeItem, arguments, location);
    };
    util.clearItems = function(api, id, location) {
      _callStorageFunction(_clearItems, arguments, location);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re2 = /%./g;
      var match2;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match2 = re2.exec(format)) {
        part = format.substring(last, re2.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re2.lastIndex;
        var code = match2[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c2 = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
      var i2 = parseInt(n = Math.abs(+n || 0).toFixed(c2), 10) + "";
      var j2 = i2.length > 3 ? i2.length % 3 : 0;
      return s2 + (j2 ? i2.substr(0, j2) + t : "") + i2.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c2 ? d + Math.abs(n - i2).toFixed(c2).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util.createBuffer();
      for (var i2 = 0; i2 < ip.length; ++i2) {
        var num = parseInt(ip[i2], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e2) {
        if (e2.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b2 = util.createBuffer();
      for (var i2 = 0; i2 < 8; ++i2) {
        if (!ip[i2] || ip[i2].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i2]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        ip.push(bytes.charCodeAt(i2));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i2 = 0; i2 < bytes.length; i2 += 2) {
        var hex2 = util.bytesToHex(bytes[i2] + bytes[i2 + 1]);
        while (hex2[0] === "0" && hex2 !== "0") {
          hex2 = hex2.substr(1);
        }
        if (hex2 === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex2);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e2) {
            var st2 = Date.now();
            var et2 = st2 + 4;
            while (Date.now() < et2) ;
            self.postMessage({ st: st2, et: et2 });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x2) {
            return avg2 + x2;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e2) {
            results.push(e2.data);
            if (results.length === numWorkers) {
              for (var i3 = 0; i3 < numWorkers; ++i3) {
                workers[i3].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i2 = 0; i2 < numWorkers; ++i2) {
          workers[i2].postMessage(i2);
        }
      }
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            if (n === i2) {
              continue;
            }
            var r2 = results[i2];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i2);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    module.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge.cipher.algorithms[name] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    forge.cipher = forge.cipher || {};
    var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = this._prev[i2] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._inBlock[i2] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._prev[i2] ^ this._outBlock[i2]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32() ^ this._outBlock[i2];
          output.putInt32(this._inBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32() ^ this._outBlock[i2];
        this._partialOutput.putInt32(this._partialBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = input.getInt32();
          output.putInt32(this._inBlock[i2] ^ this._outBlock[i2]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialBlock[i2] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i2] ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._partialBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
          this._inBlock[i2] = this._outBlock[i2];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._inBlock[i2] = this._outBlock[i2];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i2 = 0; i2 < this._ints; ++i2) {
          output.putInt32(this._outBlock[i2] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i2 = 0; i2 < this._ints; ++i2) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i2]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i2 = 0; i2 < this._ints; ++i2) {
            this._outBlock[i2] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        output.putInt32(this._outBlock[i2] ^ this._hashBlock[i2]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i2 = 0; i2 < this._ints; ++i2) {
        this.tag.putInt32(this._s[i2] ^ tag[i2]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x2, y2) {
      var z_i = [0, 0, 0, 0];
      var v_i = y2.slice(0);
      for (var i2 = 0; i2 < 128; ++i2) {
        var x_i = x2[i2 / 32 | 0] & 1 << 31 - i2 % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x2, out) {
      var lsb = x2[3] & 1;
      for (var i2 = 3; i2 > 0; --i2) {
        out[i2] = x2[i2] >>> 1 | (x2[i2 - 1] & 1) << 31;
      }
      out[0] = x2[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x2) {
      var z2 = [0, 0, 0, 0];
      for (var i2 = 0; i2 < 32; ++i2) {
        var idx = i2 / 8 | 0;
        var x_i = x2[idx] >>> (7 - i2 % 8) * 4 & 15;
        var ah = this._m[i2][x_i];
        z2[0] ^= ah[0];
        z2[1] ^= ah[1];
        z2[2] ^= ah[2];
        z2[3] ^= ah[3];
      }
      return z2;
    };
    modes.gcm.prototype.ghash = function(h, y2, x2) {
      y2[0] ^= x2[0];
      y2[1] ^= x2[1];
      y2[2] ^= x2[2];
      y2[3] ^= x2[3];
      return this.tableMultiply(y2);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits2) {
      var multiplier = 8 / bits2;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m2 = new Array(size);
      for (var i2 = 0; i2 < size; ++i2) {
        var tmp = [0, 0, 0, 0];
        var idx = i2 / perInt | 0;
        var shft = (perInt - 1 - i2 % perInt) * bits2;
        tmp[idx] = 1 << bits2 - 1 << shft;
        m2[i2] = this.generateSubHashTable(this.multiply(tmp, h), bits2);
      }
      return m2;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits2) {
      var size = 1 << bits2;
      var half = size >>> 1;
      var m2 = new Array(size);
      m2[half] = mid.slice(0);
      var i2 = half >>> 1;
      while (i2 > 0) {
        this.pow(m2[2 * i2], m2[i2] = []);
        i2 >>= 1;
      }
      i2 = 2;
      while (i2 < half) {
        for (var j2 = 1; j2 < i2; ++j2) {
          var m_i = m2[i2];
          var m_j = m2[j2];
          m2[i2 + j2] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i2 *= 2;
      }
      m2[0] = [0, 0, 0, 0];
      for (i2 = half + 1; i2 < size; ++i2) {
        var c2 = m2[i2 ^ half];
        m2[i2] = [mid[0] ^ c2[0], mid[1] ^ c2[1], mid[2] ^ c2[2], mid[3] ^ c2[3]];
      }
      return m2;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          iv.putByte(tmp[i2]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i2 = 0; i2 < blocks; ++i2) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i2 = 0; i2 < tmp.length; ++i2) {
          key.putByte(tmp[i2]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i2 = 0; i2 < len; ++i2) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i2 = 0; i2 < 128; ++i2) {
        xtime[i2] = i2 << 1;
        xtime[i2 + 128] = i2 + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i2 = 0; i2 < 4; ++i2) {
        mix[i2] = new Array(256);
        imix[i2] = new Array(256);
      }
      var e2 = 0, ei = 0, e22, e4, e8, sx, sx2, me2, ime;
      for (var i2 = 0; i2 < 256; ++i2) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e2] = sx;
        isbox[sx] = e2;
        sx2 = xtime[sx];
        e22 = xtime[e2];
        e4 = xtime[e22];
        e8 = xtime[e4];
        me2 = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e22 ^ e4 ^ e8) << 24 ^ // E (14)
        (e2 ^ e8) << 16 ^ // 9
        (e2 ^ e4 ^ e8) << 8 ^ // D (13)
        (e2 ^ e22 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e2] = me2;
          imix[n][sx] = ime;
          me2 = me2 << 24 | me2 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e2 === 0) {
          e2 = ei = 1;
        } else {
          e2 = e22 ^ xtime[xtime[xtime[e22 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w2 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w2.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i2 = Nk; i2 < end; ++i2) {
        temp = w2[i2 - 1];
        if (i2 % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i2 % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w2[i2] = w2[i2 - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w2.slice(0);
        end = w2.length;
        for (var i2 = 0, wi = end - Nb; i2 < end; i2 += Nb, wi -= Nb) {
          if (i2 === 0 || i2 === end - Nb) {
            wnew[i2] = w2[wi];
            wnew[i2 + 1] = w2[wi + 3];
            wnew[i2 + 2] = w2[wi + 2];
            wnew[i2 + 3] = w2[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w2[wi + n];
              wnew[i2 + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w2 = wnew;
      }
      return w2;
    }
    function _updateBlock(w2, input, output, decrypt) {
      var Nr = w2.length / 4 - 1;
      var m0, m1, m2, m3, sub2;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub2 = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub2 = sbox;
      }
      var a2, b2, c2, d, a22, b22, c22;
      a2 = input[0] ^ w2[0];
      b2 = input[decrypt ? 3 : 1] ^ w2[1];
      c2 = input[2] ^ w2[2];
      d = input[decrypt ? 1 : 3] ^ w2[3];
      var i2 = 3;
      for (var round = 1; round < Nr; ++round) {
        a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m2[c2 >>> 8 & 255] ^ m3[d & 255] ^ w2[++i2];
        b22 = m0[b2 >>> 24] ^ m1[c2 >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a2 & 255] ^ w2[++i2];
        c22 = m0[c2 >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w2[++i2];
        d = m0[d >>> 24] ^ m1[a2 >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c2 & 255] ^ w2[++i2];
        a2 = a22;
        b2 = b22;
        c2 = c22;
      }
      output[0] = sub2[a2 >>> 24] << 24 ^ sub2[b2 >>> 16 & 255] << 16 ^ sub2[c2 >>> 8 & 255] << 8 ^ sub2[d & 255] ^ w2[++i2];
      output[decrypt ? 3 : 1] = sub2[b2 >>> 24] << 24 ^ sub2[c2 >>> 16 & 255] << 16 ^ sub2[d >>> 8 & 255] << 8 ^ sub2[a2 & 255] ^ w2[++i2];
      output[2] = sub2[c2 >>> 24] << 24 ^ sub2[d >>> 16 & 255] << 16 ^ sub2[a2 >>> 8 & 255] << 8 ^ sub2[b2 & 255] ^ w2[++i2];
      output[decrypt ? 1 : 3] = sub2[d >>> 24] << 24 ^ sub2[a2 >>> 16 & 255] << 16 ^ sub2[b2 >>> 8 & 255] << 8 ^ sub2[c2 & 255] ^ w2[++i2];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id, name) {
      oids[id] = name;
      oids[name] = id;
    }
    function _I_(id, name) {
      oids[id] = name;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    require_oids();
    var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i2 = 0; i2 < value.length; ++i2) {
          if (value[i2] !== void 0) {
            tmp.push(value[i2]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy2;
      if (forge.util.isArray(obj)) {
        copy2 = [];
        for (var i2 = 0; i2 < obj.length; ++i2) {
          copy2.push(asn1.copy(obj[i2], options));
        }
        return copy2;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy2 = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy2.bitStringContents = obj.bitStringContents;
      }
      return copy2;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i2 = 0; i2 < obj1.length; ++i2) {
          if (!asn1.equals(obj1[i2], obj2[i2])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b22 & 128;
      if (!longForm) {
        length2 = b22;
      } else {
        length2 = b2.getInt((b22 & 127) << 3);
      }
      return length2;
    };
    function _checkBufferLength(bytes, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length2;
      var longForm = b2 & 128;
      if (!longForm) {
        length2 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length2 = bytes.getInt(longFormBytes << 3);
      }
      if (length2 < 0) {
        throw new Error("Negative length: " + length2);
      }
      return length2;
    };
    asn1.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options);
      if (options.parseAllBytes && bytes.length() !== 0) {
        var error = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error.byteCount = byteCount;
        error.remaining = bytes.length();
        throw error;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes.length();
      var length2 = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length2 !== void 0 && length2 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = length2;
          throw error;
        }
        length2 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length2 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length2 > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length2, depth + 1, options));
            remaining -= start - bytes.length();
            length2 -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length2);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type === asn1.Type.BITSTRING && length2 > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length2 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length2 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length2 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length2 > 0; length2 -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length2);
          remaining -= length2;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i2]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i2 = 0; i2 < obj.value.length; ++i2) {
            value.putInt16(obj.value.charCodeAt(i2));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i2 = lenBytes.length - 1; i2 >= 0; --i2) {
          bytes.putByte(lenBytes.charCodeAt(i2));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i2 = 2; i2 < values.length; ++i2) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i2], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c2 = utc.charAt(10);
        var end = 10;
        if (c2 !== "+" && c2 !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c2 = utc.charAt(end);
        if (c2 === "+" || c2 === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c2 === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c2 = gentime.charAt(end);
      if (c2 === "+" || c2 === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c2 === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i2 = 0; i2 < format.length; ++i2) {
        if (format[i2].length < 2) {
          rval += "0";
        }
        rval += format[i2];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x2) {
      var rval = forge.util.createBuffer();
      if (x2 >= -128 && x2 < 128) {
        return rval.putSignedInt(x2, 8);
      }
      if (x2 >= -32768 && x2 < 32768) {
        return rval.putSignedInt(x2, 16);
      }
      if (x2 >= -8388608 && x2 < 8388608) {
        return rval.putSignedInt(x2, 24);
      }
      if (x2 >= -2147483648 && x2 < 2147483648) {
        return rval.putSignedInt(x2, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x2;
      throw error;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v2, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
        if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
          rval = true;
          if (v2.value && forge.util.isArray(v2.value)) {
            var j2 = 0;
            for (var i2 = 0; rval && i2 < v2.value.length; ++i2) {
              rval = v2.value[i2].optional || false;
              if (obj.value[j2]) {
                rval = asn1.validate(obj.value[j2], v2.value[i2], capture, errors);
                if (rval) {
                  ++j2;
                } else if (v2.value[i2].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v2.capture) {
              capture[v2.capture] = obj.value;
            }
            if (v2.captureAsn1) {
              capture[v2.captureAsn1] = obj;
            }
            if (v2.captureBitStringContents && "bitStringContents" in obj) {
              capture[v2.captureBitStringContents] = obj.bitStringContents;
            }
            if (v2.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v2.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v2.tagClass) {
          errors.push(
            "[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v2.type) {
          errors.push(
            "[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i2 = 0; i2 < level * indentation; ++i2) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub2 = "";
        for (var i2 = 0; i2 < obj.value.length; ++i2) {
          if (obj.value[i2] !== void 0) {
            subvalues += 1;
            sub2 += asn1.prettyPrint(obj.value[i2], level + 1, indentation);
            if (i2 + 1 < obj.value.length) {
              sub2 += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub2;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge.util.decodeUtf8(obj.value);
          } catch (e2) {
            if (e2.message === "URI malformed") {
              rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e2;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    module.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_md();
    require_util();
    var hmac = module.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i2 = 0; i2 < tmp.length; ++i2) {
              key.putByte(tmp[i2]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i2 = 0; i2 < keylen; ++i2) {
            var tmp = key.at(i2);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i2 = 0; i2 < tmp; ++i2) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/md5.js
var require_md52 = __commonJS({
  "node_modules/node-forge/lib/md5.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_md();
    require_util();
    var md5 = module.exports = forge.md5 = forge.md5 || {};
    forge.md.md5 = forge.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var bits2, carry = 0;
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          bits2 = md.fullMessageLength[i2] * 8 + carry;
          carry = bits2 / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits2 >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        _k[i2] = Math.floor(Math.abs(Math.sin(i2 + 1)) * 4294967296);
      }
      _initialized = true;
    }
    function _update(s2, w2, bytes) {
      var t, a2, b2, c2, d, f2, r2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d = s2.h3;
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2] = bytes.getInt32Le();
          f2 = d ^ b2 & (c2 ^ d);
          t = a2 + f2 + _k[i2] + w2[i2];
          r2 = _r[i2];
          a2 = d;
          d = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 32; ++i2) {
          f2 = c2 ^ d & (b2 ^ c2);
          t = a2 + f2 + _k[i2] + w2[_g[i2]];
          r2 = _r[i2];
          a2 = d;
          d = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 48; ++i2) {
          f2 = b2 ^ c2 ^ d;
          t = a2 + f2 + _k[i2] + w2[_g[i2]];
          r2 = _r[i2];
          a2 = d;
          d = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        for (; i2 < 64; ++i2) {
          f2 = c2 ^ (b2 | ~d);
          t = a2 + f2 + _k[i2] + w2[_g[i2]];
          r2 = _r[i2];
          a2 = d;
          d = c2;
          c2 = b2;
          b2 += t << r2 | t >>> 32 - r2;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    var pem = module.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i2 = 0; i2 < msg.headers.length; ++i2) {
          rval += foldHeader(msg.headers[i2]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match2;
      while (true) {
        match2 = rMessage.exec(str);
        if (!match2) {
          break;
        }
        var type = match2[1];
        if (type === "NEW CERTIFICATE REQUEST") {
          type = "CERTIFICATE REQUEST";
        }
        var msg = {
          type,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match2[3])
        };
        rval.push(msg);
        if (!match2[2]) {
          continue;
        }
        var lines = match2[2].split(rCRLF);
        var li = 0;
        while (match2 && li < lines.length) {
          var line2 = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next2 = lines[nl];
            if (!/\s/.test(next2[0])) {
              break;
            }
            line2 += next2;
            li = nl;
          }
          match2 = line2.match(rHeader);
          if (match2) {
            var header = { name: match2[1], values: [] };
            var values = match2[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match2, $1) {
        return " " + $1;
      };
      for (var i2 = 0; i2 < header.values.length; ++i2) {
        values.push(header.values[i2].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length2 = 0;
      var candidate = -1;
      for (var i2 = 0; i2 < rval.length; ++i2, ++length2) {
        if (length2 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length2 = i2 - candidate - 1;
          candidate = -1;
          ++i2;
        } else if (rval[i2] === " " || rval[i2] === "	" || rval[i2] === ",") {
          candidate = i2;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name, mode) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name, mode);
      };
      forge.cipher.registerAlgorithm(name, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j2 = 0; j2 < iterations; j2++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i2 = 0; i2 < shifts.length; ++i2) {
          if (shifts[i2]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j2 = 0; j2 < iterations; j2 += 3) {
        var endloop = looping[j2 + 1];
        var loopinc = looping[j2 + 2];
        for (var i2 = looping[j2]; i2 != endloop; i2 += loopinc) {
          var right1 = right ^ keys[i2];
          var right2 = (right >>> 4 | right << 28) ^ keys[i2 + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto2;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto2 = require_crypto_browserify();
    }
    module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s2, c2, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s2 = Buffer.from(s2, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s2, c2, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s2, c2, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s2, c2, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s2, c2, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r2 = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i2 = 1; i2 <= len; ++i2) {
          prf.start(null, null);
          prf.update(s2);
          prf.update(forge.util.int32ToBytes(i2));
          xor = u_c1 = prf.digest().getBytes();
          for (var j2 = 2; j2 <= c2; ++j2) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i2 < len ? xor : xor.substr(0, r2);
        }
        return dk;
      }
      var i2 = 1, j2;
      function outer() {
        if (i2 > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s2);
        prf.update(forge.util.int32ToBytes(i2));
        xor = u_c1 = prf.digest().getBytes();
        j2 = 2;
        inner();
      }
      function inner() {
        if (j2 <= c2) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j2;
          return forge.util.setImmediate(inner);
        }
        dk += i2 < len ? xor : xor.substr(0, r2);
        ++i2;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_md();
    require_util();
    var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next2, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next2 = md.fullMessageLength[i2 + 1] * 8;
          carry = next2 / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next2 >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s2, w2, bytes) {
      var t1, t2, s0, s1, ch, maj, i2, a2, b2, c2, d, e2, f2, g2, h;
      var len = bytes.length();
      while (len >= 64) {
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2] = bytes.getInt32();
        }
        for (; i2 < 64; ++i2) {
          t1 = w2[i2 - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w2[i2 - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w2[i2] = t1 + w2[i2 - 7] + t2 + w2[i2 - 16] | 0;
        }
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d = s2.h3;
        e2 = s2.h4;
        f2 = s2.h5;
        g2 = s2.h6;
        h = s2.h7;
        for (i2 = 0; i2 < 64; ++i2) {
          s1 = (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
          ch = g2 ^ e2 & (f2 ^ g2);
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj = a2 & b2 | c2 & (a2 ^ b2);
          t1 = h + s1 + ch + _k[i2] + w2[i2];
          t2 = s0 + maj;
          h = g2;
          g2 = f2;
          f2 = e2;
          e2 = d + t1 >>> 0;
          d = c2;
          c2 = b2;
          b2 = a2;
          a2 = t1 + t2 >>> 0;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d | 0;
        s2.h4 = s2.h4 + e2 | 0;
        s2.h5 = s2.h5 + f2 | 0;
        s2.h6 = s2.h6 + g2 | 0;
        s2.h7 = s2.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto_browserify();
    }
    var prng = module.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i2 = 0; i2 < 32; ++i2) {
        pools[i2] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count) {
            return callback(null, b2.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge.util.createBuffer();
        while (b2.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k2 = 0; k2 < 32; ++k2) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k2].digest().getBytes());
            ctx.pools[k2].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b2 = forge.util.createBuffer();
        if (getRandomValues) {
          while (b2.length() < needed) {
            var count = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i3 = 0; i3 < entropy.length; ++i3) {
                b2.putInt32(entropy[i3]);
              }
            } catch (e2) {
              if (!(typeof QuotaExceededError !== "undefined" && e2 instanceof QuotaExceededError)) {
                throw e2;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi, lo, next2;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i3 = 0; i3 < 3; ++i3) {
              next2 = seed >>> (i3 << 3);
              next2 ^= Math.floor(Math.random() * 256);
              b2.putByte(next2 & 255);
            }
          }
        }
        return b2.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e2) {
            callback(e2);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count = bytes.length;
        for (var i3 = 0; i3 < count; ++i3) {
          ctx.pools[ctx.pool].update(bytes.substr(i3, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i3, n) {
        var bytes = "";
        for (var x2 = 0; x2 < n; x2 += 8) {
          bytes += String.fromCharCode(i3 >> x2 & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e2) {
              var data = e2.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e2) {
            var data = e2.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e2) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e2) {
              _ctx.collectInt(e2.clientX, 16);
              _ctx.collectInt(e2.clientY, 16);
            });
            jQuery2().keypress(function(e2) {
              _ctx.collectInt(e2.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s2 = [1, 2, 3, 5];
    var rol = function(word, bits2) {
      return word << bits2 & 65535 | (word & 65535) >> 16 - bits2;
    };
    var ror = function(word, bits2) {
      return (word & 65535) >> bits2 | word << 16 - bits2 & 65535;
    };
    module.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L2 = key;
      var T2 = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i2;
      for (i2 = T2; i2 < 128; i2++) {
        L2.putByte(piTable[L2.at(i2 - 1) + L2.at(i2 - T2) & 255]);
      }
      L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
      for (i2 = 127 - T8; i2 >= 0; i2--) {
        L2.setAt(i2, piTable[L2.at(i2 + 1) ^ L2.at(i2 + T8)]);
      }
      return L2;
    };
    var createCipher = function(key, bits2, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i2, j2, K2 = [];
      key = forge.rc2.expandKey(key, bits2);
      for (i2 = 0; i2 < 64; i2++) {
        K2.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            R2[i2] = rol(R2[i2], s2[i2]);
            j2++;
          }
        };
        mashRound = function(R2) {
          for (i2 = 0; i2 < 4; i2++) {
            R2[i2] += K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] = ror(R2[i2], s2[i2]);
            R2[i2] -= K2[j2] + (R2[(i2 + 3) % 4] & R2[(i2 + 2) % 4]) + (~R2[(i2 + 3) % 4] & R2[(i2 + 1) % 4]);
            j2--;
          }
        };
        mashRound = function(R2) {
          for (i2 = 3; i2 >= 0; i2--) {
            R2[i2] -= K2[R2[(i2 + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R2 = [];
        for (i2 = 0; i2 < 4; i2++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R2.push(val & 65535);
        }
        j2 = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R2);
          }
        }
        for (i2 = 0; i2 < 4; i2++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R2[i2]);
            } else {
              R2[i2] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R2[i2]);
        }
      };
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits2) {
      return createCipher(key, bits2, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    module.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c2) {
      this.data = [];
      if (a2 != null)
        if ("number" == typeof a2) this.fromNumber(a2, b2, c2);
        else if (b2 == null && "string" != typeof a2) this.fromString(a2, 256);
        else this.fromString(a2, b2);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i2, x2, w2, j2, c2, n) {
      while (--n >= 0) {
        var v2 = x2 * this.data[i2++] + w2.data[j2] + c2;
        c2 = Math.floor(v2 / 67108864);
        w2.data[j2++] = v2 & 67108863;
      }
      return c2;
    }
    function am2(i2, x2, w2, j2, c2, n) {
      var xl = x2 & 32767, xh = x2 >> 15;
      while (--n >= 0) {
        var l2 = this.data[i2] & 32767;
        var h = this.data[i2++] >> 15;
        var m2 = xh * l2 + h * xl;
        l2 = xl * l2 + ((m2 & 32767) << 15) + w2.data[j2] + (c2 & 1073741823);
        c2 = (l2 >>> 30) + (m2 >>> 15) + xh * h + (c2 >>> 30);
        w2.data[j2++] = l2 & 1073741823;
      }
      return c2;
    }
    function am3(i2, x2, w2, j2, c2, n) {
      var xl = x2 & 16383, xh = x2 >> 14;
      while (--n >= 0) {
        var l2 = this.data[i2] & 16383;
        var h = this.data[i2++] >> 14;
        var m2 = xh * l2 + h * xl;
        l2 = xl * l2 + ((m2 & 16383) << 14) + w2.data[j2] + c2;
        c2 = (l2 >> 28) + (m2 >> 14) + xh * h;
        w2.data[j2++] = l2 & 268435455;
      }
      return c2;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s2, i2) {
      var c2 = BI_RC[s2.charCodeAt(i2)];
      return c2 == null ? -1 : c2;
    }
    function bnpCopyTo(r2) {
      for (var i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2] = this.data[i2];
      r2.t = this.t;
      r2.s = this.s;
    }
    function bnpFromInt(x2) {
      this.t = 1;
      this.s = x2 < 0 ? -1 : 0;
      if (x2 > 0) this.data[0] = x2;
      else if (x2 < -1) this.data[0] = x2 + this.DV;
      else this.t = 0;
    }
    function nbv(i2) {
      var r2 = nbi();
      r2.fromInt(i2);
      return r2;
    }
    function bnpFromString(s2, b2) {
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 256) k2 = 8;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else {
        this.fromRadix(s2, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i2 = s2.length, mi = false, sh = 0;
      while (--i2 >= 0) {
        var x2 = k2 == 8 ? s2[i2] & 255 : intAt(s2, i2);
        if (x2 < 0) {
          if (s2.charAt(i2) == "-") mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x2;
        else if (sh + k2 > this.DB) {
          this.data[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x2 >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x2 << sh;
        sh += k2;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k2 == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c2 = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c2) --this.t;
    }
    function bnToString(b2) {
      if (this.s < 0) return "-" + this.negate().toString(b2);
      var k2;
      if (b2 == 16) k2 = 4;
      else if (b2 == 8) k2 = 3;
      else if (b2 == 2) k2 = 1;
      else if (b2 == 32) k2 = 5;
      else if (b2 == 4) k2 = 2;
      else return this.toRadix(b2);
      var km = (1 << k2) - 1, d, m2 = false, r2 = "", i2 = this.t;
      var p2 = this.DB - i2 * this.DB % k2;
      if (i2-- > 0) {
        if (p2 < this.DB && (d = this.data[i2] >> p2) > 0) {
          m2 = true;
          r2 = int2char(d);
        }
        while (i2 >= 0) {
          if (p2 < k2) {
            d = (this.data[i2] & (1 << p2) - 1) << k2 - p2;
            d |= this.data[--i2] >> (p2 += this.DB - k2);
          } else {
            d = this.data[i2] >> (p2 -= k2) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if (d > 0) m2 = true;
          if (m2) r2 += int2char(d);
        }
      }
      return m2 ? r2 : "0";
    }
    function bnNegate() {
      var r2 = nbi();
      BigInteger.ZERO.subTo(this, r2);
      return r2;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a2) {
      var r2 = this.s - a2.s;
      if (r2 != 0) return r2;
      var i2 = this.t;
      r2 = i2 - a2.t;
      if (r2 != 0) return this.s < 0 ? -r2 : r2;
      while (--i2 >= 0) if ((r2 = this.data[i2] - a2.data[i2]) != 0) return r2;
      return 0;
    }
    function nbits(x2) {
      var r2 = 1, t;
      if ((t = x2 >>> 16) != 0) {
        x2 = t;
        r2 += 16;
      }
      if ((t = x2 >> 8) != 0) {
        x2 = t;
        r2 += 8;
      }
      if ((t = x2 >> 4) != 0) {
        x2 = t;
        r2 += 4;
      }
      if ((t = x2 >> 2) != 0) {
        x2 = t;
        r2 += 2;
      }
      if ((t = x2 >> 1) != 0) {
        x2 = t;
        r2 += 1;
      }
      return r2;
    }
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r2) {
      var i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) r2.data[i2 + n] = this.data[i2];
      for (i2 = n - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.t = this.t + n;
      r2.s = this.s;
    }
    function bnpDRShiftTo(n, r2) {
      for (var i2 = n; i2 < this.t; ++i2) r2.data[i2 - n] = this.data[i2];
      r2.t = Math.max(this.t - n, 0);
      r2.s = this.s;
    }
    function bnpLShiftTo(n, r2) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c2 = this.s << bs & this.DM, i2;
      for (i2 = this.t - 1; i2 >= 0; --i2) {
        r2.data[i2 + ds + 1] = this.data[i2] >> cbs | c2;
        c2 = (this.data[i2] & bm) << bs;
      }
      for (i2 = ds - 1; i2 >= 0; --i2) r2.data[i2] = 0;
      r2.data[ds] = c2;
      r2.t = this.t + ds + 1;
      r2.s = this.s;
      r2.clamp();
    }
    function bnpRShiftTo(n, r2) {
      r2.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r2.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r2.data[0] = this.data[ds] >> bs;
      for (var i2 = ds + 1; i2 < this.t; ++i2) {
        r2.data[i2 - ds - 1] |= (this.data[i2] & bm) << cbs;
        r2.data[i2 - ds] = this.data[i2] >> bs;
      }
      if (bs > 0) r2.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r2.t = this.t - ds;
      r2.clamp();
    }
    function bnpSubTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] - a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 -= a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 -= a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 -= a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 < -1) r2.data[i2++] = this.DV + c2;
      else if (c2 > 0) r2.data[i2++] = c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnpMultiplyTo(a2, r2) {
      var x2 = this.abs(), y2 = a2.abs();
      var i2 = x2.t;
      r2.t = i2 + y2.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < y2.t; ++i2) r2.data[i2 + x2.t] = x2.am(0, y2.data[i2], r2, i2, 0, x2.t);
      r2.s = 0;
      r2.clamp();
      if (this.s != a2.s) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnpSquareTo(r2) {
      var x2 = this.abs();
      var i2 = r2.t = 2 * x2.t;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = 0; i2 < x2.t - 1; ++i2) {
        var c2 = x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
        if ((r2.data[i2 + x2.t] += x2.am(i2 + 1, 2 * x2.data[i2], r2, 2 * i2 + 1, c2, x2.t - i2 - 1)) >= x2.DV) {
          r2.data[i2 + x2.t] -= x2.DV;
          r2.data[i2 + x2.t + 1] = 1;
        }
      }
      if (r2.t > 0) r2.data[r2.t - 1] += x2.am(i2, x2.data[i2], r2, 2 * i2, 0, 1);
      r2.s = 0;
      r2.clamp();
    }
    function bnpDivRemTo(m2, q2, r2) {
      var pm = m2.abs();
      if (pm.t <= 0) return;
      var pt2 = this.abs();
      if (pt2.t < pm.t) {
        if (q2 != null) q2.fromInt(0);
        if (r2 != null) this.copyTo(r2);
        return;
      }
      if (r2 == null) r2 = nbi();
      var y2 = nbi(), ts = this.s, ms = m2.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt2.lShiftTo(nsh, r2);
      } else {
        pm.copyTo(y2);
        pt2.copyTo(r2);
      }
      var ys = y2.t;
      var y0 = y2.data[ys - 1];
      if (y0 == 0) return;
      var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y2.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e2 = 1 << this.F2;
      var i2 = r2.t, j2 = i2 - ys, t = q2 == null ? nbi() : q2;
      y2.dlShiftTo(j2, t);
      if (r2.compareTo(t) >= 0) {
        r2.data[r2.t++] = 1;
        r2.subTo(t, r2);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y2, y2);
      while (y2.t < ys) y2.data[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd = r2.data[--i2] == y0 ? this.DM : Math.floor(r2.data[i2] * d1 + (r2.data[i2 - 1] + e2) * d2);
        if ((r2.data[i2] += y2.am(0, qd, r2, j2, 0, ys)) < qd) {
          y2.dlShiftTo(j2, t);
          r2.subTo(t, r2);
          while (r2.data[i2] < --qd) r2.subTo(t, r2);
        }
      }
      if (q2 != null) {
        r2.drShiftTo(ys, q2);
        if (ts != ms) BigInteger.ZERO.subTo(q2, q2);
      }
      r2.t = ys;
      r2.clamp();
      if (nsh > 0) r2.rShiftTo(nsh, r2);
      if (ts < 0) BigInteger.ZERO.subTo(r2, r2);
    }
    function bnMod(a2) {
      var r2 = nbi();
      this.abs().divRemTo(a2, null, r2);
      if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) a2.subTo(r2, r2);
      return r2;
    }
    function Classic(m2) {
      this.m = m2;
    }
    function cConvert(x2) {
      if (x2.s < 0 || x2.compareTo(this.m) >= 0) return x2.mod(this.m);
      else return x2;
    }
    function cRevert(x2) {
      return x2;
    }
    function cReduce(x2) {
      x2.divRemTo(this.m, null, x2);
    }
    function cMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    function cSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x2 = this.data[0];
      if ((x2 & 1) == 0) return 0;
      var y2 = x2 & 3;
      y2 = y2 * (2 - (x2 & 15) * y2) & 15;
      y2 = y2 * (2 - (x2 & 255) * y2) & 255;
      y2 = y2 * (2 - ((x2 & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x2 * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    function montConvert(x2) {
      var r2 = nbi();
      x2.abs().dlShiftTo(this.m.t, r2);
      r2.divRemTo(this.m, null, r2);
      if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r2, r2);
      return r2;
    }
    function montRevert(x2) {
      var r2 = nbi();
      x2.copyTo(r2);
      this.reduce(r2);
      return r2;
    }
    function montReduce(x2) {
      while (x2.t <= this.mt2)
        x2.data[x2.t++] = 0;
      for (var i2 = 0; i2 < this.m.t; ++i2) {
        var j2 = x2.data[i2] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x2.data[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
        j2 = i2 + this.m.t;
        x2.data[j2] += this.m.am(0, u0, x2, i2, 0, this.m.t);
        while (x2.data[j2] >= x2.DV) {
          x2.data[j2] -= x2.DV;
          x2.data[++j2]++;
        }
      }
      x2.clamp();
      x2.drShiftTo(this.m.t, x2);
      if (x2.compareTo(this.m) >= 0) x2.subTo(this.m, x2);
    }
    function montSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function montMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e2, z2) {
      if (e2 > 4294967295 || e2 < 1) return BigInteger.ONE;
      var r2 = nbi(), r22 = nbi(), g2 = z2.convert(this), i2 = nbits(e2) - 1;
      g2.copyTo(r2);
      while (--i2 >= 0) {
        z2.sqrTo(r2, r22);
        if ((e2 & 1 << i2) > 0) z2.mulTo(r22, g2, r2);
        else {
          var t = r2;
          r2 = r22;
          r22 = t;
        }
      }
      return z2.revert(r2);
    }
    function bnModPowInt(e2, m2) {
      var z2;
      if (e2 < 256 || m2.isEven()) z2 = new Classic(m2);
      else z2 = new Montgomery(m2);
      return this.exp(e2, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r2 = nbi();
      this.copyTo(r2);
      return r2;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r2) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r2));
    }
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix(b2) {
      if (b2 == null) b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36) return "0";
      var cs = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs);
      var d = nbv(a2), y2 = nbi(), z2 = nbi(), r2 = "";
      this.divRemTo(d, y2, z2);
      while (y2.signum() > 0) {
        r2 = (a2 + z2.intValue()).toString(b2).substr(1) + r2;
        y2.divRemTo(d, y2, z2);
      }
      return z2.intValue().toString(b2) + r2;
    }
    function bnpFromRadix(s2, b2) {
      this.fromInt(0);
      if (b2 == null) b2 = 10;
      var cs = this.chunkSize(b2);
      var d = Math.pow(b2, cs), mi = false, j2 = 0, w2 = 0;
      for (var i2 = 0; i2 < s2.length; ++i2) {
        var x2 = intAt(s2, i2);
        if (x2 < 0) {
          if (s2.charAt(i2) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w2 = b2 * w2 + x2;
        if (++j2 >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w2, 0);
          j2 = 0;
          w2 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b2, j2));
        this.dAddOffset(w2, 0);
      }
      if (mi) BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a2, b2, c2) {
      if ("number" == typeof b2) {
        if (a2 < 2) this.fromInt(1);
        else {
          this.fromNumber(a2, c2);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2) this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x2 = new Array(), t = a2 & 7;
        x2.length = (a2 >> 3) + 1;
        b2.nextBytes(x2);
        if (t > 0) x2[0] &= (1 << t) - 1;
        else x2[0] = 0;
        this.fromString(x2, 256);
      }
    }
    function bnToByteArray() {
      var i2 = this.t, r2 = new Array();
      r2[0] = this.s;
      var p2 = this.DB - i2 * this.DB % 8, d, k2 = 0;
      if (i2-- > 0) {
        if (p2 < this.DB && (d = this.data[i2] >> p2) != (this.s & this.DM) >> p2)
          r2[k2++] = d | this.s << this.DB - p2;
        while (i2 >= 0) {
          if (p2 < 8) {
            d = (this.data[i2] & (1 << p2) - 1) << 8 - p2;
            d |= this.data[--i2] >> (p2 += this.DB - 8);
          } else {
            d = this.data[i2] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i2;
            }
          }
          if ((d & 128) != 0) d |= -256;
          if (k2 == 0 && (this.s & 128) != (d & 128)) ++k2;
          if (k2 > 0 || d != this.s) r2[k2++] = d;
        }
      }
      return r2;
    }
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    function bnpBitwiseTo(a2, op, r2) {
      var i2, f2, m2 = Math.min(a2.t, this.t);
      for (i2 = 0; i2 < m2; ++i2) r2.data[i2] = op(this.data[i2], a2.data[i2]);
      if (a2.t < this.t) {
        f2 = a2.s & this.DM;
        for (i2 = m2; i2 < this.t; ++i2) r2.data[i2] = op(this.data[i2], f2);
        r2.t = this.t;
      } else {
        f2 = this.s & this.DM;
        for (i2 = m2; i2 < a2.t; ++i2) r2.data[i2] = op(f2, a2.data[i2]);
        r2.t = a2.t;
      }
      r2.s = op(this.s, a2.s);
      r2.clamp();
    }
    function op_and(x2, y2) {
      return x2 & y2;
    }
    function bnAnd(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_and, r2);
      return r2;
    }
    function op_or(x2, y2) {
      return x2 | y2;
    }
    function bnOr(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_or, r2);
      return r2;
    }
    function op_xor(x2, y2) {
      return x2 ^ y2;
    }
    function bnXor(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_xor, r2);
      return r2;
    }
    function op_andnot(x2, y2) {
      return x2 & ~y2;
    }
    function bnAndNot(a2) {
      var r2 = nbi();
      this.bitwiseTo(a2, op_andnot, r2);
      return r2;
    }
    function bnNot() {
      var r2 = nbi();
      for (var i2 = 0; i2 < this.t; ++i2) r2.data[i2] = this.DM & ~this.data[i2];
      r2.t = this.t;
      r2.s = ~this.s;
      return r2;
    }
    function bnShiftLeft(n) {
      var r2 = nbi();
      if (n < 0) this.rShiftTo(-n, r2);
      else this.lShiftTo(n, r2);
      return r2;
    }
    function bnShiftRight(n) {
      var r2 = nbi();
      if (n < 0) this.lShiftTo(-n, r2);
      else this.rShiftTo(n, r2);
      return r2;
    }
    function lbit(x2) {
      if (x2 == 0) return -1;
      var r2 = 0;
      if ((x2 & 65535) == 0) {
        x2 >>= 16;
        r2 += 16;
      }
      if ((x2 & 255) == 0) {
        x2 >>= 8;
        r2 += 8;
      }
      if ((x2 & 15) == 0) {
        x2 >>= 4;
        r2 += 4;
      }
      if ((x2 & 3) == 0) {
        x2 >>= 2;
        r2 += 2;
      }
      if ((x2 & 1) == 0) ++r2;
      return r2;
    }
    function bnGetLowestSetBit() {
      for (var i2 = 0; i2 < this.t; ++i2)
        if (this.data[i2] != 0) return i2 * this.DB + lbit(this.data[i2]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit(x2) {
      var r2 = 0;
      while (x2 != 0) {
        x2 &= x2 - 1;
        ++r2;
      }
      return r2;
    }
    function bnBitCount() {
      var r2 = 0, x2 = this.s & this.DM;
      for (var i2 = 0; i2 < this.t; ++i2) r2 += cbit(this.data[i2] ^ x2);
      return r2;
    }
    function bnTestBit(n) {
      var j2 = Math.floor(n / this.DB);
      if (j2 >= this.t) return this.s != 0;
      return (this.data[j2] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r2 = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r2, op, r2);
      return r2;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a2, r2) {
      var i2 = 0, c2 = 0, m2 = Math.min(a2.t, this.t);
      while (i2 < m2) {
        c2 += this.data[i2] + a2.data[i2];
        r2.data[i2++] = c2 & this.DM;
        c2 >>= this.DB;
      }
      if (a2.t < this.t) {
        c2 += a2.s;
        while (i2 < this.t) {
          c2 += this.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += this.s;
      } else {
        c2 += this.s;
        while (i2 < a2.t) {
          c2 += a2.data[i2];
          r2.data[i2++] = c2 & this.DM;
          c2 >>= this.DB;
        }
        c2 += a2.s;
      }
      r2.s = c2 < 0 ? -1 : 0;
      if (c2 > 0) r2.data[i2++] = c2;
      else if (c2 < -1) r2.data[i2++] = this.DV + c2;
      r2.t = i2;
      r2.clamp();
    }
    function bnAdd(a2) {
      var r2 = nbi();
      this.addTo(a2, r2);
      return r2;
    }
    function bnSubtract(a2) {
      var r2 = nbi();
      this.subTo(a2, r2);
      return r2;
    }
    function bnMultiply(a2) {
      var r2 = nbi();
      this.multiplyTo(a2, r2);
      return r2;
    }
    function bnDivide(a2) {
      var r2 = nbi();
      this.divRemTo(a2, r2, null);
      return r2;
    }
    function bnRemainder(a2) {
      var r2 = nbi();
      this.divRemTo(a2, null, r2);
      return r2;
    }
    function bnDivideAndRemainder(a2) {
      var q2 = nbi(), r2 = nbi();
      this.divRemTo(a2, q2, r2);
      return new Array(q2, r2);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w2) {
      if (n == 0) return;
      while (this.t <= w2) this.data[this.t++] = 0;
      this.data[w2] += n;
      while (this.data[w2] >= this.DV) {
        this.data[w2] -= this.DV;
        if (++w2 >= this.t) this.data[this.t++] = 0;
        ++this.data[w2];
      }
    }
    function NullExp() {
    }
    function nNop(x2) {
      return x2;
    }
    function nMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
    }
    function nSqrTo(x2, r2) {
      x2.squareTo(r2);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e2) {
      return this.exp(e2, new NullExp());
    }
    function bnpMultiplyLowerTo(a2, n, r2) {
      var i2 = Math.min(this.t + a2.t, n);
      r2.s = 0;
      r2.t = i2;
      while (i2 > 0) r2.data[--i2] = 0;
      var j2;
      for (j2 = r2.t - this.t; i2 < j2; ++i2) r2.data[i2 + this.t] = this.am(0, a2.data[i2], r2, i2, 0, this.t);
      for (j2 = Math.min(a2.t, n); i2 < j2; ++i2) this.am(0, a2.data[i2], r2, i2, 0, n - i2);
      r2.clamp();
    }
    function bnpMultiplyUpperTo(a2, n, r2) {
      --n;
      var i2 = r2.t = this.t + a2.t - n;
      r2.s = 0;
      while (--i2 >= 0) r2.data[i2] = 0;
      for (i2 = Math.max(n - this.t, 0); i2 < a2.t; ++i2)
        r2.data[this.t + i2 - n] = this.am(n - i2, a2.data[i2], r2, 0, 0, this.t + i2 - n);
      r2.clamp();
      r2.drShiftTo(1, r2);
    }
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    function barrettConvert(x2) {
      if (x2.s < 0 || x2.t > 2 * this.m.t) return x2.mod(this.m);
      else if (x2.compareTo(this.m) < 0) return x2;
      else {
        var r2 = nbi();
        x2.copyTo(r2);
        this.reduce(r2);
        return r2;
      }
    }
    function barrettRevert(x2) {
      return x2;
    }
    function barrettReduce(x2) {
      x2.drShiftTo(this.m.t - 1, this.r2);
      if (x2.t > this.m.t + 1) {
        x2.t = this.m.t + 1;
        x2.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x2.compareTo(this.r2) < 0) x2.dAddOffset(1, this.m.t + 1);
      x2.subTo(this.r2, x2);
      while (x2.compareTo(this.m) >= 0) x2.subTo(this.m, x2);
    }
    function barrettSqrTo(x2, r2) {
      x2.squareTo(r2);
      this.reduce(r2);
    }
    function barrettMulTo(x2, y2, r2) {
      x2.multiplyTo(y2, r2);
      this.reduce(r2);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e2, m2) {
      var i2 = e2.bitLength(), k2, r2 = nbv(1), z2;
      if (i2 <= 0) return r2;
      else if (i2 < 18) k2 = 1;
      else if (i2 < 48) k2 = 3;
      else if (i2 < 144) k2 = 4;
      else if (i2 < 768) k2 = 5;
      else k2 = 6;
      if (i2 < 8)
        z2 = new Classic(m2);
      else if (m2.isEven())
        z2 = new Barrett(m2);
      else
        z2 = new Montgomery(m2);
      var g2 = new Array(), n = 3, k1 = k2 - 1, km = (1 << k2) - 1;
      g2[1] = z2.convert(this);
      if (k2 > 1) {
        var g22 = nbi();
        z2.sqrTo(g2[1], g22);
        while (n <= km) {
          g2[n] = nbi();
          z2.mulTo(g22, g2[n - 2], g2[n]);
          n += 2;
        }
      }
      var j2 = e2.t - 1, w2, is1 = true, r22 = nbi(), t;
      i2 = nbits(e2.data[j2]) - 1;
      while (j2 >= 0) {
        if (i2 >= k1) w2 = e2.data[j2] >> i2 - k1 & km;
        else {
          w2 = (e2.data[j2] & (1 << i2 + 1) - 1) << k1 - i2;
          if (j2 > 0) w2 |= e2.data[j2 - 1] >> this.DB + i2 - k1;
        }
        n = k2;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n;
        }
        if ((i2 -= n) < 0) {
          i2 += this.DB;
          --j2;
        }
        if (is1) {
          g2[w2].copyTo(r2);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r2, r22);
            z2.sqrTo(r22, r2);
            n -= 2;
          }
          if (n > 0) z2.sqrTo(r2, r22);
          else {
            t = r2;
            r2 = r22;
            r22 = t;
          }
          z2.mulTo(r22, g2[w2], r2);
        }
        while (j2 >= 0 && (e2.data[j2] & 1 << i2) == 0) {
          z2.sqrTo(r2, r22);
          t = r2;
          r2 = r22;
          r22 = t;
          if (--i2 < 0) {
            i2 = this.DB - 1;
            --j2;
          }
        }
      }
      return z2.revert(r2);
    }
    function bnGCD(a2) {
      var x2 = this.s < 0 ? this.negate() : this.clone();
      var y2 = a2.s < 0 ? a2.negate() : a2.clone();
      if (x2.compareTo(y2) < 0) {
        var t = x2;
        x2 = y2;
        y2 = t;
      }
      var i2 = x2.getLowestSetBit(), g2 = y2.getLowestSetBit();
      if (g2 < 0) return x2;
      if (i2 < g2) g2 = i2;
      if (g2 > 0) {
        x2.rShiftTo(g2, x2);
        y2.rShiftTo(g2, y2);
      }
      while (x2.signum() > 0) {
        if ((i2 = x2.getLowestSetBit()) > 0) x2.rShiftTo(i2, x2);
        if ((i2 = y2.getLowestSetBit()) > 0) y2.rShiftTo(i2, y2);
        if (x2.compareTo(y2) >= 0) {
          x2.subTo(y2, x2);
          x2.rShiftTo(1, x2);
        } else {
          y2.subTo(x2, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g2 > 0) y2.lShiftTo(g2, y2);
      return y2;
    }
    function bnpModInt(n) {
      if (n <= 0) return 0;
      var d = this.DV % n, r2 = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0) r2 = this.data[0] % n;
        else for (var i2 = this.t - 1; i2 >= 0; --i2) r2 = (d * r2 + this.data[i2]) % n;
      return r2;
    }
    function bnModInverse(m2) {
      var ac = m2.isEven();
      if (this.isEven() && ac || m2.signum() == 0) return BigInteger.ZERO;
      var u2 = m2.clone(), v2 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c2 = nbv(0), d = nbv(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m2, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven()) b2.subTo(m2, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac) {
            if (!c2.isEven() || !d.isEven()) {
              c2.addTo(this, c2);
              d.subTo(m2, d);
            }
            c2.rShiftTo(1, c2);
          } else if (!d.isEven()) d.subTo(m2, d);
          d.rShiftTo(1, d);
        }
        if (u2.compareTo(v2) >= 0) {
          u2.subTo(v2, u2);
          if (ac) a2.subTo(c2, a2);
          b2.subTo(d, b2);
        } else {
          v2.subTo(u2, v2);
          if (ac) c2.subTo(a2, c2);
          d.subTo(b2, d);
        }
      }
      if (v2.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d.compareTo(m2) >= 0) return d.subtract(m2);
      if (d.signum() < 0) d.addTo(m2, d);
      else return d;
      if (d.signum() < 0) return d.add(m2);
      else return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i2, x2 = this.abs();
      if (x2.t == 1 && x2.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i2 = 0; i2 < lowprimes.length; ++i2)
          if (x2.data[0] == lowprimes[i2]) return true;
        return false;
      }
      if (x2.isEven()) return false;
      i2 = 1;
      while (i2 < lowprimes.length) {
        var m2 = lowprimes[i2], j2 = i2 + 1;
        while (j2 < lowprimes.length && m2 < lplim) m2 *= lowprimes[j2++];
        m2 = x2.modInt(m2);
        while (i2 < j2) if (m2 % lowprimes[i2++] == 0) return false;
      }
      return x2.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k2 = n1.getLowestSetBit();
      if (k2 <= 0) return false;
      var r2 = n1.shiftRight(k2);
      var prng = bnGetPrng();
      var a2;
      for (var i2 = 0; i2 < t; ++i2) {
        do {
          a2 = new BigInteger(this.bitLength(), prng);
        } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n1) >= 0);
        var y2 = a2.modPow(r2, this);
        if (y2.compareTo(BigInteger.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k2 && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y2.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: function(x2) {
          for (var i2 = 0; i2 < x2.length; ++i2) {
            x2[i2] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha12 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_md();
    require_util();
    var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next2, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next2 = md.fullMessageLength[i2 + 1] * 8;
          carry = next2 / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next2 >>> 0;
        }
        finalBlock.putInt32(bits2);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s2, w2, bytes) {
      var t, a2, b2, c2, d, e2, f2, i2;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s2.h0;
        b2 = s2.h1;
        c2 = s2.h2;
        d = s2.h3;
        e2 = s2.h4;
        for (i2 = 0; i2 < 16; ++i2) {
          t = bytes.getInt32();
          w2[i2] = t;
          f2 = d ^ b2 & (c2 ^ d);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 20; ++i2) {
          t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
          t = t << 1 | t >>> 31;
          w2[i2] = t;
          f2 = d ^ b2 & (c2 ^ d);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1518500249 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 32; ++i2) {
          t = w2[i2 - 3] ^ w2[i2 - 8] ^ w2[i2 - 14] ^ w2[i2 - 16];
          t = t << 1 | t >>> 31;
          w2[i2] = t;
          f2 = b2 ^ c2 ^ d;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 40; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f2 = b2 ^ c2 ^ d;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 1859775393 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 60; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f2 = b2 & c2 | d & (b2 ^ c2);
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 2400959708 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i2 < 80; ++i2) {
          t = w2[i2 - 6] ^ w2[i2 - 16] ^ w2[i2 - 28] ^ w2[i2 - 32];
          t = t << 2 | t >>> 30;
          w2[i2] = t;
          f2 = b2 ^ c2 ^ d;
          t = (a2 << 5 | a2 >>> 27) + f2 + e2 + 3395469782 + t;
          e2 = d;
          d = c2;
          c2 = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        s2.h0 = s2.h0 + a2 | 0;
        s2.h1 = s2.h1 + b2 | 0;
        s2.h2 = s2.h2 + c2 | 0;
        s2.h3 = s2.h3 + d | 0;
        s2.h4 = s2.h4 + e2 | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    require_random();
    require_sha12();
    var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i2 = 0; i2 < PS_length; i2++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y2 = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y2 !== "\0";
      for (var i2 = 0; i2 < md.digestLength; ++i2) {
        error |= lHash.charAt(i2) !== lHashPrime.charAt(i2);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j2 = md.digestLength; j2 < db.length; j2++) {
        var code = db.charCodeAt(j2);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i2 = 0; i2 < count; ++i2) {
        var c2 = String.fromCharCode(
          i2 >> 24 & 255,
          i2 >> 16 & 255,
          i2 >> 8 & 255,
          i2 & 255
        );
        hash2.start();
        hash2.update(seed + c2);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module.exports = forge.prime;
        return;
      }
      var prime = module.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x2, y2) {
        return x2 | y2;
      };
      prime.generateProbablePrime = function(bits2, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: function(x2) {
            var b2 = prng.getBytesSync(x2.length);
            for (var i2 = 0; i2 < x2.length; ++i2) {
              x2[i2] = b2.charCodeAt(i2);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits2, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits2, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits2, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits2, rng, options, callback) {
        var num = generateRandom(bits2, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits2) {
            num = generateRandom(bits2, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits2, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits2, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits2, rng, options, callback);
        }
        var num = generateRandom(bits2, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e2) {
            if (found) {
              return;
            }
            --running;
            var data = e2.data;
            if (data.found) {
              for (var i3 = 0; i3 < workers.length; ++i3) {
                workers[i3].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits2) {
              num = generateRandom(bits2, rng);
            }
            var hex2 = num.toString(16);
            e2.target.postMessage({
              hex: hex2,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits2, rng) {
        var num = new BigInteger(bits2, rng);
        var bits1 = bits2 - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits2) {
        if (bits2 <= 100) return 27;
        if (bits2 <= 150) return 18;
        if (bits2 <= 200) return 15;
        if (bits2 <= 250) return 12;
        if (bits2 <= 300) return 9;
        if (bits2 <= 350) return 8;
        if (bits2 <= 400) return 7;
        if (bits2 <= 500) return 6;
        if (bits2 <= 600) return 5;
        if (bits2 <= 800) return 4;
        if (bits2 <= 1250) return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto_browserify() : null;
    var asn1 = forge.asn1;
    var util = forge.util;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x2, key, pub) {
      if (pub) {
        return x2.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x2.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r2;
      do {
        r2 = new BigInteger(
          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r2.compareTo(key.n) >= 0 || !r2.gcd(key.n).equals(BigInteger.ONE));
      x2 = x2.multiply(r2.modPow(key.e, key.n)).mod(key.n);
      var xp = x2.mod(key.p).modPow(key.dP, key.p);
      var xq = x2.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y2 = y2.multiply(r2.modInverse(key.n)).mod(key.n);
      return y2;
    };
    pki.rsa.encrypt = function(m2, key, bt) {
      var pub = bt;
      var eb;
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m2, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m2);
      }
      var x2 = new BigInteger(eb.toHex(), 16);
      var y2 = _modPow(x2, key, pub);
      var yhex = y2.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k2) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k2;
        throw error;
      }
      var y2 = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y2.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x2 = _modPow(y2, key, pub);
      var xhex = x2.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k2 - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits2, e2, options) {
      if (typeof bits2 === "string") {
        bits2 = parseInt(bits2, 10);
      }
      bits2 = bits2 || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: function(x2) {
          var b2 = prng.getBytesSync(x2.length);
          for (var i2 = 0; i2 < x2.length; ++i2) {
            x2[i2] = b2.charCodeAt(i2);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits: bits2,
          rng,
          eInt: e2 || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits2 >> 1,
          pBits: bits2 - (bits2 >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x2, y2) {
        return x2 | y2;
      };
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits2 = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits2 - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits2, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits2) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d,
              state.p,
              state.q,
              d.mod(state.p1),
              d.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits2, e2, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits2 === "object") {
          options = bits2;
          bits2 = void 0;
        } else if (typeof bits2 === "function") {
          callback = bits2;
          bits2 = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits2 === "number") {
          if (typeof e2 === "function") {
            callback = e2;
            e2 = void 0;
          } else if (typeof e2 !== "number") {
            options = e2;
            e2 = void 0;
          }
        } else {
          options = bits2;
          callback = e2;
          bits2 = void 0;
          e2 = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e2 === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e2;
          e2 = void 0;
        }
      }
      options = options || {};
      if (bits2 === void 0) {
        bits2 = options.bits || 2048;
      }
      if (e2 === void 0) {
        e2 = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits2 >= 256 && bits2 <= 16384 && (e2 === 65537 || e2 === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits2,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits2,
              publicExponent: _intToUint8Array(e2),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e3) {
              var pair = e3.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e4) {
                var pkcs8 = e4.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits2,
              publicExponent: e2,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits2, e2, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e2) {
      var key = {
        n,
        e: e2
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m2, key2, pub) {
              return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m2, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e4) {
            return e4;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e3 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e3, key, true);
      };
      key.verify = function(digest, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error.errors = errors;
                throw error;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
                var error = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error.oid = oid;
                throw error;
              }
              if (oid === forge.oids.md2 || oid === forge.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest2 === capture.digest;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest2 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e2, d, p2, q2, dP, dQ, qInv) {
      var key = {
        n,
        e: e2,
        d,
        p: p2,
        q: q2,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors;
        throw error;
      }
      var n, e2, d, p2, q2, dP, dQ, qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e2 = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q2 = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e2, 16),
        new BigInteger(d, 16),
        new BigInteger(p2, 16),
        new BigInteger(q2, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors;
        throw error;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e2 = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e2, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m2, key, bt) {
      var eb = forge.util.createBuffer();
      var k2 = Math.ceil(key.n.bitLength() / 8);
      if (m2.length > k2 - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m2.length;
        error.max = k2 - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k2 - 3 - m2.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i2 = 0; i2 < padNum; ++i2) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i2 = 0; i2 < padNum; ++i2) {
            padByte = padBytes.charCodeAt(i2);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m2);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k2 = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k2 - 3 - ml;
        for (var i2 = 0; i2 < padNum; ++i2) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero2 = eb.getByte();
      if (zero2 !== 0 || padNum !== k2 - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits2, callback2) {
        forge.prime.generateProbablePrime(bits2, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d,
            state.p,
            state.q,
            d.mod(state.p1),
            d.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b2) {
      var hex2 = b2.toString(16);
      if (hex2[0] >= "8") {
        hex2 = "00" + hex2;
      }
      var bytes = forge.util.hexToBytes(hex2);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    function _getMillerRabinTests(bits2) {
      if (bits2 <= 100) return 27;
      if (bits2 <= 150) return 18;
      if (bits2 <= 200) return 15;
      if (bits2 <= 250) return 12;
      if (bits2 <= 300) return 9;
      if (bits2 <= 350) return 8;
      if (bits2 <= 400) return 7;
      if (bits2 <= 500) return 6;
      if (bits2 <= 600) return 5;
      if (bits2 <= 800) return 4;
      if (bits2 <= 1250) return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x2) {
      var bytes = forge.util.hexToBytes(x2.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i2 = 0; i2 < bytes.length; ++i2) {
        buffer[i2] = bytes.charCodeAt(i2);
      }
      return buffer;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j2, l2;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge.md.sha1.create();
      }
      var u2 = md.digestLength;
      var v2 = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l2 = 0; l2 < password.length; l2++) {
          passBuf.putInt16(password.charCodeAt(l2));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s2 = salt.length();
      var D2 = new forge.util.ByteBuffer();
      D2.fillWithByte(id, v2);
      var Slen = v2 * Math.ceil(s2 / v2);
      var S2 = new forge.util.ByteBuffer();
      for (l2 = 0; l2 < Slen; l2++) {
        S2.putByte(salt.at(l2 % s2));
      }
      var Plen = v2 * Math.ceil(p2 / v2);
      var P2 = new forge.util.ByteBuffer();
      for (l2 = 0; l2 < Plen; l2++) {
        P2.putByte(passBuf.at(l2 % p2));
      }
      var I2 = S2;
      I2.putBuffer(P2);
      var c2 = Math.ceil(n / u2);
      for (var i2 = 1; i2 <= c2; i2++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D2.bytes());
        buf.putBytes(I2.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B2 = new forge.util.ByteBuffer();
        for (l2 = 0; l2 < v2; l2++) {
          B2.putByte(buf.at(l2 % u2));
        }
        var k2 = Math.ceil(s2 / v2) + Math.ceil(p2 / v2);
        var Inew = new forge.util.ByteBuffer();
        for (j2 = 0; j2 < k2; j2++) {
          var chunk = new forge.util.ByteBuffer(I2.getBytes(v2));
          var x2 = 511;
          for (l2 = B2.length() - 1; l2 >= 0; l2--) {
            x2 = x2 >> 8;
            x2 += B2.at(l2) + chunk.at(l2);
            chunk.setAt(l2, x2 & 255);
          }
          Inew.putBuffer(chunk);
        }
        I2 = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash2(md, password + salt)];
      for (var length2 = 16, i2 = 1; length2 < dkLen; ++i2, length2 += 16) {
        digests.push(hash2(md, digests[i2 - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash2(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge.asn1;
    var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    forge.mgf = forge.mgf || {};
    var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i2 = 0; i2 < len; i2++) {
            var c2 = new forge.util.ByteBuffer();
            c2.putInt32(i2);
            md.start();
            md.update(seed + c2.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_mgf1();
    module.exports = forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_random();
    require_util();
    var pss = module.exports = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options.md;
      var mgf = options.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h = hash2.digest().getBytes();
        var ps = new forge.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i2;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i2 = 0; i2 < maskLen; i2++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i2) ^ dbMask.charCodeAt(i2));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i2 = 0; i2 < checkLen; i2++) {
          if (db.charCodeAt(i2) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i2 = 0; i2 < set.value.length; ++i2) {
          obj = {};
          attr = set.value[i2];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i2 = 0; rval === null && i2 < obj.attributes.length; ++i2) {
        attr = obj.attributes[i2];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    var _createSignatureDigest = function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error.signatureOid = options.signatureOid;
          throw error;
      }
    };
    var _verifySignature = function(options) {
      var cert = options.certificate;
      var scheme;
      switch (cert.signatureOid) {
        case oids.sha1WithRSAEncryption:
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash2, mgf;
          hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error = new Error("Unsupported MGF hash function.");
            error.oid = cert.signatureParameters.mgf.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          mgf = oids[cert.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error = new Error("Unsupported MGF function.");
            error.oid = cert.signatureParameters.mgf.algorithmOid;
            error.name = mgf;
            throw error;
          }
          mgf = forge.mgf[mgf].create(forge.md[hash2].create());
          hash2 = oids[cert.signatureParameters.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error = new Error("Unsupported RSASSA-PSS hash function.");
            error.oid = cert.signatureParameters.hash.algorithmOid;
            error.name = hash2;
            throw error;
          }
          scheme = forge.pss.create(
            forge.md[hash2].create(),
            mgf,
            cert.signatureParameters.saltLength
          );
          break;
      }
      return cert.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes;
      switch (type) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex2 = digest.toHex();
        if (options.delimiter) {
          return hex2.match(/.{2}/g).join(options.delimiter);
        }
        return hex2;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = /* @__PURE__ */ new Date();
      cert.validity.notAfter = /* @__PURE__ */ new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i2 = 0; i2 < exts.length; ++i2) {
          _fillMissingExtensionFields(exts[i2], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i2 = 0; rval === null && i2 < cert.extensions.length; ++i2) {
          ext = cert.extensions[i2];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error.expectedIssuer = subject.attributes;
          error.actualIssuer = issuer.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert.isIssuer = function(parent) {
        var rval = false;
        var i2 = cert.issuer;
        var s2 = parent.subject;
        if (i2.hash && s2.hash) {
          rval = i2.hash === s2.hash;
        } else if (i2.attributes.length === s2.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i2.attributes.length; ++n) {
            iattr = i2.attributes[n];
            sattr = s2.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i2 = 0; i2 < cert.extensions.length; ++i2) {
          var ext = cert.extensions[i2];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(
        cert.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(
        cert.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = _createSignatureDigest({
          signatureOid: cert.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes.getBytes());
      }
      var imd = forge.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i2 = 0; i2 < exts.value.length; ++i2) {
        var extseq = exts.value[i2];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e2 = {};
      e2.id = asn1.derToOid(ext.value[0].value);
      e2.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e2.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e2.value = ext.value[2].value;
      } else {
        e2.value = ext.value[1].value;
      }
      if (e2.id in oids) {
        e2.name = oids[e2.id];
        if (e2.name === "keyUsage") {
          var ev = asn1.fromDer(e2.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e2.digitalSignature = (b2 & 128) === 128;
          e2.nonRepudiation = (b2 & 64) === 64;
          e2.keyEncipherment = (b2 & 32) === 32;
          e2.dataEncipherment = (b2 & 16) === 16;
          e2.keyAgreement = (b2 & 8) === 8;
          e2.keyCertSign = (b2 & 4) === 4;
          e2.cRLSign = (b2 & 2) === 2;
          e2.encipherOnly = (b2 & 1) === 1;
          e2.decipherOnly = (b3 & 128) === 128;
        } else if (e2.name === "basicConstraints") {
          var ev = asn1.fromDer(e2.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e2.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e2.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e2.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e2.name === "extKeyUsage") {
          var ev = asn1.fromDer(e2.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e2[oids[oid]] = true;
            } else {
              e2[oid] = true;
            }
          }
        } else if (e2.name === "nsCertType") {
          var ev = asn1.fromDer(e2.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e2.client = (b2 & 128) === 128;
          e2.server = (b2 & 64) === 64;
          e2.email = (b2 & 32) === 32;
          e2.objsign = (b2 & 16) === 16;
          e2.reserved = (b2 & 8) === 8;
          e2.sslCA = (b2 & 4) === 4;
          e2.emailCA = (b2 & 2) === 2;
          e2.objCA = (b2 & 1) === 1;
        } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
          e2.altNames = [];
          var gn;
          var ev = asn1.fromDer(e2.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e2.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e2.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e2.value);
          e2.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e2;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        attr = attrs[i2];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e2, options) {
      options = options || {};
      if (typeof e2.name === "undefined") {
        if (e2.id && e2.id in pki.oids) {
          e2.name = pki.oids[e2.id];
        }
      }
      if (typeof e2.id === "undefined") {
        if (e2.name && e2.name in pki.oids) {
          e2.id = pki.oids[e2.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e2;
          throw error;
        }
      }
      if (typeof e2.value !== "undefined") {
        return e2;
      }
      if (e2.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e2.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e2.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e2.name === "basicConstraints") {
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e2.cA) {
          e2.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e2) {
          e2.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e2.pathLenConstraint).getBytes()
          ));
        }
      } else if (e2.name === "extKeyUsage") {
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e2.value.value;
        for (var key in e2) {
          if (e2[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e2.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e2.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e2.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e2.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e2.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e2.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e2.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e2.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e2.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e2.name === "subjectAltName" || e2.name === "issuerAltName") {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e2.altNames.length; ++n) {
          altName = e2.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e2;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e2.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e2.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e2.comment) || e2.comment.length < 1 || e2.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e2.comment
        );
      } else if (e2.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e2.subjectKeyIdentifier = ski.toHex();
        e2.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e2.name === "authorityKeyIdentifier" && options.cert) {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e2.value.value;
        if (e2.keyIdentifier) {
          var keyIdentifier = e2.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e2.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e2.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e2.authorityCertIssuer === true ? options.cert.issuer : e2.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e2.serialNumber) {
          var serialNumber = forge.util.hexToBytes(e2.serialNumber === true ? options.cert.serialNumber : e2.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e2.name === "cRLDistributionPoints") {
        e2.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e2.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e2.altNames.length; ++n) {
          altName = e2.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error.extension = e2;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e2.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e2;
        throw error;
      }
      return e2;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i2 = 0; i2 < attrs.length; ++i2) {
        var attr = attrs[i2];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge.util.hexToBytes(cert.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert.siginfo.algorithmOid,
            cert.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.issuer.uniqueId
            )
          ])
        );
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert.subject.uniqueId
            )
          ])
        );
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i2 = 0; i2 < exts.length; ++i2) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i2]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        var match2 = getBySubject(cert2.subject);
        if (!match2) {
          return false;
        }
        if (!forge.util.isArray(match2)) {
          match2 = [match2];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i3 = 0; i3 < value.length; ++i3) {
                certList.push(value[i3]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match2 = getBySubject(cert2.subject);
        if (!forge.util.isArray(match2)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i3 = 0; i3 < match2.length; ++i3) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match2[i3])).getBytes();
          if (der1 === der2) {
            result = match2[i3];
            match2.splice(i3, 1);
          }
        }
        if (match2.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i2 = 0; i2 < certs.length; ++i2) {
          var cert = certs[i2];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent = chain[0] || caStore.getIssuer(cert);
          if (parent === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent = cert;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent && !cert.isIssuer(parent)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se2 = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i2 = 0; error === null && i2 < cert.extensions.length; ++i2) {
            var ext = cert.extensions[i2];
            if (ext.critical && !(ext.name in se2)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/node-forge/lib/pkcs12.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha12();
    require_util();
    require_x509();
    var asn1 = forge.asn1;
    var pki = forge.pki;
    var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i2 = 0; i2 < safeContents.length; i2++) {
        for (var j2 = 0; j2 < safeContents[i2].safeBags.length; j2++) {
          var bag = safeContents[i2].safeBags[j2];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error.errors = error;
        throw error;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: function(filter2) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter2) {
            localKeyId = filter2.localKeyId;
          } else if ("localKeyIdHex" in filter2) {
            localKeyId = forge.util.hexToBytes(filter2.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter2) && "bagType" in filter2) {
            rval[filter2.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter2.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter2.bagType
            );
          }
          if ("friendlyName" in filter2) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter2.friendlyName,
              filter2.bagType
            );
          }
          return rval;
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        },
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error.version = capture.version.charCodeAt(0);
        throw error;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error.oid = asn1.derToOid(capture.contentType);
        throw error;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md
        );
        var mac = forge.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge.util.createBuffer();
        for (var i2 = 0; i2 < data.value.length; ++i2) {
          value.putBytes(data.value[i2].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i2 = 0; i2 < authSafe.value.length; i2++) {
        var contentInfo = authSafe.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error = new Error("Unsupported PKCS#12 contentType.");
            error.contentType = asn1.derToOid(capture.contentType);
            throw error;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error = new Error("Cannot read EncryptedContentInfo.");
        error.errors = errors;
        throw error;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error.oid = oid;
        throw error;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i2 = 0; i2 < safeContents.value.length; i2++) {
        var safeBag = safeContents.value[i2];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error = new Error("Cannot read SafeBag.");
          error.errors = errors;
          throw error;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e2) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder = function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error2 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error2.oid = asn1.derToOid(capture.certId);
                throw error2;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e2) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            };
            break;
          default:
            var error = new Error("Unsupported PKCS#12 SafeBag type.");
            error.oid = bag.type;
            throw error;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 " + validator.name);
          error.errors = errors;
          throw error;
        }
        decoder();
      }
      return res;
    }
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i2 = 0; i2 < attributes.length; ++i2) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i2], attributeValidator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 BagAttribute.");
            error.errors = errors;
            throw error;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j2 = 0; j2 < capture.values.length; ++j2) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j2].value);
          }
        }
      }
      return decodedAttrs;
    }
    p12.toPkcs12Asn1 = function(key, cert, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert) {
          var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert !== null) {
        if (forge.util.isArray(cert)) {
          chain = cert;
        } else {
          chain = [cert];
        }
      }
      var certSafeBags = [];
      for (var i2 = 0; i2 < chain.length; ++i2) {
        cert = chain[i2];
        if (typeof cert === "string") {
          cert = pki.certificateFromPem(cert);
        }
        var certBagAttrs = i2 === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha1 = forge.md.sha1.create();
        var macSalt = new forge.util.ByteBuffer(
          forge.random.getBytes(options.saltSize)
        );
        var count = options.count;
        var key = p12.generateKey(password, macSalt, 3, count, 20);
        var mac = forge.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge.pbe.generatePkcs12Key;
  }
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/node-forge/lib/pki.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util();
    require_x509();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/node-forge/lib/tls.js
var require_tls = __commonJS({
  "node_modules/node-forge/lib/tls.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_md52();
    require_pem();
    require_pki();
    require_random();
    require_sha12();
    require_util();
    var prf_TLS1 = function(secret, label, seed, length2) {
      var rval = forge.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge.util.createBuffer();
      var hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length2 / 16);
      var sha1itr = Math.ceil(length2 / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge.util.createBuffer();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < md5itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i2 = 0; i2 < sha1itr; ++i2) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length2
      ));
      return rval;
    };
    var hmac_sha1 = function(key2, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key2);
      var b2 = forge.util.createBuffer();
      b2.putInt32(seqNum[0]);
      b2.putInt32(seqNum[1]);
      b2.putByte(record.type);
      b2.putByte(record.version.major);
      b2.putByte(record.version.minor);
      b2.putInt16(record.length);
      b2.putBytes(record.fragment.bytes());
      hmac.update(b2.getBytes());
      return hmac.digest().getBytes();
    };
    var deflate = function(c2, record, s2) {
      var rval = false;
      try {
        var bytes = c2.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var inflate = function(c2, record, s2) {
      var rval = false;
      try {
        var bytes = c2.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    };
    var readVector = function(b2, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b2.getByte();
          break;
        case 2:
          len = b2.getInt16();
          break;
        case 3:
          len = b2.getInt24();
          break;
        case 4:
          len = b2.getInt32();
          break;
      }
      return forge.util.createBuffer(b2.getBytes(len));
    };
    var writeVector = function(b2, lenBytes, v2) {
      b2.putInt(v2.length(), lenBytes << 3);
      b2.putBuffer(v2);
    };
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key2];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c2, record) {
      var ignore = !c2.open && c2.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c2.error(c2, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c2, record, length2) {
      if (!c2.handshaking && c2.handshakes > 0) {
        tls.queue(c2, tls.createAlert(c2, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c2);
      }
      c2.process();
    };
    tls.parseHelloMessage = function(c2, record, length2) {
      var msg = null;
      var client = c2.entity === tls.ConnectionEnd.client;
      if (length2 < 38) {
        c2.error(c2, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b2 = record.fragment;
        var remaining = b2.length();
        msg = {
          version: {
            major: b2.getByte(),
            minor: b2.getByte()
          },
          random: forge.util.createBuffer(b2.getBytes(32)),
          session_id: readVector(b2, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b2.getBytes(2);
          msg.compression_method = b2.getByte();
        } else {
          msg.cipher_suites = readVector(b2, 2);
          msg.compression_methods = readVector(b2, 1);
        }
        remaining = length2 - (remaining - b2.length());
        if (remaining > 0) {
          var exts = readVector(b2, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i2 = 0; i2 < msg.extensions.length; ++i2) {
              var ext = msg.extensions[i2];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c2.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c2.session.version) {
          if (msg.version.major !== c2.session.version.major || msg.version.minor !== c2.session.version.minor) {
            return c2.error(c2, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c2.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c2.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c2.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c2.session.cipherSuite === null) {
          return c2.error(c2, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c2.session.compressionMethod = msg.compression_method;
        } else {
          c2.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c2, msg) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c2.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c2.session.sp = {
        entity: c2.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c2.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c2, record, length2) {
      var msg = tls.parseHelloMessage(c2, record, length2);
      if (c2.fail) {
        return;
      }
      if (msg.version.minor <= c2.version.minor) {
        c2.version.minor = msg.version.minor;
      } else {
        return c2.error(c2, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c2.session.version = c2.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c2.session.id) {
        c2.expect = SCC;
        c2.session.resuming = true;
        c2.session.sp.server_random = msg.random.bytes();
      } else {
        c2.expect = SCE;
        c2.session.resuming = false;
        tls.createSecurityParameters(c2, msg);
      }
      c2.session.id = sessionId;
      c2.process();
    };
    tls.handleClientHello = function(c2, record, length2) {
      var msg = tls.parseHelloMessage(c2, record, length2);
      if (c2.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c2.sessionCache) {
        session = c2.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge.random.getBytes(32);
      }
      c2.session.id = sessionId;
      c2.session.clientHelloVersion = msg.version;
      c2.session.sp = {};
      if (session) {
        c2.version = c2.session.version = session.version;
        c2.session.sp = session.sp;
      } else {
        var version;
        for (var i2 = 1; i2 < tls.SupportedVersions.length; ++i2) {
          version = tls.SupportedVersions[i2];
          if (version.minor <= msg.version.minor) {
            break;
          }
        }
        c2.version = { major: version.major, minor: version.minor };
        c2.session.version = c2.version;
      }
      if (session !== null) {
        c2.expect = CCC;
        c2.session.resuming = true;
        c2.session.sp.client_random = msg.random.bytes();
      } else {
        c2.expect = c2.verifyClient !== false ? CCE : CKE;
        c2.session.resuming = false;
        tls.createSecurityParameters(c2, msg);
      }
      c2.open = true;
      tls.queue(c2, tls.createRecord(c2, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c2)
      }));
      if (c2.session.resuming) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
      } else {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c2)
        }));
        if (!c2.fail) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c2)
          }));
          if (c2.verifyClient !== false) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c2)
            }));
          }
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c2)
          }));
        }
      }
      tls.flush(c2);
      c2.process();
    };
    tls.handleCertificate = function(c2, record, length2) {
      if (length2 < 3) {
        return c2.error(c2, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_list: readVector(b2, 3)
      };
      var cert, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert = readVector(msg.certificate_list, 3);
          asn1 = forge.asn1.fromDer(cert);
          cert = forge.pki.certificateFromAsn1(asn1, true);
          certs.push(cert);
        }
      } catch (ex) {
        return c2.error(c2, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c2.entity === tls.ConnectionEnd.client;
      if ((client || c2.verifyClient === true) && certs.length === 0) {
        c2.error(c2, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c2.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c2.session.serverCertificate = certs[0];
        } else {
          c2.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c2, certs)) {
          c2.expect = client ? SKE : CKE;
        }
      }
      c2.process();
    };
    tls.handleServerKeyExchange = function(c2, record, length2) {
      if (length2 > 0) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c2.expect = SCR;
      c2.process();
    };
    tls.handleClientKeyExchange = function(c2, record, length2) {
      if (length2 < 48) {
        return c2.error(c2, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b2, 2).getBytes()
      };
      var privateKey = null;
      if (c2.getPrivateKey) {
        try {
          privateKey = c2.getPrivateKey(c2, c2.session.serverCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c2.error(c2, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c2.error(c2, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c2.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version = c2.session.clientHelloVersion;
        if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge.random.getBytes(48);
      }
      c2.expect = CCC;
      if (c2.session.clientCertificate !== null) {
        c2.expect = CCV;
      }
      c2.process();
    };
    tls.handleCertificateRequest = function(c2, record, length2) {
      if (length2 < 3) {
        return c2.error(c2, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_types: readVector(b2, 1),
        certificate_authorities: readVector(b2, 2)
      };
      c2.session.certificateRequest = msg;
      c2.expect = SHD;
      c2.process();
    };
    tls.handleCertificateVerify = function(c2, record, length2) {
      if (length2 < 2) {
        return c2.error(c2, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var msg = {
        signature: readVector(b2, 2).getBytes()
      };
      var verify2 = forge.util.createBuffer();
      verify2.putBuffer(c2.session.md5.digest());
      verify2.putBuffer(c2.session.sha1.digest());
      verify2 = verify2.getBytes();
      try {
        var cert = c2.session.clientCertificate;
        if (!cert.publicKey.verify(verify2, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c2.session.md5.update(msgBytes);
        c2.session.sha1.update(msgBytes);
      } catch (ex) {
        return c2.error(c2, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c2.expect = CCC;
      c2.process();
    };
    tls.handleServerHelloDone = function(c2, record, length2) {
      if (length2 > 0) {
        return c2.error(c2, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c2.serverCertificate === null) {
        var error = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c2.verify(c2, error.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error.alert.description = ret;
            }
          }
          return c2.error(c2, error);
        }
      }
      if (c2.session.certificateRequest !== null) {
        record = tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c2)
        });
        tls.queue(c2, record);
      }
      record = tls.createRecord(c2, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c2)
      });
      tls.queue(c2, record);
      c2.expect = SER;
      var callback = function(c3, signature) {
        if (c3.session.certificateRequest !== null && c3.session.clientCertificate !== null) {
          tls.queue(c3, tls.createRecord(c3, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c3, signature)
          }));
        }
        tls.queue(c3, tls.createRecord(c3, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c3.state.pending = tls.createConnectionState(c3);
        c3.state.current.write = c3.state.pending.write;
        tls.queue(c3, tls.createRecord(c3, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c3)
        }));
        c3.expect = SCC;
        tls.flush(c3);
        c3.process();
      };
      if (c2.session.certificateRequest === null || c2.session.clientCertificate === null) {
        return callback(c2, null);
      }
      tls.getClientSignature(c2, callback);
    };
    tls.handleChangeCipherSpec = function(c2, record) {
      if (record.fragment.getByte() !== 1) {
        return c2.error(c2, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c2.entity === tls.ConnectionEnd.client;
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        c2.state.pending = tls.createConnectionState(c2);
      }
      c2.state.current.read = c2.state.pending.read;
      if (!c2.session.resuming && client || c2.session.resuming && !client) {
        c2.state.pending = null;
      }
      c2.expect = client ? SFI : CFI;
      c2.process();
    };
    tls.handleFinished = function(c2, record, length2) {
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var vd = record.fragment.getBytes();
      b2 = forge.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      if (b2.getBytes() !== vd) {
        return c2.error(c2, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c2.session.md5.update(msgBytes);
      c2.session.sha1.update(msgBytes);
      if (c2.session.resuming && client || !c2.session.resuming && !client) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.current.write = c2.state.pending.write;
        c2.state.pending = null;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
      }
      c2.expect = client ? SAD : CAD;
      c2.handshaking = false;
      ++c2.handshakes;
      c2.peerCertificate = client ? c2.session.serverCertificate : c2.session.clientCertificate;
      tls.flush(c2);
      c2.isConnected = true;
      c2.connected(c2);
      c2.process();
    };
    tls.handleAlert = function(c2, record) {
      var b2 = record.fragment;
      var alert = {
        level: b2.getByte(),
        description: b2.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c2.close();
      }
      c2.error(c2, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c2.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c2.process();
    };
    tls.handleHandshake = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length2 = b2.getInt24();
      if (length2 > b2.length()) {
        c2.fragmented = record;
        record.fragment = forge.util.createBuffer();
        b2.read -= 4;
        return c2.process();
      }
      c2.fragmented = null;
      b2.read -= 4;
      var bytes = b2.bytes(length2 + 4);
      b2.read += 4;
      if (type in hsTable[c2.entity][c2.expect]) {
        if (c2.entity === tls.ConnectionEnd.server && !c2.open && !c2.fail) {
          c2.handshaking = true;
          c2.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
        }
        if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
          c2.session.md5.update(bytes);
          c2.session.sha1.update(bytes);
        }
        hsTable[c2.entity][c2.expect][type](c2, record, length2);
      } else {
        tls.handleUnexpected(c2, record);
      }
    };
    tls.handleApplicationData = function(c2, record) {
      c2.data.putBuffer(record.fragment);
      c2.dataReady(c2);
      c2.process();
    };
    tls.handleHeartbeat = function(c2, record) {
      var b2 = record.fragment;
      var type = b2.getByte();
      var length2 = b2.getInt16();
      var payload = b2.getBytes(length2);
      if (type === tls.HeartbeatMessageType.heartbeat_request) {
        if (c2.handshaking || length2 > payload.length) {
          return c2.process();
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c2);
      } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c2.expectedHeartbeatPayload) {
          return c2.process();
        }
        if (c2.heartbeatReceived) {
          c2.heartbeatReceived(c2, forge.util.createBuffer(payload));
        }
      }
      c2.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R2, __, R4],
      /*SCE*/
      [__, R1, R2, __, R4],
      /*SKE*/
      [__, R1, R2, __, R4],
      /*SCR*/
      [__, R1, R2, __, R4],
      /*SHD*/
      [__, R1, R2, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R2, __, R4],
      /*SAD*/
      [__, R1, R2, R3, R4],
      /*SER*/
      [__, R1, R2, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R2, __, R4],
      /*CCE*/
      [__, R1, R2, __, R4],
      /*CKE*/
      [__, R1, R2, __, R4],
      /*CCV*/
      [__, R1, R2, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R2, __, R4],
      /*CAD*/
      [__, R1, R2, R3, R4],
      /*CER*/
      [__, R1, R2, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c2, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c2.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length2 = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c2.version.major === tls.Versions.TLS_1_0.major && c2.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length2 += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length2);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c2) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var createMode = function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: function(record) {
            return true;
          },
          compressionState: null,
          compressFunction: function(record) {
            return true;
          },
          updateSequenceNumber: function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }
        };
        return mode;
      };
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c3, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c3.error(c3, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c3, record, state.read)) {
          c3.error(c3, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c3.fail;
      };
      state.write.update = function(c3, record) {
        if (!state.write.compressFunction(c3, record, state.write)) {
          c3.error(c3, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c3.error(c3, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c3.fail;
      };
      if (c2.session) {
        var sp = c2.session.sp;
        c2.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c2, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c2.session.cipherSuite.initConnectionState(state, c2, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate;
            state.write.compressFunction = deflate;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d = /* @__PURE__ */ new Date();
      var utc = +d + d.getTimezoneOffset() * 6e4;
      var rval = forge.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c2, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c2.version.major,
          minor: c2.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c2, alert) {
      var b2 = forge.util.createBuffer();
      b2.putByte(alert.level);
      b2.putByte(alert.description);
      return tls.createRecord(c2, {
        type: tls.ContentType.alert,
        data: b2
      });
    };
    tls.createClientHello = function(c2) {
      c2.session.clientHelloVersion = {
        major: c2.version.major,
        minor: c2.version.minor
      };
      var cipherSuites = forge.util.createBuffer();
      for (var i2 = 0; i2 < c2.cipherSuites.length; ++i2) {
        var cs = c2.cipherSuites[i2];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge.util.createBuffer();
      if (c2.virtualHost) {
        var ext = forge.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge.util.createBuffer(c2.virtualHost));
        var snList = forge.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c2.session.id;
      var length2 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length2);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.client_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c2) {
      var sessionId = c2.session.id;
      var length2 = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length2);
      rval.putByte(c2.version.major);
      rval.putByte(c2.version.minor);
      rval.putBytes(c2.session.sp.server_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      rval.putByte(c2.session.cipherSuite.id[0]);
      rval.putByte(c2.session.cipherSuite.id[1]);
      rval.putByte(c2.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c2) {
      var client = c2.entity === tls.ConnectionEnd.client;
      var cert = null;
      if (c2.getCertificate) {
        var hint;
        if (client) {
          hint = c2.session.certificateRequest;
        } else {
          hint = c2.session.extensions.server_name.serverNameList;
        }
        cert = c2.getCertificate(c2, hint);
      }
      var certList = forge.util.createBuffer();
      if (cert !== null) {
        try {
          if (!forge.util.isArray(cert)) {
            cert = [cert];
          }
          var asn1 = null;
          for (var i2 = 0; i2 < cert.length; ++i2) {
            var msg = forge.pem.decode(cert[i2])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error.headerType = msg.type;
              throw error;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert = forge.pki.certificateFromAsn1(asn1);
          if (client) {
            c2.session.clientCertificate = cert;
          } else {
            c2.session.serverCertificate = cert;
          }
        } catch (ex) {
          return c2.error(c2, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length2 = 3 + certList.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length2);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c2) {
      var b2 = forge.util.createBuffer();
      b2.putByte(c2.session.clientHelloVersion.major);
      b2.putByte(c2.session.clientHelloVersion.minor);
      b2.putBytes(forge.random.getBytes(46));
      var sp = c2.session.sp;
      sp.pre_master_secret = b2.getBytes();
      var key2 = c2.session.serverCertificate.publicKey;
      b2 = key2.encrypt(sp.pre_master_secret);
      var length2 = b2.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length2);
      rval.putInt16(b2.length);
      rval.putBytes(b2);
      return rval;
    };
    tls.createServerKeyExchange = function(c2) {
      var length2 = 0;
      var rval = forge.util.createBuffer();
      if (length2 > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length2);
      }
      return rval;
    };
    tls.getClientSignature = function(c2, callback) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      b2 = b2.getBytes();
      c2.getSignature = c2.getSignature || function(c3, b3, callback2) {
        var privateKey = null;
        if (c3.getPrivateKey) {
          try {
            privateKey = c3.getPrivateKey(c3, c3.session.clientCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c3.error(c3, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c3.error(c3, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b3 = privateKey.sign(b3, null);
        }
        callback2(c3, b3);
      };
      c2.getSignature(c2, b2, callback);
    };
    tls.createCertificateVerify = function(c2, signature) {
      var length2 = signature.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length2);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c2) {
      var certTypes = forge.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge.util.createBuffer();
      for (var key2 in c2.caStore.certs) {
        var cert = c2.caStore.certs[key2];
        var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
        var byteBuffer = forge.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length2 = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length2);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c2) {
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c2) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c2.session.md5.digest());
      b2.putBuffer(c2.session.sha1.digest());
      var client = c2.entity === tls.ConnectionEnd.client;
      var sp = c2.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b2.length());
      rval.putBuffer(b2);
      return rval;
    };
    tls.createHeartbeat = function(type, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge.util.createBuffer();
      rval.putByte(type);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c2, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c2.session.md5.update(bytes);
        c2.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c2, {
            type: record.type,
            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c2, {
            type: record.type,
            data: forge.util.createBuffer(data)
          }));
        }
      }
      for (var i2 = 0; i2 < records.length && !c2.fail; ++i2) {
        var rec = records[i2];
        var s2 = c2.state.current.write;
        if (s2.update(c2, rec)) {
          c2.records.push(rec);
        }
      }
    };
    tls.flush = function(c2) {
      for (var i2 = 0; i2 < c2.records.length; ++i2) {
        var record = c2.records[i2];
        c2.tlsData.putByte(record.type);
        c2.tlsData.putByte(record.version.major);
        c2.tlsData.putByte(record.version.minor);
        c2.tlsData.putInt16(record.fragment.length());
        c2.tlsData.putBuffer(c2.records[i2].fragment);
      }
      c2.records = [];
      return c2.tlsDataReady(c2);
    };
    var _certErrorToAlertDesc = function(error) {
      switch (error) {
        case true:
          return true;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    };
    var _alertDescToCertError = function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    };
    tls.verifyCertificateChain = function(c2, chain) {
      try {
        var options = {};
        for (var key2 in c2.verifyOptions) {
          options[key2] = c2.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c2.verify(c2, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              var error = new Error("The application rejected the certificate.");
              error.send = true;
              error.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.alert) {
                error.alert.description = ret.alert;
              }
              throw error;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge.pki.verifyCertificateChain(c2.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c2.error(c2, err);
      }
      return !c2.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i2 in rval.order) {
              if (rval.order[i2] === key3) {
                rval.order.splice(i2, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge.util.isArray(options.caStore)) {
          caStore = forge.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c2 = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: function(c3, ex) {
          ex.origin = ex.origin || (c3.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c3, tls.createAlert(c3, ex.alert));
            tls.flush(c3);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c3.fail = true;
          }
          options.error(c3, ex);
          if (fatal) {
            c3.close(false);
          }
        },
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c2.reset = function(clearFail) {
        c2.version = { major: tls.Version.major, minor: tls.Version.minor };
        c2.record = null;
        c2.session = null;
        c2.peerCertificate = null;
        c2.state = {
          pending: null,
          current: null
        };
        c2.expect = c2.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c2.fragmented = null;
        c2.records = [];
        c2.open = false;
        c2.handshakes = 0;
        c2.handshaking = false;
        c2.isConnected = false;
        c2.fail = !(clearFail || typeof clearFail === "undefined");
        c2.input.clear();
        c2.tlsData.clear();
        c2.data.clear();
        c2.state.current = tls.createConnectionState(c2);
      };
      c2.reset();
      var _update = function(c3, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c3.entity][c3.expect];
        if (aligned in handlers) {
          handlers[aligned](c3, record);
        } else {
          tls.handleUnexpected(c3, record);
        }
      };
      var _readRecordHeader = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c3.record = {
            type: b2.getByte(),
            version: {
              major: b2.getByte(),
              minor: b2.getByte()
            },
            length: b2.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c3.record.version.major === c3.version.major;
          if (compatibleVersion && c3.session && c3.session.version) {
            compatibleVersion = c3.record.version.minor === c3.version.minor;
          }
          if (!compatibleVersion) {
            c3.error(c3, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      };
      var _readRecord = function(c3) {
        var rval = 0;
        var b2 = c3.input;
        var len = b2.length();
        if (len < c3.record.length) {
          rval = c3.record.length - len;
        } else {
          c3.record.fragment.putBytes(b2.getBytes(c3.record.length));
          b2.compact();
          var s2 = c3.state.current.read;
          if (s2.update(c3, c3.record)) {
            if (c3.fragmented !== null) {
              if (c3.fragmented.type === c3.record.type) {
                c3.fragmented.fragment.putBuffer(c3.record.fragment);
                c3.record = c3.fragmented;
              } else {
                c3.error(c3, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c3.record.ready = true;
          }
        }
        return rval;
      };
      c2.handshake = function(sessionId) {
        if (c2.entity !== tls.ConnectionEnd.client) {
          c2.error(c2, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c2.handshaking) {
          c2.error(c2, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c2.fail && !c2.open && c2.handshakes === 0) {
            c2.fail = false;
          }
          c2.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c2.sessionCache) {
              session = c2.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c2.sessionCache) {
            session = c2.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c2.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
          if (session) {
            c2.version = session.version;
            c2.session.sp = session.sp;
          }
          c2.session.sp.client_random = tls.createRandom().getBytes();
          c2.open = true;
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c2)
          }));
          tls.flush(c2);
        }
      };
      c2.process = function(data) {
        var rval = 0;
        if (data) {
          c2.input.putBytes(data);
        }
        if (!c2.fail) {
          if (c2.record !== null && c2.record.ready && c2.record.fragment.isEmpty()) {
            c2.record = null;
          }
          if (c2.record === null) {
            rval = _readRecordHeader(c2);
          }
          if (!c2.fail && c2.record !== null && !c2.record.ready) {
            rval = _readRecord(c2);
          }
          if (!c2.fail && c2.record !== null && c2.record.ready) {
            _update(c2, c2.record);
          }
        }
        return rval;
      };
      c2.prepare = function(data) {
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.application_data,
          data: forge.util.createBuffer(data)
        }));
        return tls.flush(c2);
      };
      c2.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c2.expectedHeartbeatPayload = payload;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c2);
      };
      c2.close = function(clearFail) {
        if (!c2.fail && c2.sessionCache && c2.session) {
          var session = {
            id: c2.session.id,
            version: c2.session.version,
            sp: c2.session.sp
          };
          session.sp.keys = null;
          c2.sessionCache.setSession(session.id, session);
        }
        if (c2.open) {
          c2.open = false;
          c2.input.clear();
          if (c2.isConnected || c2.handshaking) {
            c2.isConnected = c2.handshaking = false;
            tls.queue(c2, tls.createAlert(c2, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c2);
          }
          c2.closed(c2);
        }
        c2.reset(clearFail);
      };
      return c2;
    };
    module.exports = forge.tls = forge.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge.tls[key] = tls[key];
      }
    }
    var key;
    forge.tls.prf_tls1 = prf_TLS1;
    forge.tls.hmac_sha1 = hmac_sha1;
    forge.tls.createSessionCache = tls.createSessionCache;
    forge.tls.createConnection = tls.createConnection;
  }
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/node-forge/lib/aesCipherSuites.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_tls();
    var tls = module.exports = forge.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      },
      initConnectionState
    };
    function initConnectionState(state, c2, sp) {
      var client = c2.entity === forge.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    function encrypt_aes_cbc_sha1(record, s2) {
      var rval = false;
      var mac = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s2.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s2.cipherState.init ? null : s2.cipherState.iv;
      } else {
        iv = forge.random.getBytesSync(16);
      }
      s2.cipherState.init = true;
      var cipher = s2.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
      if (!decrypt) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
      var rval = true;
      if (decrypt) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i2 = len - 1 - paddingLength; i2 < len - 1; ++i2) {
          rval = rval && output.at(i2) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    function decrypt_aes_cbc_sha1(record, s2) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s2.cipherState.init ? null : s2.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s2.cipherState.init = true;
      var cipher = s2.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s2.macLength;
      var mac = forge.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
      s2.updateSequenceNumber();
      rval = compareMacs(s2.macKey, mac, mac2) && rval;
      return rval;
    }
    function compareMacs(key, mac1, mac2) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_md();
    require_util();
    var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha512.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha512.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i2 = 0; i2 < int32s; ++i2) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i2 = 0; i2 < _state.length; ++i2) {
          _h[i2] = _state[i2].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i2 = md.fullMessageLength.length - 1; i2 >= 0; --i2) {
          md.fullMessageLength[i2] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i2] / 4294967296 >>> 0);
          md.fullMessageLength[i2] = md.fullMessageLength[i2] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next2, carry;
        var bits2 = md.fullMessageLength[0] * 8;
        for (var i2 = 0; i2 < md.fullMessageLength.length - 1; ++i2) {
          next2 = md.fullMessageLength[i2 + 1] * 8;
          carry = next2 / 4294967296 >>> 0;
          bits2 += carry;
          finalBlock.putInt32(bits2 >>> 0);
          bits2 = next2 >>> 0;
        }
        finalBlock.putInt32(bits2);
        var h = new Array(_h.length);
        for (var i2 = 0; i2 < _h.length; ++i2) {
          h[i2] = _h[i2].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i2 = 0; i2 < hlen; ++i2) {
          rval.putInt32(h[i2][0]);
          if (i2 !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i2][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s2, w2, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i2, hi, lo, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i2 = 0; i2 < 16; ++i2) {
          w2[i2][0] = bytes.getInt32() >>> 0;
          w2[i2][1] = bytes.getInt32() >>> 0;
        }
        for (; i2 < 80; ++i2) {
          w22 = w2[i2 - 2];
          hi = w22[0];
          lo = w22[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w2[i2 - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w2[i2 - 7];
          w16 = w2[i2 - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w2[i2][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w2[i2][1] = lo >>> 0;
        }
        a_hi = s2[0][0];
        a_lo = s2[0][1];
        b_hi = s2[1][0];
        b_lo = s2[1][1];
        c_hi = s2[2][0];
        c_lo = s2[2][1];
        d_hi = s2[3][0];
        d_lo = s2[3][1];
        e_hi = s2[4][0];
        e_lo = s2[4][1];
        f_hi = s2[5][0];
        f_lo = s2[5][1];
        g_hi = s2[6][0];
        g_lo = s2[6][1];
        h_hi = s2[7][0];
        h_lo = s2[7][1];
        for (i2 = 0; i2 < 80; ++i2) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i2][1] + w2[i2][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i2][0] + w2[i2][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s2[0][1] + a_lo;
        s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[0][1] = lo >>> 0;
        lo = s2[1][1] + b_lo;
        s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[1][1] = lo >>> 0;
        lo = s2[2][1] + c_lo;
        s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[2][1] = lo >>> 0;
        lo = s2[3][1] + d_lo;
        s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[3][1] = lo >>> 0;
        lo = s2[4][1] + e_lo;
        s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[4][1] = lo >>> 0;
        lo = s2[5][1] + f_lo;
        s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[5][1] = lo >>> 0;
        lo = s2[6][1] + g_lo;
        s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[6][1] = lo >>> 0;
        lo = s2[7][1] + h_lo;
        s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s2[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_asn1();
    var asn1 = forge.asn1;
    exports.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed25519 = forge.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < 32; ++i2) {
        sk[i2] = seed[i2];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i2 = 0; i2 < pk.length; ++i2) {
        pk[i2] = privateKey[32 + i2];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i2 = 0; i2 < sig.length; ++i2) {
        sig[i2] = signedMsg[i2];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m2 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i2;
      for (i2 = 0; i2 < ed25519.constants.SIGN_BYTE_LENGTH; ++i2) {
        sm[i2] = sig[i2];
      }
      for (i2 = 0; i2 < msg.length; ++i2) {
        sm[i2 + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i2];
      }
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message.length());
      for (var i2 = 0; i2 < buffer.length; ++i2) {
        buffer[i2] = message.at(i2);
      }
      return buffer;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X2 = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y2 = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L2 = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md = forge.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash2 = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash2, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i2 = 0; i2 < 64; ++i2) {
        out[i2] = hash2.charCodeAt(i2);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf(), gf(), gf(), gf()];
      var i2;
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p2, d);
      pack(pk, p2);
      for (i2 = 0; i2 < 32; ++i2) {
        sk[i2 + 32] = pk[i2];
      }
      return 0;
    }
    function crypto_sign(sm, m2, n, sk) {
      var i2, j2, x2 = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var d = sha512(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i2 = 0; i2 < n; ++i2) {
        sm[64 + i2] = m2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        sm[32 + i2] = d[32 + i2];
      }
      var r2 = sha512(sm.subarray(32), n + 32);
      reduce(r2);
      scalarbase(p2, r2);
      pack(sm, p2);
      for (i2 = 32; i2 < 64; ++i2) {
        sm[i2] = sk[i2];
      }
      var h = sha512(sm, n + 64);
      reduce(h);
      for (i2 = 32; i2 < 64; ++i2) {
        x2[i2] = 0;
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x2[i2] = r2[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        for (j2 = 0; j2 < 32; j2++) {
          x2[i2 + j2] += h[i2] * d[j2];
        }
      }
      modL(sm.subarray(32), x2);
      return smlen;
    }
    function crypto_sign_open(m2, sm, n, pk) {
      var i2, mlen;
      var t = new NativeBuffer(32);
      var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q2, pk)) {
        return -1;
      }
      for (i2 = 0; i2 < n; ++i2) {
        m2[i2] = sm[i2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        m2[i2 + 32] = pk[i2];
      }
      var h = sha512(m2, n);
      reduce(h);
      scalarmult(p2, q2, h);
      scalarbase(q2, sm.subarray(32));
      add2(p2, q2);
      pack(t, p2);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i2 = 0; i2 < n; ++i2) {
          m2[i2] = 0;
        }
        return -1;
      }
      for (i2 = 0; i2 < n; ++i2) {
        m2[i2] = sm[i2 + 64];
      }
      mlen = n;
      return mlen;
    }
    function modL(r2, x2) {
      var carry, i2, j2, k2;
      for (i2 = 63; i2 >= 32; --i2) {
        carry = 0;
        for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
          x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
          carry = x2[j2] + 128 >> 8;
          x2[j2] -= carry * 256;
        }
        x2[j2] += carry;
        x2[i2] = 0;
      }
      carry = 0;
      for (j2 = 0; j2 < 32; ++j2) {
        x2[j2] += carry - (x2[31] >> 4) * L2[j2];
        carry = x2[j2] >> 8;
        x2[j2] &= 255;
      }
      for (j2 = 0; j2 < 32; ++j2) {
        x2[j2] -= carry * L2[j2];
      }
      for (i2 = 0; i2 < 32; ++i2) {
        x2[i2 + 1] += x2[i2] >> 8;
        r2[i2] = x2[i2] & 255;
      }
    }
    function reduce(r2) {
      var x2 = new Float64Array(64);
      for (var i2 = 0; i2 < 64; ++i2) {
        x2[i2] = r2[i2];
        r2[i2] = 0;
      }
      modL(r2, x2);
    }
    function add2(p2, q2) {
      var a2 = gf(), b2 = gf(), c2 = gf(), d = gf(), e2 = gf(), f2 = gf(), g2 = gf(), h = gf(), t = gf();
      Z2(a2, p2[1], p2[0]);
      Z2(t, q2[1], q2[0]);
      M2(a2, a2, t);
      A2(b2, p2[0], p2[1]);
      A2(t, q2[0], q2[1]);
      M2(b2, b2, t);
      M2(c2, p2[3], q2[3]);
      M2(c2, c2, D22);
      M2(d, p2[2], q2[2]);
      A2(d, d, d);
      Z2(e2, b2, a2);
      Z2(f2, d, c2);
      A2(g2, d, c2);
      A2(h, b2, a2);
      M2(p2[0], e2, f2);
      M2(p2[1], h, g2);
      M2(p2[2], g2, f2);
      M2(p2[3], e2, h);
    }
    function cswap(p2, q2, b2) {
      for (var i2 = 0; i2 < 4; ++i2) {
        sel25519(p2[i2], q2[i2], b2);
      }
    }
    function pack(r2, p2) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p2[2]);
      M2(tx, p2[0], zi);
      M2(ty, p2[1], zi);
      pack25519(r2, ty);
      r2[31] ^= par25519(tx) << 7;
    }
    function pack25519(o2, n) {
      var i2, j2, b2;
      var m2 = gf(), t = gf();
      for (i2 = 0; i2 < 16; ++i2) {
        t[i2] = n[i2];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j2 = 0; j2 < 2; ++j2) {
        m2[0] = t[0] - 65517;
        for (i2 = 1; i2 < 15; ++i2) {
          m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
          m2[i2 - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b2);
      }
      for (i2 = 0; i2 < 16; i2++) {
        o2[2 * i2] = t[i2] & 255;
        o2[2 * i2 + 1] = t[i2] >> 8;
      }
    }
    function unpackneg(r2, p2) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r2[2], gf1);
      unpack25519(r2[1], p2);
      S2(num, r2[1]);
      M2(den, num, D2);
      Z2(num, num, r2[2]);
      A2(den, r2[2], den);
      S2(den2, den);
      S2(den4, den2);
      M2(den6, den4, den2);
      M2(t, den6, num);
      M2(t, t, den);
      pow2523(t, t);
      M2(t, t, num);
      M2(t, t, den);
      M2(t, t, den);
      M2(r2[0], t, den);
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num)) {
        M2(r2[0], r2[0], I2);
      }
      S2(chk, r2[0]);
      M2(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r2[0]) === p2[31] >> 7) {
        Z2(r2[0], gf0, r2[0]);
      }
      M2(r2[3], r2[0], r2[1]);
      return 0;
    }
    function unpack25519(o2, n) {
      var i2;
      for (i2 = 0; i2 < 16; ++i2) {
        o2[i2] = n[2 * i2] + (n[2 * i2 + 1] << 8);
      }
      o2[15] &= 32767;
    }
    function pow2523(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 1) {
          M2(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function neq25519(a2, b2) {
      var c2 = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c2, a2);
      pack25519(d, b2);
      return crypto_verify_32(c2, 0, d, 0);
    }
    function crypto_verify_32(x2, xi, y2, yi) {
      return vn(x2, xi, y2, yi, 32);
    }
    function vn(x2, xi, y2, yi, n) {
      var i2, d = 0;
      for (i2 = 0; i2 < n; ++i2) {
        d |= x2[xi + i2] ^ y2[yi + i2];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a2) {
      var d = new NativeBuffer(32);
      pack25519(d, a2);
      return d[0] & 1;
    }
    function scalarmult(p2, q2, s2) {
      var b2, i2;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i2 = 255; i2 >= 0; --i2) {
        b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
        cswap(p2, q2, b2);
        add2(q2, p2);
        add2(p2, p2);
        cswap(p2, q2, b2);
      }
    }
    function scalarbase(p2, s2) {
      var q2 = [gf(), gf(), gf(), gf()];
      set25519(q2[0], X2);
      set25519(q2[1], Y2);
      set25519(q2[2], gf1);
      M2(q2[3], X2, Y2);
      scalarmult(p2, q2, s2);
    }
    function set25519(r2, a2) {
      var i2;
      for (i2 = 0; i2 < 16; i2++) {
        r2[i2] = a2[i2] | 0;
      }
    }
    function inv25519(o2, i2) {
      var c2 = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c2[a2] = i2[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S2(c2, c2);
        if (a2 !== 2 && a2 !== 4) {
          M2(c2, c2, i2);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o2[a2] = c2[a2];
      }
    }
    function car25519(o2) {
      var i2, v2, c2 = 1;
      for (i2 = 0; i2 < 16; ++i2) {
        v2 = o2[i2] + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        o2[i2] = v2 - c2 * 65536;
      }
      o2[0] += c2 - 1 + 37 * (c2 - 1);
    }
    function sel25519(p2, q2, b2) {
      var t, c2 = ~(b2 - 1);
      for (var i2 = 0; i2 < 16; ++i2) {
        t = c2 & (p2[i2] ^ q2[i2]);
        p2[i2] ^= t;
        q2[i2] ^= t;
      }
    }
    function gf(init) {
      var i2, r2 = new Float64Array(16);
      if (init) {
        for (i2 = 0; i2 < init.length; ++i2) {
          r2[i2] = init[i2];
        }
      }
      return r2;
    }
    function A2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] + b2[i2];
      }
    }
    function Z2(o2, a2, b2) {
      for (var i2 = 0; i2 < 16; ++i2) {
        o2[i2] = a2[i2] - b2[i2];
      }
    }
    function S2(o2, a2) {
      M2(o2, a2, a2);
    }
    function M2(o2, a2, b2) {
      var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      c2 = 1;
      v2 = t0 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t0 = v2 - c2 * 65536;
      v2 = t1 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t1 = v2 - c2 * 65536;
      v2 = t2 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t2 = v2 - c2 * 65536;
      v2 = t3 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t3 = v2 - c2 * 65536;
      v2 = t4 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t4 = v2 - c2 * 65536;
      v2 = t5 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t5 = v2 - c2 * 65536;
      v2 = t6 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t6 = v2 - c2 * 65536;
      v2 = t7 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t7 = v2 - c2 * 65536;
      v2 = t8 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t8 = v2 - c2 * 65536;
      v2 = t9 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t9 = v2 - c2 * 65536;
      v2 = t10 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t10 = v2 - c2 * 65536;
      v2 = t11 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t11 = v2 - c2 * 65536;
      v2 = t12 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t12 = v2 - c2 * 65536;
      v2 = t13 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t13 = v2 - c2 * 65536;
      v2 = t14 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t14 = v2 - c2 * 65536;
      v2 = t15 + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      t15 = v2 - c2 * 65536;
      t0 += c2 - 1 + 37 * (c2 - 1);
      o2[0] = t0;
      o2[1] = t1;
      o2[2] = t2;
      o2[3] = t3;
      o2[4] = t4;
      o2[5] = t5;
      o2[6] = t6;
      o2[7] = t7;
      o2[8] = t8;
      o2[9] = t9;
      o2[10] = t10;
      o2[11] = t11;
      o2[12] = t12;
      o2[13] = t13;
      o2[14] = t14;
      o2[15] = t15;
    }
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/node-forge/lib/kem.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    require_random();
    require_jsbn();
    module.exports = forge.kem = forge.kem || {};
    var BigInteger = forge.jsbn.BigInteger;
    forge.kem.rsa = {};
    forge.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength2 = Math.ceil(publicKey.n.bitLength() / 8);
        var r2;
        do {
          r2 = new BigInteger(
            forge.util.bytesToHex(prng.getBytesSync(byteLength2)),
            16
          ).mod(publicKey.n);
        } while (r2.compareTo(BigInteger.ONE) <= 0);
        r2 = forge.util.hexToBytes(r2.toString(16));
        var zeros = byteLength2 - r2.length;
        if (zeros > 0) {
          r2 = forge.util.fillString(String.fromCharCode(0), zeros) + r2;
        }
        var encapsulation = publicKey.encrypt(r2, "NONE");
        var key = kdf.generate(r2, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r2 = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r2, keyLength);
      };
      return kem;
    };
    forge.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x2, length2) {
        var key = new forge.util.ByteBuffer();
        var k2 = Math.ceil(length2 / digestLength) + counterStart;
        var c2 = new forge.util.ByteBuffer();
        for (var i2 = counterStart; i2 < k2; ++i2) {
          c2.putInt32(i2);
          md.start();
          md.update(x2 + c2.getBytes());
          var hash2 = md.digest();
          key.putBytes(hash2.getBytes(digestLength));
        }
        key.truncate(key.length() - length2);
        return key.getBytes();
      };
    }
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/node-forge/lib/log.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_util();
    module.exports = forge.log = forge.log || {};
    forge.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge.log.LEVEL_LOCKED = 1 << 1;
    forge.log.NO_LEVEL_CHECK = 1 << 2;
    forge.log.INTERPOLATE = 1 << 3;
    for (i2 = 0; i2 < forge.log.levels.length; ++i2) {
      level = forge.log.levels[i2];
      sLevelInfo[level] = {
        index: i2,
        name: level.toUpperCase()
      };
    }
    var level;
    var i2;
    forge.log.logMessage = function(message) {
      var messageLevelIndex = sLevelInfo[message.level].index;
      for (var i3 = 0; i3 < sLoggers.length; ++i3) {
        var logger2 = sLoggers[i3];
        if (logger2.flags & forge.log.NO_LEVEL_CHECK) {
          logger2.f(message);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message);
          }
        }
      }
    };
    forge.log.prepareStandard = function(message) {
      if (!("standard" in message)) {
        message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
        " [" + message.category + "] " + message.message;
      }
    };
    forge.log.prepareFull = function(message) {
      if (!("full" in message)) {
        var args = [message.message];
        args = args.concat([]);
        message.full = forge.util.format.apply(this, args);
      }
    };
    forge.log.prepareStandardFull = function(message) {
      if (!("standardFull" in message)) {
        forge.log.prepareStandard(message);
        message.standardFull = message.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i2 = 0; i2 < levels.length; ++i2) {
        (function(level2) {
          forge.log[level2] = function(category, message) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge.log.logMessage(msg);
          };
        })(levels[i2]);
      }
    }
    var levels;
    var i2;
    forge.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge.log.setLevel(logger2, "none");
      return logger2;
    };
    forge.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge.log.LEVEL_LOCKED)) {
        for (var i3 = 0; i3 < forge.log.levels.length; ++i3) {
          var aValidLevel = forge.log.levels[i3];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge.log.LEVEL_LOCKED;
      }
    };
    forge.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f2 = function(logger2, message) {
          forge.log.prepareStandard(message);
          var handler = levelHandlers[message.level];
          var args = [message.standard];
          args = args.concat(message["arguments"].slice());
          handler.apply(console, args);
        };
        logger = forge.log.makeLogger(f2);
      } else {
        f2 = function(logger2, message) {
          forge.log.prepareStandardFull(message);
          console.log(message.standardFull);
        };
        logger = forge.log.makeLogger(f2);
      }
      forge.log.setLevel(logger, "debug");
      forge.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: function() {
        }
      };
    }
    var logger;
    var levelHandlers;
    var f2;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/node-forge/lib/md.all.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = require_md();
    require_md52();
    require_sha12();
    require_sha256();
    require_sha512();
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge.asn1;
    var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i2 = 0; i2 < certs.length; ++i2) {
              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i2]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i2 = 0; i2 < msg.certificates.length; ++i2) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i2]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        },
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i2 = 0; i2 < authenticatedAttributes.length; ++i2) {
              var attr = authenticatedAttributes[i2];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i2 = 0; i2 < msg.signers.length; ++i2) {
          var signer = msg.signers[i2];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        },
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var r2 = msg.recipients[i2];
            var rAttr = r2.issuer;
            if (r2.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match2 = true;
            for (var j2 = 0; j2 < sAttr.length; ++j2) {
              if (rAttr[j2].type !== sAttr[j2].type || rAttr[j2].value !== sAttr[j2].value) {
                match2 = false;
                break;
              }
            }
            if (match2) {
              return r2;
            }
          }
          return null;
        },
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(
              forge.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i2 = 0; i2 < msg.recipients.length; ++i2) {
            var recipient = msg.recipients[i2];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i2 = 0; i2 < infos.length; ++i2) {
        ret.push(_recipientFromAsn1(infos[i2]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i2 = 0; i2 < recipients.length; ++i2) {
        ret.push(_recipientToAsn1(recipients[i2]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i2 = 0; i2 < obj.unauthenticatedAttributes.length; ++i2) {
          var attr = obj.unauthenticatedAttributes[i2];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i2 = 0; i2 < signers.length; ++i2) {
        ret.push(_signerToAsn1(signers[i2]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i2 = 0; i2 < capture.encryptedContent.length; ++i2) {
            if (capture.encryptedContent[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i2].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge.util.isArray(capture.content)) {
          for (var i2 = 0; i2 < capture.content.length; ++i2) {
            if (capture.content[i2].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i2].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids["aes128-CBC"]:
          case forge.pki.oids["aes192-CBC"]:
          case forge.pki.oids["aes256-CBC"]:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids["desCBC"]:
          case forge.pki.oids["des-EDE3-CBC"]:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/node-forge/lib/ssh.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var forge = require_forge();
    require_aes();
    require_hmac();
    require_md52();
    require_sha12();
    require_util();
    var ssh = module.exports = forge.ssh = forge.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment2) {
      comment2 = comment2 || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment2 + "\r\n";
      var pubbuffer = forge.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge.util.encode64(pubbuffer.bytes(), 64);
      var length2 = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length2 + "\r\n";
      ppk += pub;
      var privbuffer = forge.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge.util.encode64(encrypted.bytes(), 64);
      }
      length2 = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length2 + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment2);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment2) {
      var type = "ssh-rsa";
      comment2 = comment2 || "";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment2;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge.pki.privateKeyToPem(privateKey);
      }
      return forge.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.md5.create();
      var type = "ssh-rsa";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex2 = digest.toHex();
        if (options.delimiter) {
          return hex2.match(/.{2}/g).join(options.delimiter);
        }
        return hex2;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes = forge.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    function _sha1() {
      var sha = forge.md.sha1.create();
      var num = arguments.length;
      for (var i2 = 0; i2 < num; ++i2) {
        sha.update(arguments[i2]);
      }
      return sha.digest();
    }
  }
});

// node_modules/node-forge/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-forge/lib/index.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls();
    require_util();
  }
});

// node_modules/tslib/tslib.es6.mjs
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
var import_dist7, import_dist8, import_dist9, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    import_dist7 = __toESM(require_dist(), 1);
    import_dist8 = __toESM(require_dist2(), 1);
    import_dist9 = __toESM(require_dist3(), 1);
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var import_dist10, import_dist11, import_dist12;
var init_emotion_memoize_esm = __esm({
  "node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
    import_dist10 = __toESM(require_dist());
    import_dist11 = __toESM(require_dist2());
    import_dist12 = __toESM(require_dist3());
  }
});

// node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var import_dist13, import_dist14, import_dist15, reactPropsRegex, isPropValid;
var init_emotion_is_prop_valid_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
    import_dist13 = __toESM(require_dist());
    import_dist14 = __toESM(require_dist2());
    import_dist15 = __toESM(require_dist3());
    init_emotion_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    isPropValid = memoize(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    module.exports = function shallowEqual(objA, objB, compare2, compareContext) {
      var ret = compare2 ? compare2.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare2 ? compare2.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/stylis/src/Enum.js
var import_dist16, import_dist17, import_dist18, MS, MOZ, WEBKIT, COMMENT, RULESET, DECLARATION, IMPORT, KEYFRAMES, LAYER;
var init_Enum = __esm({
  "node_modules/stylis/src/Enum.js"() {
    import_dist16 = __toESM(require_dist(), 1);
    import_dist17 = __toESM(require_dist2(), 1);
    import_dist18 = __toESM(require_dist3(), 1);
    MS = "-ms-";
    MOZ = "-moz-";
    WEBKIT = "-webkit-";
    COMMENT = "comm";
    RULESET = "rule";
    DECLARATION = "decl";
    IMPORT = "@import";
    KEYFRAMES = "@keyframes";
    LAYER = "@layer";
  }
});

// node_modules/stylis/src/Utility.js
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}
var import_dist19, import_dist20, import_dist21, abs2, from, assign;
var init_Utility = __esm({
  "node_modules/stylis/src/Utility.js"() {
    import_dist19 = __toESM(require_dist(), 1);
    import_dist20 = __toESM(require_dist2(), 1);
    import_dist21 = __toESM(require_dist3(), 1);
    abs2 = Math.abs;
    from = String.fromCharCode;
    assign = Object.assign;
  }
});

// node_modules/stylis/src/Tokenizer.js
function node(value, root, parent, type, props, children, length2, siblings) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev2() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
var import_dist22, import_dist23, import_dist24, line, column, length, position, character, characters;
var init_Tokenizer = __esm({
  "node_modules/stylis/src/Tokenizer.js"() {
    import_dist22 = __toESM(require_dist(), 1);
    import_dist23 = __toESM(require_dist2(), 1);
    import_dist24 = __toESM(require_dist3(), 1);
    init_Utility();
    line = 1;
    column = 1;
    length = 0;
    position = 0;
    character = 0;
    characters = "";
  }
});

// node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs2(index ? points[index - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev2() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs2(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
var import_dist25, import_dist26, import_dist27;
var init_Parser = __esm({
  "node_modules/stylis/src/Parser.js"() {
    import_dist25 = __toESM(require_dist(), 1);
    import_dist26 = __toESM(require_dist2(), 1);
    import_dist27 = __toESM(require_dist3(), 1);
    init_Enum();
    init_Utility();
    init_Tokenizer();
  }
});

// node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length2 = index, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b2, c2, d, e2, f2) {
        return MS + a2 + ":" + b2 + f2 + (c2 ? MS + a2 + "-span:" + (d ? e2 : +e2 - +b2) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
var import_dist28, import_dist29, import_dist30;
var init_Prefixer = __esm({
  "node_modules/stylis/src/Prefixer.js"() {
    import_dist28 = __toESM(require_dist(), 1);
    import_dist29 = __toESM(require_dist2(), 1);
    import_dist30 = __toESM(require_dist3(), 1);
    init_Enum();
    init_Utility();
  }
});

// node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
var import_dist31, import_dist32, import_dist33;
var init_Serializer = __esm({
  "node_modules/stylis/src/Serializer.js"() {
    import_dist31 = __toESM(require_dist(), 1);
    import_dist32 = __toESM(require_dist2(), 1);
    import_dist33 = __toESM(require_dist3(), 1);
    init_Enum();
    init_Utility();
  }
});

// node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}
var import_dist34, import_dist35, import_dist36;
var init_Middleware = __esm({
  "node_modules/stylis/src/Middleware.js"() {
    import_dist34 = __toESM(require_dist(), 1);
    import_dist35 = __toESM(require_dist2(), 1);
    import_dist36 = __toESM(require_dist3(), 1);
    init_Enum();
    init_Utility();
    init_Tokenizer();
    init_Serializer();
    init_Prefixer();
  }
});

// node_modules/stylis/index.js
var import_dist37, import_dist38, import_dist39;
var init_stylis = __esm({
  "node_modules/stylis/index.js"() {
    import_dist37 = __toESM(require_dist());
    import_dist38 = __toESM(require_dist2());
    import_dist39 = __toESM(require_dist3());
    init_Enum();
    init_Utility();
    init_Parser();
    init_Prefixer();
    init_Tokenizer();
    init_Serializer();
    init_Middleware();
  }
});

// node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var import_dist40, import_dist41, import_dist42, unitlessKeys;
var init_emotion_unitless_esm = __esm({
  "node_modules/@emotion/unitless/dist/emotion-unitless.esm.js"() {
    import_dist40 = __toESM(require_dist());
    import_dist41 = __toESM(require_dist2());
    import_dist42 = __toESM(require_dist3());
    unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
  }
});

// node_modules/styled-components/dist/styled-components.browser.esm.js
var styled_components_browser_esm_exports = {};
__export(styled_components_browser_esm_exports, {
  ServerStyleSheet: () => vt,
  StyleSheetConsumer: () => Be,
  StyleSheetContext: () => $e,
  StyleSheetManager: () => Ye,
  ThemeConsumer: () => tt,
  ThemeContext: () => et,
  ThemeProvider: () => ot,
  __PRIVATE__: () => gt2,
  createGlobalStyle: () => ft,
  css: () => lt2,
  default: () => dt,
  isStyledComponent: () => se,
  keyframes: () => mt,
  styled: () => dt,
  useTheme: () => nt,
  version: () => v,
  withTheme: () => yt
});
function I(e2, t, n) {
  return void 0 === n && (n = C), e2.theme !== n.theme && e2.theme || t || n.theme;
}
function R(e2) {
  return e2.replace(O, "-").replace(D, "");
}
function x(e2) {
  var t, n = "";
  for (t = Math.abs(e2); t > k; t = t / k | 0) n = j(t % k) + n;
  return (j(t % k) + n).replace(T, "$1-$2");
}
function $(e2) {
  return x(z(e2) >>> 0);
}
function B(e2) {
  return "production" !== process.env.NODE_ENV && "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
}
function L(e2) {
  return "string" == typeof e2 && ("production" === process.env.NODE_ENV || e2.charAt(0) === e2.charAt(0).toLowerCase());
}
function X(e2) {
  return ("type" in (t = e2) && t.type.$$typeof) === Y ? U : "$$typeof" in e2 ? J[e2.$$typeof] : q;
  var t;
}
function oe(e2, t, n) {
  if ("string" != typeof t) {
    if (ne) {
      var o2 = te(t);
      o2 && o2 !== ne && oe(e2, o2, n);
    }
    var r2 = K(t);
    Q && (r2 = r2.concat(Q(t)));
    for (var s2 = X(e2), i2 = X(t), a2 = 0; a2 < r2.length; ++a2) {
      var c2 = r2[a2];
      if (!(c2 in H || n && n[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
        var l2 = ee(t, c2);
        try {
          Z(e2, c2, l2);
        } catch (e3) {
        }
      }
    }
  }
  return e2;
}
function re(e2) {
  return "function" == typeof e2;
}
function se(e2) {
  return "object" == typeof e2 && "styledComponentId" in e2;
}
function ie(e2, t) {
  return e2 && t ? "".concat(e2, " ").concat(t) : e2 || t || "";
}
function ae(e2, t) {
  if (0 === e2.length) return "";
  for (var n = e2[0], o2 = 1; o2 < e2.length; o2++) n += t ? t + e2[o2] : e2[o2];
  return n;
}
function ce(e2) {
  return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function le(e2, t, n) {
  if (void 0 === n && (n = false), !n && !ce(e2) && !Array.isArray(e2)) return t;
  if (Array.isArray(t)) for (var o2 = 0; o2 < t.length; o2++) e2[o2] = le(e2[o2], t[o2]);
  else if (ce(t)) for (var o2 in t) e2[o2] = le(e2[o2], t[o2]);
  return e2;
}
function ue(e2, t) {
  Object.defineProperty(e2, "toString", { value: t });
}
function de() {
  for (var e2 = [], t = 0; t < arguments.length; t++) e2[t] = arguments[t];
  for (var n = e2[0], o2 = [], r2 = 1, s2 = e2.length; r2 < s2; r2 += 1) o2.push(e2[r2]);
  return o2.forEach(function(e3) {
    n = n.replace(/%[a-z]/, e3);
  }), n;
}
function he(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  return "production" === process.env.NODE_ENV ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de.apply(void 0, __spreadArray([pe[t]], n, false)).trim());
}
function Ce() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
function Ve(e2, t) {
  return e2.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Ve(e3.children, t)), e3;
  });
}
function Fe(e2) {
  var t, n, o2, r2 = void 0 === e2 ? C : e2, s2 = r2.options, i2 = void 0 === s2 ? C : s2, a2 = r2.plugins, c2 = void 0 === a2 ? _ : a2, l2 = function(e3, o3, r3) {
    return r3.startsWith(n) && r3.endsWith(n) && r3.replaceAll(n, "").length > 0 ? ".".concat(t) : e3;
  }, u2 = c2.slice();
  u2.push(function(e3) {
    e3.type === RULESET && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(je, n).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e3, r3, s3, a3) {
    void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t = a3, n = r3, o2 = new RegExp("\\".concat(n, "\\b"), "g");
    var c3 = e3.replace(xe, ""), l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e4) {
      return p3.push(e4);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e3, t2) {
    return t2.name || he(15), M(e3, t2.name);
  }, F).toString() : "", p2;
}
function Ge() {
  return (0, import_react.useContext)($e);
}
function Ye(e2) {
  var t = (0, import_react.useState)(e2.stylisPlugins), n = t[0], r2 = t[1], c2 = Ge().styleSheet, l2 = (0, import_react.useMemo)(function() {
    var t2 = c2;
    return e2.sheet ? t2 = e2.sheet : e2.target && (t2 = t2.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t2 = t2.reconstructWithOptions({ useCSSOMInjection: false })), t2;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target, c2]), u2 = (0, import_react.useMemo)(function() {
    return Fe({ options: { namespace: e2.namespace, prefix: e2.enableVendorPrefixes }, plugins: n });
  }, [e2.enableVendorPrefixes, e2.namespace, n]);
  (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n, e2.stylisPlugins) || r2(e2.stylisPlugins);
  }, [e2.stylisPlugins]);
  var d = (0, import_react.useMemo)(function() {
    return { shouldForwardProp: e2.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e2.shouldForwardProp, l2, u2]);
  return import_react.default.createElement($e.Provider, { value: d }, import_react.default.createElement(Le.Provider, { value: u2 }, e2.children));
}
function He(e2) {
  for (var t = "", n = 0; n < e2.length; n++) {
    var o2 = e2[n];
    if (1 === n && "-" === o2 && "-" === e2[0]) return e2;
    qe(o2) ? t += "-" + o2.toLowerCase() : t += o2;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
function Xe(e2, t, n, o2) {
  if (Ue(e2)) return [];
  if (se(e2)) return [".".concat(e2.styledComponentId)];
  if (re(e2)) {
    if (!re(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t) return [e2];
    var r2 = e2(t);
    return "production" === process.env.NODE_ENV || "object" != typeof r2 || Array.isArray(r2) || r2 instanceof We || ce(r2) || null === r2 || console.error("".concat(B(e2), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(r2, t, n, o2);
  }
  var s2;
  return e2 instanceof We ? n ? (e2.inject(n, o2), [e2.getName(o2)]) : [e2] : ce(e2) ? Je(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(_, e2.map(function(e3) {
    return Xe(e3, t, n, o2);
  })) : [e2.toString()];
}
function Ze(e2) {
  for (var t = 0; t < e2.length; t += 1) {
    var n = e2[t];
    if (re(n) && !se(n)) return false;
  }
  return true;
}
function nt() {
  var e2 = (0, import_react.useContext)(et);
  if (!e2) throw he(18);
  return e2;
}
function ot(e2) {
  var n = import_react.default.useContext(et), r2 = (0, import_react.useMemo)(function() {
    return function(e3, n2) {
      if (!e3) throw he(14);
      if (re(e3)) {
        var o2 = e3(n2);
        if ("production" !== process.env.NODE_ENV && (null === o2 || Array.isArray(o2) || "object" != typeof o2)) throw he(7);
        return o2;
      }
      if (Array.isArray(e3) || "object" != typeof e3) throw he(8);
      return n2 ? __assign(__assign({}, n2), e3) : e3;
    }(e2.theme, n);
  }, [e2.theme, n]);
  return e2.children ? import_react.default.createElement(et.Provider, { value: r2 }, e2.children) : null;
}
function it(e2, r2, s2) {
  var i2 = se(e2), a2 = e2, c2 = !L(e2), p2 = r2.attrs, d = void 0 === p2 ? _ : p2, h = r2.componentId, f2 = void 0 === h ? function(e3, t) {
    var n = "string" != typeof e3 ? "sc" : R(e3);
    rt[n] = (rt[n] || 0) + 1;
    var o2 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t ? "".concat(t, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h, m2 = r2.displayName, y2 = void 0 === m2 ? function(e3) {
    return L(e3) ? "styled.".concat(e3) : "Styled(".concat(B(e3), ")");
  }(e2) : m2, g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, S2 = i2 && a2.attrs ? a2.attrs.concat(d).filter(Boolean) : d, w2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var b2 = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var E2 = r2.shouldForwardProp;
      w2 = function(e3, t) {
        return b2(e3, t) && E2(e3, t);
      };
    } else w2 = b2;
  }
  var N2 = new Qe(s2, g2, i2 ? a2.componentStyle : void 0);
  function O2(e3, r3) {
    return function(e4, r4, s3) {
      var i3 = e4.attrs, a3 = e4.componentStyle, c3 = e4.defaultProps, p3 = e4.foldedComponentIds, d2 = e4.styledComponentId, h2 = e4.target, f3 = import_react.default.useContext(et), m3 = Ge(), y3 = e4.shouldForwardProp || m3.shouldForwardProp;
      "production" !== process.env.NODE_ENV && (0, import_react.useDebugValue)(d2);
      var v2 = I(r4, f3, c3) || C, g3 = function(e5, n, o2) {
        for (var r5, s4 = __assign(__assign({}, n), { className: void 0, theme: o2 }), i4 = 0; i4 < e5.length; i4 += 1) {
          var a4 = re(r5 = e5[i4]) ? r5(s4) : r5;
          for (var c4 in a4) s4[c4] = "className" === c4 ? ie(s4[c4], a4[c4]) : "style" === c4 ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
        }
        return n.className && (s4.className = ie(s4.className, n.className)), s4;
      }(i3, r4, v2), S3 = g3.as || h2, w3 = {};
      for (var b3 in g3) void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v2 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y3 && !y3(b3, S3) || (w3[b3] = g3[b3], y3 || "development" !== process.env.NODE_ENV || isPropValid(b3) || st.has(b3) || !A.has(S3) || (st.add(b3), console.warn('styled-components: it looks like an unknown prop "'.concat(b3, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E3 = function(e5, t) {
        var n = Ge(), o2 = e5.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return "production" !== process.env.NODE_ENV && (0, import_react.useDebugValue)(o2), o2;
      }(a3, g3);
      "production" !== process.env.NODE_ENV && e4.warnTooManyClasses && e4.warnTooManyClasses(E3);
      var N3 = ie(p3, d2);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, w3.ref = s3, (0, import_react.createElement)(S3, w3);
    }(D2, e3, r3);
  }
  O2.displayName = y2;
  var D2 = import_react.default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e2, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = i2 ? function(e4) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      for (var o2 = 0, r3 = t; o2 < r3.length; o2++) le(e4, r3[o2], true);
      return e4;
    }({}, a2.defaultProps, e3) : e3;
  } }), "production" !== process.env.NODE_ENV && (P(y2, g2), D2.warnTooManyClasses = /* @__PURE__ */ function(e3, t) {
    var n = {}, o2 = false;
    return function(r3) {
      if (!o2 && (n[r3] = true, Object.keys(n).length >= 200)) {
        var s3 = t ? ' with the id of "'.concat(t, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e3).concat(s3, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o2 = true, n = {};
      }
    };
  }(y2, g2)), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && oe(D2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function at(e2, t) {
  for (var n = [e2[0]], o2 = 0, r2 = t.length; o2 < r2; o2 += 1) n.push(t[o2], e2[o2 + 1]);
  return n;
}
function lt2(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  if (re(t) || ce(t)) return ct(Xe(at(_, __spreadArray([t], n, true))));
  var r2 = t;
  return 0 === n.length && 1 === r2.length && "string" == typeof r2[0] ? Xe(r2) : ct(Xe(at(r2, n)));
}
function ut(n, o2, r2) {
  if (void 0 === r2 && (r2 = C), !o2) throw he(1, o2);
  var s2 = function(t) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
    return n(o2, r2, lt2.apply(void 0, __spreadArray([t], s3, false)));
  };
  return s2.attrs = function(e2) {
    return ut(n, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean) }));
  }, s2.withConfig = function(e2) {
    return ut(n, o2, __assign(__assign({}, r2), e2));
  }, s2;
}
function ft(n) {
  for (var r2 = [], s2 = 1; s2 < arguments.length; s2++) r2[s2 - 1] = arguments[s2];
  var i2 = lt2.apply(void 0, __spreadArray([n], r2, false)), a2 = "sc-global-".concat($(JSON.stringify(i2))), c2 = new ht(i2, a2);
  "production" !== process.env.NODE_ENV && P(a2);
  var l2 = function(e2) {
    var t = Ge(), n2 = import_react.default.useContext(et), r3 = import_react.default.useRef(t.styleSheet.allocateGSInstance(a2)).current;
    return "production" !== process.env.NODE_ENV && import_react.default.Children.count(e2.children) && console.warn("The global style component ".concat(a2, " was given child JSX. createGlobalStyle does not render children.")), "production" !== process.env.NODE_ENV && i2.some(function(e3) {
      return "string" == typeof e3 && -1 !== e3.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t.styleSheet.server && u2(r3, e2, t.styleSheet, n2, t.stylis), import_react.default.useLayoutEffect(function() {
      if (!t.styleSheet.server) return u2(r3, e2, t.styleSheet, n2, t.stylis), function() {
        return c2.removeStyles(r3, t.styleSheet);
      };
    }, [r3, e2, t.styleSheet, n2, t.stylis]), null;
  };
  function u2(e2, n2, o2, r3, s3) {
    if (c2.isStatic) c2.renderStyles(e2, b, o2, s3);
    else {
      var i3 = __assign(__assign({}, n2), { theme: I(n2, r3, l2.defaultProps) });
      c2.renderStyles(e2, i3, o2, s3);
    }
  }
  return import_react.default.memo(l2);
}
function mt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var r2 = ae(lt2.apply(void 0, __spreadArray([t], n, false))), s2 = $(r2);
  return new We(s2, r2);
}
function yt(e2) {
  var n = import_react.default.forwardRef(function(n2, r2) {
    var s2 = I(n2, import_react.default.useContext(et), e2.defaultProps);
    return "production" !== process.env.NODE_ENV && void 0 === s2 && console.warn('[withTheme] You are not using a ThemeProvider nor passing a theme prop or a theme in defaultProps in component class "'.concat(B(e2), '"')), import_react.default.createElement(e2, __assign({}, n2, { theme: s2, ref: r2 }));
  });
  return n.displayName = "WithTheme(".concat(B(e2), ")"), oe(n, e2);
}
var import_dist43, import_dist44, import_dist45, import_react, import_shallowequal, f, m, y, v, g, S, w, b, E, N, P, _, C, A, O, D, T, k, j, V, F, M, z, G, Y, W, q, H, U, J, Z, K, Q, ee, te, ne, pe, fe, me, ye, ve, ge, Se, we, be, Ee, Ne, Pe, _e, Ie, Ae, Oe, De, Re, Te, ke, je, xe, Me, ze, $e, Be, Le, We, qe, Ue, Je, Ke, Qe, et, tt, rt, st, ct, pt, dt, ht, vt, gt2, St;
var init_styled_components_browser_esm = __esm({
  "node_modules/styled-components/dist/styled-components.browser.esm.js"() {
    import_dist43 = __toESM(require_dist());
    import_dist44 = __toESM(require_dist2());
    import_dist45 = __toESM(require_dist3());
    init_tslib_es6();
    init_emotion_is_prop_valid_esm();
    import_react = __toESM(require_react());
    import_shallowequal = __toESM(require_shallowequal());
    init_stylis();
    init_emotion_unitless_esm();
    f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
    m = "active";
    y = "data-styled-version";
    v = "6.1.12";
    g = "/*!sc*/\n";
    S = "undefined" != typeof window && "HTMLElement" in window;
    w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : "production" !== process.env.NODE_ENV);
    b = {};
    E = /invalid hook call/i;
    N = /* @__PURE__ */ new Set();
    P = function(t, n) {
      if ("production" !== process.env.NODE_ENV) {
        var o2 = n ? ' with the id of "'.concat(n, '"') : "", s2 = "The component ".concat(t).concat(o2, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", i2 = console.error;
        try {
          var a2 = true;
          console.error = function(t2) {
            for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
            E.test(t2) ? (a2 = false, N.delete(s2)) : i2.apply(void 0, __spreadArray([t2], n2, false));
          }, (0, import_react.useRef)(), a2 && !N.has(s2) && (console.warn(s2), N.add(s2));
        } catch (e2) {
          E.test(e2.message) && N.delete(s2);
        } finally {
          console.error = i2;
        }
      }
    };
    _ = Object.freeze([]);
    C = Object.freeze({});
    A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
    O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
    D = /(^-|-$)/g;
    T = /(a)(d)/gi;
    k = 52;
    j = function(e2) {
      return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
    };
    F = 5381;
    M = function(e2, t) {
      for (var n = t.length; n; ) e2 = 33 * e2 ^ t.charCodeAt(--n);
      return e2;
    };
    z = function(e2) {
      return M(F, e2);
    };
    G = "function" == typeof Symbol && Symbol.for;
    Y = G ? Symbol.for("react.memo") : 60115;
    W = G ? Symbol.for("react.forward_ref") : 60112;
    q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
    H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
    U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
    J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
    Z = Object.defineProperty;
    K = Object.getOwnPropertyNames;
    Q = Object.getOwnPropertySymbols;
    ee = Object.getOwnPropertyDescriptor;
    te = Object.getPrototypeOf;
    ne = Object.prototype;
    pe = "production" !== process.env.NODE_ENV ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
    fe = function() {
      function e2(e3) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
      }
      return e2.prototype.indexOfGroup = function(e3) {
        for (var t = 0, n = 0; n < e3; n++) t += this.groupSizes[n];
        return t;
      }, e2.prototype.insertRules = function(e3, t) {
        if (e3 >= this.groupSizes.length) {
          for (var n = this.groupSizes, o2 = n.length, r2 = o2; e3 >= r2; ) if ((r2 <<= 1) < 0) throw he(16, "".concat(e3));
          this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n), this.length = r2;
          for (var s2 = o2; s2 < r2; s2++) this.groupSizes[s2] = 0;
        }
        for (var i2 = this.indexOfGroup(e3 + 1), a2 = (s2 = 0, t.length); s2 < a2; s2++) this.tag.insertRule(i2, t[s2]) && (this.groupSizes[e3]++, i2++);
      }, e2.prototype.clearGroup = function(e3) {
        if (e3 < this.length) {
          var t = this.groupSizes[e3], n = this.indexOfGroup(e3), o2 = n + t;
          this.groupSizes[e3] = 0;
          for (var r2 = n; r2 < o2; r2++) this.tag.deleteRule(n);
        }
      }, e2.prototype.getGroup = function(e3) {
        var t = "";
        if (e3 >= this.length || 0 === this.groupSizes[e3]) return t;
        for (var n = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r2 = o2 + n, s2 = o2; s2 < r2; s2++) t += "".concat(this.tag.getRule(s2)).concat(g);
        return t;
      }, e2;
    }();
    me = 1 << 30;
    ye = /* @__PURE__ */ new Map();
    ve = /* @__PURE__ */ new Map();
    ge = 1;
    Se = function(e2) {
      if (ye.has(e2)) return ye.get(e2);
      for (; ve.has(ge); ) ge++;
      var t = ge++;
      if ("production" !== process.env.NODE_ENV && ((0 | t) < 0 || t > me)) throw he(16, "".concat(t));
      return ye.set(e2, t), ve.set(t, e2), t;
    };
    we = function(e2, t) {
      ge = t + 1, ye.set(e2, t), ve.set(t, e2);
    };
    be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]');
    Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
    Ne = function(e2, t, n) {
      for (var o2, r2 = n.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++) (o2 = r2[s2]) && e2.registerName(t, o2);
    };
    Pe = function(e2, t) {
      for (var n, o2 = (null !== (n = t.textContent) && void 0 !== n ? n : "").split(g), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
        var a2 = o2[s2].trim();
        if (a2) {
          var c2 = a2.match(Ee);
          if (c2) {
            var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
            0 !== l2 && (we(u2, l2), Ne(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
          } else r2.push(a2);
        }
      }
    };
    _e = function(e2) {
      for (var t = document.querySelectorAll(be), n = 0, o2 = t.length; n < o2; n++) {
        var r2 = t[n];
        r2 && r2.getAttribute(f) !== m && (Pe(e2, r2), r2.parentNode && r2.parentNode.removeChild(r2));
      }
    };
    Ie = function(e2) {
      var t = document.head, n = e2 || t, o2 = document.createElement("style"), r2 = function(e3) {
        var t2 = Array.from(e3.querySelectorAll("style[".concat(f, "]")));
        return t2[t2.length - 1];
      }(n), s2 = void 0 !== r2 ? r2.nextSibling : null;
      o2.setAttribute(f, m), o2.setAttribute(y, v);
      var i2 = Ce();
      return i2 && o2.setAttribute("nonce", i2), n.insertBefore(o2, s2), o2;
    };
    Ae = function() {
      function e2(e3) {
        this.element = Ie(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
          if (e4.sheet) return e4.sheet;
          for (var t = document.styleSheets, n = 0, o2 = t.length; n < o2; n++) {
            var r2 = t[n];
            if (r2.ownerNode === e4) return r2;
          }
          throw he(17);
        }(this.element), this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t) {
        try {
          return this.sheet.insertRule(t, e3), this.length++, true;
        } catch (e4) {
          return false;
        }
      }, e2.prototype.deleteRule = function(e3) {
        this.sheet.deleteRule(e3), this.length--;
      }, e2.prototype.getRule = function(e3) {
        var t = this.sheet.cssRules[e3];
        return t && t.cssText ? t.cssText : "";
      }, e2;
    }();
    Oe = function() {
      function e2(e3) {
        this.element = Ie(e3), this.nodes = this.element.childNodes, this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t) {
        if (e3 <= this.length && e3 >= 0) {
          var n = document.createTextNode(t);
          return this.element.insertBefore(n, this.nodes[e3] || null), this.length++, true;
        }
        return false;
      }, e2.prototype.deleteRule = function(e3) {
        this.element.removeChild(this.nodes[e3]), this.length--;
      }, e2.prototype.getRule = function(e3) {
        return e3 < this.length ? this.nodes[e3].textContent : "";
      }, e2;
    }();
    De = function() {
      function e2(e3) {
        this.rules = [], this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t) {
        return e3 <= this.length && (this.rules.splice(e3, 0, t), this.length++, true);
      }, e2.prototype.deleteRule = function(e3) {
        this.rules.splice(e3, 1), this.length--;
      }, e2.prototype.getRule = function(e3) {
        return e3 < this.length ? this.rules[e3] : "";
      }, e2;
    }();
    Re = S;
    Te = { isServer: !S, useCSSOMInjection: !w };
    ke = function() {
      function e2(e3, n, o2) {
        void 0 === e3 && (e3 = C), void 0 === n && (n = {});
        var r2 = this;
        this.options = __assign(__assign({}, Te), e3), this.gs = n, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
          return function(e4) {
            for (var t = e4.getTag(), n2 = t.length, o3 = "", r3 = function(n3) {
              var r4 = function(e5) {
                return ve.get(e5);
              }(n3);
              if (void 0 === r4) return "continue";
              var s3 = e4.names.get(r4), i2 = t.getGroup(n3);
              if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
              var a2 = "".concat(f, ".g").concat(n3, '[id="').concat(r4, '"]'), c2 = "";
              void 0 !== s3 && s3.forEach(function(e5) {
                e5.length > 0 && (c2 += "".concat(e5, ","));
              }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat(g);
            }, s2 = 0; s2 < n2; s2++) r3(s2);
            return o3;
          }(r2);
        });
      }
      return e2.registerId = function(e3) {
        return Se(e3);
      }, e2.prototype.rehydrate = function() {
        !this.server && S && _e(this);
      }, e2.prototype.reconstructWithOptions = function(n, o2) {
        return void 0 === o2 && (o2 = true), new e2(__assign(__assign({}, this.options), n), this.gs, o2 && this.names || void 0);
      }, e2.prototype.allocateGSInstance = function(e3) {
        return this.gs[e3] = (this.gs[e3] || 0) + 1;
      }, e2.prototype.getTag = function() {
        return this.tag || (this.tag = (e3 = function(e4) {
          var t = e4.useCSSOMInjection, n = e4.target;
          return e4.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
        }(this.options), new fe(e3)));
        var e3;
      }, e2.prototype.hasNameForId = function(e3, t) {
        return this.names.has(e3) && this.names.get(e3).has(t);
      }, e2.prototype.registerName = function(e3, t) {
        if (Se(e3), this.names.has(e3)) this.names.get(e3).add(t);
        else {
          var n = /* @__PURE__ */ new Set();
          n.add(t), this.names.set(e3, n);
        }
      }, e2.prototype.insertRules = function(e3, t, n) {
        this.registerName(e3, t), this.getTag().insertRules(Se(e3), n);
      }, e2.prototype.clearNames = function(e3) {
        this.names.has(e3) && this.names.get(e3).clear();
      }, e2.prototype.clearRules = function(e3) {
        this.getTag().clearGroup(Se(e3)), this.clearNames(e3);
      }, e2.prototype.clearTag = function() {
        this.tag = void 0;
      }, e2;
    }();
    je = /&/g;
    xe = /^\s*\/\/.*$/gm;
    Me = new ke();
    ze = Fe();
    $e = import_react.default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
    Be = $e.Consumer;
    Le = import_react.default.createContext(void 0);
    We = function() {
      function e2(e3, t) {
        var n = this;
        this.inject = function(e4, t2) {
          void 0 === t2 && (t2 = ze);
          var o2 = n.name + t2.hash;
          e4.hasNameForId(n.id, o2) || e4.insertRules(n.id, o2, t2(n.rules, o2, "@keyframes"));
        }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t, ue(this, function() {
          throw he(12, String(n.name));
        });
      }
      return e2.prototype.getName = function(e3) {
        return void 0 === e3 && (e3 = ze), this.name + e3.hash;
      }, e2;
    }();
    qe = function(e2) {
      return e2 >= "A" && e2 <= "Z";
    };
    Ue = function(e2) {
      return null == e2 || false === e2 || "" === e2;
    };
    Je = function(t) {
      var n, o2, r2 = [];
      for (var s2 in t) {
        var i2 = t[s2];
        t.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r2.push("".concat(He(s2), ": ").concat((n = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n in unitlessKeys || n.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
      }
      return r2;
    };
    Ke = z(v);
    Qe = function() {
      function e2(e3, t, n) {
        this.rules = e3, this.staticRulesId = "", this.isStatic = "production" === process.env.NODE_ENV && (void 0 === n || n.isStatic) && Ze(e3), this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
      }
      return e2.prototype.generateAndInjectStyles = function(e3, t, n) {
        var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t, n) : "";
        if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) o2 = ie(o2, this.staticRulesId);
        else {
          var r2 = ae(Xe(this.rules, e3, t, n)), s2 = x(M(this.baseHash, r2) >>> 0);
          if (!t.hasNameForId(this.componentId, s2)) {
            var i2 = n(r2, ".".concat(s2), void 0, this.componentId);
            t.insertRules(this.componentId, s2, i2);
          }
          o2 = ie(o2, s2), this.staticRulesId = s2;
        }
        else {
          for (var a2 = M(this.baseHash, n.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
            var u2 = this.rules[l2];
            if ("string" == typeof u2) c2 += u2, "production" !== process.env.NODE_ENV && (a2 = M(a2, u2));
            else if (u2) {
              var p2 = ae(Xe(u2, e3, t, n));
              a2 = M(a2, p2 + l2), c2 += p2;
            }
          }
          if (c2) {
            var d = x(a2 >>> 0);
            t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c2, ".".concat(d), void 0, this.componentId)), o2 = ie(o2, d);
          }
        }
        return o2;
      }, e2;
    }();
    et = import_react.default.createContext(void 0);
    tt = et.Consumer;
    rt = {};
    st = /* @__PURE__ */ new Set();
    ct = function(e2) {
      return Object.assign(e2, { isCss: true });
    };
    pt = function(e2) {
      return ut(it, e2);
    };
    dt = pt;
    A.forEach(function(e2) {
      dt[e2] = pt(e2);
    });
    ht = function() {
      function e2(e3, t) {
        this.rules = e3, this.componentId = t, this.isStatic = Ze(e3), ke.registerId(this.componentId + 1);
      }
      return e2.prototype.createStyles = function(e3, t, n, o2) {
        var r2 = o2(ae(Xe(this.rules, t, n, o2)), ""), s2 = this.componentId + e3;
        n.insertRules(s2, s2, r2);
      }, e2.prototype.removeStyles = function(e3, t) {
        t.clearRules(this.componentId + e3);
      }, e2.prototype.renderStyles = function(e3, t, n, o2) {
        e3 > 2 && ke.registerId(this.componentId + e3), this.removeStyles(e3, n), this.createStyles(e3, t, n, o2);
      }, e2;
    }();
    vt = function() {
      function e2() {
        var e3 = this;
        this._emitSheetCSS = function() {
          var t = e3.instance.toString();
          if (!t) return "";
          var n = Ce(), o2 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y, '="').concat(v, '"')].filter(Boolean), " ");
          return "<style ".concat(o2, ">").concat(t, "</style>");
        }, this.getStyleTags = function() {
          if (e3.sealed) throw he(2);
          return e3._emitSheetCSS();
        }, this.getStyleElement = function() {
          var n;
          if (e3.sealed) throw he(2);
          var r2 = e3.instance.toString();
          if (!r2) return [];
          var s2 = ((n = {})[f] = "", n[y] = v, n.dangerouslySetInnerHTML = { __html: r2 }, n), i2 = Ce();
          return i2 && (s2.nonce = i2), [import_react.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
        }, this.seal = function() {
          e3.sealed = true;
        }, this.instance = new ke({ isServer: true }), this.sealed = false;
      }
      return e2.prototype.collectStyles = function(e3) {
        if (this.sealed) throw he(2);
        return import_react.default.createElement(Ye, { sheet: this.instance }, e3);
      }, e2.prototype.interleaveWithNodeStream = function(e3) {
        throw he(3);
      }, e2;
    }();
    gt2 = { StyleSheet: ke, mainSheet: Me };
    "production" !== process.env.NODE_ENV && "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
    St = "__sc-".concat(f, "__");
    "production" !== process.env.NODE_ENV && "test" !== process.env.NODE_ENV && "undefined" != typeof window && (window[St] || (window[St] = 0), 1 === window[St] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[St] += 1);
  }
});

// node_modules/ua-parser-js/dist/ua-parser.min.js
var require_ua_parser_min = __commonJS({
  "node_modules/ua-parser-js/dist/ua-parser.min.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    (function(window2, undefined2) {
      "use strict";
      var LIBVERSION = "1.0.38", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
      var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
      var extend = function(regexes2, extensions) {
        var mergedRegexes = {};
        for (var i2 in regexes2) {
          if (extensions[i2] && extensions[i2].length % 2 === 0) {
            mergedRegexes[i2] = extensions[i2].concat(regexes2[i2]);
          } else {
            mergedRegexes[i2] = regexes2[i2];
          }
        }
        return mergedRegexes;
      }, enumerize = function(arr) {
        var enums = {};
        for (var i2 = 0; i2 < arr.length; i2++) {
          enums[arr[i2].toUpperCase()] = arr[i2];
        }
        return enums;
      }, has = function(str1, str2) {
        return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
      }, lowerize = function(str) {
        return str.toLowerCase();
      }, majorize = function(version) {
        return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
      }, trim2 = function(str, len) {
        if (typeof str === STR_TYPE) {
          str = str.replace(/^\s\s*/, EMPTY);
          return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
        }
      };
      var rgxMapper = function(ua, arrays) {
        var i2 = 0, j2, k2, p2, q2, matches, match2;
        while (i2 < arrays.length && !matches) {
          var regex = arrays[i2], props = arrays[i2 + 1];
          j2 = k2 = 0;
          while (j2 < regex.length && !matches) {
            if (!regex[j2]) {
              break;
            }
            matches = regex[j2++].exec(ua);
            if (!!matches) {
              for (p2 = 0; p2 < props.length; p2++) {
                match2 = matches[++k2];
                q2 = props[p2];
                if (typeof q2 === OBJ_TYPE && q2.length > 0) {
                  if (q2.length === 2) {
                    if (typeof q2[1] == FUNC_TYPE) {
                      this[q2[0]] = q2[1].call(this, match2);
                    } else {
                      this[q2[0]] = q2[1];
                    }
                  } else if (q2.length === 3) {
                    if (typeof q2[1] === FUNC_TYPE && !(q2[1].exec && q2[1].test)) {
                      this[q2[0]] = match2 ? q2[1].call(this, match2, q2[2]) : undefined2;
                    } else {
                      this[q2[0]] = match2 ? match2.replace(q2[1], q2[2]) : undefined2;
                    }
                  } else if (q2.length === 4) {
                    this[q2[0]] = match2 ? q2[3].call(this, match2.replace(q2[1], q2[2])) : undefined2;
                  }
                } else {
                  this[q2] = match2 ? match2 : undefined2;
                }
              }
            }
          }
          i2 += 2;
        }
      }, strMapper = function(str, map) {
        for (var i2 in map) {
          if (typeof map[i2] === OBJ_TYPE && map[i2].length > 0) {
            for (var j2 = 0; j2 < map[i2].length; j2++) {
              if (has(map[i2][j2], str)) {
                return i2 === UNKNOWN ? undefined2 : i2;
              }
            }
          } else if (has(map[i2], str)) {
            return i2 === UNKNOWN ? undefined2 : i2;
          }
        }
        return str;
      };
      var oldSafariMap = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, windowsVersionMap = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" };
      var regexes = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [VERSION, [NAME, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [VERSION, [NAME, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [NAME, VERSION], [/opios[\/ ]+([\w\.]+)/i], [VERSION, [NAME, OPERA + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " GX"]], [/\bopr\/([\w\.]+)/i], [VERSION, [NAME, OPERA]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [NAME, VERSION], [/\bddg\/([\w\.]+)/i], [VERSION, [NAME, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [VERSION, [NAME, "UC" + BROWSER]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [VERSION, [NAME, "WeChat"]], [/konqueror\/([\w\.]+)/i], [VERSION, [NAME, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [VERSION, [NAME, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [VERSION, [NAME, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [VERSION, [NAME, "Smart Lenovo " + BROWSER]], [/(avast|avg)\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION], [/\bfocus\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " Focus"]], [/\bopt\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [VERSION, [NAME, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [VERSION, [NAME, "Dolphin"]], [/coast\/([\w\.]+)/i], [VERSION, [NAME, OPERA + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [VERSION, [NAME, "MIUI " + BROWSER]], [/fxios\/([-\w\.]+)/i], [VERSION, [NAME, FIREFOX]], [/\bqihu|(qi?ho?o?|360)browser/i], [[NAME, "360 " + BROWSER]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[NAME, /(.+)/, "$1 " + BROWSER], VERSION], [/samsungbrowser\/([\w\.]+)/i], [VERSION, [NAME, SAMSUNG + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[NAME, /_/g, " "], VERSION], [/metasr[\/ ]?([\d\.]+)/i], [VERSION, [NAME, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[NAME, "Sogou Mobile"], VERSION], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [NAME, VERSION], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [NAME], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[NAME, FACEBOOK], VERSION], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [NAME, VERSION], [/\bgsa\/([\w\.]+) .*safari\//i], [VERSION, [NAME, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [VERSION, [NAME, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [VERSION, [NAME, CHROME + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[NAME, CHROME + " WebView"], VERSION], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [VERSION, [NAME, "Android " + BROWSER]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [NAME, VERSION], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [VERSION, [NAME, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [VERSION, NAME], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [NAME, [VERSION, strMapper, oldSafariMap]], [/(webkit|khtml)\/([\w\.]+)/i], [NAME, VERSION], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[NAME, "Netscape"], VERSION], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [VERSION, [NAME, FIREFOX + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [NAME, VERSION], [/(cobalt)\/([\w\.]+)/i], [NAME, [VERSION, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[ARCHITECTURE, "amd64"]], [/(ia32(?=;))/i], [[ARCHITECTURE, lowerize]], [/((?:i[346]|x)86)[;\)]/i], [[ARCHITECTURE, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[ARCHITECTURE, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[ARCHITECTURE, "armhf"]], [/windows (ce|mobile); ppc;/i], [[ARCHITECTURE, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [/(sun4\w)[;\)]/i], [[ARCHITECTURE, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[ARCHITECTURE, lowerize]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [/(macintosh);/i], [MODEL, [VENDOR, APPLE]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]], [/\b(opd2\d{3}a?) bui/i], [MODEL, [VENDOR, "OPPO"], [TYPE, TABLET]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]], [/(pixel c)\b/i], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]], [/(playbook);[-\w\),; ]+(rim)/i], [MODEL, VENDOR, [TYPE, TABLET]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [/(nexus 9)/i], [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [VENDOR, MODEL, [TYPE, TABLET]], [/(surface duo)/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]], [/(u304aa)/i], [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]], [/\bsie-(\w*)/i], [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]], [/\b(rct\w+) b/i], [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]], [/\b(venue[\d ]{2,7}) b/i], [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]], [/\b(q(?:mv|ta)\w+) b/i], [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]], [/\b(tm\d{3}\w+) b/i], [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]], [/\b(k88) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]], [/\b(nx\d{3}j) b/i], [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]], [/\b(gen\d{3}) b.+49h/i], [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]], [/\b(zur\d{3}) b/i], [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]], [/\b((zeki)?tb.*\b) b/i], [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]], [/\b(ns-?\w{0,9}) b/i], [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]], [/\b((nxa|next)-?\w{0,9}) b/i], [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]], [/\b(lvtel\-)?(v1[12]) b/i], [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]], [/\b(ph-1) /i], [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]], [/\b(trio[-\w\. ]+) b/i], [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]], [/\btu_(1491) b/i], [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]], [/(shield[\w ]+) b/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]], [/(sprint) (\w+)/i], [VENDOR, MODEL, [TYPE, MOBILE]], [/(kin\.[onetw]{3})/i], [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [/smart-tv.+(samsung)/i], [VENDOR, [TYPE, SMARTTV]], [/hbbtv.+maple;(\d+)/i], [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[VENDOR, LG], [TYPE, SMARTTV]], [/(apple) ?tv/i], [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]], [/crkey/i], [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [/droid.+aft(\w+)( bui|\))/i], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]], [/(bravia[\w ]+)( bui|\))/i], [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]], [/(mitv-\w{5}) bui/i], [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]], [/Hbbtv.*(technisat) (.*);/i], [VENDOR, MODEL, [TYPE, SMARTTV]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[VENDOR, trim2], [MODEL, trim2], [TYPE, SMARTTV]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[TYPE, SMARTTV]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [VENDOR, MODEL, [TYPE, CONSOLE]], [/droid.+; (shield) bui/i], [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]], [/(playstation [345portablevi]+)/i], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [/((pebble))app/i], [VENDOR, MODEL, [TYPE, WEARABLE]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]], [/droid.+; (glass) \d/i], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [/droid.+; (wt63?0{2,3})\)/i], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [/(quest( \d| pro)?)/i], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [VENDOR, [TYPE, EMBEDDED]], [/(aeobc)\b/i], [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [MODEL, [TYPE, MOBILE]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [MODEL, [TYPE, TABLET]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[TYPE, TABLET]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[TYPE, MOBILE]], [/(android[-\w\. ]{0,9});.+buil/i], [MODEL, [VENDOR, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [VERSION, [NAME, EDGE + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [VERSION, [NAME, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [NAME, VERSION], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [VERSION, NAME]], os: [[/microsoft (windows) (vista|xp)/i], [NAME, VERSION], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [NAME, [VERSION, strMapper, windowsVersionMap]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[VERSION, /_/g, "."], [NAME, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[NAME, MAC_OS], [VERSION, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [VERSION, NAME], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [NAME, VERSION], [/\(bb(10);/i], [VERSION, [NAME, BLACKBERRY]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [VERSION, [NAME, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [VERSION, [NAME, FIREFOX + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [VERSION, [NAME, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [VERSION, [NAME, "watchOS"]], [/crkey\/([\d\.]+)/i], [VERSION, [NAME, CHROME + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[NAME, CHROMIUM_OS], VERSION], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [NAME, VERSION], [/(sunos) ?([\w\.\d]*)/i], [[NAME, "Solaris"], VERSION], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [NAME, VERSION]] };
      var UAParser = function(ua, extensions) {
        if (typeof ua === OBJ_TYPE) {
          extensions = ua;
          ua = undefined2;
        }
        if (!(this instanceof UAParser)) {
          return new UAParser(ua, extensions).getResult();
        }
        var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
        var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
        var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
        var _isSelfNav = _navigator && _navigator.userAgent == _ua;
        this.getBrowser = function() {
          var _browser = {};
          _browser[NAME] = undefined2;
          _browser[VERSION] = undefined2;
          rgxMapper.call(_browser, _ua, _rgxmap.browser);
          _browser[MAJOR] = majorize(_browser[VERSION]);
          if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
            _browser[NAME] = "Brave";
          }
          return _browser;
        };
        this.getCPU = function() {
          var _cpu = {};
          _cpu[ARCHITECTURE] = undefined2;
          rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
          return _cpu;
        };
        this.getDevice = function() {
          var _device = {};
          _device[VENDOR] = undefined2;
          _device[MODEL] = undefined2;
          _device[TYPE] = undefined2;
          rgxMapper.call(_device, _ua, _rgxmap.device);
          if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
            _device[TYPE] = MOBILE;
          }
          if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
            _device[MODEL] = "iPad";
            _device[TYPE] = TABLET;
          }
          return _device;
        };
        this.getEngine = function() {
          var _engine = {};
          _engine[NAME] = undefined2;
          _engine[VERSION] = undefined2;
          rgxMapper.call(_engine, _ua, _rgxmap.engine);
          return _engine;
        };
        this.getOS = function() {
          var _os = {};
          _os[NAME] = undefined2;
          _os[VERSION] = undefined2;
          rgxMapper.call(_os, _ua, _rgxmap.os);
          if (_isSelfNav && !_os[NAME] && _uach && _uach.platform && _uach.platform != "Unknown") {
            _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
          }
          return _os;
        };
        this.getResult = function() {
          return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
        };
        this.getUA = function() {
          return _ua;
        };
        this.setUA = function(ua2) {
          _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim2(ua2, UA_MAX_LENGTH) : ua2;
          return this;
        };
        this.setUA(_ua);
        return this;
      };
      UAParser.VERSION = LIBVERSION;
      UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
      UAParser.CPU = enumerize([ARCHITECTURE]);
      UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
      UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
      if (typeof exports !== UNDEF_TYPE) {
        if (typeof module !== UNDEF_TYPE && module.exports) {
          exports = module.exports = UAParser;
        }
        exports.UAParser = UAParser;
      } else {
        if (typeof define === FUNC_TYPE && define.amd) {
          define(function() {
            return UAParser;
          });
        } else if (typeof window2 !== UNDEF_TYPE) {
          window2.UAParser = UAParser;
        }
      }
      var $2 = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
      if ($2 && !$2.ua) {
        var parser = new UAParser();
        $2.ua = parser.getResult();
        $2.ua.get = function() {
          return parser.getUA();
        };
        $2.ua.set = function(ua) {
          parser.setUA(ua);
          var result = parser.getResult();
          for (var prop in result) {
            $2.ua[prop] = result[prop];
          }
        };
      }
    })(typeof window === "object" ? window : exports);
  }
});

// node_modules/react-device-detect/dist/lib.js
var require_lib2 = __commonJS({
  "node_modules/react-device-detect/dist/lib.js"(exports) {
    "use strict";
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var React = require_react();
    var React__default = _interopDefault(React);
    var UAParser = require_ua_parser_min();
    var ClientUAInstance = new UAParser();
    var browser2 = ClientUAInstance.getBrowser();
    var cpu = ClientUAInstance.getCPU();
    var device = ClientUAInstance.getDevice();
    var engine = ClientUAInstance.getEngine();
    var os = ClientUAInstance.getOS();
    var ua = ClientUAInstance.getUA();
    var setUa = function setUa2(userAgentString) {
      return ClientUAInstance.setUA(userAgentString);
    };
    var parseUserAgent = function parseUserAgent2(userAgent) {
      if (!userAgent) {
        console.error("No userAgent string was provided");
        return;
      }
      var UserAgentInstance = new UAParser(userAgent);
      return {
        UA: UserAgentInstance,
        browser: UserAgentInstance.getBrowser(),
        cpu: UserAgentInstance.getCPU(),
        device: UserAgentInstance.getDevice(),
        engine: UserAgentInstance.getEngine(),
        os: UserAgentInstance.getOS(),
        ua: UserAgentInstance.getUA(),
        setUserAgent: function setUserAgent2(userAgentString) {
          return UserAgentInstance.setUA(userAgentString);
        }
      };
    };
    var UAHelper = Object.freeze({
      ClientUAInstance,
      browser: browser2,
      cpu,
      device,
      engine,
      os,
      ua,
      setUa,
      parseUserAgent
    });
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2] != null ? arguments[i2] : {};
        if (i2 % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o2) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
        return o3.__proto__ || Object.getPrototypeOf(o3);
      };
      return _getPrototypeOf(o2);
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i2;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
          key = sourceSymbolKeys[i2];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _slicedToArray(arr, i2) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
    }
    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }
    function _iterableToArrayLimit(arr, i2) {
      var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
      if (_i == null) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _s, _e2;
      try {
        for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i2 && _arr.length === i2) break;
        }
      } catch (err) {
        _d = true;
        _e2 = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e2;
        }
      }
      return _arr;
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
      var n = Object.prototype.toString.call(o2).slice(8, -1);
      if (n === "Object" && o2.constructor) n = o2.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o2);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
      return arr2;
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var DeviceTypes = {
      Mobile: "mobile",
      Tablet: "tablet",
      SmartTv: "smarttv",
      Console: "console",
      Wearable: "wearable",
      Embedded: "embedded",
      Browser: void 0
    };
    var BrowserTypes = {
      Chrome: "Chrome",
      Firefox: "Firefox",
      Opera: "Opera",
      Yandex: "Yandex",
      Safari: "Safari",
      InternetExplorer: "Internet Explorer",
      Edge: "Edge",
      Chromium: "Chromium",
      Ie: "IE",
      MobileSafari: "Mobile Safari",
      EdgeChromium: "Edge Chromium",
      MIUI: "MIUI Browser",
      SamsungBrowser: "Samsung Browser"
    };
    var OsTypes = {
      IOS: "iOS",
      Android: "Android",
      WindowsPhone: "Windows Phone",
      Windows: "Windows",
      MAC_OS: "Mac OS"
    };
    var InitialDeviceTypes = {
      isMobile: false,
      isTablet: false,
      isBrowser: false,
      isSmartTV: false,
      isConsole: false,
      isWearable: false
    };
    var checkDeviceType = function checkDeviceType2(type) {
      switch (type) {
        case DeviceTypes.Mobile:
          return {
            isMobile: true
          };
        case DeviceTypes.Tablet:
          return {
            isTablet: true
          };
        case DeviceTypes.SmartTv:
          return {
            isSmartTV: true
          };
        case DeviceTypes.Console:
          return {
            isConsole: true
          };
        case DeviceTypes.Wearable:
          return {
            isWearable: true
          };
        case DeviceTypes.Browser:
          return {
            isBrowser: true
          };
        case DeviceTypes.Embedded:
          return {
            isEmbedded: true
          };
        default:
          return InitialDeviceTypes;
      }
    };
    var setUserAgent = function setUserAgent2(userAgent) {
      return setUa(userAgent);
    };
    var setDefaults = function setDefaults2(p2) {
      var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
      return p2 ? p2 : d;
    };
    var getNavigatorInstance = function getNavigatorInstance2() {
      if (typeof window !== "undefined") {
        if (window.navigator || navigator) {
          return window.navigator || navigator;
        }
      }
      return false;
    };
    var isIOS13Check = function isIOS13Check2(type) {
      var nav = getNavigatorInstance();
      return nav && nav.platform && (nav.platform.indexOf(type) !== -1 || nav.platform === "MacIntel" && nav.maxTouchPoints > 1 && !window.MSStream);
    };
    var browserPayload = function browserPayload2(isBrowser2, browser3, engine2, os2, ua2) {
      return {
        isBrowser: isBrowser2,
        browserMajorVersion: setDefaults(browser3.major),
        browserFullVersion: setDefaults(browser3.version),
        browserName: setDefaults(browser3.name),
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var mobilePayload = function mobilePayload2(type, device2, os2, ua2) {
      return _objectSpread2({}, type, {
        vendor: setDefaults(device2.vendor),
        model: setDefaults(device2.model),
        os: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        ua: setDefaults(ua2)
      });
    };
    var smartTvPayload = function smartTvPayload2(isSmartTV2, engine2, os2, ua2) {
      return {
        isSmartTV: isSmartTV2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var consolePayload = function consolePayload2(isConsole2, engine2, os2, ua2) {
      return {
        isConsole: isConsole2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var wearablePayload = function wearablePayload2(isWearable2, engine2, os2, ua2) {
      return {
        isWearable: isWearable2,
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    var embeddedPayload = function embeddedPayload2(isEmbedded2, device2, engine2, os2, ua2) {
      return {
        isEmbedded: isEmbedded2,
        vendor: setDefaults(device2.vendor),
        model: setDefaults(device2.model),
        engineName: setDefaults(engine2.name),
        engineVersion: setDefaults(engine2.version),
        osName: setDefaults(os2.name),
        osVersion: setDefaults(os2.version),
        userAgent: setDefaults(ua2)
      };
    };
    function deviceDetect(userAgent) {
      var _ref = userAgent ? parseUserAgent(userAgent) : UAHelper, device2 = _ref.device, browser3 = _ref.browser, engine2 = _ref.engine, os2 = _ref.os, ua2 = _ref.ua;
      var type = checkDeviceType(device2.type);
      var isBrowser2 = type.isBrowser, isMobile2 = type.isMobile, isTablet2 = type.isTablet, isSmartTV2 = type.isSmartTV, isConsole2 = type.isConsole, isWearable2 = type.isWearable, isEmbedded2 = type.isEmbedded;
      if (isBrowser2) {
        return browserPayload(isBrowser2, browser3, engine2, os2, ua2);
      }
      if (isSmartTV2) {
        return smartTvPayload(isSmartTV2, engine2, os2, ua2);
      }
      if (isConsole2) {
        return consolePayload(isConsole2, engine2, os2, ua2);
      }
      if (isMobile2) {
        return mobilePayload(type, device2, os2, ua2);
      }
      if (isTablet2) {
        return mobilePayload(type, device2, os2, ua2);
      }
      if (isWearable2) {
        return wearablePayload(isWearable2, engine2, os2, ua2);
      }
      if (isEmbedded2) {
        return embeddedPayload(isEmbedded2, device2, engine2, os2, ua2);
      }
    }
    var isMobileType = function isMobileType2(_ref) {
      var type = _ref.type;
      return type === DeviceTypes.Mobile;
    };
    var isTabletType = function isTabletType2(_ref2) {
      var type = _ref2.type;
      return type === DeviceTypes.Tablet;
    };
    var isMobileAndTabletType = function isMobileAndTabletType2(_ref3) {
      var type = _ref3.type;
      return type === DeviceTypes.Mobile || type === DeviceTypes.Tablet;
    };
    var isSmartTVType = function isSmartTVType2(_ref4) {
      var type = _ref4.type;
      return type === DeviceTypes.SmartTv;
    };
    var isBrowserType = function isBrowserType2(_ref5) {
      var type = _ref5.type;
      return type === DeviceTypes.Browser;
    };
    var isWearableType = function isWearableType2(_ref6) {
      var type = _ref6.type;
      return type === DeviceTypes.Wearable;
    };
    var isConsoleType = function isConsoleType2(_ref7) {
      var type = _ref7.type;
      return type === DeviceTypes.Console;
    };
    var isEmbeddedType = function isEmbeddedType2(_ref8) {
      var type = _ref8.type;
      return type === DeviceTypes.Embedded;
    };
    var getMobileVendor = function getMobileVendor2(_ref9) {
      var vendor = _ref9.vendor;
      return setDefaults(vendor);
    };
    var getMobileModel = function getMobileModel2(_ref10) {
      var model = _ref10.model;
      return setDefaults(model);
    };
    var getDeviceType = function getDeviceType2(_ref11) {
      var type = _ref11.type;
      return setDefaults(type, "browser");
    };
    var isAndroidType = function isAndroidType2(_ref12) {
      var name = _ref12.name;
      return name === OsTypes.Android;
    };
    var isWindowsType = function isWindowsType2(_ref13) {
      var name = _ref13.name;
      return name === OsTypes.Windows;
    };
    var isMacOsType = function isMacOsType2(_ref14) {
      var name = _ref14.name;
      return name === OsTypes.MAC_OS;
    };
    var isWinPhoneType = function isWinPhoneType2(_ref15) {
      var name = _ref15.name;
      return name === OsTypes.WindowsPhone;
    };
    var isIOSType = function isIOSType2(_ref16) {
      var name = _ref16.name;
      return name === OsTypes.IOS;
    };
    var getOsVersion = function getOsVersion2(_ref17) {
      var version = _ref17.version;
      return setDefaults(version);
    };
    var getOsName = function getOsName2(_ref18) {
      var name = _ref18.name;
      return setDefaults(name);
    };
    var isChromeType = function isChromeType2(_ref19) {
      var name = _ref19.name;
      return name === BrowserTypes.Chrome;
    };
    var isFirefoxType = function isFirefoxType2(_ref20) {
      var name = _ref20.name;
      return name === BrowserTypes.Firefox;
    };
    var isChromiumType = function isChromiumType2(_ref21) {
      var name = _ref21.name;
      return name === BrowserTypes.Chromium;
    };
    var isEdgeType = function isEdgeType2(_ref22) {
      var name = _ref22.name;
      return name === BrowserTypes.Edge;
    };
    var isYandexType = function isYandexType2(_ref23) {
      var name = _ref23.name;
      return name === BrowserTypes.Yandex;
    };
    var isSafariType = function isSafariType2(_ref24) {
      var name = _ref24.name;
      return name === BrowserTypes.Safari || name === BrowserTypes.MobileSafari;
    };
    var isMobileSafariType = function isMobileSafariType2(_ref25) {
      var name = _ref25.name;
      return name === BrowserTypes.MobileSafari;
    };
    var isOperaType = function isOperaType2(_ref26) {
      var name = _ref26.name;
      return name === BrowserTypes.Opera;
    };
    var isIEType = function isIEType2(_ref27) {
      var name = _ref27.name;
      return name === BrowserTypes.InternetExplorer || name === BrowserTypes.Ie;
    };
    var isMIUIType = function isMIUIType2(_ref28) {
      var name = _ref28.name;
      return name === BrowserTypes.MIUI;
    };
    var isSamsungBrowserType = function isSamsungBrowserType2(_ref29) {
      var name = _ref29.name;
      return name === BrowserTypes.SamsungBrowser;
    };
    var getBrowserFullVersion = function getBrowserFullVersion2(_ref30) {
      var version = _ref30.version;
      return setDefaults(version);
    };
    var getBrowserVersion = function getBrowserVersion2(_ref31) {
      var major = _ref31.major;
      return setDefaults(major);
    };
    var getBrowserName = function getBrowserName2(_ref32) {
      var name = _ref32.name;
      return setDefaults(name);
    };
    var getEngineName = function getEngineName2(_ref33) {
      var name = _ref33.name;
      return setDefaults(name);
    };
    var getEngineVersion = function getEngineVersion2(_ref34) {
      var version = _ref34.version;
      return setDefaults(version);
    };
    var isElectronType = function isElectronType2() {
      var nav = getNavigatorInstance();
      var ua2 = nav && nav.userAgent && nav.userAgent.toLowerCase();
      return typeof ua2 === "string" ? /electron/.test(ua2) : false;
    };
    var isEdgeChromiumType = function isEdgeChromiumType2(ua2) {
      return typeof ua2 === "string" && ua2.indexOf("Edg/") !== -1;
    };
    var getIOS13 = function getIOS132() {
      var nav = getNavigatorInstance();
      return nav && (/iPad|iPhone|iPod/.test(nav.platform) || nav.platform === "MacIntel" && nav.maxTouchPoints > 1) && !window.MSStream;
    };
    var getIPad13 = function getIPad132() {
      return isIOS13Check("iPad");
    };
    var getIphone13 = function getIphone132() {
      return isIOS13Check("iPhone");
    };
    var getIPod13 = function getIPod132() {
      return isIOS13Check("iPod");
    };
    var getUseragent = function getUseragent2(userAg) {
      return setDefaults(userAg);
    };
    function buildSelectorsObject(options) {
      var _ref = options ? options : UAHelper, device2 = _ref.device, browser3 = _ref.browser, os2 = _ref.os, engine2 = _ref.engine, ua2 = _ref.ua;
      return {
        isSmartTV: isSmartTVType(device2),
        isConsole: isConsoleType(device2),
        isWearable: isWearableType(device2),
        isEmbedded: isEmbeddedType(device2),
        isMobileSafari: isMobileSafariType(browser3) || getIPad13(),
        isChromium: isChromiumType(browser3),
        isMobile: isMobileAndTabletType(device2) || getIPad13(),
        isMobileOnly: isMobileType(device2),
        isTablet: isTabletType(device2) || getIPad13(),
        isBrowser: isBrowserType(device2),
        isDesktop: isBrowserType(device2),
        isAndroid: isAndroidType(os2),
        isWinPhone: isWinPhoneType(os2),
        isIOS: isIOSType(os2) || getIPad13(),
        isChrome: isChromeType(browser3),
        isFirefox: isFirefoxType(browser3),
        isSafari: isSafariType(browser3),
        isOpera: isOperaType(browser3),
        isIE: isIEType(browser3),
        osVersion: getOsVersion(os2),
        osName: getOsName(os2),
        fullBrowserVersion: getBrowserFullVersion(browser3),
        browserVersion: getBrowserVersion(browser3),
        browserName: getBrowserName(browser3),
        mobileVendor: getMobileVendor(device2),
        mobileModel: getMobileModel(device2),
        engineName: getEngineName(engine2),
        engineVersion: getEngineVersion(engine2),
        getUA: getUseragent(ua2),
        isEdge: isEdgeType(browser3) || isEdgeChromiumType(ua2),
        isYandex: isYandexType(browser3),
        deviceType: getDeviceType(device2),
        isIOS13: getIOS13(),
        isIPad13: getIPad13(),
        isIPhone13: getIphone13(),
        isIPod13: getIPod13(),
        isElectron: isElectronType(),
        isEdgeChromium: isEdgeChromiumType(ua2),
        isLegacyEdge: isEdgeType(browser3) && !isEdgeChromiumType(ua2),
        isWindows: isWindowsType(os2),
        isMacOs: isMacOsType(os2),
        isMIUI: isMIUIType(browser3),
        isSamsungBrowser: isSamsungBrowserType(browser3)
      };
    }
    var isSmartTV = isSmartTVType(device);
    var isConsole = isConsoleType(device);
    var isWearable = isWearableType(device);
    var isEmbedded = isEmbeddedType(device);
    var isMobileSafari = isMobileSafariType(browser2) || getIPad13();
    var isChromium = isChromiumType(browser2);
    var isMobile = isMobileAndTabletType(device) || getIPad13();
    var isMobileOnly = isMobileType(device);
    var isTablet = isTabletType(device) || getIPad13();
    var isBrowser = isBrowserType(device);
    var isDesktop = isBrowserType(device);
    var isAndroid = isAndroidType(os);
    var isWinPhone = isWinPhoneType(os);
    var isIOS = isIOSType(os) || getIPad13();
    var isChrome = isChromeType(browser2);
    var isFirefox = isFirefoxType(browser2);
    var isSafari = isSafariType(browser2);
    var isOpera = isOperaType(browser2);
    var isIE = isIEType(browser2);
    var osVersion = getOsVersion(os);
    var osName = getOsName(os);
    var fullBrowserVersion = getBrowserFullVersion(browser2);
    var browserVersion = getBrowserVersion(browser2);
    var browserName = getBrowserName(browser2);
    var mobileVendor = getMobileVendor(device);
    var mobileModel = getMobileModel(device);
    var engineName = getEngineName(engine);
    var engineVersion = getEngineVersion(engine);
    var getUA = getUseragent(ua);
    var isEdge = isEdgeType(browser2) || isEdgeChromiumType(ua);
    var isYandex = isYandexType(browser2);
    var deviceType = getDeviceType(device);
    var isIOS13 = getIOS13();
    var isIPad13 = getIPad13();
    var isIPhone13 = getIphone13();
    var isIPod13 = getIPod13();
    var isElectron = isElectronType();
    var isEdgeChromium = isEdgeChromiumType(ua);
    var isLegacyEdge = isEdgeType(browser2) && !isEdgeChromiumType(ua);
    var isWindows = isWindowsType(os);
    var isMacOs = isMacOsType(os);
    var isMIUI = isMIUIType(browser2);
    var isSamsungBrowser = isSamsungBrowserType(browser2);
    var getSelectorsByUserAgent = function getSelectorsByUserAgent2(userAgent) {
      if (!userAgent || typeof userAgent !== "string") {
        console.error("No valid user agent string was provided");
        return;
      }
      var _UAHelper$parseUserAg = parseUserAgent(userAgent), device2 = _UAHelper$parseUserAg.device, browser3 = _UAHelper$parseUserAg.browser, os2 = _UAHelper$parseUserAg.os, engine2 = _UAHelper$parseUserAg.engine, ua2 = _UAHelper$parseUserAg.ua;
      return buildSelectorsObject({
        device: device2,
        browser: browser3,
        os: os2,
        engine: engine2,
        ua: ua2
      });
    };
    var AndroidView = function AndroidView2(_ref) {
      var renderWithFragment = _ref.renderWithFragment, children = _ref.children, props = _objectWithoutProperties(_ref, ["renderWithFragment", "children"]);
      return isAndroid ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var BrowserView = function BrowserView2(_ref2) {
      var renderWithFragment = _ref2.renderWithFragment, children = _ref2.children, props = _objectWithoutProperties(_ref2, ["renderWithFragment", "children"]);
      return isBrowser ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var IEView = function IEView2(_ref3) {
      var renderWithFragment = _ref3.renderWithFragment, children = _ref3.children, props = _objectWithoutProperties(_ref3, ["renderWithFragment", "children"]);
      return isIE ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var IOSView = function IOSView2(_ref4) {
      var renderWithFragment = _ref4.renderWithFragment, children = _ref4.children, props = _objectWithoutProperties(_ref4, ["renderWithFragment", "children"]);
      return isIOS ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var MobileView = function MobileView2(_ref5) {
      var renderWithFragment = _ref5.renderWithFragment, children = _ref5.children, props = _objectWithoutProperties(_ref5, ["renderWithFragment", "children"]);
      return isMobile ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var TabletView = function TabletView2(_ref6) {
      var renderWithFragment = _ref6.renderWithFragment, children = _ref6.children, props = _objectWithoutProperties(_ref6, ["renderWithFragment", "children"]);
      return isTablet ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var WinPhoneView = function WinPhoneView2(_ref7) {
      var renderWithFragment = _ref7.renderWithFragment, children = _ref7.children, props = _objectWithoutProperties(_ref7, ["renderWithFragment", "children"]);
      return isWinPhone ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var MobileOnlyView = function MobileOnlyView2(_ref8) {
      var renderWithFragment = _ref8.renderWithFragment, children = _ref8.children, viewClassName = _ref8.viewClassName, style = _ref8.style, props = _objectWithoutProperties(_ref8, ["renderWithFragment", "children", "viewClassName", "style"]);
      return isMobileOnly ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var SmartTVView = function SmartTVView2(_ref9) {
      var renderWithFragment = _ref9.renderWithFragment, children = _ref9.children, props = _objectWithoutProperties(_ref9, ["renderWithFragment", "children"]);
      return isSmartTV ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var ConsoleView = function ConsoleView2(_ref10) {
      var renderWithFragment = _ref10.renderWithFragment, children = _ref10.children, props = _objectWithoutProperties(_ref10, ["renderWithFragment", "children"]);
      return isConsole ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var WearableView = function WearableView2(_ref11) {
      var renderWithFragment = _ref11.renderWithFragment, children = _ref11.children, props = _objectWithoutProperties(_ref11, ["renderWithFragment", "children"]);
      return isWearable ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    var CustomView = function CustomView2(_ref12) {
      var renderWithFragment = _ref12.renderWithFragment, children = _ref12.children, viewClassName = _ref12.viewClassName, style = _ref12.style, condition = _ref12.condition, props = _objectWithoutProperties(_ref12, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
      return condition ? renderWithFragment ? React__default.createElement(React.Fragment, null, children) : React__default.createElement("div", props, children) : null;
    };
    function withOrientationChange(WrappedComponent) {
      return function(_React$Component) {
        _inherits(_class, _React$Component);
        function _class(props) {
          var _this;
          _classCallCheck(this, _class);
          _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, props));
          _this.isEventListenerAdded = false;
          _this.handleOrientationChange = _this.handleOrientationChange.bind(_assertThisInitialized(_this));
          _this.onOrientationChange = _this.onOrientationChange.bind(_assertThisInitialized(_this));
          _this.onPageLoad = _this.onPageLoad.bind(_assertThisInitialized(_this));
          _this.state = {
            isLandscape: false,
            isPortrait: false
          };
          return _this;
        }
        _createClass(_class, [{
          key: "handleOrientationChange",
          value: function handleOrientationChange() {
            if (!this.isEventListenerAdded) {
              this.isEventListenerAdded = true;
            }
            var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
            this.setState({
              isPortrait: orientation === 0,
              isLandscape: orientation === 90
            });
          }
        }, {
          key: "onOrientationChange",
          value: function onOrientationChange() {
            this.handleOrientationChange();
          }
        }, {
          key: "onPageLoad",
          value: function onPageLoad() {
            this.handleOrientationChange();
          }
        }, {
          key: "componentDidMount",
          value: function componentDidMount() {
            if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== void 0 && isMobile) {
              if (!this.isEventListenerAdded) {
                this.handleOrientationChange();
                window.addEventListener("load", this.onPageLoad, false);
              } else {
                window.removeEventListener("load", this.onPageLoad, false);
              }
              window.addEventListener("resize", this.onOrientationChange, false);
            }
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            window.removeEventListener("resize", this.onOrientationChange, false);
          }
        }, {
          key: "render",
          value: function render() {
            return React__default.createElement(WrappedComponent, _extends({}, this.props, {
              isLandscape: this.state.isLandscape,
              isPortrait: this.state.isPortrait
            }));
          }
        }]);
        return _class;
      }(React__default.Component);
    }
    function useMobileOrientation() {
      var _useState = React.useState(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        return {
          isPortrait: orientation === 0,
          isLandscape: orientation === 90,
          orientation: orientation === 0 ? "portrait" : "landscape"
        };
      }), _useState2 = _slicedToArray(_useState, 2), state = _useState2[0], setState = _useState2[1];
      var handleOrientationChange = React.useCallback(function() {
        var orientation = window.innerWidth > window.innerHeight ? 90 : 0;
        var next2 = {
          isPortrait: orientation === 0,
          isLandscape: orientation === 90,
          orientation: orientation === 0 ? "portrait" : "landscape"
        };
        state.orientation !== next2.orientation && setState(next2);
      }, [state.orientation]);
      React.useEffect(function() {
        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) !== void 0 && isMobile) {
          handleOrientationChange();
          window.addEventListener("load", handleOrientationChange, false);
          window.addEventListener("resize", handleOrientationChange, false);
        }
        return function() {
          window.removeEventListener("resize", handleOrientationChange, false);
          window.removeEventListener("load", handleOrientationChange, false);
        };
      }, [handleOrientationChange]);
      return state;
    }
    function useDeviceData(userAgent) {
      var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
      return parseUserAgent(hookUserAgent);
    }
    function useDeviceSelectors(userAgent) {
      var hookUserAgent = userAgent ? userAgent : window.navigator.userAgent;
      var deviceData = useDeviceData(hookUserAgent);
      var selectors = buildSelectorsObject(deviceData);
      return [selectors, deviceData];
    }
    exports.AndroidView = AndroidView;
    exports.BrowserTypes = BrowserTypes;
    exports.BrowserView = BrowserView;
    exports.ConsoleView = ConsoleView;
    exports.CustomView = CustomView;
    exports.IEView = IEView;
    exports.IOSView = IOSView;
    exports.MobileOnlyView = MobileOnlyView;
    exports.MobileView = MobileView;
    exports.OsTypes = OsTypes;
    exports.SmartTVView = SmartTVView;
    exports.TabletView = TabletView;
    exports.WearableView = WearableView;
    exports.WinPhoneView = WinPhoneView;
    exports.browserName = browserName;
    exports.browserVersion = browserVersion;
    exports.deviceDetect = deviceDetect;
    exports.deviceType = deviceType;
    exports.engineName = engineName;
    exports.engineVersion = engineVersion;
    exports.fullBrowserVersion = fullBrowserVersion;
    exports.getSelectorsByUserAgent = getSelectorsByUserAgent;
    exports.getUA = getUA;
    exports.isAndroid = isAndroid;
    exports.isBrowser = isBrowser;
    exports.isChrome = isChrome;
    exports.isChromium = isChromium;
    exports.isConsole = isConsole;
    exports.isDesktop = isDesktop;
    exports.isEdge = isEdge;
    exports.isEdgeChromium = isEdgeChromium;
    exports.isElectron = isElectron;
    exports.isEmbedded = isEmbedded;
    exports.isFirefox = isFirefox;
    exports.isIE = isIE;
    exports.isIOS = isIOS;
    exports.isIOS13 = isIOS13;
    exports.isIPad13 = isIPad13;
    exports.isIPhone13 = isIPhone13;
    exports.isIPod13 = isIPod13;
    exports.isLegacyEdge = isLegacyEdge;
    exports.isMIUI = isMIUI;
    exports.isMacOs = isMacOs;
    exports.isMobile = isMobile;
    exports.isMobileOnly = isMobileOnly;
    exports.isMobileSafari = isMobileSafari;
    exports.isOpera = isOpera;
    exports.isSafari = isSafari;
    exports.isSamsungBrowser = isSamsungBrowser;
    exports.isSmartTV = isSmartTV;
    exports.isTablet = isTablet;
    exports.isWearable = isWearable;
    exports.isWinPhone = isWinPhone;
    exports.isWindows = isWindows;
    exports.isYandex = isYandex;
    exports.mobileModel = mobileModel;
    exports.mobileVendor = mobileVendor;
    exports.osName = osName;
    exports.osVersion = osVersion;
    exports.parseUserAgent = parseUserAgent;
    exports.setUserAgent = setUserAgent;
    exports.useDeviceData = useDeviceData;
    exports.useDeviceSelectors = useDeviceSelectors;
    exports.useMobileOrientation = useMobileOrientation;
    exports.withOrientationChange = withOrientationChange;
  }
});

// node_modules/@anon-aadhaar/react/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/@anon-aadhaar/react/dist/index.js"(exports, module) {
    var import_dist46 = __toESM(require_dist());
    var import_dist47 = __toESM(require_dist2());
    var import_dist48 = __toESM(require_dist3());
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from2, except, desc) => {
      if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
      mod2
    ));
    var __toCommonJS2 = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
    var src_exports = {};
    __export2(src_exports, {
      AnonAadhaarProof: () => AnonAadhaarProof,
      AnonAadhaarProvider: () => AnonAadhaarProvider,
      LaunchProveModal: () => LaunchProveModal,
      LogInWithAnonAadhaar: () => LogInWithAnonAadhaar,
      processAadhaarArgs: () => processAadhaarArgs,
      proveAndSerialize: () => proveAndSerialize,
      useAnonAadhaar: () => useAnonAadhaar,
      useProver: () => useProver,
      verifySignature: () => verifySignature
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react2 = require_react();
    var import_core = require_dist5();
    function useAnonAadhaar() {
      const val = (0, import_react2.useContext)(AnonAadhaarContext);
      return [val.state, val.startReq];
    }
    var AnonAadhaarContext = (0, import_react2.createContext)({
      state: { status: "logged-out" },
      startReq: () => {
      },
      appName: "",
      proverState: import_core.ProverState.Initializing,
      useTestAadhaar: false
    });
    var import_react22 = require_react();
    var import_core4 = require_dist5();
    var import_react3 = __toESM2(require_react());
    var import_core3 = require_dist5();
    var import_core2 = require_dist5();
    var import_jsqr = __toESM2(require_jsQR());
    var uploadQRpng = (e2, setQrStatus) => {
      return new Promise((resolve, reject) => {
        if (e2.target.files) {
          try {
            const fileReader = new FileReader();
            fileReader.readAsDataURL(e2.target.files[0]);
            fileReader.onload = (e22) => {
              if (e22.target && e22.target.result) {
                try {
                  const image = new Image();
                  image.onload = () => {
                    const canvas = document.createElement("canvas");
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext("2d");
                    if (!ctx)
                      throw Error("Image cannot be reconstructed");
                    ctx.drawImage(image, 0, 0);
                    const imageData = ctx.getImageData(
                      0,
                      0,
                      image.width,
                      image.height
                    );
                    const qrValue = (0, import_jsqr.default)(imageData.data, image.width, image.height);
                    if (qrValue != null) {
                      resolve({
                        qrValue: qrValue.data
                      });
                      setQrStatus(
                        "QR code scanned, verifying QR Code "
                        /* QR_CODE_SCANNED */
                      );
                    } else {
                      setQrStatus(
                        "QR code invalid "
                        /* ERROR_PARSING_QR */
                      );
                    }
                  };
                  image.src = e22.target.result.toString();
                } catch (error) {
                  setQrStatus(
                    "QR code invalid "
                    /* ERROR_PARSING_QR */
                  );
                  console.error(error);
                  reject(error);
                }
              }
            };
          } catch {
            setQrStatus(null);
            reject(new Error("No file selected"));
          }
        }
      });
    };
    function str2ab(str) {
      const buf = new ArrayBuffer(str.length);
      const bufView = new Uint8Array(buf);
      for (let i2 = 0, strLen = str.length; i2 < strLen; i2++) {
        bufView[i2] = str.charCodeAt(i2);
      }
      return buf;
    }
    var createBlobURL = (icon) => {
      const blob = new Blob([icon], { type: "image/svg+xml" });
      return URL.createObjectURL(blob);
    };
    var import_node_forge = require_lib();
    var testCertificate = `-----BEGIN CERTIFICATE-----
MIID6jCCAtKgAwIBAgIBATANBgkqhkiG9w0BAQsFADBpMRQwEgYDVQQDEwtleGFt
cGxlLm9yZzELMAkGA1UEBhMCVVMxETAPBgNVBAgTCFZpcmdpbmlhMRMwEQYDVQQH
EwpCbGFja3NidXJnMQ0wCwYDVQQKEwRUZXN0MQ0wCwYDVQQLEwRUZXN0MB4XDTI0
MDMwMTE2MTc0MFoXDTI1MDMwMTE2MTc0MFowaTEUMBIGA1UEAxMLZXhhbXBsZS5v
cmcxCzAJBgNVBAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxh
Y2tzYnVyZzENMAsGA1UEChMEVGVzdDENMAsGA1UECxMEVGVzdDCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAJXoH3UGWVzCYq3c/d012AQFWyrfRtxxnFa1
ju4ZmZXvoaMlRxBiCseAHpdvROO+RU2w8ZDj99TjWYlyEXNE3lL894JvhJSIqVmn
s9Iett0DRRZi6og+7u/eiJoUmbmkf5UExfCWwmK5bSPRl1AzLZ6X62FB0mHel5lN
TEFjypy+PgdyIbRCU9z4FglCi2g1HuPptg0rNR/apu6MKKhFI5+X3nzA/l0UTkdI
E/tD7Fg/gbTuMowiFnM0iY0hC6AXom7GiUDwXfIr2cyGu8OkNUOSNy1WYWd2m3Nb
oSyjWA+RnBvYunDEwqsKzysJvC+umB88ApWm4enySPUAcwlP+vECAwEAAaOBnDCB
mTAMBgNVHRMEBTADAQH/MAsGA1UdDwQEAwIC9DA7BgNVHSUENDAyBggrBgEFBQcD
AQYIKwYBBQUHAwIGCCsGAQUFBwMDBggrBgEFBQcDBAYIKwYBBQUHAwgwEQYJYIZI
AYb4QgEBBAQDAgD3MCwGA1UdEQQlMCOGG2h0dHA6Ly9leGFtcGxlLm9yZy93ZWJp
ZCNtZYcEfwAAATANBgkqhkiG9w0BAQsFAAOCAQEAjDnIK8R7ruSiJpdUeZ2ZxaGI
ewf020sAc0ENw6x3jaKKFINNLnMqEKLntZzIg7WbjnKLhtUhb/SLHP59mfT2OJVS
YMW7uRmnajfEd0MzfrXIUKBwCeWTCyP/bcdlJOT4u24ngFnkUyWaEKnqH3YuI8cw
BKWQ26Lq7ODq6e6Otxf0KOtWTeVSzlCL66MGBvQ36LF1g8PLEZ9hvvX06ieaE99W
HDK9/pGSuobx6Fi7ufzqymirT/GOuxslquB4mleCu4ArCg2qAVC2wDjQymgvq8FS
bVukYnC6XdwqYhvIuTPnEys4gGdeirY+UPGQeqxMrNm+ZpKPTS0NwzxHwlhutw==
-----END CERTIFICATE-----`;
    var uidai_offline_publickey_26022021 = `-----BEGIN CERTIFICATE-----
MIIHwjCCBqqgAwIBAgIEU5laMzANBgkqhkiG9w0BAQsFADCB/DELMAkGA1UEBhMC
SU4xQTA/BgNVBAoTOEd1amFyYXQgTmFybWFkYSBWYWxsZXkgRmVydGlsaXplcnMg
YW5kIENoZW1pY2FscyBMaW1pdGVkMR0wGwYDVQQLExRDZXJ0aWZ5aW5nIEF1dGhv
cml0eTEPMA0GA1UEERMGMzgwMDU0MRAwDgYDVQQIEwdHdWphcmF0MSYwJAYDVQQJ
Ex1Cb2Rha2RldiwgUyBHIFJvYWQsIEFobWVkYWJhZDEcMBoGA1UEMxMTMzAxLCBH
TkZDIEluZm90b3dlcjEiMCAGA1UEAxMZKG4pQ29kZSBTb2x1dGlvbnMgQ0EgMjAx
NDAeFw0yMTAyMjYxMTU0MjRaFw0yNDAyMjcwMDI3MTFaMIHdMQswCQYDVQQGEwJJ
TjExMC8GA1UEChMoVU5JUVVFIElERU5USUZJQ0FUSU9OIEFVVEhPUklUWSBPRiBJ
TkRJQTEPMA0GA1UEERMGMTEwMDAxMQ4wDAYDVQQIEwVEZWxoaTEbMBkGA1UECRMS
QkVISU5EIEtBTEkgTUFORElSMSQwIgYDVQQzExtBQURIQVIgSFEgQkFOR0xBIFNB
SElCIFJPQUQxNzA1BgNVBAMTLkRTIFVOSVFVRSBJREVOVElGSUNBVElPTiBBVVRI
T1JJVFkgT0YgSU5ESUEgMDUwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIB
AQCiciwOXy3lunB+2T8DbsKx8LlVkyOQ+swPC8vyDIChXAiLSIaGa3LrJasL9Vov
4Gtp7b1cyDt0x3CdshQebAfGi834WdPa9/P87SQdByBV3BVIhHS0XCyYL6lUqlKq
b/+ySBhhxlCF2EtkFY6fQ9nzXKabSM6TAFIhAqTK4JO//UdLCNMtHQQG9of35VvS
JqI4S/WKQcOEw5dPHHxRFYGckm3jrfPsu5kExIbx9dUwOXe+pjWENnMptcFor9yV
Ehcx9/SNQ6988x9pseO755Sdx6ixDAvd66ur3r6gdqHPgWat8GqKQd7fFDv/g129
K9W7C2HSRywjSm1EEbybU2CVAgMBAAGjggNnMIIDYzAOBgNVHQ8BAf8EBAMCBsAw
KgYDVR0lBCMwIQYIKwYBBQUHAwQGCisGAQQBgjcKAwwGCSqGSIb3LwEBBTCCAQIG
A1UdIASB+jCB9zCBhgYGYIJkZAICMHwwegYIKwYBBQUHAgIwbgxsQ2xhc3MgMiBj
ZXJ0aWZpY2F0ZXMgYXJlIHVzZWQgZm9yIGZvcm0gc2lnbmluZywgZm9ybSBhdXRo
ZW50aWNhdGlvbiBhbmQgc2lnbmluZyBvdGhlciBsb3cgcmlzayB0cmFuc2FjdGlv
bnMuMGwGBmCCZGQKATBiMGAGCCsGAQUFBwICMFQMUlRoaXMgY2VydGlmaWNhdGUg
cHJvdmlkZXMgaGlnaGVyIGxldmVsIG9mIGFzc3VyYW5jZSBmb3IgZG9jdW1lbnQg
c2lnbmluZyBmdW5jdGlvbi4wDAYDVR0TAQH/BAIwADAjBgNVHREEHDAagRhyYWh1
bC5rdW1hckB1aWRhaS5uZXQuaW4wggFuBgNVHR8EggFlMIIBYTCCAR6gggEaoIIB
FqSCARIwggEOMQswCQYDVQQGEwJJTjFBMD8GA1UEChM4R3VqYXJhdCBOYXJtYWRh
IFZhbGxleSBGZXJ0aWxpemVycyBhbmQgQ2hlbWljYWxzIExpbWl0ZWQxHTAbBgNV
BAsTFENlcnRpZnlpbmcgQXV0aG9yaXR5MQ8wDQYDVQQREwYzODAwNTQxEDAOBgNV
BAgTB0d1amFyYXQxJjAkBgNVBAkTHUJvZGFrZGV2LCBTIEcgUm9hZCwgQWhtZWRh
YmFkMRwwGgYDVQQzExMzMDEsIEdORkMgSW5mb3Rvd2VyMSIwIAYDVQQDExkobilD
b2RlIFNvbHV0aW9ucyBDQSAyMDE0MRAwDgYDVQQDEwdDUkw1Njk0MD2gO6A5hjdo
dHRwczovL3d3dy5uY29kZXNvbHV0aW9ucy5jb20vcmVwb3NpdG9yeS9uY29kZWNh
MTQuY3JsMCsGA1UdEAQkMCKADzIwMjEwMjI2MTE1NDI0WoEPMjAyNDAyMjcwMDI3
MTFaMBMGA1UdIwQMMAqACE0HvvGenfu9MB0GA1UdDgQWBBTpS5Cfqf2zdwqjupLA
qMwk/bqX9DAZBgkqhkiG9n0HQQAEDDAKGwRWOC4xAwIDKDANBgkqhkiG9w0BAQsF
AAOCAQEAbTlOC4sonzb44+u5+VZ3wGz3OFg0uJGsufbBu5efh7kO2DlYnx7okdEf
ayQQs6AUzDvsH1yBSBjsaZo3fwBgQUIMaNKdKSrRI0eOTDqilizldHqj113f4eUz
U2j4okcNSF7TxQWMjxwyM86QsQ6vxZK7arhBhVjwp443+pxfSIdFUu428K6yH4JB
GhZSzWuqD6GNhOhDzS+sS23MkwHFq0GX4erhVfN/W7XLeSjzF4zmjg+O77vTySCN
e2VRYDrfFS8EAOcO4q7szc7+6xdg8RlgzoZHoRG/GqUp9inpJUn7OIzhHi2e8Mll
aMdtXo0nbr150tMe8ZSvY2fMiTCY1w==
-----END CERTIFICATE-----
`;
    var uidai_offline_publickey_17022026 = `-----BEGIN CERTIFICATE-----
MIIHCjCCBfKgAwIBAgIEYklh9TANBgkqhkiG9w0BAQsFADCBkTELMAkGA1UEBhMC
SU4xQTA/BgNVBAoTOEd1amFyYXQgTmFybWFkYSBWYWxsZXkgRmVydGlsaXplcnMg
YW5kIENoZW1pY2FscyBMaW1pdGVkMQ8wDQYDVQQLEwZTdWItQ0ExLjAsBgNVBAMT
JShuKUNvZGUgU29sdXRpb25zIFN1Yi1DQSBmb3IgRFNDIDIwMjIwHhcNMjQwMjIx
MTIyMzE5WhcNMjYwMjE2MjIyNzQwWjCB8zELMAkGA1UEBhMCSU4xMTAvBgNVBAoT
KFVOSVFVRSBJREVOVElGSUNBVElPTiBBVVRIT1JJVFkgT0YgSU5ESUExDzANBgNV
BBETBjExMDAwMTEOMAwGA1UECBMFRGVsaGkxODA2BgNVBAkTL0JhbmdsYSBTYWhp
YiBSb2FkIEJlaGluZCBLYWxpIE1hbmRpciBHb2xlTWFya2V0MR0wGwYDVQQzExRB
YWRoYWFyIEhlYWRxdWFydGVyczE3MDUGA1UEAxMuRFMgVW5pcXVlIElkZW50aWZp
Y2F0aW9uIEF1dGhvcml0eSBvZiBJbmRpYSAwNTCCASIwDQYJKoZIhvcNAQEBBQAD
ggEPADCCAQoCggEBAJjCCSo9vCXEzdQe9qdv6YMwwqILobP62yF4Df8mzTYdDVTq
2VdipZa5k+VTmJTKwAabyKeyVP5+oZmt/zteJ+5754Cf8t3KJYfK5O5rA8FQDu2b
lQ/hgs32mDyy5FEvsKh+zOxThyJ/6ciaNUZMZvfJTt3cqMeUbixtlKpuyX1SKJpt
Le0CiaDOa3/CTbz13cLMTfPXlpU9gX+wRf/xtxSohe2R37yMsqrXv96K0URvzPNE
Ki6wz9USHjmud2U4CC13MkDm9smTqjR94jdrkikbLrDTte06ORTm9ifR3ecCDLg7
988ODFk6ygFrk2KJ/dEEnhkSr9XeQEDUbdMeXUsCAwEAAaOCAwQwggMAMA4GA1Ud
DwEB/wQEAwIGwDAqBgNVHSUEIzAhBggrBgEFBQcDBAYKKwYBBAGCNwoDDAYJKoZI
hvcvAQEFMIIBAgYDVR0gBIH6MIH3MIGGBgZggmRkAgIwfDB6BggrBgEFBQcCAjBu
DGxDbGFzcyAyIGNlcnRpZmljYXRlcyBhcmUgdXNlZCBmb3IgZm9ybSBzaWduaW5n
LCBmb3JtIGF1dGhlbnRpY2F0aW9uIGFuZCBzaWduaW5nIG90aGVyIGxvdyByaXNr
IHRyYW5zYWN0aW9ucy4wbAYGYIJkZAoBMGIwYAYIKwYBBQUHAgIwVAxSVGhpcyBj
ZXJ0aWZpY2F0ZSBwcm92aWRlcyBoaWdoZXIgbGV2ZWwgb2YgYXNzdXJhbmNlIGZv
ciBkb2N1bWVudCBzaWduaW5nIGZ1bmN0aW9uLjAMBgNVHRMBAf8EAjAAMCIGA1Ud
EQQbMBmBF2Rpci5sY2ktaHFAdWlkYWkubmV0LmluMIIBAAYDVR0fBIH4MIH1MEKg
QKA+hjxodHRwOi8vd3d3Lm5jb2Rlc29sdXRpb25zLmNvbS9yZXBvc2l0b3J5L25j
b2RlY2EyMnN1YmNhMS5jcmwwga6ggauggaikgaUwgaIxCzAJBgNVBAYTAklOMUEw
PwYDVQQKEzhHdWphcmF0IE5hcm1hZGEgVmFsbGV5IEZlcnRpbGl6ZXJzIGFuZCBD
aGVtaWNhbHMgTGltaXRlZDEPMA0GA1UECxMGU3ViLUNBMS4wLAYDVQQDEyUobilD
b2RlIFNvbHV0aW9ucyBTdWItQ0EgZm9yIERTQyAyMDIyMQ8wDQYDVQQDEwZDUkwx
ODMwKwYDVR0QBCQwIoAPMjAyNDAyMjExMjIzMTlagQ8yMDI2MDIxNjIyMjc0MFow
HwYDVR0jBBgwFoAURsE2obZEOWzewDFm8UhoheJjvzswHQYDVR0OBBYEFKzhXAem
Tyikhe8ZRfMcBEnWfEfTMBkGCSqGSIb2fQdBAAQMMAobBFY4LjMDAgMoMA0GCSqG
SIb3DQEBCwUAA4IBAQAw7POBP18z1+IG4bjBk6vgfIyTH6Vz+e1j7jcmG+sUfY0E
GVKonznB87M4hNcVcylDrwZscJwZxKaYUAt/q1Uph46v37jRjZyAvawZBD/oL1lS
qUmIGQxI+zqUFYrc5dWSHROoCGfkyHAskr60Y3tN489NKo+AsFC1iu1dY29FW2hK
Wt1dQEDYkTeYJu8WPf/XaOR562gq566IFgL6cpYujNrMuKOGj+5o2UbjmCTjkbTp
HdTU+Mja3mYfUDdBia4YVQwDXB07xZD7FiMbhm1oYsATfjiFA1jCy3X8q9dsFkMe
tMjs/7td7cCA1L45savQhcL7+c902NZMolXgRnFx
-----END CERTIFICATE-----
`;
    var verifyRSASha256WithSubtle = async (certificate, signature, signedData) => {
      const publicKey = import_node_forge.pki.certificateFromPem(certificate).publicKey;
      const publicKeyPem = import_node_forge.pki.publicKeyToPem(publicKey);
      const pemHeader = "-----BEGIN PUBLIC KEY-----";
      const pemFooter = "-----END PUBLIC KEY-----";
      const pemContents = publicKeyPem.substring(
        pemHeader.length,
        publicKeyPem.length - pemFooter.length - 2
      );
      const binaryDerString = window.atob(pemContents);
      const binaryDer = str2ab(binaryDerString);
      const pk = await window.crypto.subtle.importKey(
        "spki",
        binaryDer,
        { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
        true,
        ["verify"]
      );
      const isSignatureValid = await window.crypto.subtle.verify(
        { name: "RSASSA-PKCS1-v1_5" },
        pk,
        signature.buffer,
        signedData.buffer
      );
      return { isSignatureValid, certificate };
    };
    var verifySignature = async (qrData, useTestAadhaar) => {
      const bigIntData = BigInt(qrData);
      const byteArray = (0, import_core2.convertBigIntToByteArray)(bigIntData);
      const decompressedByteArray = (0, import_core2.decompressByteArray)(byteArray);
      const signature = decompressedByteArray.slice(
        decompressedByteArray.length - 256,
        decompressedByteArray.length
      );
      const signedData = decompressedByteArray.slice(
        0,
        decompressedByteArray.length - 256
      );
      if (useTestAadhaar) {
        const { isSignatureValid, certificate } = await verifyRSASha256WithSubtle(
          testCertificate,
          signature,
          signedData
        );
        return isSignatureValid ? { isSignatureValid, certificate } : { isSignatureValid };
      } else {
        const results = await Promise.all([
          verifyRSASha256WithSubtle(
            uidai_offline_publickey_26022021,
            signature,
            signedData
          ),
          verifyRSASha256WithSubtle(
            uidai_offline_publickey_17022026,
            signature,
            signedData
          )
        ]);
        const validResult = results.find((result) => result.isSignatureValid);
        return validResult ? { isSignatureValid: true, certificate: validResult.certificate } : { isSignatureValid: false };
      }
    };
    var proveAndSerialize = async (anonAadhaarArgs, setProverState) => {
      let anonAadhaarProof;
      let serialized;
      try {
        anonAadhaarProof = await (0, import_core3.prove)(anonAadhaarArgs, setProverState);
        serialized = await (0, import_core3.serialize)(anonAadhaarProof);
      } catch (e2) {
        console.error(e2);
        throw new Error("Error while generating the proof");
      }
      return { anonAadhaarProof, serialized };
    };
    var processAadhaarArgs = async (qrData, useTestAadhaar, nullifierSeed, fieldsToRevealArray, signal) => {
      let certificateFile = null;
      try {
        if (useTestAadhaar) {
          return (0, import_core3.generateArgs)({
            qrData,
            certificateFile: testCertificate,
            nullifierSeed,
            fieldsToRevealArray,
            signal
          });
        } else {
          const { isSignatureValid, certificate } = await verifySignature(
            qrData,
            useTestAadhaar
          );
          if (!certificate)
            throw new Error(
              "[processAadhaarArgs]: Error while processing the arguments, no certificate retrieved"
            );
          if (isSignatureValid)
            certificateFile = certificate;
          if (!certificateFile)
            throw Error("Error while fetching public key.");
          return (0, import_core3.generateArgs)({
            qrData,
            certificateFile,
            nullifierSeed,
            fieldsToRevealArray,
            signal
          });
        }
      } catch (error) {
        if (error instanceof Error)
          throw new Error(error.message);
        throw new Error(JSON.stringify(error));
      }
    };
    var import_jsx_runtime = require_jsx_runtime();
    function AnonAadhaarProvider(anonAadhaarProviderProps) {
      const [anonAadhaarProofStr, setAnonAadhaarProofStr] = (0, import_react22.useState)(null);
      const [anonAadhaarProof, setAnonAadhaarProof] = (0, import_react22.useState)(null);
      const [appName, setAppName] = (0, import_react22.useState)("The current application");
      const [proverState, setProverState] = (0, import_react22.useState)(
        import_core4.ProverState.Initializing
      );
      const [useTestAadhaar, setUseTestAadhaar] = (0, import_react22.useState)(false);
      const [state, setState] = (0, import_react22.useState)({
        status: "logged-out"
      });
      (0, import_react22.useEffect)(() => {
        if (anonAadhaarProviderProps._appName !== void 0)
          setAppName(anonAadhaarProviderProps._appName);
        if (anonAadhaarProviderProps._useTestAadhaar)
          setUseTestAadhaar(true);
      }, [
        anonAadhaarProviderProps._appName,
        anonAadhaarProviderProps._useTestAadhaar
      ]);
      (0, import_react22.useEffect)(() => {
        let anonAadhaarInitArgs;
        if (anonAadhaarProviderProps._artifactslinks) {
          anonAadhaarInitArgs = {
            wasmURL: anonAadhaarProviderProps._artifactslinks.wasm_url,
            zkeyURL: anonAadhaarProviderProps._artifactslinks.zkey_url,
            vkeyURL: anonAadhaarProviderProps._artifactslinks.vkey_url,
            artifactsOrigin: import_core4.ArtifactsOrigin.server
          };
        } else {
          anonAadhaarInitArgs = {
            wasmURL: import_core4.artifactUrls.v2.wasm,
            zkeyURL: import_core4.artifactUrls.v2.chunked,
            vkeyURL: import_core4.artifactUrls.v2.vk,
            artifactsOrigin: import_core4.ArtifactsOrigin.chunked
          };
        }
        (0, import_core4.init)(anonAadhaarInitArgs).then().catch((e2) => {
          throw Error(e2);
        });
      }, [anonAadhaarProviderProps._artifactslinks]);
      const setAndWriteState = (newState) => {
        console.log(`[ANON-AADHAAR] new state ${shallowToString(newState)}`);
        setState(newState);
        writeToLocalStorage(newState);
      };
      const startReq = import_react3.default.useCallback(
        (request) => {
          console.log(`[ANON-AADHAAR] startReq ${shallowToString(request)}`);
          setAndWriteState(
            handleLoginReq(
              request,
              state,
              setAnonAadhaarProofStr,
              setAnonAadhaarProof,
              setProverState
            )
          );
        },
        [setAndWriteState, setAnonAadhaarProofStr, setAnonAadhaarProof]
      );
      import_react3.default.useEffect(() => {
        if (anonAadhaarProofStr === null || anonAadhaarProof === null)
          return;
        console.log(`[ANON-AADHAAR] trying to log in with ${anonAadhaarProofStr}`);
        handleLogin(state, anonAadhaarProofStr, anonAadhaarProof, useTestAadhaar).then((newState) => {
          if (newState)
            setAndWriteState(newState);
          else
            console.log(
              `[ANON-AADHAAR] ${state.status}, ignoring anonAadhaarProof: ${anonAadhaarProofStr}`
            );
        }).catch((e2) => {
          setAndWriteState({ status: "logged-out" });
          console.error(e2);
          console.error(
            `[ANON-AADHAAR] error logging in, ignoring anonAadhaarProof: ${anonAadhaarProofStr}`
          );
        });
      }, [anonAadhaarProofStr]);
      const val = import_react3.default.useMemo(
        () => ({ state, startReq, proverState, appName, useTestAadhaar }),
        [state, proverState, appName, useTestAadhaar]
      );
      return (0, import_jsx_runtime.jsx)(AnonAadhaarContext.Provider, { value: val, children: anonAadhaarProviderProps.children });
    }
    function writeToLocalStorage(state) {
      console.log(`[ANON-AADHAAR] writing to local storage, status ${state.status}`);
      window.localStorage["anonAadhaar"] = serialize2(state);
    }
    function serialize2(state) {
      const { status } = state;
      let serState;
      if (status === "logged-out") {
        serState = {
          status: "logged-out"
        };
      } else {
        serState = {
          status,
          anonAadhaarProofs: state.anonAadhaarProofs
        };
      }
      return JSON.stringify(serState);
    }
    function shallowToString(obj) {
      return JSON.stringify(obj, function(key, val) {
        if (key === "")
          return val;
        if (val == null)
          return null;
        if (typeof val === "bigint")
          return "" + val;
        if (Array.isArray(val))
          return "<array>";
        if (typeof val === "object")
          return "<object>";
        return val;
      });
    }
    function handleLoginReq(request, state, setAnonAadhaarStr, setAnonAadhaar, setProverState) {
      const { type } = request;
      switch (type) {
        case "login":
          try {
            const { args } = request;
            proveAndSerialize(args, setProverState).then(
              ({
                anonAadhaarProof,
                serialized
              }) => {
                setAnonAadhaarStr(serialized);
                setAnonAadhaar(anonAadhaarProof);
              }
            );
          } catch (error) {
            console.log(error);
          }
          return {
            status: "logging-in",
            ...state.status !== "logged-out" ? {
              anonAadhaarProofs: state.anonAadhaarProofs
            } : {}
          };
        case "logout":
          return { status: "logged-out" };
        default:
          throw new Error(`Invalid request type ${type}`);
      }
    }
    async function handleLogin(state, _anonAadhaarProofStr, _anonAadhaarProof, useTestAadhaar) {
      if (state.status !== "logging-in") {
        console.log(
          `[ANON-AADHAAR] ignoring message. State != logging-in: ${state}`
        );
        return null;
      }
      if (!await (0, import_core4.verify)(_anonAadhaarProof, useTestAadhaar)) {
        throw new Error("Invalid proof");
      }
      const index = state.anonAadhaarProofs === void 0 ? 0 : Object.keys(state.anonAadhaarProofs).length;
      return {
        status: "logged-in",
        anonAadhaarProofs: {
          ...state.anonAadhaarProofs,
          [index]: _anonAadhaarProofStr
        }
      };
    }
    var import_react4 = require_react();
    var import_styled_components = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_jsx_runtime2 = require_jsx_runtime();
    var AnonAadhaarProof = ({
      code,
      label
    }) => {
      const [collapsed, setCollapsed] = (0, import_react4.useState)(true);
      const toggle = (0, import_react4.useCallback)(() => {
        setCollapsed((collapsed2) => !collapsed2);
      }, []);
      let buttonText = collapsed ? "Show proof" : "Hide proof";
      if (label !== void 0) {
        buttonText += " " + label;
      }
      if (collapsed) {
        return (0, import_jsx_runtime2.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText });
      }
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(RevealProofBtn, { onClick: toggle, children: buttonText }),
        (0, import_jsx_runtime2.jsx)(ProofContainer, { children: (0, import_jsx_runtime2.jsx)("pre", { children: code }) })
      ] });
    };
    var ProofContainer = import_styled_components.default.div`
  border-radius: 8px;
  border: 1px solid grey;
  overflow-y: scroll;
  max-width: 100%;
  padding: 8px;
`;
    var RevealProofBtn = import_styled_components.default.button`
  font-size: 1rem;
  cursor: pointer;
  color: #000000;
  font-weight: bold;
  border-radius: 1.3125rem;
  background: #fff;
  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);
  border: none;
  min-width: 8rem;
  min-height: 2rem;
  border-radius: 0.5rem;
`;
    var import_react12 = require_react();
    var import_react11 = require_react();
    var import_styled_components9 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_react5 = require_react();
    var import_styled_components2 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_jsx_runtime3 = require_jsx_runtime();
    var ErrorToast = ({
      message,
      setErrorMessage
    }) => {
      const [isVisible, setIsVisible] = (0, import_react5.useState)(false);
      (0, import_react5.useEffect)(() => {
        if (message)
          setIsVisible(true);
      }, [message]);
      const handleClose = () => {
        setIsVisible(false);
        setErrorMessage(null);
      };
      return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: isVisible && (0, import_jsx_runtime3.jsxs)(Box, { children: [
        (0, import_jsx_runtime3.jsx)(Message, { children: message }),
        (0, import_jsx_runtime3.jsx)(CloseButton, { onClick: handleClose })
      ] }) });
    };
    var Box = import_styled_components2.default.div`
  display: flex;
  position: absolute;
  width: 85%;
  border-radius: 5px;
  background-color: #efc8c8;
  padding: 4px;
  align-items: flex-start;
`;
    var Message = import_styled_components2.default.div`
  text-align: left;
  margin-left: 3px;
  font-size: 0.875rem;
  color: #a00f0f;
  flex: 1;
  width: fit-content;
  max-width: 92%;
  overflow: hidden;
  text-overflow: ellipsis;
`;
    var CloseButton = import_styled_components2.default.button`
  border: none;
  background: none;
  color: #a00f0f;
  cursor: pointer;
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;

  &::before,
  &::after {
    content: '';
    position: absolute;
    width: 2px;
    height: 12px;
    background-color: currentColor;
  }

  &::before {
    transform: rotate(45deg);
  }

  &::after {
    transform: rotate(-45deg);
  }
`;
    var import_react_device_detect = require_lib2();
    var import_styled_components4 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_react6 = require_react();
    var import_styled_components3 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var icons = {
      aalogo: '<svg xmlns="http://www.w3.org/2000/svg" width="173" height="173" fill="none"><path fill="#FD8B0E" d="M80.39.81v22.03c0 .45-.36.81-.81.81H31.52c-4.2 0-7.6 3.4-7.6 7.6V79.7c0 .45-.36.81-.81.81H.81c-.45 0-.81-.36-.81-.81V53.47c0-3.69 1.47-7.24 4.08-9.85l39.5-39.49c2.6-2.6 6.13-4.07 9.82-4.08L79.57 0c.45 0 .82.36.82.81"/><path fill="#081224" d="M91.85.81v22.03c0 .45.36.81.81.81h48.05c4.2 0 7.6 3.4 7.6 7.6V79.7c0 .45.36.81.81.81h22.29c.45 0 .81-.36.81-.81V53.47c0-3.69-1.47-7.24-4.08-9.85L128.66 4.13a13.94 13.94 0 0 0-9.82-4.08L92.67 0c-.45 0-.82.36-.82.81M80.39 171.56v-22.03c0-.45-.36-.81-.81-.81H31.52c-4.2 0-7.6-3.4-7.6-7.6V92.67c0-.45-.36-.81-.81-.81H.81c-.45 0-.81.36-.81.81v26.23c0 3.69 1.47 7.24 4.08 9.85l39.5 39.5c2.61 2.61 6.14 4.07 9.82 4.08l26.18.05c.45 0 .82-.36.82-.81z"/><path fill="#009A08" d="M91.85 171.56v-22.03c0-.45.36-.81.81-.81h48.05c4.2 0 7.6-3.4 7.6-7.6V92.67c0-.45.36-.81.81-.81h22.29c.45 0 .81.36.81.81v26.23c0 3.69-1.47 7.24-4.08 9.85l-39.5 39.5a13.934 13.934 0 0 1-9.82 4.08l-26.18.05c-.45 0-.82-.36-.82-.81z"/></svg>',
      illustration: '<svg xmlns="http://www.w3.org/2000/svg" width="82" height="82" fill="none"><path fill="#191919" d="M46.733 19.72c-1.386-2.03-4.097-1.749-6.242-1.734-5 .033-25.743.008-27.2.08-2.244.116-4.497 1.025-4.861 3.258-.197 1.206-.022 2.496.023 3.712.18 4.921.316 11.01.922 15.395.164 1.193.38 2.388 1.122 3.374 1.171 1.556 3.492 2.103 5.44 2.136.022.038 17.84.457 24.28-.025 1.875-.14 4.156-.282 5.42-1.885.633-.805.686-1.964.813-2.94.456-3.504.76-9.433 1.158-15.791.114-1.816.202-4.002-.875-5.58m.492 4.424c-.013.727-.555 9.325-.59 9.846-.12 1.764-.509 7.313-1.01 9.046-.496 1.71-2.724 2.131-4.238 2.292a51.503 51.503 0 0 1-3.863.26c-6.62.214-20.998.17-21.574.154-2.332-.108-4.949-.791-5.828-3.211a13.11 13.11 0 0 1-.534-3.384c-.438-5.278-.37-6.87-.707-14.994-.048-1.163-.285-2.53.248-3.618 1.17-2.376 4.702-2.043 6.866-2.067 2.545-.028 24.146-.044 25.483-.055 1.189-.01 2.472-.07 3.58.446 1.996.93 2.202 3.345 2.167 5.283zM28.015 47.531c.312.704 1.48.348 1.072-.592a.592.592 0 0 0-.879-.258c-.248.17-.465.627-.185.87a.08.08 0 0 0 .124-.012.08.08 0 0 0 .014-.045c.017-.186-.02-.384.135-.523a.368.368 0 0 1 .574.061.431.431 0 0 1-.075.583.49.49 0 0 1-.65-.16c-.051-.084-.168-.01-.13.076M26.426 51.863c.628.107 1.264.15 1.9.13.694.02 1.392.044 2.086.04a.178.178 0 0 0 0-.357c-.694-.028-1.392-.03-2.086-.033a9.359 9.359 0 0 0-1.9.063.083.083 0 0 0-.042.128c.01.014.026.024.042.03"/><path fill="#191919" d="M49.812 18.044a4.262 4.262 0 0 0-2.337-2.22c-1.325-.52-2.8-.438-4.195-.425-5.942.055-30.336.037-32.016.106a7.593 7.593 0 0 0-3.727 1.034c-2.533 1.6-1.955 4.27-1.854 7.262.195 5.755.343 12.898.988 18.013.17 1.347.357 2.71 1.08 3.891 1.292 2.106 3.908 2.901 6.369 2.891.095 0 5.565.131 11.839.178.01.331.075.697.112 1.046-.137-.017-3.82.075-4.903.23a.156.156 0 0 0-.113.21c-.555.47-1.046 1.051-1.552 1.564-.622.628-1.28 1.237-1.86 1.903a.133.133 0 0 0 .187.188c.652-.598 1.244-1.27 1.857-1.907.51-.532 1.094-1.046 1.554-1.627a45.948 45.948 0 0 1 4.856-.175c.003.264-.011.577.251.71.04.022.11.007.118-.048.02-.35.005-.7-.043-1.046a3.288 3.288 0 0 0-.195-1.045c1.462.01 2.964.015 4.449.013a3.567 3.567 0 0 0-.08 1.859.095.095 0 0 0 .18 0 2.31 2.31 0 0 0 .093-.538c.823.11 1.504.033 3.721.172.337.02.817.026 1.1.024a8.072 8.072 0 0 0 1.461 1.538c.541.532 1.111 1.033 1.707 1.501.144.109.322-.129.193-.25-.574-.524-1.177-1.015-1.75-1.543a15.075 15.075 0 0 0-1.395-1.314.111.111 0 0 0-.048-.13 2.664 2.664 0 0 0-1.063-.167c-.48-.03-.96-.054-1.44-.07-.819-.081-1.643-.11-2.466-.086.023-.357.084-.686.087-.996 4.236-.01 8.298-.083 10.846-.285 2.163-.172 4.81-.298 6.29-2.132.767-.948.839-2.26.99-3.425.635-4.92.901-12.521 1.303-18.152.162-2.21.352-4.681-.594-6.752m.26 5.067c-.023.68-.62 10.508-.683 11.488-.136 2.065-.582 8.506-1.144 10.524-.543 1.95-2.943 2.52-4.684 2.732a51.73 51.73 0 0 1-4.504.328c-7.638.26-24.618.165-24.922.154-2.77-.121-5.716-1.018-6.666-3.912-.42-1.28-.471-2.677-.578-4.013-.42-5.297-.391-6.99-.764-17.321-.05-1.37-.293-2.89.097-4.226.917-3.134 5.046-2.929 7.593-2.962 3.013-.04 28.773-.071 30.311-.08 1.386-.008 2.879.027 4.053.865 1.944 1.386 1.967 4.277 1.892 6.422zM3.215 64.738c.243-.345 5.932-6.756 6.215-7.075a1.717 1.717 0 0 1 1.467-.603c3.875-.023 7.751-.047 11.626.015 7.231.118 23.137-.287 23.67-.282.523.006 1.198-.115 1.597.269.38.366 4.316 5.719 5.691 7.152.214.223.552-.115.339-.338-1.347-1.405-4.71-5.932-5.259-6.616a2.778 2.778 0 0 0-.764-.812c-.686-.342-8.65.075-12.054.153-4.03.092-2.993.02-24.419.015-.948 0-1.619.04-2.243.816-.718.893-5.823 6.814-6.052 7.196-.071.122.107.22.186.11M53.128 66.26c.351-.598 1.079-1.576.73-1.689-.54-.172-50.546.289-50.546.289s-.962.025-.04.883c.922.857.965 1.077 2.63 1.012 1.664-.064 42.49-.194 43.629-.176 1.138.018 3.374.06 3.597-.319"/><path fill="#191919" d="M8.526 60.692c-.354.438-1.925 2.053-1.989 2.453a.174.174 0 0 0 .077.188c.214.138 6.734 0 8.187-.005 3.07-.013 24.83.12 25.381.128.421.005.72-.084.513-.556-.703-1.608-1.402-3.217-2.116-4.82-.182-.407-.327-.462-.764-.46 0 0-26.107 0-26.933-.01a.149.149 0 0 0 0 .298c5.161.05 25.73-.014 27.178.072.117.007-.04-.265 2.258 4.918.033.072.024.201-.357.21-.264.006-25.514-.1-31.297-.057-.308 0-1.611.054-1.602-.023.032-.259 2.042-2.395 3.757-5.022.059-.09-.08-.165-.142-.083-.003-.001-1.366 1.796-2.151 2.769M41.396 62.223c.132.387.301.76.505 1.115.12.166.201.164.402.17 1.122.035 4.24-.107 7.36-.046.206.004 1.057.134 1.045-.201-.016-.492-1.511-2.231-3.573-5.448-.235-.368-.336-.39-.802-.37-.76.032-5.242.194-6.721.242-.197.006-.198.312 0 .306 7.633-.241 7.045-.26 7.092-.23.15.096.301.466.398.614.215.327 2.834 4.225 3.071 4.566.142.203.003.191-.281.186-.322-.007-7.309.038-7.536.036-.281-.004-.419-.553-.534-.798-1.474-3.151-1.71-3.637-2.112-4.294-.064-.104-.228-.072-.183.033.705 1.651 1.228 2.67 1.869 4.119"/><path fill="#F2AE7F" d="M23.74 26.961c-.133-1.717.603-3.482 1.326-4.222a4.21 4.21 0 0 1 5.554-.171 5.759 5.759 0 0 1 1.92 3.575c.078.329.361 1.16-.764 1.236-.08.006-.311-.197-.343-.26-.322-.623-.376-1.343-.648-1.988a3.582 3.582 0 0 0-1.725-1.896 2.417 2.417 0 0 0-2.48.232 3.69 3.69 0 0 0-1.189 2.232c-.367 2.346.55 4.007.783 4.107a.983.983 0 0 0 .412.05c1.106-.027 5.503-.201 6.55-.18.111.003.358.04.428.233.25.694.108 2.377.095 2.55-.054.663-.46.233-1.14.66-2.272-.281-3.067-.394-3.499-.27a.676.676 0 0 0-.426.32.694.694 0 0 0 .408.876c.33.146.727.192.992.335-.022.442.03.61.009 1.055a.77.77 0 0 0 .032.332.514.514 0 0 0 .41.281c.173.015.348 0 .516-.044a4.75 4.75 0 0 1 .273-1.625c.334.055.708.191 1.042.247.04.009-.293 1.113-.23 1.559.022.158.287.115.313.147.39.495.54.597.81.662.303.074.349.212.406.575.402 2.563-2.19 4.877-4.859 4.923-1.495.027-4.084 0-5.957-2.702a3.587 3.587 0 0 1-.684-2.017c.048-.174.128-.337.235-.482.647-.618 1.153-1.153 1.066-2.283-.072-.937-.456-1.786-1.35-1.953-.078-.014-.254-.28-.266-.358a9.533 9.533 0 0 1-.057-2.506.357.357 0 0 1 .156-.15c.504-.107 1.778-.033 2.279-.127a.49.49 0 0 0 .134-.38 9.466 9.466 0 0 1-.533-2.573"/><path fill="#191919" d="M38.797 29.258c-.046.755-.507 9.873-.32 10.614a.1.1 0 0 0 .098.072.102.102 0 0 0 .097-.072c.216-.703.222-9.724.21-10.614a.043.043 0 0 0-.042-.043.043.043 0 0 0-.043.043M58.86 32.705a4.651 4.651 0 0 0-3.388.274c-1.367.668-2.26 2.064-2.794 3.547a1.563 1.563 0 0 0-.792-.668c-.599-.223-1.794 0-1.827.796a.12.12 0 0 0 .206.084c.42-.336.876-.68 1.448-.467a1.06 1.06 0 0 1 .68.82 1.136 1.136 0 0 1-.647 1.127 1.389 1.389 0 0 1-1.609-.556c-.02-.024-.068-.02-.064.016.084.903 1.352 1.287 2.096.793-.379 2.206.095 4.806 2.095 5.823a4.169 4.169 0 0 0 5.692-1.916c.127-.262-.26-.492-.394-.23a3.703 3.703 0 0 1-4.581 1.922c-1.999-.644-2.622-2.922-2.466-4.81.119-1.211.457-2.39.999-3.48.37-.88.986-1.636 1.775-2.174a4.352 4.352 0 0 1 3.173-.526c1.751.377 2.778 2.431 2.618 4.078-.009.086.116.09.142.018.624-1.71-.696-3.897-2.363-4.47"/><path fill="#191919" d="M58.41 41.094c-.608.469-1.2.997-2.005 1.045-1.422.087-2.805-1.633-1.835-4.208.478-1.269 1.522-3.032 3.051-3.08a1.76 1.76 0 0 1 1.61.907c.197.39.092.801.234 1.19.04.11.223.17.283.037.385-.847-.208-1.89-.956-2.308-1.126-.629-2.408-.12-3.214.775-1.477 1.644-2.843 5.164-.486 6.704 1.177.77 2.633.087 3.428-.917.061-.073-.02-.216-.11-.145M29.34 32.979a4.936 4.936 0 0 1 1.718.086c2.65.327 5.288 1.008 6.985.893.062-.005.087-.103.015-.117-1.176-.224-2.386-.26-3.568-.464-1.132-.195-2.26-.418-3.398-.57a6.135 6.135 0 0 0-1.772-.142 1.126 1.126 0 0 0-1.046-.47c-1.352.01-1.642 1.475-1.134 2.342.16.273.364.52.603.729a.314.314 0 0 1 .09.348 39.27 39.27 0 0 1-.774 1.94.175.175 0 0 0 .012.163.173.173 0 0 0 .142.08c.79.022 1.613.053 2.401.036a.171.171 0 0 0 .167-.154.173.173 0 0 0-.01-.08c-.27-.695-.42-1.344-.696-2.014a.307.307 0 0 1 .088-.358 1.104 1.104 0 0 0 .378-.883c.644.246-.07 1.184.175 1.636.141.26.831.368 1.092.305.466-.114.338-1.304.49-1.557.093-.158.753.047.777.09a1.64 1.64 0 0 1-.076.373c-.066.361-.362 1.012.092 1.175.173.028.348.043.523.044.134.042.273.07.413.086.45-.035.344-.729.418-1.081.104-.503.364-.37.773-.294a37.46 37.46 0 0 0 3.71.634c.169.014.211-.275.04-.301-1.006-.152-1.998-.3-2.991-.519a6.425 6.425 0 0 0-1.453-.295c-.3.013-.313.23-.362.491a3.217 3.217 0 0 1-.143.882c-.125.186-.306.08-.506.062-.48-.043-.305-.279-.294-.344.044-.263.306-.942.066-1.163a2.648 2.648 0 0 0-1.006-.227c-.17.026-.197.11-.246.257-.057.22-.102.441-.135.665-.029.137.033.799-.5.644-.3-.118-.338-.161-.373-.487-.036-.326.148-.676.11-.996-.03-.246-.103-.268-.349-.326-.264-.062-.574-.035-.795-.22-.444-.372-.053-.796.349-.899M49.026 33.319v.071c0 .006.01.006.01 0 0-.023 0-.048.004-.071 0-.008-.014-.009-.014 0M17.623 54.048s21.258-.274 21.464-.23c.206.046-.05 1.42-.684 1.417-.633-.004-19.623.149-19.93.027-.307-.121-1.178-1.21-.85-1.214M61.926 35.055c.718.008 5.775-.568 6.485-.495.727.073 10.023 1.952 10.746 1.92.055 0 .09-.087.031-.114-.672-.306-9.827-2.09-10.686-2.168-.74-.064-5.3.285-6.584.791a.033.033 0 0 0 .008.066"/><path fill="#191919" d="M58.777 38.473c5.509.25 8.002-2.433 11.887-1.649.172.035.414.033.45-.138.04-.182-.209-.255-.39-.295a7.166 7.166 0 0 0-4.377.272 26.14 26.14 0 0 1-7.57 1.73.04.04 0 0 0-.03.068.04.04 0 0 0 .03.012"/><path fill="#191919" d="M59.245 39.578c1.792 2.044 5.152 1.198 7.425.8 2.237-.393 4.046.607 6.213.885.757.098 1.717.181 2.423-.17.126-.064.047-.225-.065-.239-.483-.059-1.22.189-2.797-.137-.975-.202-1.884-.563-2.838-.822-2.395-.643-4.745.764-7.114.569-2.89-.236-3.795-2.01-3.852-2.01.135.406.34.787.605 1.124M60.363 43.519c1.665.085 3.335.167 4.987.395 2.301.319 4.488 1.37 6.843 1.229 2.356-.14 4.592-1.096 6.963-1.116a.126.126 0 0 0 .064-.233c-1.254-.652-2.319.007-4.026.348-1.459.29-2.875.692-4.359.494-1.83-.245-3.559-.954-5.397-1.185a19.28 19.28 0 0 0-5.092-.043c-.063.011-.043.108.017.11M10.286 62.706l.003-.001v-.006l-.003-.001-.002.001v.006zM38.604 61.193c-.361-.006-.97-.01-1.775-.013-.194-.485.084.236-.7-1.741.705 0 1.245 0 1.575.004a.125.125 0 0 0 0-.25c-.338-.004-.916-.009-1.679-.012-.183-.442-.243-.51-.39-.588a.09.09 0 0 0-.11.017.09.09 0 0 0-.019.034c-.047.135-.053.217.058.535-1.41-.005-3.318-.007-5.45-.008a3.787 3.787 0 0 0-.326-.72.083.083 0 0 0-.154.04c.005.229.032.456.08.679-1.814 0-3.774 0-5.717.004l-.03-.513a.095.095 0 0 0-.094-.088.094.094 0 0 0-.094.088c-.017.171-.035.343-.05.514-2.026.002-4.022.007-5.81.012a1.032 1.032 0 0 0-.06-.459c-.018-.043-.075-.071-.11-.03a1.02 1.02 0 0 0-.214.49c-2.034.007-3.766.016-4.908.026.117-.182.215-.376.29-.58.061-.17-.197-.328-.315-.182-.199.249-.387.505-.566.768-.273.001-.547.006-.82.015a.082.082 0 0 0-.058.14.082.082 0 0 0 .058.023c.187.014.413.027.673.038-.955 1.42-.877 1.267-1.218 1.782a48.47 48.47 0 0 0-1.105.016.081.081 0 0 0-.082.082.082.082 0 0 0 .082.082c.225.016.55.03.961.04a7.85 7.85 0 0 0-.54.986.07.07 0 0 0 .078.102.07.07 0 0 0 .042-.032c.241-.35.51-.702.786-1.046 1.368.031 3.466.044 5.915.046a3.712 3.712 0 0 0-.21.953c-.007.117.145.133.202.054.21-.308.372-.647.479-1.005 1.955 0 4.11-.005 6.284-.013-.04.341-.002.686.113 1.01a.14.14 0 0 0 .19.05.14.14 0 0 0 .051-.05c.129-.321.181-.667.154-1.012 2.14-.008 4.284-.019 6.256-.028.087.314.211.617.37.902a.126.126 0 0 0 .233-.063 3.954 3.954 0 0 0-.132-.84c2.198-.01 4.159-.019 5.63-.019.134.371.317.723.544 1.046.057.076.22.066.208-.056a4.194 4.194 0 0 0-.252-.99c.719 0 1.29.003 1.678.01a.126.126 0 0 0 .115-.078.124.124 0 0 0-.117-.172m-27.523.022c.509-.624 1.02-1.223 1.386-1.756 1.226.04 2.97.058 4.979.065-.146.564-.323 1.12-.53 1.664-2.431.008-4.505.017-5.835.027m6.293-.028c.38-1.275.419-1.287.497-1.662 1.807.005 3.807 0 5.825-.01-.09 1.012-.061 1.057-.112 1.659-2.07.003-4.14.007-6.21.013m6.683-.014c-.023-.537.005-.683-.042-1.659 1.97-.009 3.946-.023 5.771-.036.1.393-.017-.103.46 1.69-1.952.001-4.073.002-6.189.005m6.66-.003-.504-1.695c2.141-.015 4.048-.029 5.447-.035.314.824.215.508.67 1.738a1774.75 1774.75 0 0 0-5.612-.008M48.372 61.506c-.216-.077-.409-.108-1.347-.096a22.81 22.81 0 0 0-1.212-2.085c.401.022.803-.014 1.194-.106a.127.127 0 0 0 0-.242 4.396 4.396 0 0 0-1.47-.073 33.517 33.517 0 0 0-.402-.588.109.109 0 0 0-.188.11l.274.49c-.67.024-1.755.07-2.466.102a3.967 3.967 0 0 0-.595-.74.072.072 0 0 0-.085-.01.072.072 0 0 0-.033.078c.066.239.153.47.26.693a7.32 7.32 0 0 0-1.429.123.082.082 0 0 0 0 .159c.532.11 1.077.139 1.618.087.215.395.458.78.66 1.153.163.3.316.622.48.938a6.609 6.609 0 0 0-1.542.116.08.08 0 0 0-.065.08.08.08 0 0 0 .065.078c.574.108 1.16.14 1.743.098.16.294.352.57.573.822.06.066.155-.006.14-.08a3.796 3.796 0 0 0-.235-.742c.855-.004 1.986-.014 2.534-.022.126.227.27.444.43.649.062.08.208.04.175-.073a4.88 4.88 0 0 0-.217-.58c.384.027.77-.006 1.144-.097a.126.126 0 0 0-.004-.242m-4.243-.02c-.196-.39-.425-.769-.625-1.131-.167-.301-.335-.633-.52-.956.603-.014 1.401-.036 2.47-.065.582 1.045.922 1.672 1.147 2.084-.532.008-1.053.026-2.472.066z"/></svg>',
      alert: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16M2 12C2 6.477 6.477 2 12 2s10 4.477 10 10-4.477 10-10 10S2 17.523 2 12" clip-rule="evenodd"/><path fill="#fff" d="M13 8a1 1 0 1 0-2 0v4a1 1 0 1 0 2 0zM12 15a1 1 0 1 0 0 2 1 1 0 0 0 0-2"/></svg>',
      arrowDown: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M5.293 9.707a1 1 0 0 1 1.32-1.497l.094.083L12 13.585l5.293-5.292a1 1 0 0 1 1.32-.083l.094.083a1 1 0 0 1 .083 1.32l-.083.094-6 6a1 1 0 0 1-1.32.083l-.094-.083z" clip-rule="evenodd"/></svg>',
      arrowUp: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M18.707 14.293a1 1 0 0 1-1.32 1.497l-.094-.083L12 10.415l-5.293 5.292a1 1 0 0 1-1.32.083l-.094-.083a1 1 0 0 1-.083-1.32l.083-.094 6-6a1 1 0 0 1 1.32-.083l.094.083z" clip-rule="evenodd"/></svg>',
      arrow: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="m16.58 11.012-2.29-2.285v-.01a.987.987 0 0 1 0-1.418c.39-.399 1.02-.399 1.42 0l4 3.992c.236.23.33.554.28.86a1 1 0 0 1-.39.656L15.7 16.7c-.19.18-.45.289-.71.289L15 17c-.27 0-.53-.11-.71-.29a.996.996 0 0 1-.01-1.417v-.01l2.28-2.275H5c-.56 0-1-.45-1-.998a.99.99 0 0 1 1-.998z" clip-rule="evenodd"/></svg>',
      externalLink: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M20.383 3.076A.997.997 0 0 0 20 3h-5l-.117.007A1 1 0 0 0 14 4l.007.117A1 1 0 0 0 15 5h2.586l-8.293 8.293-.083.094a1 1 0 0 0 1.497 1.32L19 6.414V9l.007.117A1 1 0 0 0 21 9V4a1.001 1.001 0 0 0-.617-.924M11 6a1 1 0 0 1 .117 1.993L11 8H6a1 1 0 0 0-.993.883L5 9v9a1 1 0 0 0 .883.993L6 19h9a1 1 0 0 0 .993-.883L16 18v-5a1 1 0 0 1 1.993-.117L18 13v5a3 3 0 0 1-2.824 2.995L15 21H6a3 3 0 0 1-2.995-2.824L3 18V9a3 3 0 0 1 2.824-2.995L6 6z" clip-rule="evenodd"/></svg>',
      menu: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M20 5a1 1 0 0 1 .117 1.993L20 7H4a1 1 0 0 1-.117-1.993L4 5zm0 6a1 1 0 0 1 .117 1.993L20 13H4a1 1 0 0 1-.117-1.993L4 11zm1 7a1 1 0 0 0-1-1H4l-.117.007A1 1 0 0 0 4 19h16l.117-.007A1 1 0 0 0 21 18" clip-rule="evenodd"/></svg>',
      x: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M7.382 6.18a.857.857 0 0 0-1.13 1.283L10.787 12 6.25 16.537l-.071.08a.857.857 0 0 0 1.283 1.132L12 13.212l4.537 4.537.08.071a.857.857 0 0 0 1.132-1.283L13.212 12l4.537-4.537.071-.08a.857.857 0 0 0-1.283-1.132L12 10.788 7.463 6.25z" clip-rule="evenodd"/></svg>',
      fileUpload: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#081224" fill-rule="evenodd" d="M17 22zc1.65 0 3-1.35 3-3V8a1.011 1.011 0 0 0-.29-.71l-5-5A.966.966 0 0 0 14 2H7C5.34 2 4 3.34 4 5v14c0 1.65 1.34 3 3 3zM13 4H7c-.56 0-1 .44-1 1v14c0 .55.44 1 1 1h10c.55 0 1-.45 1-1V9h-3a2 2 0 0 1-2-2zm2 1.41V7h1.59zM12 18c-.56 0-1-.45-1-1v-3.585L9.71 14.71v-.01c-.4.39-1.03.39-1.42 0-.4-.4-.4-1.03 0-1.42l3-3c.38-.4 1.02-.4 1.41-.01l3 3c.39.38.39 1.02 0 1.41h-.01c-.19.18-.45.29-.71.29L15 15c-.27 0-.53-.11-.71-.29L13 13.414V17c0 .55-.45 1-1 1" clip-rule="evenodd"/></svg>',
      xBlack: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none"><path fill="#334155" fill-rule="evenodd" d="M7.382 6.18a.857.857 0 0 0-1.13 1.283L10.787 12 6.25 16.537l-.071.08a.857.857 0 0 0 1.283 1.132L12 13.212l4.537 4.537.08.071a.857.857 0 0 0 1.132-1.283L13.212 12l4.537-4.537.071-.08a.857.857 0 0 0-1.283-1.132L12 10.788 7.463 6.25z" clip-rule="evenodd"/></svg>',
      eyeOff: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="#B6B9C3" d="M4.478 4.478c-1.54 1.159-2.39 2.71-2.776 3.577a2.315 2.315 0 0 0 0 1.89C2.356 11.41 4.42 15 9 15c1.906 0 3.395-.63 4.522-1.478l-1.074-1.074c-.872.61-1.997 1.052-3.448 1.052-3.641 0-5.332-2.83-5.927-4.165a.815.815 0 0 1 0-.67C3.418 7.89 4.166 6.55 5.48 5.603a.758.758 0 0 0 .067-.054z"/><path fill="#B6B9C3" d="M6.879 6.879a3 3 0 1 0 4.243 4.243L10.06 10.06A1.5 1.5 0 1 1 7.94 7.94zM9 3c4.582 0 6.646 3.59 7.298 5.055a2.316 2.316 0 0 1 0 1.89 9.937 9.937 0 0 1-.476.93.75.75 0 1 1-1.298-.75c.172-.298.305-.57.403-.79a.816.816 0 0 0 0-.67C14.333 7.33 12.642 4.5 9 4.5h-.75a.75.75 0 1 1 0-1.5z"/><path fill="#B6B9C3" fill-rule="evenodd" d="M1.72 1.72a.75.75 0 0 1 1.06 0l13.5 13.5a.75.75 0 1 1-1.06 1.06L1.72 2.78a.75.75 0 0 1 0-1.06" clip-rule="evenodd"/></svg>',
      eye: '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none"><path fill="#009A08" fill-rule="evenodd" d="M9 4.5c-3.641 0-5.332 2.83-5.927 4.165a.816.816 0 0 0 0 .67C3.668 10.67 5.359 13.5 9 13.5c3.642 0 5.333-2.83 5.927-4.165a.816.816 0 0 0 0-.67C14.333 7.33 12.642 4.5 9 4.5M1.703 8.055C2.355 6.59 4.419 3 9 3c4.582 0 6.646 3.59 7.298 5.055a2.316 2.316 0 0 1 0 1.89C15.646 11.409 13.582 15 9 15c-4.581 0-6.645-3.59-7.297-5.055a2.316 2.316 0 0 1 0-1.89" clip-rule="evenodd"/><path fill="#009A08" fill-rule="evenodd" d="M9 6a3 3 0 1 0 0 6 3 3 0 0 0 0-6m-.064 1.501L9 7.5a1.5 1.5 0 1 1-1.499 1.436 1.125 1.125 0 0 0 1.435-1.435" clip-rule="evenodd"/></svg>'
    };
    var import_jsx_runtime4 = require_jsx_runtime();
    var FileInput = ({
      onChange,
      id,
      setQrStatus,
      qrStatus
    }) => {
      const [fileName, setFileName] = (0, import_react6.useState)(null);
      const fileInputRef = (0, import_react6.useRef)(null);
      const uploadIcon = createBlobURL(icons.fileUpload);
      const xIcon = createBlobURL(icons.xBlack);
      const clearFileInput = () => {
        if (fileInputRef.current) {
          fileInputRef.current.value = "";
          setFileName(null);
          setQrStatus(null);
        }
      };
      return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        (0, import_jsx_runtime4.jsxs)(InputFile, { htmlFor: id, children: [
          (0, import_jsx_runtime4.jsx)(
            "input",
            {
              type: "file",
              id,
              ref: fileInputRef,
              onChange: (e2) => {
                if (!e2.target.files)
                  return;
                setFileName(e2.target.files[0].name);
                onChange(e2);
              },
              accept: "image/*",
              hidden: true
            }
          ),
          (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: uploadIcon }),
          (0, import_jsx_runtime4.jsx)(FileName, { id: "file-chosen", children: "Choose file" })
        ] }),
        fileName && (() => {
          switch (qrStatus) {
            case "QR code invalid ":
              return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
                (0, import_jsx_runtime4.jsxs)(InputFileWrong, { children: [
                  (0, import_jsx_runtime4.jsx)(FileName, { id: "file-chosen", children: fileName }),
                  (0, import_jsx_runtime4.jsx)("button", { onClick: clearFileInput, children: (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })
                ] }),
                (0, import_jsx_runtime4.jsx)(DocumentResultWrong, { children: "Invalid QR Code." })
              ] });
            case "Signature verified ":
              return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
                (0, import_jsx_runtime4.jsxs)(InputFileCorrect, { children: [
                  (0, import_jsx_runtime4.jsx)(FileName, { id: "file-chosen", children: fileName }),
                  (0, import_jsx_runtime4.jsx)("button", { onClick: clearFileInput, children: (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })
                ] }),
                (0, import_jsx_runtime4.jsx)(DocumentResultCorrect, { children: "Valid QR Code." })
              ] });
            case "QR code scanned, verifying QR Code ":
              return (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
                (0, import_jsx_runtime4.jsxs)(FileNameContainer, { children: [
                  (0, import_jsx_runtime4.jsx)(FileName, { id: "file-chosen", children: fileName }),
                  (0, import_jsx_runtime4.jsx)("button", { onClick: clearFileInput, children: (0, import_jsx_runtime4.jsx)(FileUploadIcon, { src: xIcon }) })
                ] }),
                (0, import_jsx_runtime4.jsx)(DocumentResult, { children: "Verifying QR Code." })
              ] });
          }
        })()
      ] });
    };
    var FileName = import_styled_components3.default.span`
  margin-left: 5px;
`;
    var InputFile = import_styled_components3.default.label`
  display: flex;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  max-width: 80%;
  border-radius: 4px;
  border-width: 1px;
  border-color: black;
  max-width: 100%;
  font-size: '16px';
  line-height: 1.25rem;
  color: #111827;
  padding-top: 6px;
  padding-bottom: 6px;
  padding-left: 14px;
  padding-right: 14px;
  cursor: pointer;
  margin-top: 0.3rem;
`;
    var FileNameContainer = import_styled_components3.default.label`
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  display: flex;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  max-width: 80%;
  border-radius: 4px;
  border-width: 1px;
  border-color: black;
  max-width: 100%;
  font-size: '16px';
  line-height: 1.25rem;
  color: #111827;
  padding-top: 6px;
  padding-bottom: 6px;
  padding-left: 14px;
  padding-right: 14px;
  cursor: pointer;
  margin-top: 0.3rem;
`;
    var InputFileCorrect = import_styled_components3.default.label`
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  display: flex;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  max-width: 80%;
  border-radius: 4px;
  border-width: 2px;
  border-color: #00bf06;
  max-width: 100%;
  font-size: '16px';
  line-height: 1.25rem;
  color: #111827;
  padding-top: 6px;
  padding-bottom: 6px;
  padding-left: 14px;
  padding-right: 14px;
  cursor: pointer;
  margin-top: 0.3rem;
`;
    var InputFileWrong = import_styled_components3.default.label`
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  display: flex;
  align-items: center;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  max-width: 80%;
  border-radius: 4px;
  border-width: 2px;
  border-color: #ef4444;
  max-width: 100%;
  font-size: '16px';
  line-height: 1.25rem;
  color: #111827;
  padding-top: 6px;
  padding-bottom: 6px;
  padding-left: 14px;
  padding-right: 14px;
  cursor: pointer;
  margin-top: 0.3rem;
`;
    var FileUploadIcon = import_styled_components3.default.img`
  height: 1.5rem;
`;
    var DocumentResultCorrect = import_styled_components3.default.div`
  color: #00bf06;
  position: absolute;
  font-size: 0.875rem;
  margin-top: 4px;
`;
    var DocumentResult = import_styled_components3.default.div`
  color: #717686;
  position: absolute;
  font-size: 0.875rem;
  margin-top: 4px;
`;
    var DocumentResultWrong = import_styled_components3.default.div`
  color: #ef4444;
  position: absolute;
  font-size: 0.875rem;
  margin-top: 4px;
`;
    var import_react7 = require_react();
    var useFonts = () => {
      (0, import_react7.useEffect)(() => {
        if (window) {
          const element = document.createElement("link");
          element.setAttribute("rel", "stylesheet");
          element.setAttribute("type", "text/css");
          element.setAttribute(
            "href",
            "https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700&display=swap"
          );
          document.getElementsByTagName("head")[0].appendChild(element);
        }
      }, []);
    };
    var import_jsx_runtime5 = require_jsx_runtime();
    var VerifyModal = ({
      qrStatus,
      provingEnabled,
      setQrStatus,
      setQrData,
      setCurrentView,
      useTestAadhaar
    }) => {
      useFonts();
      return (0, import_jsx_runtime5.jsxs)(MainContainer, { children: [
        (0, import_jsx_runtime5.jsxs)(Container, { children: [
          (0, import_jsx_runtime5.jsx)(TitleSection, { children: (0, import_jsx_runtime5.jsxs)(Disclaimer, { children: [
            "Anon Aadhaar allows you to create a proof of your Aadhaar ID without revealing any personal data. This process is local to your browser for privacy, and QR images are not uploaded to any server.",
            (0, import_jsx_runtime5.jsx)("p", { children: "" }),
            (0, import_jsx_runtime5.jsx)("p", { children: "Note: Internet speed may affect processing time." }),
            (0, import_jsx_runtime5.jsx)(Line, {}),
            (0, import_jsx_runtime5.jsx)(StyledParagraph, { children: "GENERATE A QR CODE:" }),
            useTestAadhaar ? (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
              "You can try this example app by generating a test Adhaar QR Code",
              (0, import_jsx_runtime5.jsx)("p", { children: "" }),
              (0, import_jsx_runtime5.jsx)(
                PhonePlatformLinks,
                {
                  href: "https://documentation.anon-aadhaar.pse.dev/docs/generate-qr",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "Link to generate a QR Code"
                }
              )
            ] }) : (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
              "Open mAadhaar app",
              " ",
              (0, import_jsx_runtime5.jsx)(
                PhonePlatformLinks,
                {
                  href: "https://apps.apple.com/in/app/maadhaar/id1435469474",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "iOS"
                }
              ),
              " ",
              "or",
              " ",
              (0, import_jsx_runtime5.jsx)(
                PhonePlatformLinks,
                {
                  href: "https://play.google.com/store/apps/details?id=in.gov.uidai.mAadhaarPlus&hl=en_IN&pli=1",
                  target: "_blank",
                  rel: "noreferrer",
                  children: "Android"
                }
              ),
              (0, import_jsx_runtime5.jsx)("p", { children: "By entering your Aadhaar number and OTP verification. You can then save the QR as an image using the 'Share' button for import." })
            ] })
          ] }) }),
          (0, import_jsx_runtime5.jsx)(UploadSection, { children: (0, import_jsx_runtime5.jsxs)(UploadFile, { children: [
            (0, import_jsx_runtime5.jsxs)(StyledParagraph, { children: [
              "UPLOAD YOUR AADHAAR SECURE QR CODE:",
              " "
            ] }),
            (0, import_jsx_runtime5.jsx)(
              FileInput,
              {
                onChange: async (e2) => {
                  const { qrValue } = await uploadQRpng(e2, setQrStatus);
                  setQrData(qrValue);
                },
                id: "handlePdfChange",
                setQrStatus,
                qrStatus
              }
            )
          ] }) })
        ] }),
        (0, import_jsx_runtime5.jsxs)(Container, { children: [
          (0, import_jsx_runtime5.jsx)(Btn, { disabled: !provingEnabled, onClick: () => setCurrentView("Prove"), children: "CONTINUE" }),
          (0, import_jsx_runtime5.jsx)(SmallDisclaimer, { children: "No Aadhaar data ever leaves your device!" })
        ] })
      ] });
    };
    var UploadFile = import_styled_components4.default.div`
  margin-top: 20px;
  margin-bottom: 30px;
`;
    var SmallDisclaimer = import_styled_components4.default.p`
  font-size: small;
  color: #717686;
  text-decoration: wavy;
  text-align: center;
  margin-top: 10px;
`;
    var TitleSection = import_styled_components4.default.div`
  color: #111827;
  flex-shrink: 0;
  row-gap: 1rem;
  margin-left: auto;
  margin-right: auto;
  display: flex;
  flex-flow: column;
`;
    var Disclaimer = import_styled_components4.default.span`
  color: #717686;
  font-size: 14px;
  font-weight: normal;
  line-height: 20px;
`;
    var UploadSection = import_styled_components4.default.div`
  row-gap: 1rem;
  max-width: 100%;
`;
    var PhonePlatformLinks = import_styled_components4.default.a`
  color: #1d24e0;
  margin-top: 0.3rem;
  font-size: 0.9rem;
  font-weight: normal;
  text-decoration: underline;
`;
    var Container = import_styled_components4.default.div`
  width: 100%;
`;
    var Line = import_styled_components4.default.div`
  height: 2px;
  margin: 20px 0;
  width: 5rem;
  background-color: rgba(0, 154, 8, 1);
  margin-left: auto;
  margin-right: auto;
`;
    var StyledParagraph = import_styled_components4.default.p`
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600; // Regular weight
  font-size: 16px; // Example font size
  color: #333; // Example text color
  margin: 10px 0;
  line-height: 1.5;
  text-transform: capitalize;
`;
    var Btn = import_styled_components4.default.button`
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600;
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  font-size: 16px;
  cursor: pointer;
  color: white;
  background-color: #009a08;
  border: none;
  min-width: 12rem;
  min-height: 3rem;
  border-radius: 6px;

  &:hover {
    opacity: 70%;
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
    cursor: not-allowed;
  }
`;
    var MainContainer = import_styled_components4.default.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 100%;
  width: 100%;
`;
    var import_react9 = require_react();
    var import_styled_components7 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_styled_components5 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_react8 = require_react();
    var import_jsx_runtime6 = require_jsx_runtime();
    var ProveButton = ({
      qrData,
      provingEnabled,
      setErrorMessage,
      signal,
      fieldsToReveal,
      nullifierSeed,
      setQrStatus,
      setCurrentView,
      useTestAadhaar = false
    }) => {
      const { startReq } = (0, import_react8.useContext)(AnonAadhaarContext);
      const startProving = async () => {
        try {
          setCurrentView("Proving");
          if (qrData === null)
            throw new Error("Missing QR code data.");
          if (fieldsToReveal === void 0)
            fieldsToReveal = [];
          const args = await processAadhaarArgs(
            qrData,
            useTestAadhaar,
            nullifierSeed,
            fieldsToReveal,
            signal
          );
          startReq({ type: "login", args, useTestAadhaar });
          setQrStatus(null);
        } catch (error) {
          console.log(error);
          if (error instanceof Error)
            setErrorMessage(error.message);
        }
      };
      return (0, import_jsx_runtime6.jsxs)(Btn2, { disabled: !provingEnabled, onClick: startProving, children: [
        " ",
        "GENERATE ANON AADHAAR PROOF",
        " "
      ] });
    };
    var Btn2 = import_styled_components5.default.button`
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600;
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: center;
  padding: 0.5rem 1rem;
  font-size: 16px;
  cursor: pointer;
  color: white;
  background-color: #009a08;
  border: none;
  min-width: 12rem;
  min-height: 3rem;
  border-radius: 6px;

  &:hover {
    opacity: 70%;
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
    cursor: not-allowed;
  }
`;
    var import_styled_components6 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_jsx_runtime7 = require_jsx_runtime();
    var SignalDisplay = ({
      signal
    }) => {
      const isJsonObject = typeof signal === "object" && signal !== null;
      const displaySignal = isJsonObject ? JSON.stringify(signal, null, 2) : signal;
      return (0, import_jsx_runtime7.jsx)(Signal, { children: displaySignal });
    };
    var Signal = import_styled_components6.default.div`
  display: flex;
  flex-direction: row;
  width: 100%;
  border: solid;
  align-items: center;
  border-color: #b6b9c3;
  font-size: 14px;
  border-radius: 4px;
  color: black;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 12px;
  padding-right: 12px;
  margin-top: 10px;
`;
    var import_core5 = require_dist5();
    var import_jsx_runtime8 = require_jsx_runtime();
    var ProveModal = ({
      setErrorMessage,
      qrStatus,
      qrData,
      setQrStatus,
      signal,
      fieldsToReveal,
      nullifierSeed,
      setCurrentView,
      useTestAadhaar
    }) => {
      const [provingEnabled, setProvingEnabled] = (0, import_react9.useState)(false);
      const { appName } = (0, import_react9.useContext)(AnonAadhaarContext);
      const noRevealillustration = createBlobURL(icons.eyeOff);
      const revealillustration = createBlobURL(icons.eye);
      (0, import_react9.useEffect)(() => {
        if (qrStatus === "Signature verified ") {
          setProvingEnabled(true);
        } else {
          setProvingEnabled(false);
        }
      }, [qrStatus]);
      return (0, import_jsx_runtime8.jsxs)(MainContainer2, { children: [
        (0, import_jsx_runtime8.jsxs)("div", { children: [
          (0, import_jsx_runtime8.jsx)(TitleSection2, { children: "YOUR QR CODE IS VERIFIED!" }),
          (0, import_jsx_runtime8.jsxs)(Section, { children: [
            (0, import_jsx_runtime8.jsxs)(Label, { children: [
              "Data you are sharing to ",
              appName,
              ": "
            ] }),
            (0, import_jsx_runtime8.jsx)(RevealSection, { children: fieldsToReveal ? import_core5.fieldsLabel.map(
              ({ key, label }) => fieldsToReveal.includes(key) ? (0, import_jsx_runtime8.jsx)(FieldRow, { children: (0, import_jsx_runtime8.jsxs)(DiscloseOn, { children: [
                (0, import_jsx_runtime8.jsx)(Icon, { src: revealillustration }),
                label.toLocaleUpperCase()
              ] }) }, key) : (0, import_jsx_runtime8.jsx)(FieldRow, { children: (0, import_jsx_runtime8.jsxs)(DiscloseOff, { children: [
                (0, import_jsx_runtime8.jsx)(Icon, { src: noRevealillustration }),
                label.toLocaleUpperCase()
              ] }) }, key)
            ) : import_core5.fieldsLabel.map(({ key, label }) => (0, import_jsx_runtime8.jsx)(FieldRow, { children: (0, import_jsx_runtime8.jsxs)(DiscloseOff, { children: [
              (0, import_jsx_runtime8.jsx)(Icon, { src: noRevealillustration }),
              label.toLocaleUpperCase()
            ] }) }, key)) })
          ] }),
          signal && (0, import_jsx_runtime8.jsxs)(Section, { children: [
            (0, import_jsx_runtime8.jsx)(Label, { children: "Data you are signing: " }),
            (0, import_jsx_runtime8.jsx)(SignalDisplay, { signal })
          ] })
        ] }),
        (0, import_jsx_runtime8.jsxs)("div", { children: [
          (0, import_jsx_runtime8.jsx)(
            ProveButton,
            {
              qrData,
              provingEnabled,
              setErrorMessage,
              signal,
              setQrStatus,
              nullifierSeed,
              fieldsToReveal,
              setCurrentView,
              useTestAadhaar
            }
          ),
          (0, import_jsx_runtime8.jsx)(SmallDisclaimer2, { children: "No Aadhaar data ever leaves your device!" })
        ] })
      ] });
    };
    var TitleSection2 = import_styled_components7.default.div`
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600; // Regular weight
  font-size: 16px; // Example font size
  color: #333; // Example text color
  line-height: 1.5;
  text-transform: capitalize;
`;
    var Icon = import_styled_components7.default.img`
  height: 1.5rem;
  margin-right: 5px;
`;
    var DiscloseOn = import_styled_components7.default.div`
  display: flex;
  flex-direction: row;
  width: 100%;
  border: solid;
  align-items: center;
  border-color: #009a08;
  border-radius: 4px;
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600;
  color: black;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 12px;
  padding-right: 12px;
`;
    var DiscloseOff = import_styled_components7.default.div`
  display: flex;
  flex-direction: row;
  width: 100%;
  border: solid;
  align-items: center;
  border-color: #b6b9c3;
  border-radius: 4px;
  font-family: 'Rajdhani', sans-serif;
  font-weight: 600;
  color: #b6b9c3;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 12px;
  padding-right: 12px;
`;
    var Section = import_styled_components7.default.div`
  margin-top: 15px;
  row-gap: 1rem;
  max-width: 100%;
`;
    var Label = import_styled_components7.default.div`
  font-size: 14px;
  text-align: left;
  font-weight: 400;
  color: #6b7280;
`;
    var RevealSection = import_styled_components7.default.div`
  display: flex;
  flex-direction: column;
  row-gap: 10px;
  margin-top: 10px;
`;
    var FieldRow = import_styled_components7.default.div`
  display: flex;
  align-items: center;
`;
    var MainContainer2 = import_styled_components7.default.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  height: 100%;
  width: 100%;
`;
    var SmallDisclaimer2 = import_styled_components7.default.p`
  font-size: small;
  color: #717686;
  text-decoration: wavy;
  text-align: center;
  margin-top: 10px;
`;
    var import_react10 = require_react();
    var import_styled_components8 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var icons2 = {
      bottomLeftPlain: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path fill="#081224" d="M63.813 63.116V45.86a.632.632 0 0 0-.636-.635H25.474a5.956 5.956 0 0 1-5.963-5.953V1.322a.632.632 0 0 0-.636-.635H1.385a.632.632 0 0 0-.635.635v20.545c0 2.89 1.153 5.671 3.201 7.716l30.978 30.932a10.948 10.948 0 0 0 7.706 3.196l20.534.039a.64.64 0 0 0 .644-.635"/></svg>',
      bottomLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path stroke="#081224" stroke-width=".674" d="M4.19 29.344a10.575 10.575 0 0 1-3.103-7.477V1.322c0-.166.13-.298.298-.298h17.49c.168 0 .299.132.299.298v37.95c0 3.477 2.819 6.29 6.3 6.29h37.703c.167 0 .298.132.298.298v17.255c0 .16-.133.298-.306.298l-20.533-.04a10.611 10.611 0 0 1-7.469-3.097z"/></svg>',
      bottomRightPlain: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path fill="#FD8B0E" d="M.188 63.116V45.86c0-.353.282-.635.635-.635h37.703a5.956 5.956 0 0 0 5.963-5.953V1.322c0-.353.283-.635.636-.635h17.49c.353 0 .635.282.635.635v20.545c0 2.89-1.153 5.671-3.201 7.716L29.071 60.515a10.948 10.948 0 0 1-7.706 3.196L.831 63.75a.64.64 0 0 1-.643-.635"/></svg>',
      bottomRight: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path stroke="#FD8B0E" stroke-width=".674" d="M59.81 29.344a10.575 10.575 0 0 0 3.103-7.477V1.322a.295.295 0 0 0-.298-.298h-17.49a.295.295 0 0 0-.299.298v37.95c0 3.477-2.819 6.29-6.3 6.29H.823a.295.295 0 0 0-.298.298v17.255c0 .16.133.298.306.298l20.534-.04a10.611 10.611 0 0 0 7.468-3.097z"/></svg>',
      topLeftPlain: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path fill="#009A08" d="M63.813.884V18.14a.632.632 0 0 1-.636.635H25.474a5.956 5.956 0 0 0-5.963 5.953v37.95a.632.632 0 0 1-.636.635H1.385a.632.632 0 0 1-.635-.635V42.134c0-2.89 1.153-5.671 3.201-7.716L34.929 3.485A10.948 10.948 0 0 1 42.635.289L63.169.25a.64.64 0 0 1 .644.634"/></svg>',
      topLeft: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path stroke="#009A08" stroke-width=".674" d="M4.19 34.656a10.575 10.575 0 0 0-3.103 7.477v20.545c0 .166.13.298.298.298h17.49a.295.295 0 0 0 .299-.297V24.728c0-3.477 2.819-6.29 6.3-6.29h37.703a.295.295 0 0 0 .298-.298V.884a.302.302 0 0 0-.306-.297l-20.533.04a10.611 10.611 0 0 0-7.469 3.097z"/></svg>',
      topRightPlain: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path fill="#081224" d="M.188.884V18.14c0 .353.282.635.635.635h37.703a5.956 5.956 0 0 1 5.963 5.953v37.95c0 .353.283.635.636.635h17.49a.632.632 0 0 0 .635-.635V42.134c0-2.89-1.153-5.671-3.201-7.716L29.071 3.485A10.949 10.949 0 0 0 21.365.289L.831.25a.64.64 0 0 0-.643.634"/></svg>',
      topRight: '<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" fill="none"><path stroke="#081224" stroke-width=".674" d="M59.81 34.656a10.575 10.575 0 0 1 3.103 7.477v20.545a.295.295 0 0 1-.298.298h-17.49a.295.295 0 0 1-.299-.298v-37.95c0-3.477-2.819-6.29-6.3-6.29H.823a.295.295 0 0 1-.298-.298V.884c0-.16.133-.297.306-.297l20.534.04a10.611 10.611 0 0 1 7.468 3.097z"/></svg>'
    };
    var import_core6 = require_dist5();
    var import_jsx_runtime9 = require_jsx_runtime();
    var LoaderView = () => {
      useFonts();
      const { proverState } = (0, import_react10.useContext)(AnonAadhaarContext);
      const [iconsState, setIconsState] = (0, import_react10.useState)({
        topLeft: false,
        topRight: false,
        bottomLeft: false,
        bottomRight: false
      });
      const iconsUrl = (0, import_react10.useMemo)(
        () => ({
          topLeft: createBlobURL(icons2.topLeft),
          topLeftPlain: createBlobURL(icons2.topLeftPlain),
          topRight: createBlobURL(icons2.topRight),
          topRightPlain: createBlobURL(icons2.topRightPlain),
          bottomLeft: createBlobURL(icons2.bottomLeft),
          bottomLeftPlain: createBlobURL(icons2.bottomLeftPlain),
          bottomRight: createBlobURL(icons2.bottomRight),
          bottomRightPlain: createBlobURL(icons2.bottomRightPlain)
        }),
        [icons2]
      );
      (0, import_react10.useEffect)(() => {
        const intervalId = setInterval(() => {
          setIconsState((prevState) => {
            const newState = { ...prevState };
            if (!newState.topLeft) {
              newState.topLeft = true;
            } else if (!newState.topRight) {
              newState.topRight = true;
            } else if (!newState.bottomRight) {
              newState.bottomRight = true;
            } else if (!newState.bottomLeft) {
              newState.bottomLeft = true;
            } else {
              return {
                topLeft: false,
                topRight: false,
                bottomLeft: false,
                bottomRight: false
              };
            }
            return newState;
          });
        }, 1e3);
        return () => {
          clearInterval(intervalId);
          Object.values(iconsUrl).forEach(URL.revokeObjectURL);
        };
      }, [iconsUrl]);
      return (0, import_jsx_runtime9.jsxs)(import_jsx_runtime9.Fragment, { children: [
        (0, import_jsx_runtime9.jsx)(MainContainer3, { children: (0, import_jsx_runtime9.jsxs)(LoaderContainer, { children: [
          (0, import_jsx_runtime9.jsxs)(TopContainer, { children: [
            (0, import_jsx_runtime9.jsx)(
              Icon2,
              {
                src: iconsState.topLeft ? iconsUrl.topLeftPlain : iconsUrl.topLeft,
                alt: "Top left icon"
              }
            ),
            (0, import_jsx_runtime9.jsx)(
              Icon2,
              {
                src: iconsState.topRight ? iconsUrl.topRightPlain : iconsUrl.topRight,
                alt: "Top right icon"
              }
            )
          ] }),
          (0, import_jsx_runtime9.jsxs)(BottomContainer, { children: [
            (0, import_jsx_runtime9.jsx)(
              Icon2,
              {
                src: iconsState.bottomLeft ? iconsUrl.bottomLeftPlain : iconsUrl.bottomLeft,
                alt: "Bottom left icon"
              }
            ),
            (0, import_jsx_runtime9.jsx)(
              Icon2,
              {
                src: iconsState.bottomRight ? iconsUrl.bottomRightPlain : iconsUrl.bottomRight,
                alt: "Bottom right icon"
              }
            )
          ] }),
          (0, import_jsx_runtime9.jsxs)(TitleSection3, { children: [
            proverState === import_core6.ProverState.Initializing && "GENERATE PROOF...",
            proverState === import_core6.ProverState.Completed && "GENERATE PROOF...",
            proverState === import_core6.ProverState.FetchingWasm && "SEARCHING FOR WASM FILE...",
            proverState === import_core6.ProverState.FetchingZkey && "SEARCHING FOR ZKEY FILE...",
            proverState === import_core6.ProverState.Proving && "GENERATING PROOF...",
            proverState === import_core6.ProverState.Error && "Oops, something went wrong..."
          ] })
        ] }) }),
        (0, import_jsx_runtime9.jsx)(SmallDisclaimer3, { children: "Proof generation on a MacBook Pro M1 - 16GB is about 26 seconds" })
      ] });
    };
    var LoaderContainer = import_styled_components8.default.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 8px;
`;
    var TopContainer = import_styled_components8.default.div`
  display: flex;
  flex-direction: row;
  gap: 8px;
`;
    var BottomContainer = import_styled_components8.default.div`
  display: flex;
  flex-direction: row;
  gap: 8px;
`;
    var Icon2 = import_styled_components8.default.img`
  height: 65px;
`;
    var MainContainer3 = import_styled_components8.default.div`
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 100%;
  width: 100%;
`;
    var TitleSection3 = import_styled_components8.default.div`
  margin-top: 20px;
  font-family: 'Rajdhani', sans-serif;
  font-weight: 500; // Regular weight
  font-size: 28px; // Example font size
  color: #333; // Example text color
  line-height: 1.5;
  text-transform: capitalize;
`;
    var SmallDisclaimer3 = import_styled_components8.default.p`
  font-size: 12px;
  color: black;
  text-decoration: wavy;
  text-align: center;
  margin-top: 10px;
`;
    var import_jsx_runtime10 = require_jsx_runtime();
    var Modal = ({
      isOpen,
      onClose,
      errorMessage,
      setErrorMessage,
      logo,
      qrStatus,
      setQrStatus,
      signal,
      fieldsToReveal,
      nullifierSeed,
      currentView,
      setCurrentView,
      useTestAadhaar = false
    }) => {
      const [qrData, setQrData] = (0, import_react11.useState)(null);
      const [provingEnabled, setProvingEnabled] = (0, import_react11.useState)(false);
      (0, import_react11.useEffect)(() => {
        if (qrData) {
          verifySignature(qrData, useTestAadhaar).then((verified) => {
            verified.isSignatureValid ? setQrStatus(
              "Signature verified "
              /* SIGNATURE_VERIFIED */
            ) : setQrStatus(
              "QR code invalid "
              /* ERROR_PARSING_QR */
            );
          }).catch((error) => {
            setQrStatus(
              "QR code invalid "
              /* ERROR_PARSING_QR */
            );
            console.error(error);
          });
        }
      }, [qrData]);
      (0, import_react11.useEffect)(() => {
        if (qrStatus === "Signature verified ") {
          setProvingEnabled(true);
        } else {
          setProvingEnabled(false);
        }
      }, [qrStatus]);
      return isOpen ? (0, import_jsx_runtime10.jsxs)(ModalOverlay, { onClick: onClose, children: [
        (0, import_jsx_runtime10.jsx)(import_react_device_detect.BrowserView, { children: (0, import_jsx_runtime10.jsxs)(ModalContent, { onClick: (e2) => e2.stopPropagation(), children: [
          errorMessage !== null && (0, import_jsx_runtime10.jsx)(
            ErrorToast,
            {
              message: errorMessage,
              setErrorMessage
            }
          ),
          (() => {
            switch (currentView) {
              case "Verify":
                return (0, import_jsx_runtime10.jsx)(
                  VerifyModal,
                  {
                    provingEnabled,
                    qrStatus,
                    setQrStatus,
                    setQrData,
                    setCurrentView,
                    useTestAadhaar
                  }
                );
              case "Prove":
                return (0, import_jsx_runtime10.jsx)(
                  ProveModal,
                  {
                    setErrorMessage,
                    qrStatus,
                    qrData,
                    setQrStatus,
                    signal,
                    fieldsToReveal,
                    nullifierSeed,
                    setCurrentView,
                    useTestAadhaar
                  }
                );
              case "Proving":
                return (0, import_jsx_runtime10.jsx)(LoaderView, {});
            }
          })()
        ] }) }),
        (0, import_jsx_runtime10.jsx)(import_react_device_detect.MobileView, { children: (0, import_jsx_runtime10.jsxs)(ModalContent, { onClick: (e2) => e2.stopPropagation(), children: [
          errorMessage !== null && (0, import_jsx_runtime10.jsx)(
            ErrorToast,
            {
              message: errorMessage,
              setErrorMessage
            }
          ),
          (0, import_jsx_runtime10.jsxs)(TitleSection4, { children: [
            (0, import_jsx_runtime10.jsxs)(Title, { children: [
              (0, import_jsx_runtime10.jsx)(Logo, { src: logo }),
              "Prove your Identity"
            ] }),
            (0, import_jsx_runtime10.jsxs)(Disclaimer2, { children: [
              (0, import_jsx_runtime10.jsx)("b", { children: "Notice: " }),
              " Currently, Anon Aadhaar Identity verification is not available on mobile devices. To complete this process, please visit this website using a desktop browser. We apologize for any inconvenience and thank you for your understanding."
            ] })
          ] })
        ] }) })
      ] }) : null;
    };
    var ModalOverlay = import_styled_components9.default.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 9999;
`;
    var ModalContent = import_styled_components9.default.div`
  position: fixed;
  display: flex;
  flex-direction: column;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: #ffffff;
  border-radius: 1rem;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
  padding: 2rem;

  @media (max-width: 425px) {
    /* For screens <= 425px (e.g., mobile devices) */
    width: 100%;
    height: 30%;
    max-width: 100%;
    max-height: 100%;
  }

  @media (min-width: 426px) {
    /* For screens > 426px (e.g., desktop) */
    min-height: 600px;
    max-width: 450px;
    width: 80%;
  }
`;
    var TitleSection4 = import_styled_components9.default.div`
  color: #111827;
  flex-shrink: 0;
  row-gap: 1rem;
  margin-left: auto;
  margin-right: auto;
  display: flex;
  flex-flow: column;
`;
    var Title = import_styled_components9.default.h3`
  display: flex;
  flex-shrink: 0;
  margin-left: auto;
  margin-right: auto;
  font-size: medium;
  font-weight: bold;
`;
    var Disclaimer2 = import_styled_components9.default.span`
  color: #6d6d6d;
  font-size: small;
  font-weight: normal;
`;
    var import_styled_components10 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_react13 = require_react();
    var import_core7 = require_dist5();
    var import_jsx_runtime11 = require_jsx_runtime();
    var LogInWithAnonAadhaar = ({
      signal,
      fieldsToReveal,
      nullifierSeed
    }) => {
      const [isModalOpen, setIsModalOpen] = (0, import_react12.useState)(false);
      const [errorMessage, setErrorMessage] = (0, import_react12.useState)(null);
      const [qrStatus, setQrStatus] = (0, import_react12.useState)(null);
      const [currentView, setCurrentView] = (0, import_react12.useState)("Verify");
      const [isMenuOpen, setIsMenuOpen] = (0, import_react12.useState)(false);
      const { state, startReq, proverState, useTestAadhaar } = (0, import_react13.useContext)(AnonAadhaarContext);
      const anonAadhaarLogo = createBlobURL(icons.aalogo);
      const toggleMenu = () => {
        setIsMenuOpen(!isMenuOpen);
      };
      (0, import_react13.useEffect)(() => {
        if (proverState === import_core7.ProverState.Completed)
          closeModal();
      }, [proverState]);
      const openModal = () => {
        setIsModalOpen(true);
      };
      const closeModal = () => {
        setIsModalOpen(false);
        setErrorMessage(null);
        setQrStatus(null);
        setCurrentView("Verify");
      };
      return (0, import_jsx_runtime11.jsxs)("div", { children: [
        (state.status === "logged-out" || state.status === "logging-in") && (0, import_jsx_runtime11.jsxs)("div", { children: [
          (0, import_jsx_runtime11.jsxs)(Btn3, { onClick: openModal, children: [
            (0, import_jsx_runtime11.jsx)(Logo, { src: anonAadhaarLogo }),
            "Login"
          ] }),
          (0, import_jsx_runtime11.jsx)(
            Modal,
            {
              isOpen: isModalOpen,
              onClose: closeModal,
              errorMessage,
              setErrorMessage,
              logo: anonAadhaarLogo,
              qrStatus,
              setQrStatus,
              signal,
              fieldsToReveal,
              nullifierSeed,
              setCurrentView,
              currentView,
              useTestAadhaar
            }
          )
        ] }),
        state.status === "logged-in" && (0, import_jsx_runtime11.jsxs)(RelativeContainer, { children: [
          (0, import_jsx_runtime11.jsxs)(Btn3, { onClick: toggleMenu, children: [
            (0, import_jsx_runtime11.jsx)(Logo, { src: anonAadhaarLogo }),
            "Menu"
          ] }),
          (0, import_jsx_runtime11.jsxs)(MenuContainer, { $isopen: isMenuOpen, children: [
            (0, import_jsx_runtime11.jsx)(MenuItem, { onClick: openModal, children: "Create a proof" }),
            (0, import_jsx_runtime11.jsx)(
              Modal,
              {
                isOpen: isModalOpen,
                onClose: closeModal,
                errorMessage,
                setErrorMessage,
                logo: anonAadhaarLogo,
                qrStatus,
                setQrStatus,
                signal,
                fieldsToReveal,
                nullifierSeed,
                setCurrentView,
                currentView,
                useTestAadhaar
              }
            ),
            (0, import_jsx_runtime11.jsx)(MenuItem, { onClick: () => startReq({ type: "logout" }), children: "Logout" })
          ] })
        ] })
      ] });
    };
    var Logo = import_styled_components10.default.img`
  height: 1.5rem;
  margin-right: 0.5rem;
`;
    var Btn3 = import_styled_components10.default.button`
  display: flex;
  padding: 0 1rem;
  font-size: 1rem;
  cursor: pointer;
  color: #000000;
  font-weight: bold;
  border-radius: 1.3125rem;
  background: #fff;
  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);
  border: none;
  min-height: 2.5rem;
  border-radius: 0.5rem;
  align-items: center;

  &:hover {
    background: #fafafa;
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
  }
`;
    var MenuItem = import_styled_components10.default.button`
  display: block;
  width: 100%;
  padding: 0.5rem 1rem;
  font-size: 1rem;
  color: #000000;
  text-align: left;
  background: none;
  border: none;
  border-bottom: 1px solid #cccccc;
  cursor: pointer;

  &:hover {
    border-radius: 0.5rem;
    background-color: #f2f2f2;
  }

  &:last-child {
    border-bottom: none;
  }
`;
    var MenuContainer = import_styled_components10.default.div`
  display: ${(props) => props.$isopen ? "block" : "none"};
  position: absolute;
  margin-top: 0.5rem;
  top: 100%;
  right: 0;
  width: 130%;
  background: #fff;
  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
  border-radius: 0.5rem;
  z-index: 10;
`;
    var RelativeContainer = import_styled_components10.default.div`
  position: relative;
  display: inline-block;
`;
    var import_react14 = require_react();
    var import_styled_components11 = __toESM2((init_styled_components_browser_esm(), __toCommonJS(styled_components_browser_esm_exports)));
    var import_react15 = require_react();
    var import_core8 = require_dist5();
    var import_jsx_runtime12 = require_jsx_runtime();
    var LaunchProveModal = ({
      signal,
      buttonStyle,
      fieldsToReveal,
      nullifierSeed,
      buttonTitle = "Generate a proof"
    }) => {
      const [isModalOpen, setIsModalOpen] = (0, import_react14.useState)(false);
      const [errorMessage, setErrorMessage] = (0, import_react14.useState)(null);
      const [qrStatus, setQrStatus] = (0, import_react14.useState)(null);
      const [currentView, setCurrentView] = (0, import_react14.useState)("Verify");
      const { proverState, useTestAadhaar } = (0, import_react15.useContext)(AnonAadhaarContext);
      const anonAadhaarLogo = createBlobURL(icons.aalogo);
      (0, import_react15.useEffect)(() => {
        if (proverState === import_core8.ProverState.Completed)
          closeModal();
      }, [proverState]);
      const openModal = () => {
        setIsModalOpen(true);
      };
      const closeModal = () => {
        setIsModalOpen(false);
        setErrorMessage(null);
        setQrStatus(null);
        setCurrentView("Verify");
      };
      return (0, import_jsx_runtime12.jsxs)("div", { children: [
        (0, import_jsx_runtime12.jsxs)(Btn4, { style: buttonStyle, onClick: openModal, children: [
          (0, import_jsx_runtime12.jsx)(Logo2, { src: anonAadhaarLogo }),
          buttonTitle
        ] }),
        (0, import_jsx_runtime12.jsx)(
          Modal,
          {
            isOpen: isModalOpen,
            onClose: closeModal,
            errorMessage,
            setErrorMessage,
            logo: anonAadhaarLogo,
            qrStatus,
            setQrStatus,
            signal,
            fieldsToReveal,
            nullifierSeed,
            setCurrentView,
            currentView,
            useTestAadhaar
          }
        )
      ] });
    };
    var Logo2 = import_styled_components11.default.img`
  height: 1.5rem;
  margin-right: 0.5rem;
`;
    var Btn4 = import_styled_components11.default.button`
  display: flex;
  padding: 0 1rem;
  font-size: 1rem;
  cursor: pointer;
  color: #000000;
  font-weight: bold;
  border-radius: 1.3125rem;
  background: #fff;
  box-shadow: 0px 3px 8px 1px rgba(0, 0, 0, 0.25);
  border: none;
  min-height: 2.5rem;
  border-radius: 0.5rem;
  align-items: center;

  &:hover {
    background: #fafafa;
  }

  &:active {
    background: #f8f8f8;
  }

  &:disabled {
    color: #a8aaaf;
    background: #e8e8e8;
    cursor: default;
  }
`;
    var import_react16 = require_react();
    var import_core9 = require_dist5();
    function useProver() {
      const [latestProof, setLatestProof] = (0, import_react16.useState)();
      const { proverState, state } = (0, import_react16.useContext)(AnonAadhaarContext);
      (0, import_react16.useEffect)(() => {
        if (state.status === "logged-in") {
          (0, import_core9.deserialize)(
            state.anonAadhaarProofs[Object.keys(state.anonAadhaarProofs).length - 1].pcd
          ).then((anonAadhaarCore) => setLatestProof(anonAadhaarCore));
        }
      }, [proverState, state]);
      return [proverState, latestProof];
    }
  }
});
export default require_dist6();
/*! Bundled license information:

snarkjs/build/browser.esm.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

localforage/dist/localforage.js:
  (*!
      localForage -- Offline Storage, Improved
      Version 1.10.0
      https://localforage.github.io/localForage
      (c) 2013-2017 Mozilla, Apache License 2.0
  *)

@anon-aadhaar/core/dist/index.js:
  (*! Bundled license information:
  
  js-sha3/src/sha3.js:
    (**
     * [js-sha3]{@link https://github.com/emn178/js-sha3}
     *
     * @version 0.8.0
     * @author Chen, Yi-Cyuan [emn178@gmail.com]
     * @copyright Chen, Yi-Cyuan 2015-2018
     * @license MIT
     *)
  *)
*/
//# sourceMappingURL=@anon-aadhaar_react.js.map
