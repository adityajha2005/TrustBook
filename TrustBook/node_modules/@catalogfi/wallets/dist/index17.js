import{MaxUint256 as m,AbiCoder as o,sha256 as n,formatEther as E}from"ethers";import{WalletChain as A}from"./index2.js";import{with0x as w}from"@catalogfi/utils";import{EVMHTLCErrors as e}from"./index18.js";import{AtomicSwap__factory as u}from"./index15.js";import{ERC20__factory as f}from"./index16.js";class g{newSwap(t){return Promise.resolve(new d(t,this))}chain(){return A.EVM}}class d{constructor(t,s){if(this.swap={...t,contractAddress:t.contractAddress},this.swap.secretHash=w(this.swap.secretHash),this.swap.secretHash.length!==66)throw new Error(e.INVALID_SECRET_HASH);this.wallet=s,this.AtomicSwapContract=u.connect(this.swap.contractAddress,s.getSigner())}id(){return this.swap.contractAddress}async init(){const t=await this.wallet.getAddress(),s=await this.AtomicSwapContract.token(),a=f.connect(s,this.wallet.getSigner());return await a.allowance(t,this.swap.contractAddress)<BigInt(this.swap.amount)&&await this.contractExecutor(a.approve,[this.swap.contractAddress,m],s,t,!0),this.contractExecutor(this.AtomicSwapContract.initiate,[this.swap.recipientAddress,this.swap.expiryBlocks,this.swap.amount,this.swap.secretHash],this.swap.contractAddress,t)}async redeem(t){t=w(t);const s=this.swap.initiatorAddress,a=new o,i=n(a.encode(["bytes32","address"],[this.swap.secretHash,s]));return this.contractExecutor(this.AtomicSwapContract.redeem,[i,t],this.swap.contractAddress,await this.wallet.getAddress())}async refund(){const t=this.swap.initiatorAddress,s=new o,a=n(s.encode(["bytes32","address"],[this.swap.secretHash,t]));return this.contractExecutor(this.AtomicSwapContract.refund,[a],this.swap.contractAddress,t)}async contractExecutor(t,s,a,i,p){let l;try{const r=await t.populateTransaction(...s);l=E(await t.estimateGas(...s));const c=await this.wallet.contractCall({to:a,from:i,data:r.data});return p&&await c.wait(),c.hash}catch(r){throw console.log(r),r.message.includes("exceeds balance")?new Error(e.INSUFFICIENT_TOKENS):r.message.includes("duplicate")?new Error(e.ORDER_INITIATED):r.message.includes("invalid secret")?new Error(e.INVALID_SECRET):r.message.includes("order not expired")?new Error(e.ORDER_NOT_EXPIRED):new Error(r.message)}}}export{g as AbstractEVMWallet,d as EVMHTLC};
