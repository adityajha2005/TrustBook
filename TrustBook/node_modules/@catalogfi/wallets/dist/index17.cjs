"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("ethers"),E=require("./index2.cjs"),n=require("@catalogfi/utils"),i=require("./index18.cjs"),u=require("./index15.cjs"),p=require("./index16.cjs");class A{newSwap(t){return Promise.resolve(new d(t,this))}chain(){return E.WalletChain.EVM}}class d{constructor(t,s){if(this.swap={...t,contractAddress:t.contractAddress},this.swap.secretHash=n.with0x(this.swap.secretHash),this.swap.secretHash.length!==66)throw new Error(i.EVMHTLCErrors.INVALID_SECRET_HASH);this.wallet=s,this.AtomicSwapContract=u.AtomicSwap__factory.connect(this.swap.contractAddress,s.getSigner())}id(){return this.swap.contractAddress}async init(){const t=await this.wallet.getAddress(),s=await this.AtomicSwapContract.token(),r=p.ERC20__factory.connect(s,this.wallet.getSigner());return await r.allowance(t,this.swap.contractAddress)<BigInt(this.swap.amount)&&await this.contractExecutor(r.approve,[this.swap.contractAddress,a.MaxUint256],s,t,!0),this.contractExecutor(this.AtomicSwapContract.initiate,[this.swap.recipientAddress,this.swap.expiryBlocks,this.swap.amount,this.swap.secretHash],this.swap.contractAddress,t)}async redeem(t){t=n.with0x(t);const s=this.swap.initiatorAddress,r=new a.AbiCoder,o=a.sha256(r.encode(["bytes32","address"],[this.swap.secretHash,s]));return this.contractExecutor(this.AtomicSwapContract.redeem,[o,t],this.swap.contractAddress,await this.wallet.getAddress())}async refund(){const t=this.swap.initiatorAddress,s=new a.AbiCoder,r=a.sha256(s.encode(["bytes32","address"],[this.swap.secretHash,t]));return this.contractExecutor(this.AtomicSwapContract.refund,[r],this.swap.contractAddress,t)}async contractExecutor(t,s,r,o,h){let l;try{const e=await t.populateTransaction(...s);l=a.formatEther(await t.estimateGas(...s));const c=await this.wallet.contractCall({to:r,from:o,data:e.data});return h&&await c.wait(),c.hash}catch(e){throw console.log(e),e.message.includes("exceeds balance")?new Error(i.EVMHTLCErrors.INSUFFICIENT_TOKENS):e.message.includes("duplicate")?new Error(i.EVMHTLCErrors.ORDER_INITIATED):e.message.includes("invalid secret")?new Error(i.EVMHTLCErrors.INVALID_SECRET):e.message.includes("order not expired")?new Error(i.EVMHTLCErrors.ORDER_NOT_EXPIRED):new Error(e.message)}}}exports.AbstractEVMWallet=A;exports.EVMHTLC=d;
