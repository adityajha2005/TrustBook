var U=(h,t,e)=>{if(!t.has(h))throw TypeError("Cannot "+e)};var p=(h,t,e)=>(U(h,t,"read from private field"),e?e.call(h):t.get(h)),k=(h,t,e)=>{if(t.has(h))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(h):t.set(h,e)},v=(h,t,e,r)=>(U(h,t,"write to private field"),r?r.call(h,e):t.set(h,e),e);var w,f,A,g;import{BitcoinNetwork as b,Urgency as F}from"./index7.js";import{EncryptedStore as X,WalletMemoryStore as j}from"./index14.js";import{generateMnemonic as R}from"./index3.js";import{BitcoinWallet as T}from"./index10.js";import{generateRootNode as H,getInitialAccounts as P,discover as G,getAccount as C}from"./index25.js";import{address as L,Transaction as M,payments as N,script as S,networks as K}from"bitcoinjs-lib";import{reversify as V}from"./index22.js";import{AddressType as m}from"./index13.js";import{ripemd160 as D}from"./index29.js";import{sha256 as $}from"./index28.js";import{WalletDetailsStore as y}from"./index30.js";import{Path as x}from"./index31.js";import{ensureVal as O}from"@catalogfi/utils";import{MultiKeyWalletErrors as W}from"./index32.js";const l=class l{constructor(t,e,r){k(this,w,void 0);k(this,f,void 0);k(this,A,void 0);k(this,g,void 0);v(this,w,t),v(this,f,e),v(this,A,r),v(this,g,new y(r,e.getNetwork()))}async getAccounts(){const t=[];let e=-1;const r=O(await p(this,g).getMnemonic(),W.MissingMnemonic),s=H(r,p(this,f).getNetwork());for(;++e>=0;){const a=await p(this,g).getAccounts(e);if(a instanceof Error)break;for(const n of a){const i=s.derivePath(n.path).privateKey;if(!i)throw new Error("Unable to generate private key");const o=T.fromPrivateKey(i.toString("hex"),p(this,f),{pkType:n.addressType,pkPath:n.path});t.push({...n,accountNumber:x.getAccountNumber(n.path),address:await o.getAddress()})}}return t}async getMnemonic(){return O(await p(this,g).getMnemonic(),W.MissingMnemonic)}get provider(){return p(this,f)}wallets(){return Array.from(p(this,w).values())}walletByAddress(t){const e=p(this,w).get(t);if(!e)throw new Error("Wallet not found");return e}walletByType(t){for(const e of p(this,w).values())if(e.walletConfig().addressType===t)return e}getNetwork(){return J(p(this,f).getNetwork())}async getAddresses(){const t=p(this,w).keys(),e=[];for(const r of t){const s=p(this,w).get(r);if(!s)throw new Error("Wallet not found");const a=s.walletConfig().addressType;e.push({address:r,type:a})}return e}async getBalance(){let t=0;for(const e of this.wallets())t+=await e.getBalance();return t}async nextAccount(t){if(t??(t=x.getAccountNumber(this.wallets()[0].walletConfig().path)+1),!(await p(this,g).getAccounts(t)instanceof Error))return this.nextAccount(t+1);const e=P(await this.getMnemonic(),p(this,f),t),r=e.map(a=>({...a,transactions:[]})),s=B(r,p(this,f));return await p(this,g).save(await this.getMnemonic(),e.map(a=>({path:a.path,addressType:a.type}))),new l(s,p(this,f),p(this,A))}static async createRandom(t,e){const r=R(),s=new X(e,r),a=P(r,t),n=a.map(o=>({...o,transactions:[]})),i=B(n,t);return await y.save(r,a.map(o=>({path:o.path,addressType:o.type})),s,t.getNetwork()),new l(i,t,s)}static async fromDisk(t,e,r=0){const s=O(await y.getMnemonic(e),W.MissingMnemonic),a=await y.getAccounts(e,r,t.getNetwork());if(a instanceof Error){const i=P(s,t,r),o=B(i,t);return await y.save(s,i.map(c=>({path:c.path,addressType:c.type})),e,t.getNetwork()),new l(o,t,e)}const n=new Map;for(const i of a){const o=H(s,t.getNetwork()).derivePath(i.path).privateKey;if(!o)throw new Error("Unable to generate private key");const c=T.fromPrivateKey(o.toString("hex"),t,{pkType:i.addressType,pkPath:i.path});n.set(await c.getAddress(),c)}return new l(n,t,e)}static async fromMnemonic(t,e,r){if(await y.getMnemonic(r)&&e.getNetwork()===b.Mainnet)throw new Error("Wallet already exists in store");const s=await G(t,e);if(s.length===0){const o=P(t,e);s.push(...o.map(c=>({...c})))}const a=s.map(o=>o.type);for(const o of Object.values(m))if(!a.includes(o)){const c=C(t,e,o);s.push({...c})}const n=[];for(const o of s){const c=x.getAccountNumber(o.path),u=s.filter(d=>x.getAccountNumber(d.path)===c).map(d=>d.type);if(u.length!==Object.values(m).length){for(const d of Object.values(m))if(!u.includes(d)){const E=C(t,e,d,c);n.push(E)}}}s.push(...n);const i=B(s,e);return await y.save(t,s.map(o=>({path:o.path,addressType:o.type})),r,e.getNetwork()),new l(i,e,r)}static async fromPrivateKeys(t,e){const r=new Map;for(const s of t)for(const a of Object.values(m)){const n=T.fromPrivateKey(s,e,{pkType:a});r.set(await n.getAddress(),n)}return new l(r,e,new j)}async sanityChecksBeforeSend(t){if(await this.getBalance()<t)throw new Error("Insufficient balance")}async getUTXOs(t,e){try{return await this.provider.getUTXOs(t,e)}catch{return await this.getUTXOs(t,0)}}async getPayouts(t,e){const r=await this.getAddresses();let s=t;const a=[];for(const i of r){const o=this.walletByAddress(i.address),c=await this.getUTXOs(i.address,s);if(c.length===0)continue;const u=c.reduce((d,E)=>d+E.value,0);if(s>u){a.push({address:i.address,amt:u,fee:0,change:0}),s-=u;continue}else if(e??(e=await o.suggestFee(s,F.FAST)),e+s>u){a.push({address:i.address,amt:s,fee:u-s,change:0}),s-=u;continue}else{a.push({address:i.address,amt:s>0?s:0,fee:s>0?e:e+s,change:u-s-e});break}}const n=a.reduce((i,o)=>i+o.amt+o.fee,0);if(n!==t+e)throw new Error("Amounts do not match: Expected "+(t+e)+" but got "+n);return a}async addPayoutsToTx(t,e,r){const s=[];for(const n of e){const i=await this.provider.getUTXOs(n.address,n.amt+n.fee+n.change);for(const o of i)t.addInput(V(o.txid),o.vout),s.push({address:n.address,val:o.value})}const a=e.reduce((n,i)=>n+i.amt,0);t.addOutput(L.toOutputScript(r,this.getNetwork()),a);for(const n of e)n.change>0&&t.addOutput(L.toOutputScript(n.address,this.getNetwork()),n.change);return s}async handleP2wpkh(t,e,r,s){const a=Buffer.from(await e.getPublicKey(),"hex"),n=M.SIGHASH_ALL,i=N.p2pkh({pubkey:a,network:await e.getNetwork()}),o=t.hashForWitnessV0(r,i.output,s,n),c=await e.sign(o.toString("hex")),u=[S.signature.encode(Buffer.from(c,"hex"),n),a];return t.setWitness(r,u),t}async handleP2pkh(t,e,r){var u;const s=Buffer.from(await e.getPublicKey(),"hex"),a=N.p2pkh({pubkey:s,network:this.getNetwork()}),n=M.SIGHASH_ALL,i=t.hashForSignature(r,a.output,n),o=await e.sign(i.toString("hex")),c=(u=N.p2pkh({pubkey:s,redeem:{input:S.compile([S.signature.encode(Buffer.from(o,"hex"),n),s]),output:a.output},network:this.getNetwork()}).redeem)==null?void 0:u.input;if(!c)throw new Error("Redeem script not found");return t.setInputScript(r,c),t}async handleP2wpkhP2sh(t,e,r,s){const a=Buffer.from(await e.getPublicKey(),"hex"),n=N.p2pkh({network:await e.getNetwork(),pubkey:a}),i=`160014${z(a).toString("hex")}`,o=M.SIGHASH_ALL,c=t.hashForWitnessV0(r,n.output,s,o),u=await e.sign(c.toString("hex")),d=[S.signature.encode(Buffer.from(u,"hex"),o),a];t.setInputScript(r,Buffer.from(i,"hex")),t.setWitness(r,d)}async send(t,e,r){await this.sanityChecksBeforeSend(e);const s=await this.getPayouts(e,r);let a=q();const n=await this.addPayoutsToTx(a,s,t);for(let i=0;i<n.length;i++){const o=n[i],c=this.walletByAddress(o.address);switch(c.walletConfig().addressType){case m.p2pkh:a=await this.handleP2pkh(a,c,i);break;case m.p2wpkh:a=await this.handleP2wpkh(a,c,i,o.val);break;case m["p2wpkh-p2sh"]:await this.handleP2wpkhP2sh(a,c,i,o.val);break}}return await this.provider.broadcast(a.toHex())}};w=new WeakMap,f=new WeakMap,A=new WeakMap,g=new WeakMap;let I=l;function q(){const h=new M;return h.version=2,h}function z(h){return Buffer.from(D($(Uint8Array.from(h))))}function J(h){switch(h){case b.Mainnet:return K.bitcoin;case b.Testnet:return K.testnet;case b.Regtest:return K.regtest;default:throw new Error("Invalid network")}}function B(h,t){const e=new Map;for(const r of h){const s=T.fromPrivateKey(r.privateKey,t,{pkType:r.type,pkPath:r.path});e.set(r.address,s)}return e}export{I as BitcoinMultiKeyWallet};
