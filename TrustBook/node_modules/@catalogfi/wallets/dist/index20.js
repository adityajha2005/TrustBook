import{sleep as m,Fetcher as y}from"@catalogfi/utils";import*as w from"bip39";import{HDNodeWallet as P,Mnemonic as v}from"ethers";class b{constructor(t){this.endpoint=t}async getTransactions(t){for(let e=1;e<=10;e++){const s=await this._getTransactions(t);if(typeof s.result!="string")return s.result;await m(1e3*e)}throw new Error("Unable to fetch transactions.")}async _getTransactions(t){try{const e=new URL(this.endpoint);return e.searchParams.append("module","account"),e.searchParams.append("address",t),e.searchParams.append("startblock","0"),e.searchParams.append("endblock","latest"),e.searchParams.append("offset","1"),e.searchParams.append("action","txlist"),await y.get(e)}catch(e){return{status:"0",message:e.message,result:"Failed to fetch transactions"}}}}const K=(a,t)=>`m/44'/60'/${a}'/0/${t}`,f=(a,t,e)=>{const s=K(t,a),r=e.derivePath(s);return{address:r.address,path:s,publicKey:r.publicKey,privateKey:r.privateKey}},T=(a,t,e,s,r)=>{const i=[];for(let n=t;n<e;n++){const{address:o,path:c,privateKey:d}=f(n,a,s),l=new Promise((p,g)=>{r.getTransactions(o).then(h=>p({address:o,path:c,privateKey:d,transactions:h})).catch(h=>g(h))});i.push(l)}return i},u=a=>{if(!w.validateMnemonic(a))throw new Error("Invalid mnemonic");return P.fromSeed(v.fromPhrase(a,"").computeSeed())},k=async(a,t)=>{const e=u(a),s=20,r=5;let i=[];for(let n=0;;n++){const o=[];let c=0;for(let d=0;c<=s;d+=r){const l=await Promise.all(T(n,d,d+r,e,t));await m(1500);for(const p of l)p.transactions.length===0?c++:(o.push(p),c>0&&(c=0))}if(o.length===0)break;i.push(...o)}return i};export{b as EtherscanTxProvider,k as discover,u as generateRootNode,f as getKeysFromAddress};
