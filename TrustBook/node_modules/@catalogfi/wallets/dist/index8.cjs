"use strict";var x=Object.create;var v=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var P=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var b=(n,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of B(t))!N.call(n,s)&&s!==e&&v(n,s,{get:()=>t[s],enumerable:!(i=A(t,s))||i.enumerable});return n};var O=(n,t,e)=>(e=n!=null?x(P(n)):{},b(t||!n||!n.__esModule?v(e,"default",{value:n,enumerable:!0}):e,n));Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const S=require("./index7.cjs"),C=require("./index22.cjs"),W=require("ethers"),a=require("bitcoinjs-lib"),q=require("ecpair"),m=require("./index5.cjs"),I=require("./index4.cjs"),U=require("@catalogfi/utils"),E=require("./index11.cjs"),T=require("./index23.cjs");class F extends I.AbstractBitcoinWallet{constructor(t,e,i){super(),this.minAmt=1e3,this.jsonRPCSigner=e,this.nonce=i||0,this.provider=t,this.network=t.getNetwork()===S.BitcoinNetwork.Mainnet?a.networks.bitcoin:t.getNetwork()===S.BitcoinNetwork.Testnet?a.networks.testnet:a.networks.regtest}async getSigner(){return this.signer||(this.signer=await this.getBitcoinSigner()),this.signer}getProvider(){return Promise.resolve(this.provider)}async getAddress(){const t=await this.getSigner(),e=a.payments.p2wpkh({pubkey:t.publicKey,network:this.network}).address;if(!e)throw new Error("failed to generate address");return e}async getBalance(){const t=await this.getAddress();return this.provider.getBalance(t)}async sign(t){return t=U.trim0x(t),(await this.getSigner()).sign(Buffer.from(t,"hex")).toString("hex")}async signSchnorr(t){return(await this.getSigner()).signSchnorr(t)}async getPublicKey(){return(await this.getSigner()).publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}walletConfig(){return{network:this.provider.getNetwork(),path:""}}async getBitcoinSigner(){if(!this.jsonRPCSigner.provider)throw new Error("no provider in the signer");const t=await this.jsonRPCSigner.provider.getNetwork(),e={Data:[{name:"Message",type:"string"},{name:"Version",type:"string"},{name:"Nonce",type:"uint256"}]},i={Message:"Initialize your swap",Version:"1.1.0",Nonce:this.nonce},s={name:"CATALOG x WBTC GARDEN",version:"1",chainId:t.chainId},h={types:e,domain:s,primaryType:"Data",message:i},g=await this.jsonRPCSigner.signTypedData(h.domain,h.types,h.message),d=await import("tiny-secp256k1");return q.ECPairFactory(d).fromPrivateKey(Buffer.from(W.sha256(g).slice(2),"hex"),{network:this.network})}async send(t,e,i){const s=await this.getSigner();if(i||(i=await this.provider.suggestFee(await this.getAddress(),e,S.Urgency.FAST)),i>e)throw new Error(m.BWErrors.FEE_EXCEEDS_AMOUNT(i,e));if(e<this.minAmt)throw new Error(m.BWErrors.MIN_AMOUNT(this.minAmt));const h=await this.getAddress(),g=await this.provider.getUTXOs(h,e+i),d=g.reduce((r,w)=>r+w.value,0),o=new a.Psbt({network:this.network});for(const r of g){const w=await this.provider.getTransactionHex(r.txid);o.addInput({hash:C.reversify(r.txid),index:r.vout,nonWitnessUtxo:Buffer.from(w,"hex")})}const c=d-e-i;return o.addOutput({address:t,value:e}),c>0&&o.addOutput({address:h,value:c}),o.signAllInputs(s).finalizeAllInputs(),this.provider.broadcast(o.extractTransaction().toHex())}async spend(t,e,{toAddress:i,fee:s,nSequence:h,unlockScript:g,witness:d}){const o=this.getScriptType(e,this.network),c=await this.provider.getBalance(e);if(c===0)throw new Error(m.BWErrors.SCRIPT_NOT_FUNDED);let r=new a.Transaction;if(r.version=2,s??=await this.provider.suggestFee(e,c,S.Urgency.FAST),s>c)throw new Error(m.BWErrors.FEE_EXCEEDS_AMOUNT(s,c));const w=await this.provider.getUTXOs(e);r=await this.addAllInputs(r,e,this.provider,{nSequence:h,utxos:w}),r.addOutput(await this.toOutputScript(i??await this.getAddress()),c-s);for(let u=0;u<r.ins.length;u++)if(o===T.ScriptType.P2SH){if(!g)throw new Error("Unlock script is required for p2sh");const p=[];for(const l of g)if(l instanceof E.AddSignature){const y=l.sigHashType,k=r.hashForSignature(u,t,y);p.push(a.script.signature.encode(Buffer.from(await this.sign(k.toString("hex")),"hex"),y))}else p.push(l);const f=a.payments.p2sh({redeem:{input:a.script.compile(p),output:t},network:this.network}).redeem?.input;r.setInputScript(u,f)}else if(o===T.ScriptType.P2WSH){if(!d)throw new Error("Witness is required for p2wsh");const p=[];for(const f of d)if(f instanceof E.AddSignature){const l=f.sigHashType,y=r.hashForWitnessV0(u,t,w[u].value,l);p.push(a.script.signature.encode(Buffer.from(await this.sign(y.toString("hex")),"hex"),l))}else p.push(f);r.setWitness(u,p)}else throw new Error("Invalid script type "+o);return this.provider.broadcast(r.toHex())}}exports.BitcoinOTA=F;
